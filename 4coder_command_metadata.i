# 1 "4coder_sam.cpp"
# 1 "/home/sam/.bin/4coder//"
# 1 "<built-in>"
# 1 "<command-line>"
# 1 "/usr/include/stdc-predef.h" 1 3 4
# 1 "<command-line>" 2
# 1 "4coder_sam.cpp"
# 1 "/usr/include/stdio.h" 1 3 4
# 27 "/usr/include/stdio.h" 3 4
# 1 "/usr/include/bits/libc-header-start.h" 1 3 4
# 33 "/usr/include/bits/libc-header-start.h" 3 4
# 1 "/usr/include/features.h" 1 3 4
# 465 "/usr/include/features.h" 3 4
# 1 "/usr/include/sys/cdefs.h" 1 3 4
# 452 "/usr/include/sys/cdefs.h" 3 4
# 1 "/usr/include/bits/wordsize.h" 1 3 4
# 453 "/usr/include/sys/cdefs.h" 2 3 4
# 1 "/usr/include/bits/long-double.h" 1 3 4
# 454 "/usr/include/sys/cdefs.h" 2 3 4
# 466 "/usr/include/features.h" 2 3 4
# 489 "/usr/include/features.h" 3 4
# 1 "/usr/include/gnu/stubs.h" 1 3 4
# 10 "/usr/include/gnu/stubs.h" 3 4
# 1 "/usr/include/gnu/stubs-64.h" 1 3 4
# 11 "/usr/include/gnu/stubs.h" 2 3 4
# 490 "/usr/include/features.h" 2 3 4
# 34 "/usr/include/bits/libc-header-start.h" 2 3 4
# 28 "/usr/include/stdio.h" 2 3 4


# 29 "/usr/include/stdio.h" 3 4
extern "C" {



# 1 "/usr/lib/gcc/x86_64-pc-linux-gnu/10.2.0/include/stddef.h" 1 3 4
# 209 "/usr/lib/gcc/x86_64-pc-linux-gnu/10.2.0/include/stddef.h" 3 4
typedef long unsigned int size_t;
# 34 "/usr/include/stdio.h" 2 3 4


# 1 "/usr/lib/gcc/x86_64-pc-linux-gnu/10.2.0/include/stdarg.h" 1 3 4
# 40 "/usr/lib/gcc/x86_64-pc-linux-gnu/10.2.0/include/stdarg.h" 3 4
typedef __builtin_va_list __gnuc_va_list;
# 37 "/usr/include/stdio.h" 2 3 4

# 1 "/usr/include/bits/types.h" 1 3 4
# 27 "/usr/include/bits/types.h" 3 4
# 1 "/usr/include/bits/wordsize.h" 1 3 4
# 28 "/usr/include/bits/types.h" 2 3 4
# 1 "/usr/include/bits/timesize.h" 1 3 4
# 29 "/usr/include/bits/types.h" 2 3 4


typedef unsigned char __u_char;
typedef unsigned short int __u_short;
typedef unsigned int __u_int;
typedef unsigned long int __u_long;


typedef signed char __int8_t;
typedef unsigned char __uint8_t;
typedef signed short int __int16_t;
typedef unsigned short int __uint16_t;
typedef signed int __int32_t;
typedef unsigned int __uint32_t;

typedef signed long int __int64_t;
typedef unsigned long int __uint64_t;






typedef __int8_t __int_least8_t;
typedef __uint8_t __uint_least8_t;
typedef __int16_t __int_least16_t;
typedef __uint16_t __uint_least16_t;
typedef __int32_t __int_least32_t;
typedef __uint32_t __uint_least32_t;
typedef __int64_t __int_least64_t;
typedef __uint64_t __uint_least64_t;



typedef long int __quad_t;
typedef unsigned long int __u_quad_t;







typedef long int __intmax_t;
typedef unsigned long int __uintmax_t;
# 141 "/usr/include/bits/types.h" 3 4
# 1 "/usr/include/bits/typesizes.h" 1 3 4
# 142 "/usr/include/bits/types.h" 2 3 4
# 1 "/usr/include/bits/time64.h" 1 3 4
# 143 "/usr/include/bits/types.h" 2 3 4


typedef unsigned long int __dev_t;
typedef unsigned int __uid_t;
typedef unsigned int __gid_t;
typedef unsigned long int __ino_t;
typedef unsigned long int __ino64_t;
typedef unsigned int __mode_t;
typedef unsigned long int __nlink_t;
typedef long int __off_t;
typedef long int __off64_t;
typedef int __pid_t;
typedef struct { int __val[2]; } __fsid_t;
typedef long int __clock_t;
typedef unsigned long int __rlim_t;
typedef unsigned long int __rlim64_t;
typedef unsigned int __id_t;
typedef long int __time_t;
typedef unsigned int __useconds_t;
typedef long int __suseconds_t;
typedef long int __suseconds64_t;

typedef int __daddr_t;
typedef int __key_t;


typedef int __clockid_t;


typedef void * __timer_t;


typedef long int __blksize_t;




typedef long int __blkcnt_t;
typedef long int __blkcnt64_t;


typedef unsigned long int __fsblkcnt_t;
typedef unsigned long int __fsblkcnt64_t;


typedef unsigned long int __fsfilcnt_t;
typedef unsigned long int __fsfilcnt64_t;


typedef long int __fsword_t;

typedef long int __ssize_t;


typedef long int __syscall_slong_t;

typedef unsigned long int __syscall_ulong_t;



typedef __off64_t __loff_t;
typedef char *__caddr_t;


typedef long int __intptr_t;


typedef unsigned int __socklen_t;




typedef int __sig_atomic_t;
# 39 "/usr/include/stdio.h" 2 3 4
# 1 "/usr/include/bits/types/__fpos_t.h" 1 3 4




# 1 "/usr/include/bits/types/__mbstate_t.h" 1 3 4
# 13 "/usr/include/bits/types/__mbstate_t.h" 3 4
typedef struct
{
  int __count;
  union
  {
    unsigned int __wch;
    char __wchb[4];
  } __value;
} __mbstate_t;
# 6 "/usr/include/bits/types/__fpos_t.h" 2 3 4




typedef struct _G_fpos_t
{
  __off_t __pos;
  __mbstate_t __state;
} __fpos_t;
# 40 "/usr/include/stdio.h" 2 3 4
# 1 "/usr/include/bits/types/__fpos64_t.h" 1 3 4
# 10 "/usr/include/bits/types/__fpos64_t.h" 3 4
typedef struct _G_fpos64_t
{
  __off64_t __pos;
  __mbstate_t __state;
} __fpos64_t;
# 41 "/usr/include/stdio.h" 2 3 4
# 1 "/usr/include/bits/types/__FILE.h" 1 3 4



struct _IO_FILE;
typedef struct _IO_FILE __FILE;
# 42 "/usr/include/stdio.h" 2 3 4
# 1 "/usr/include/bits/types/FILE.h" 1 3 4



struct _IO_FILE;


typedef struct _IO_FILE FILE;
# 43 "/usr/include/stdio.h" 2 3 4
# 1 "/usr/include/bits/types/struct_FILE.h" 1 3 4
# 35 "/usr/include/bits/types/struct_FILE.h" 3 4
struct _IO_FILE;
struct _IO_marker;
struct _IO_codecvt;
struct _IO_wide_data;




typedef void _IO_lock_t;





struct _IO_FILE
{
  int _flags;


  char *_IO_read_ptr;
  char *_IO_read_end;
  char *_IO_read_base;
  char *_IO_write_base;
  char *_IO_write_ptr;
  char *_IO_write_end;
  char *_IO_buf_base;
  char *_IO_buf_end;


  char *_IO_save_base;
  char *_IO_backup_base;
  char *_IO_save_end;

  struct _IO_marker *_markers;

  struct _IO_FILE *_chain;

  int _fileno;
  int _flags2;
  __off_t _old_offset;


  unsigned short _cur_column;
  signed char _vtable_offset;
  char _shortbuf[1];

  _IO_lock_t *_lock;







  __off64_t _offset;

  struct _IO_codecvt *_codecvt;
  struct _IO_wide_data *_wide_data;
  struct _IO_FILE *_freeres_list;
  void *_freeres_buf;
  size_t __pad5;
  int _mode;

  char _unused2[15 * sizeof (int) - 4 * sizeof (void *) - sizeof (size_t)];
};
# 44 "/usr/include/stdio.h" 2 3 4


# 1 "/usr/include/bits/types/cookie_io_functions_t.h" 1 3 4
# 27 "/usr/include/bits/types/cookie_io_functions_t.h" 3 4
typedef __ssize_t cookie_read_function_t (void *__cookie, char *__buf,
                                          size_t __nbytes);







typedef __ssize_t cookie_write_function_t (void *__cookie, const char *__buf,
                                           size_t __nbytes);







typedef int cookie_seek_function_t (void *__cookie, __off64_t *__pos, int __w);


typedef int cookie_close_function_t (void *__cookie);






typedef struct _IO_cookie_io_functions_t
{
  cookie_read_function_t *read;
  cookie_write_function_t *write;
  cookie_seek_function_t *seek;
  cookie_close_function_t *close;
} cookie_io_functions_t;
# 47 "/usr/include/stdio.h" 2 3 4





typedef __gnuc_va_list va_list;
# 63 "/usr/include/stdio.h" 3 4
typedef __off_t off_t;






typedef __off64_t off64_t;






typedef __ssize_t ssize_t;






typedef __fpos_t fpos_t;




typedef __fpos64_t fpos64_t;
# 133 "/usr/include/stdio.h" 3 4
# 1 "/usr/include/bits/stdio_lim.h" 1 3 4
# 134 "/usr/include/stdio.h" 2 3 4



extern FILE *stdin;
extern FILE *stdout;
extern FILE *stderr;






extern int remove (const char *__filename) throw ();

extern int rename (const char *__old, const char *__new) throw ();



extern int renameat (int __oldfd, const char *__old, int __newfd,
       const char *__new) throw ();
# 164 "/usr/include/stdio.h" 3 4
extern int renameat2 (int __oldfd, const char *__old, int __newfd,
        const char *__new, unsigned int __flags) throw ();







extern FILE *tmpfile (void) ;
# 183 "/usr/include/stdio.h" 3 4
extern FILE *tmpfile64 (void) ;



extern char *tmpnam (char *__s) throw () ;




extern char *tmpnam_r (char *__s) throw () ;
# 204 "/usr/include/stdio.h" 3 4
extern char *tempnam (const char *__dir, const char *__pfx)
     throw () __attribute__ ((__malloc__)) ;







extern int fclose (FILE *__stream);




extern int fflush (FILE *__stream);
# 227 "/usr/include/stdio.h" 3 4
extern int fflush_unlocked (FILE *__stream);
# 237 "/usr/include/stdio.h" 3 4
extern int fcloseall (void);
# 246 "/usr/include/stdio.h" 3 4
extern FILE *fopen (const char *__restrict __filename,
      const char *__restrict __modes) ;




extern FILE *freopen (const char *__restrict __filename,
        const char *__restrict __modes,
        FILE *__restrict __stream) ;
# 270 "/usr/include/stdio.h" 3 4
extern FILE *fopen64 (const char *__restrict __filename,
        const char *__restrict __modes) ;
extern FILE *freopen64 (const char *__restrict __filename,
   const char *__restrict __modes,
   FILE *__restrict __stream) ;




extern FILE *fdopen (int __fd, const char *__modes) throw () ;





extern FILE *fopencookie (void *__restrict __magic_cookie,
     const char *__restrict __modes,
     cookie_io_functions_t __io_funcs) throw () ;




extern FILE *fmemopen (void *__s, size_t __len, const char *__modes)
  throw () ;




extern FILE *open_memstream (char **__bufloc, size_t *__sizeloc) throw () ;





extern void setbuf (FILE *__restrict __stream, char *__restrict __buf) throw ();



extern int setvbuf (FILE *__restrict __stream, char *__restrict __buf,
      int __modes, size_t __n) throw ();




extern void setbuffer (FILE *__restrict __stream, char *__restrict __buf,
         size_t __size) throw ();


extern void setlinebuf (FILE *__stream) throw ();







extern int fprintf (FILE *__restrict __stream,
      const char *__restrict __format, ...);




extern int printf (const char *__restrict __format, ...);

extern int sprintf (char *__restrict __s,
      const char *__restrict __format, ...) throw ();





extern int vfprintf (FILE *__restrict __s, const char *__restrict __format,
       __gnuc_va_list __arg);




extern int vprintf (const char *__restrict __format, __gnuc_va_list __arg);

extern int vsprintf (char *__restrict __s, const char *__restrict __format,
       __gnuc_va_list __arg) throw ();



extern int snprintf (char *__restrict __s, size_t __maxlen,
       const char *__restrict __format, ...)
     throw () __attribute__ ((__format__ (__printf__, 3, 4)));

extern int vsnprintf (char *__restrict __s, size_t __maxlen,
        const char *__restrict __format, __gnuc_va_list __arg)
     throw () __attribute__ ((__format__ (__printf__, 3, 0)));





extern int vasprintf (char **__restrict __ptr, const char *__restrict __f,
        __gnuc_va_list __arg)
     throw () __attribute__ ((__format__ (__printf__, 2, 0))) ;
extern int __asprintf (char **__restrict __ptr,
         const char *__restrict __fmt, ...)
     throw () __attribute__ ((__format__ (__printf__, 2, 3))) ;
extern int asprintf (char **__restrict __ptr,
       const char *__restrict __fmt, ...)
     throw () __attribute__ ((__format__ (__printf__, 2, 3))) ;




extern int vdprintf (int __fd, const char *__restrict __fmt,
       __gnuc_va_list __arg)
     __attribute__ ((__format__ (__printf__, 2, 0)));
extern int dprintf (int __fd, const char *__restrict __fmt, ...)
     __attribute__ ((__format__ (__printf__, 2, 3)));







extern int fscanf (FILE *__restrict __stream,
     const char *__restrict __format, ...) ;




extern int scanf (const char *__restrict __format, ...) ;

extern int sscanf (const char *__restrict __s,
     const char *__restrict __format, ...) throw ();





# 1 "/usr/include/bits/floatn.h" 1 3 4
# 74 "/usr/include/bits/floatn.h" 3 4
typedef _Complex float __cfloat128 __attribute__ ((__mode__ (__TC__)));
# 86 "/usr/include/bits/floatn.h" 3 4
typedef __float128 _Float128;
# 119 "/usr/include/bits/floatn.h" 3 4
# 1 "/usr/include/bits/floatn-common.h" 1 3 4
# 24 "/usr/include/bits/floatn-common.h" 3 4
# 1 "/usr/include/bits/long-double.h" 1 3 4
# 25 "/usr/include/bits/floatn-common.h" 2 3 4
# 214 "/usr/include/bits/floatn-common.h" 3 4
typedef float _Float32;
# 251 "/usr/include/bits/floatn-common.h" 3 4
typedef double _Float64;
# 268 "/usr/include/bits/floatn-common.h" 3 4
typedef double _Float32x;
# 285 "/usr/include/bits/floatn-common.h" 3 4
typedef long double _Float64x;
# 120 "/usr/include/bits/floatn.h" 2 3 4
# 407 "/usr/include/stdio.h" 2 3 4



extern int fscanf (FILE *__restrict __stream, const char *__restrict __format, ...) __asm__ ("" "__isoc99_fscanf")

                               ;
extern int scanf (const char *__restrict __format, ...) __asm__ ("" "__isoc99_scanf")
                              ;
extern int sscanf (const char *__restrict __s, const char *__restrict __format, ...) throw () __asm__ ("" "__isoc99_sscanf")

                      ;
# 435 "/usr/include/stdio.h" 3 4
extern int vfscanf (FILE *__restrict __s, const char *__restrict __format,
      __gnuc_va_list __arg)
     __attribute__ ((__format__ (__scanf__, 2, 0))) ;





extern int vscanf (const char *__restrict __format, __gnuc_va_list __arg)
     __attribute__ ((__format__ (__scanf__, 1, 0))) ;


extern int vsscanf (const char *__restrict __s,
      const char *__restrict __format, __gnuc_va_list __arg)
     throw () __attribute__ ((__format__ (__scanf__, 2, 0)));





extern int vfscanf (FILE *__restrict __s, const char *__restrict __format, __gnuc_va_list __arg) __asm__ ("" "__isoc99_vfscanf")



     __attribute__ ((__format__ (__scanf__, 2, 0))) ;
extern int vscanf (const char *__restrict __format, __gnuc_va_list __arg) __asm__ ("" "__isoc99_vscanf")

     __attribute__ ((__format__ (__scanf__, 1, 0))) ;
extern int vsscanf (const char *__restrict __s, const char *__restrict __format, __gnuc_va_list __arg) throw () __asm__ ("" "__isoc99_vsscanf")



     __attribute__ ((__format__ (__scanf__, 2, 0)));
# 489 "/usr/include/stdio.h" 3 4
extern int fgetc (FILE *__stream);
extern int getc (FILE *__stream);





extern int getchar (void);






extern int getc_unlocked (FILE *__stream);
extern int getchar_unlocked (void);
# 514 "/usr/include/stdio.h" 3 4
extern int fgetc_unlocked (FILE *__stream);
# 525 "/usr/include/stdio.h" 3 4
extern int fputc (int __c, FILE *__stream);
extern int putc (int __c, FILE *__stream);





extern int putchar (int __c);
# 541 "/usr/include/stdio.h" 3 4
extern int fputc_unlocked (int __c, FILE *__stream);







extern int putc_unlocked (int __c, FILE *__stream);
extern int putchar_unlocked (int __c);






extern int getw (FILE *__stream);


extern int putw (int __w, FILE *__stream);







extern char *fgets (char *__restrict __s, int __n, FILE *__restrict __stream)
     __attribute__ ((__access__ (__write_only__, 1, 2)));
# 581 "/usr/include/stdio.h" 3 4
extern char *gets (char *__s) __attribute__ ((__deprecated__));
# 591 "/usr/include/stdio.h" 3 4
extern char *fgets_unlocked (char *__restrict __s, int __n,
        FILE *__restrict __stream)
    __attribute__ ((__access__ (__write_only__, 1, 2)));
# 608 "/usr/include/stdio.h" 3 4
extern __ssize_t __getdelim (char **__restrict __lineptr,
                             size_t *__restrict __n, int __delimiter,
                             FILE *__restrict __stream) ;
extern __ssize_t getdelim (char **__restrict __lineptr,
                           size_t *__restrict __n, int __delimiter,
                           FILE *__restrict __stream) ;







extern __ssize_t getline (char **__restrict __lineptr,
                          size_t *__restrict __n,
                          FILE *__restrict __stream) ;







extern int fputs (const char *__restrict __s, FILE *__restrict __stream);





extern int puts (const char *__s);






extern int ungetc (int __c, FILE *__stream);






extern size_t fread (void *__restrict __ptr, size_t __size,
       size_t __n, FILE *__restrict __stream) ;




extern size_t fwrite (const void *__restrict __ptr, size_t __size,
        size_t __n, FILE *__restrict __s);
# 667 "/usr/include/stdio.h" 3 4
extern int fputs_unlocked (const char *__restrict __s,
      FILE *__restrict __stream);
# 678 "/usr/include/stdio.h" 3 4
extern size_t fread_unlocked (void *__restrict __ptr, size_t __size,
         size_t __n, FILE *__restrict __stream) ;
extern size_t fwrite_unlocked (const void *__restrict __ptr, size_t __size,
          size_t __n, FILE *__restrict __stream);







extern int fseek (FILE *__stream, long int __off, int __whence);




extern long int ftell (FILE *__stream) ;




extern void rewind (FILE *__stream);
# 712 "/usr/include/stdio.h" 3 4
extern int fseeko (FILE *__stream, __off_t __off, int __whence);




extern __off_t ftello (FILE *__stream) ;
# 736 "/usr/include/stdio.h" 3 4
extern int fgetpos (FILE *__restrict __stream, fpos_t *__restrict __pos);




extern int fsetpos (FILE *__stream, const fpos_t *__pos);
# 755 "/usr/include/stdio.h" 3 4
extern int fseeko64 (FILE *__stream, __off64_t __off, int __whence);
extern __off64_t ftello64 (FILE *__stream) ;
extern int fgetpos64 (FILE *__restrict __stream, fpos64_t *__restrict __pos);
extern int fsetpos64 (FILE *__stream, const fpos64_t *__pos);



extern void clearerr (FILE *__stream) throw ();

extern int feof (FILE *__stream) throw () ;

extern int ferror (FILE *__stream) throw () ;



extern void clearerr_unlocked (FILE *__stream) throw ();
extern int feof_unlocked (FILE *__stream) throw () ;
extern int ferror_unlocked (FILE *__stream) throw () ;







extern void perror (const char *__s);




extern int fileno (FILE *__stream) throw () ;




extern int fileno_unlocked (FILE *__stream) throw () ;
# 799 "/usr/include/stdio.h" 3 4
extern FILE *popen (const char *__command, const char *__modes) ;





extern int pclose (FILE *__stream);





extern char *ctermid (char *__s) throw ();





extern char *cuserid (char *__s);




struct obstack;


extern int obstack_printf (struct obstack *__restrict __obstack,
      const char *__restrict __format, ...)
     throw () __attribute__ ((__format__ (__printf__, 2, 3)));
extern int obstack_vprintf (struct obstack *__restrict __obstack,
       const char *__restrict __format,
       __gnuc_va_list __args)
     throw () __attribute__ ((__format__ (__printf__, 2, 0)));







extern void flockfile (FILE *__stream) throw ();



extern int ftrylockfile (FILE *__stream) throw () ;


extern void funlockfile (FILE *__stream) throw ();
# 857 "/usr/include/stdio.h" 3 4
extern int __uflow (FILE *);
extern int __overflow (FILE *, int);
# 874 "/usr/include/stdio.h" 3 4
}
# 2 "4coder_sam.cpp" 2
# 1 "/usr/include/c++/10.2.0/stdlib.h" 1 3
# 36 "/usr/include/c++/10.2.0/stdlib.h" 3
# 1 "/usr/include/c++/10.2.0/cstdlib" 1 3
# 39 "/usr/include/c++/10.2.0/cstdlib" 3
       
# 40 "/usr/include/c++/10.2.0/cstdlib" 3

# 1 "/usr/include/c++/10.2.0/x86_64-pc-linux-gnu/bits/c++config.h" 1 3
# 258 "/usr/include/c++/10.2.0/x86_64-pc-linux-gnu/bits/c++config.h" 3
namespace std
{
  typedef long unsigned int size_t;
  typedef long int ptrdiff_t;


  typedef decltype(nullptr) nullptr_t;

}
# 280 "/usr/include/c++/10.2.0/x86_64-pc-linux-gnu/bits/c++config.h" 3
namespace std
{
  inline namespace __cxx11 __attribute__((__abi_tag__ ("cxx11"))) { }
}
namespace __gnu_cxx
{
  inline namespace __cxx11 __attribute__((__abi_tag__ ("cxx11"))) { }
}
# 518 "/usr/include/c++/10.2.0/x86_64-pc-linux-gnu/bits/c++config.h" 3
# 1 "/usr/include/c++/10.2.0/x86_64-pc-linux-gnu/bits/os_defines.h" 1 3
# 519 "/usr/include/c++/10.2.0/x86_64-pc-linux-gnu/bits/c++config.h" 2 3


# 1 "/usr/include/c++/10.2.0/x86_64-pc-linux-gnu/bits/cpu_defines.h" 1 3
# 522 "/usr/include/c++/10.2.0/x86_64-pc-linux-gnu/bits/c++config.h" 2 3
# 42 "/usr/include/c++/10.2.0/cstdlib" 2 3
# 75 "/usr/include/c++/10.2.0/cstdlib" 3
# 1 "/usr/include/stdlib.h" 1 3 4
# 25 "/usr/include/stdlib.h" 3 4
# 1 "/usr/include/bits/libc-header-start.h" 1 3 4
# 26 "/usr/include/stdlib.h" 2 3 4





# 1 "/usr/lib/gcc/x86_64-pc-linux-gnu/10.2.0/include/stddef.h" 1 3 4
# 32 "/usr/include/stdlib.h" 2 3 4

extern "C" {





# 1 "/usr/include/bits/waitflags.h" 1 3 4
# 40 "/usr/include/stdlib.h" 2 3 4
# 1 "/usr/include/bits/waitstatus.h" 1 3 4
# 41 "/usr/include/stdlib.h" 2 3 4
# 58 "/usr/include/stdlib.h" 3 4
typedef struct
  {
    int quot;
    int rem;
  } div_t;



typedef struct
  {
    long int quot;
    long int rem;
  } ldiv_t;





__extension__ typedef struct
  {
    long long int quot;
    long long int rem;
  } lldiv_t;
# 97 "/usr/include/stdlib.h" 3 4
extern size_t __ctype_get_mb_cur_max (void) throw () ;



extern double atof (const char *__nptr)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;

extern int atoi (const char *__nptr)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;

extern long int atol (const char *__nptr)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;



__extension__ extern long long int atoll (const char *__nptr)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;



extern double strtod (const char *__restrict __nptr,
        char **__restrict __endptr)
     throw () __attribute__ ((__nonnull__ (1)));



extern float strtof (const char *__restrict __nptr,
       char **__restrict __endptr) throw () __attribute__ ((__nonnull__ (1)));

extern long double strtold (const char *__restrict __nptr,
       char **__restrict __endptr)
     throw () __attribute__ ((__nonnull__ (1)));
# 140 "/usr/include/stdlib.h" 3 4
extern _Float32 strtof32 (const char *__restrict __nptr,
     char **__restrict __endptr)
     throw () __attribute__ ((__nonnull__ (1)));



extern _Float64 strtof64 (const char *__restrict __nptr,
     char **__restrict __endptr)
     throw () __attribute__ ((__nonnull__ (1)));



extern _Float128 strtof128 (const char *__restrict __nptr,
       char **__restrict __endptr)
     throw () __attribute__ ((__nonnull__ (1)));



extern _Float32x strtof32x (const char *__restrict __nptr,
       char **__restrict __endptr)
     throw () __attribute__ ((__nonnull__ (1)));



extern _Float64x strtof64x (const char *__restrict __nptr,
       char **__restrict __endptr)
     throw () __attribute__ ((__nonnull__ (1)));
# 176 "/usr/include/stdlib.h" 3 4
extern long int strtol (const char *__restrict __nptr,
   char **__restrict __endptr, int __base)
     throw () __attribute__ ((__nonnull__ (1)));

extern unsigned long int strtoul (const char *__restrict __nptr,
      char **__restrict __endptr, int __base)
     throw () __attribute__ ((__nonnull__ (1)));



__extension__
extern long long int strtoq (const char *__restrict __nptr,
        char **__restrict __endptr, int __base)
     throw () __attribute__ ((__nonnull__ (1)));

__extension__
extern unsigned long long int strtouq (const char *__restrict __nptr,
           char **__restrict __endptr, int __base)
     throw () __attribute__ ((__nonnull__ (1)));




__extension__
extern long long int strtoll (const char *__restrict __nptr,
         char **__restrict __endptr, int __base)
     throw () __attribute__ ((__nonnull__ (1)));

__extension__
extern unsigned long long int strtoull (const char *__restrict __nptr,
     char **__restrict __endptr, int __base)
     throw () __attribute__ ((__nonnull__ (1)));




extern int strfromd (char *__dest, size_t __size, const char *__format,
       double __f)
     throw () __attribute__ ((__nonnull__ (3)));

extern int strfromf (char *__dest, size_t __size, const char *__format,
       float __f)
     throw () __attribute__ ((__nonnull__ (3)));

extern int strfroml (char *__dest, size_t __size, const char *__format,
       long double __f)
     throw () __attribute__ ((__nonnull__ (3)));
# 232 "/usr/include/stdlib.h" 3 4
extern int strfromf32 (char *__dest, size_t __size, const char * __format,
         _Float32 __f)
     throw () __attribute__ ((__nonnull__ (3)));



extern int strfromf64 (char *__dest, size_t __size, const char * __format,
         _Float64 __f)
     throw () __attribute__ ((__nonnull__ (3)));



extern int strfromf128 (char *__dest, size_t __size, const char * __format,
   _Float128 __f)
     throw () __attribute__ ((__nonnull__ (3)));



extern int strfromf32x (char *__dest, size_t __size, const char * __format,
   _Float32x __f)
     throw () __attribute__ ((__nonnull__ (3)));



extern int strfromf64x (char *__dest, size_t __size, const char * __format,
   _Float64x __f)
     throw () __attribute__ ((__nonnull__ (3)));
# 272 "/usr/include/stdlib.h" 3 4
# 1 "/usr/include/bits/types/locale_t.h" 1 3 4
# 22 "/usr/include/bits/types/locale_t.h" 3 4
# 1 "/usr/include/bits/types/__locale_t.h" 1 3 4
# 28 "/usr/include/bits/types/__locale_t.h" 3 4
struct __locale_struct
{

  struct __locale_data *__locales[13];


  const unsigned short int *__ctype_b;
  const int *__ctype_tolower;
  const int *__ctype_toupper;


  const char *__names[13];
};

typedef struct __locale_struct *__locale_t;
# 23 "/usr/include/bits/types/locale_t.h" 2 3 4

typedef __locale_t locale_t;
# 273 "/usr/include/stdlib.h" 2 3 4

extern long int strtol_l (const char *__restrict __nptr,
     char **__restrict __endptr, int __base,
     locale_t __loc) throw () __attribute__ ((__nonnull__ (1, 4)));

extern unsigned long int strtoul_l (const char *__restrict __nptr,
        char **__restrict __endptr,
        int __base, locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 4)));

__extension__
extern long long int strtoll_l (const char *__restrict __nptr,
    char **__restrict __endptr, int __base,
    locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 4)));

__extension__
extern unsigned long long int strtoull_l (const char *__restrict __nptr,
       char **__restrict __endptr,
       int __base, locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 4)));

extern double strtod_l (const char *__restrict __nptr,
   char **__restrict __endptr, locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 3)));

extern float strtof_l (const char *__restrict __nptr,
         char **__restrict __endptr, locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 3)));

extern long double strtold_l (const char *__restrict __nptr,
         char **__restrict __endptr,
         locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 3)));
# 316 "/usr/include/stdlib.h" 3 4
extern _Float32 strtof32_l (const char *__restrict __nptr,
       char **__restrict __endptr,
       locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 3)));



extern _Float64 strtof64_l (const char *__restrict __nptr,
       char **__restrict __endptr,
       locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 3)));



extern _Float128 strtof128_l (const char *__restrict __nptr,
         char **__restrict __endptr,
         locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 3)));



extern _Float32x strtof32x_l (const char *__restrict __nptr,
         char **__restrict __endptr,
         locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 3)));



extern _Float64x strtof64x_l (const char *__restrict __nptr,
         char **__restrict __endptr,
         locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 3)));
# 385 "/usr/include/stdlib.h" 3 4
extern char *l64a (long int __n) throw () ;


extern long int a64l (const char *__s)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;




# 1 "/usr/include/sys/types.h" 1 3 4
# 27 "/usr/include/sys/types.h" 3 4
extern "C" {





typedef __u_char u_char;
typedef __u_short u_short;
typedef __u_int u_int;
typedef __u_long u_long;
typedef __quad_t quad_t;
typedef __u_quad_t u_quad_t;
typedef __fsid_t fsid_t;


typedef __loff_t loff_t;




typedef __ino_t ino_t;






typedef __ino64_t ino64_t;




typedef __dev_t dev_t;




typedef __gid_t gid_t;




typedef __mode_t mode_t;




typedef __nlink_t nlink_t;




typedef __uid_t uid_t;
# 97 "/usr/include/sys/types.h" 3 4
typedef __pid_t pid_t;





typedef __id_t id_t;
# 114 "/usr/include/sys/types.h" 3 4
typedef __daddr_t daddr_t;
typedef __caddr_t caddr_t;





typedef __key_t key_t;




# 1 "/usr/include/bits/types/clock_t.h" 1 3 4






typedef __clock_t clock_t;
# 127 "/usr/include/sys/types.h" 2 3 4

# 1 "/usr/include/bits/types/clockid_t.h" 1 3 4






typedef __clockid_t clockid_t;
# 129 "/usr/include/sys/types.h" 2 3 4
# 1 "/usr/include/bits/types/time_t.h" 1 3 4






typedef __time_t time_t;
# 130 "/usr/include/sys/types.h" 2 3 4
# 1 "/usr/include/bits/types/timer_t.h" 1 3 4






typedef __timer_t timer_t;
# 131 "/usr/include/sys/types.h" 2 3 4



typedef __useconds_t useconds_t;



typedef __suseconds_t suseconds_t;





# 1 "/usr/lib/gcc/x86_64-pc-linux-gnu/10.2.0/include/stddef.h" 1 3 4
# 145 "/usr/include/sys/types.h" 2 3 4



typedef unsigned long int ulong;
typedef unsigned short int ushort;
typedef unsigned int uint;




# 1 "/usr/include/bits/stdint-intn.h" 1 3 4
# 24 "/usr/include/bits/stdint-intn.h" 3 4
typedef __int8_t int8_t;
typedef __int16_t int16_t;
typedef __int32_t int32_t;
typedef __int64_t int64_t;
# 156 "/usr/include/sys/types.h" 2 3 4


typedef __uint8_t u_int8_t;
typedef __uint16_t u_int16_t;
typedef __uint32_t u_int32_t;
typedef __uint64_t u_int64_t;


typedef int register_t __attribute__ ((__mode__ (__word__)));
# 176 "/usr/include/sys/types.h" 3 4
# 1 "/usr/include/endian.h" 1 3 4
# 24 "/usr/include/endian.h" 3 4
# 1 "/usr/include/bits/endian.h" 1 3 4
# 35 "/usr/include/bits/endian.h" 3 4
# 1 "/usr/include/bits/endianness.h" 1 3 4
# 36 "/usr/include/bits/endian.h" 2 3 4
# 25 "/usr/include/endian.h" 2 3 4
# 35 "/usr/include/endian.h" 3 4
# 1 "/usr/include/bits/byteswap.h" 1 3 4
# 33 "/usr/include/bits/byteswap.h" 3 4
static __inline __uint16_t
__bswap_16 (__uint16_t __bsx)
{

  return __builtin_bswap16 (__bsx);



}






static __inline __uint32_t
__bswap_32 (__uint32_t __bsx)
{

  return __builtin_bswap32 (__bsx);



}
# 69 "/usr/include/bits/byteswap.h" 3 4
__extension__ static __inline __uint64_t
__bswap_64 (__uint64_t __bsx)
{

  return __builtin_bswap64 (__bsx);



}
# 36 "/usr/include/endian.h" 2 3 4
# 1 "/usr/include/bits/uintn-identity.h" 1 3 4
# 32 "/usr/include/bits/uintn-identity.h" 3 4
static __inline __uint16_t
__uint16_identity (__uint16_t __x)
{
  return __x;
}

static __inline __uint32_t
__uint32_identity (__uint32_t __x)
{
  return __x;
}

static __inline __uint64_t
__uint64_identity (__uint64_t __x)
{
  return __x;
}
# 37 "/usr/include/endian.h" 2 3 4
# 177 "/usr/include/sys/types.h" 2 3 4


# 1 "/usr/include/sys/select.h" 1 3 4
# 30 "/usr/include/sys/select.h" 3 4
# 1 "/usr/include/bits/select.h" 1 3 4
# 31 "/usr/include/sys/select.h" 2 3 4


# 1 "/usr/include/bits/types/sigset_t.h" 1 3 4



# 1 "/usr/include/bits/types/__sigset_t.h" 1 3 4




typedef struct
{
  unsigned long int __val[(1024 / (8 * sizeof (unsigned long int)))];
} __sigset_t;
# 5 "/usr/include/bits/types/sigset_t.h" 2 3 4


typedef __sigset_t sigset_t;
# 34 "/usr/include/sys/select.h" 2 3 4



# 1 "/usr/include/bits/types/struct_timeval.h" 1 3 4







struct timeval
{
  __time_t tv_sec;
  __suseconds_t tv_usec;
};
# 38 "/usr/include/sys/select.h" 2 3 4

# 1 "/usr/include/bits/types/struct_timespec.h" 1 3 4
# 10 "/usr/include/bits/types/struct_timespec.h" 3 4
struct timespec
{
  __time_t tv_sec;



  __syscall_slong_t tv_nsec;
# 26 "/usr/include/bits/types/struct_timespec.h" 3 4
};
# 40 "/usr/include/sys/select.h" 2 3 4
# 49 "/usr/include/sys/select.h" 3 4
typedef long int __fd_mask;
# 59 "/usr/include/sys/select.h" 3 4
typedef struct
  {



    __fd_mask fds_bits[1024 / (8 * (int) sizeof (__fd_mask))];





  } fd_set;






typedef __fd_mask fd_mask;
# 91 "/usr/include/sys/select.h" 3 4
extern "C" {
# 101 "/usr/include/sys/select.h" 3 4
extern int select (int __nfds, fd_set *__restrict __readfds,
     fd_set *__restrict __writefds,
     fd_set *__restrict __exceptfds,
     struct timeval *__restrict __timeout);
# 113 "/usr/include/sys/select.h" 3 4
extern int pselect (int __nfds, fd_set *__restrict __readfds,
      fd_set *__restrict __writefds,
      fd_set *__restrict __exceptfds,
      const struct timespec *__restrict __timeout,
      const __sigset_t *__restrict __sigmask);
# 126 "/usr/include/sys/select.h" 3 4
}
# 180 "/usr/include/sys/types.h" 2 3 4





typedef __blksize_t blksize_t;






typedef __blkcnt_t blkcnt_t;



typedef __fsblkcnt_t fsblkcnt_t;



typedef __fsfilcnt_t fsfilcnt_t;
# 219 "/usr/include/sys/types.h" 3 4
typedef __blkcnt64_t blkcnt64_t;
typedef __fsblkcnt64_t fsblkcnt64_t;
typedef __fsfilcnt64_t fsfilcnt64_t;





# 1 "/usr/include/bits/pthreadtypes.h" 1 3 4
# 23 "/usr/include/bits/pthreadtypes.h" 3 4
# 1 "/usr/include/bits/thread-shared-types.h" 1 3 4
# 44 "/usr/include/bits/thread-shared-types.h" 3 4
# 1 "/usr/include/bits/pthreadtypes-arch.h" 1 3 4
# 21 "/usr/include/bits/pthreadtypes-arch.h" 3 4
# 1 "/usr/include/bits/wordsize.h" 1 3 4
# 22 "/usr/include/bits/pthreadtypes-arch.h" 2 3 4
# 45 "/usr/include/bits/thread-shared-types.h" 2 3 4




typedef struct __pthread_internal_list
{
  struct __pthread_internal_list *__prev;
  struct __pthread_internal_list *__next;
} __pthread_list_t;

typedef struct __pthread_internal_slist
{
  struct __pthread_internal_slist *__next;
} __pthread_slist_t;
# 74 "/usr/include/bits/thread-shared-types.h" 3 4
# 1 "/usr/include/bits/struct_mutex.h" 1 3 4
# 22 "/usr/include/bits/struct_mutex.h" 3 4
struct __pthread_mutex_s
{
  int __lock;
  unsigned int __count;
  int __owner;

  unsigned int __nusers;



  int __kind;

  short __spins;
  short __elision;
  __pthread_list_t __list;
# 53 "/usr/include/bits/struct_mutex.h" 3 4
};
# 75 "/usr/include/bits/thread-shared-types.h" 2 3 4
# 87 "/usr/include/bits/thread-shared-types.h" 3 4
# 1 "/usr/include/bits/struct_rwlock.h" 1 3 4
# 23 "/usr/include/bits/struct_rwlock.h" 3 4
struct __pthread_rwlock_arch_t
{
  unsigned int __readers;
  unsigned int __writers;
  unsigned int __wrphase_futex;
  unsigned int __writers_futex;
  unsigned int __pad3;
  unsigned int __pad4;

  int __cur_writer;
  int __shared;
  signed char __rwelision;




  unsigned char __pad1[7];


  unsigned long int __pad2;


  unsigned int __flags;
# 55 "/usr/include/bits/struct_rwlock.h" 3 4
};
# 88 "/usr/include/bits/thread-shared-types.h" 2 3 4




struct __pthread_cond_s
{
  __extension__ union
  {
    __extension__ unsigned long long int __wseq;
    struct
    {
      unsigned int __low;
      unsigned int __high;
    } __wseq32;
  };
  __extension__ union
  {
    __extension__ unsigned long long int __g1_start;
    struct
    {
      unsigned int __low;
      unsigned int __high;
    } __g1_start32;
  };
  unsigned int __g_refs[2] ;
  unsigned int __g_size[2];
  unsigned int __g1_orig_size;
  unsigned int __wrefs;
  unsigned int __g_signals[2];
};

typedef unsigned int __tss_t;
typedef unsigned long int __thrd_t;

typedef struct
{
  int __data ;
} __once_flag;
# 24 "/usr/include/bits/pthreadtypes.h" 2 3 4



typedef unsigned long int pthread_t;




typedef union
{
  char __size[4];
  int __align;
} pthread_mutexattr_t;




typedef union
{
  char __size[4];
  int __align;
} pthread_condattr_t;



typedef unsigned int pthread_key_t;



typedef int pthread_once_t;


union pthread_attr_t
{
  char __size[56];
  long int __align;
};

typedef union pthread_attr_t pthread_attr_t;




typedef union
{
  struct __pthread_mutex_s __data;
  char __size[40];
  long int __align;
} pthread_mutex_t;


typedef union
{
  struct __pthread_cond_s __data;
  char __size[48];
  __extension__ long long int __align;
} pthread_cond_t;





typedef union
{
  struct __pthread_rwlock_arch_t __data;
  char __size[56];
  long int __align;
} pthread_rwlock_t;

typedef union
{
  char __size[8];
  long int __align;
} pthread_rwlockattr_t;





typedef volatile int pthread_spinlock_t;




typedef union
{
  char __size[32];
  long int __align;
} pthread_barrier_t;

typedef union
{
  char __size[4];
  int __align;
} pthread_barrierattr_t;
# 228 "/usr/include/sys/types.h" 2 3 4


}
# 395 "/usr/include/stdlib.h" 2 3 4






extern long int random (void) throw ();


extern void srandom (unsigned int __seed) throw ();





extern char *initstate (unsigned int __seed, char *__statebuf,
   size_t __statelen) throw () __attribute__ ((__nonnull__ (2)));



extern char *setstate (char *__statebuf) throw () __attribute__ ((__nonnull__ (1)));







struct random_data
  {
    int32_t *fptr;
    int32_t *rptr;
    int32_t *state;
    int rand_type;
    int rand_deg;
    int rand_sep;
    int32_t *end_ptr;
  };

extern int random_r (struct random_data *__restrict __buf,
       int32_t *__restrict __result) throw () __attribute__ ((__nonnull__ (1, 2)));

extern int srandom_r (unsigned int __seed, struct random_data *__buf)
     throw () __attribute__ ((__nonnull__ (2)));

extern int initstate_r (unsigned int __seed, char *__restrict __statebuf,
   size_t __statelen,
   struct random_data *__restrict __buf)
     throw () __attribute__ ((__nonnull__ (2, 4)));

extern int setstate_r (char *__restrict __statebuf,
         struct random_data *__restrict __buf)
     throw () __attribute__ ((__nonnull__ (1, 2)));





extern int rand (void) throw ();

extern void srand (unsigned int __seed) throw ();



extern int rand_r (unsigned int *__seed) throw ();







extern double drand48 (void) throw ();
extern double erand48 (unsigned short int __xsubi[3]) throw () __attribute__ ((__nonnull__ (1)));


extern long int lrand48 (void) throw ();
extern long int nrand48 (unsigned short int __xsubi[3])
     throw () __attribute__ ((__nonnull__ (1)));


extern long int mrand48 (void) throw ();
extern long int jrand48 (unsigned short int __xsubi[3])
     throw () __attribute__ ((__nonnull__ (1)));


extern void srand48 (long int __seedval) throw ();
extern unsigned short int *seed48 (unsigned short int __seed16v[3])
     throw () __attribute__ ((__nonnull__ (1)));
extern void lcong48 (unsigned short int __param[7]) throw () __attribute__ ((__nonnull__ (1)));





struct drand48_data
  {
    unsigned short int __x[3];
    unsigned short int __old_x[3];
    unsigned short int __c;
    unsigned short int __init;
    __extension__ unsigned long long int __a;

  };


extern int drand48_r (struct drand48_data *__restrict __buffer,
        double *__restrict __result) throw () __attribute__ ((__nonnull__ (1, 2)));
extern int erand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        double *__restrict __result) throw () __attribute__ ((__nonnull__ (1, 2)));


extern int lrand48_r (struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     throw () __attribute__ ((__nonnull__ (1, 2)));
extern int nrand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int mrand48_r (struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     throw () __attribute__ ((__nonnull__ (1, 2)));
extern int jrand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int srand48_r (long int __seedval, struct drand48_data *__buffer)
     throw () __attribute__ ((__nonnull__ (2)));

extern int seed48_r (unsigned short int __seed16v[3],
       struct drand48_data *__buffer) throw () __attribute__ ((__nonnull__ (1, 2)));

extern int lcong48_r (unsigned short int __param[7],
        struct drand48_data *__buffer)
     throw () __attribute__ ((__nonnull__ (1, 2)));




extern void *malloc (size_t __size) throw () __attribute__ ((__malloc__))
     __attribute__ ((__alloc_size__ (1))) ;

extern void *calloc (size_t __nmemb, size_t __size)
     throw () __attribute__ ((__malloc__)) __attribute__ ((__alloc_size__ (1, 2))) ;






extern void *realloc (void *__ptr, size_t __size)
     throw () __attribute__ ((__warn_unused_result__)) __attribute__ ((__alloc_size__ (2)));







extern void *reallocarray (void *__ptr, size_t __nmemb, size_t __size)
     throw () __attribute__ ((__warn_unused_result__))
     __attribute__ ((__alloc_size__ (2, 3)));



extern void free (void *__ptr) throw ();


# 1 "/usr/include/alloca.h" 1 3 4
# 24 "/usr/include/alloca.h" 3 4
# 1 "/usr/lib/gcc/x86_64-pc-linux-gnu/10.2.0/include/stddef.h" 1 3 4
# 25 "/usr/include/alloca.h" 2 3 4

extern "C" {





extern void *alloca (size_t __size) throw ();





}
# 569 "/usr/include/stdlib.h" 2 3 4





extern void *valloc (size_t __size) throw () __attribute__ ((__malloc__))
     __attribute__ ((__alloc_size__ (1))) ;




extern int posix_memalign (void **__memptr, size_t __alignment, size_t __size)
     throw () __attribute__ ((__nonnull__ (1))) ;




extern void *aligned_alloc (size_t __alignment, size_t __size)
     throw () __attribute__ ((__malloc__)) __attribute__ ((__alloc_size__ (2))) ;



extern void abort (void) throw () __attribute__ ((__noreturn__));



extern int atexit (void (*__func) (void)) throw () __attribute__ ((__nonnull__ (1)));




extern "C++" int at_quick_exit (void (*__func) (void))
     throw () __asm ("at_quick_exit") __attribute__ ((__nonnull__ (1)));
# 610 "/usr/include/stdlib.h" 3 4
extern int on_exit (void (*__func) (int __status, void *__arg), void *__arg)
     throw () __attribute__ ((__nonnull__ (1)));





extern void exit (int __status) throw () __attribute__ ((__noreturn__));





extern void quick_exit (int __status) throw () __attribute__ ((__noreturn__));





extern void _Exit (int __status) throw () __attribute__ ((__noreturn__));




extern char *getenv (const char *__name) throw () __attribute__ ((__nonnull__ (1))) ;




extern char *secure_getenv (const char *__name)
     throw () __attribute__ ((__nonnull__ (1))) ;






extern int putenv (char *__string) throw () __attribute__ ((__nonnull__ (1)));





extern int setenv (const char *__name, const char *__value, int __replace)
     throw () __attribute__ ((__nonnull__ (2)));


extern int unsetenv (const char *__name) throw () __attribute__ ((__nonnull__ (1)));






extern int clearenv (void) throw ();
# 675 "/usr/include/stdlib.h" 3 4
extern char *mktemp (char *__template) throw () __attribute__ ((__nonnull__ (1)));
# 688 "/usr/include/stdlib.h" 3 4
extern int mkstemp (char *__template) __attribute__ ((__nonnull__ (1))) ;
# 698 "/usr/include/stdlib.h" 3 4
extern int mkstemp64 (char *__template) __attribute__ ((__nonnull__ (1))) ;
# 710 "/usr/include/stdlib.h" 3 4
extern int mkstemps (char *__template, int __suffixlen) __attribute__ ((__nonnull__ (1))) ;
# 720 "/usr/include/stdlib.h" 3 4
extern int mkstemps64 (char *__template, int __suffixlen)
     __attribute__ ((__nonnull__ (1))) ;
# 731 "/usr/include/stdlib.h" 3 4
extern char *mkdtemp (char *__template) throw () __attribute__ ((__nonnull__ (1))) ;
# 742 "/usr/include/stdlib.h" 3 4
extern int mkostemp (char *__template, int __flags) __attribute__ ((__nonnull__ (1))) ;
# 752 "/usr/include/stdlib.h" 3 4
extern int mkostemp64 (char *__template, int __flags) __attribute__ ((__nonnull__ (1))) ;
# 762 "/usr/include/stdlib.h" 3 4
extern int mkostemps (char *__template, int __suffixlen, int __flags)
     __attribute__ ((__nonnull__ (1))) ;
# 774 "/usr/include/stdlib.h" 3 4
extern int mkostemps64 (char *__template, int __suffixlen, int __flags)
     __attribute__ ((__nonnull__ (1))) ;
# 784 "/usr/include/stdlib.h" 3 4
extern int system (const char *__command) ;





extern char *canonicalize_file_name (const char *__name)
     throw () __attribute__ ((__nonnull__ (1))) ;
# 800 "/usr/include/stdlib.h" 3 4
extern char *realpath (const char *__restrict __name,
         char *__restrict __resolved) throw () ;






typedef int (*__compar_fn_t) (const void *, const void *);


typedef __compar_fn_t comparison_fn_t;



typedef int (*__compar_d_fn_t) (const void *, const void *, void *);




extern void *bsearch (const void *__key, const void *__base,
        size_t __nmemb, size_t __size, __compar_fn_t __compar)
     __attribute__ ((__nonnull__ (1, 2, 5))) ;







extern void qsort (void *__base, size_t __nmemb, size_t __size,
     __compar_fn_t __compar) __attribute__ ((__nonnull__ (1, 4)));

extern void qsort_r (void *__base, size_t __nmemb, size_t __size,
       __compar_d_fn_t __compar, void *__arg)
  __attribute__ ((__nonnull__ (1, 4)));




extern int abs (int __x) throw () __attribute__ ((__const__)) ;
extern long int labs (long int __x) throw () __attribute__ ((__const__)) ;


__extension__ extern long long int llabs (long long int __x)
     throw () __attribute__ ((__const__)) ;






extern div_t div (int __numer, int __denom)
     throw () __attribute__ ((__const__)) ;
extern ldiv_t ldiv (long int __numer, long int __denom)
     throw () __attribute__ ((__const__)) ;


__extension__ extern lldiv_t lldiv (long long int __numer,
        long long int __denom)
     throw () __attribute__ ((__const__)) ;
# 872 "/usr/include/stdlib.h" 3 4
extern char *ecvt (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign) throw () __attribute__ ((__nonnull__ (3, 4))) ;




extern char *fcvt (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign) throw () __attribute__ ((__nonnull__ (3, 4))) ;




extern char *gcvt (double __value, int __ndigit, char *__buf)
     throw () __attribute__ ((__nonnull__ (3))) ;




extern char *qecvt (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign)
     throw () __attribute__ ((__nonnull__ (3, 4))) ;
extern char *qfcvt (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign)
     throw () __attribute__ ((__nonnull__ (3, 4))) ;
extern char *qgcvt (long double __value, int __ndigit, char *__buf)
     throw () __attribute__ ((__nonnull__ (3))) ;




extern int ecvt_r (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign, char *__restrict __buf,
     size_t __len) throw () __attribute__ ((__nonnull__ (3, 4, 5)));
extern int fcvt_r (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign, char *__restrict __buf,
     size_t __len) throw () __attribute__ ((__nonnull__ (3, 4, 5)));

extern int qecvt_r (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign,
      char *__restrict __buf, size_t __len)
     throw () __attribute__ ((__nonnull__ (3, 4, 5)));
extern int qfcvt_r (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign,
      char *__restrict __buf, size_t __len)
     throw () __attribute__ ((__nonnull__ (3, 4, 5)));





extern int mblen (const char *__s, size_t __n) throw ();


extern int mbtowc (wchar_t *__restrict __pwc,
     const char *__restrict __s, size_t __n) throw ();


extern int wctomb (char *__s, wchar_t __wchar) throw ();



extern size_t mbstowcs (wchar_t *__restrict __pwcs,
   const char *__restrict __s, size_t __n) throw ()
    __attribute__ ((__access__ (__read_only__, 2)));

extern size_t wcstombs (char *__restrict __s,
   const wchar_t *__restrict __pwcs, size_t __n)
     throw ()
  __attribute__ ((__access__ (__write_only__, 1, 3))) __attribute__ ((__access__ (__read_only__, 2)));






extern int rpmatch (const char *__response) throw () __attribute__ ((__nonnull__ (1))) ;
# 958 "/usr/include/stdlib.h" 3 4
extern int getsubopt (char **__restrict __optionp,
        char *const *__restrict __tokens,
        char **__restrict __valuep)
     throw () __attribute__ ((__nonnull__ (1, 2, 3))) ;







extern int posix_openpt (int __oflag) ;







extern int grantpt (int __fd) throw ();



extern int unlockpt (int __fd) throw ();




extern char *ptsname (int __fd) throw () ;






extern int ptsname_r (int __fd, char *__buf, size_t __buflen)
     throw () __attribute__ ((__nonnull__ (2))) __attribute__ ((__access__ (__write_only__, 2, 3)));


extern int getpt (void);






extern int getloadavg (double __loadavg[], int __nelem)
     throw () __attribute__ ((__nonnull__ (1)));
# 1014 "/usr/include/stdlib.h" 3 4
# 1 "/usr/include/bits/stdlib-float.h" 1 3 4
# 1015 "/usr/include/stdlib.h" 2 3 4
# 1026 "/usr/include/stdlib.h" 3 4
}
# 76 "/usr/include/c++/10.2.0/cstdlib" 2 3

# 1 "/usr/include/c++/10.2.0/bits/std_abs.h" 1 3
# 33 "/usr/include/c++/10.2.0/bits/std_abs.h" 3
       
# 34 "/usr/include/c++/10.2.0/bits/std_abs.h" 3
# 46 "/usr/include/c++/10.2.0/bits/std_abs.h" 3
extern "C++"
{
namespace std __attribute__ ((__visibility__ ("default")))
{


  using ::abs;


  inline long
  abs(long __i) { return __builtin_labs(__i); }



  inline long long
  abs(long long __x) { return __builtin_llabs (__x); }
# 70 "/usr/include/c++/10.2.0/bits/std_abs.h" 3
  inline constexpr double
  abs(double __x)
  { return __builtin_fabs(__x); }

  inline constexpr float
  abs(float __x)
  { return __builtin_fabsf(__x); }

  inline constexpr long double
  abs(long double __x)
  { return __builtin_fabsl(__x); }
# 107 "/usr/include/c++/10.2.0/bits/std_abs.h" 3

}
}
# 78 "/usr/include/c++/10.2.0/cstdlib" 2 3
# 121 "/usr/include/c++/10.2.0/cstdlib" 3
extern "C++"
{
namespace std __attribute__ ((__visibility__ ("default")))
{


  using ::div_t;
  using ::ldiv_t;

  using ::abort;



  using ::atexit;


  using ::at_quick_exit;


  using ::atof;
  using ::atoi;
  using ::atol;
  using ::bsearch;
  using ::calloc;
  using ::div;
  using ::exit;
  using ::free;
  using ::getenv;
  using ::labs;
  using ::ldiv;
  using ::malloc;

  using ::mblen;
  using ::mbstowcs;
  using ::mbtowc;

  using ::qsort;


  using ::quick_exit;


  using ::rand;
  using ::realloc;
  using ::srand;
  using ::strtod;
  using ::strtol;
  using ::strtoul;
  using ::system;

  using ::wcstombs;
  using ::wctomb;



  inline ldiv_t
  div(long __i, long __j) { return ldiv(__i, __j); }




}
# 195 "/usr/include/c++/10.2.0/cstdlib" 3
namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{



  using ::lldiv_t;





  using ::_Exit;



  using ::llabs;

  inline lldiv_t
  div(long long __n, long long __d)
  { lldiv_t __q; __q.quot = __n / __d; __q.rem = __n % __d; return __q; }

  using ::lldiv;
# 227 "/usr/include/c++/10.2.0/cstdlib" 3
  using ::atoll;
  using ::strtoll;
  using ::strtoull;

  using ::strtof;
  using ::strtold;


}

namespace std
{

  using ::__gnu_cxx::lldiv_t;

  using ::__gnu_cxx::_Exit;

  using ::__gnu_cxx::llabs;
  using ::__gnu_cxx::div;
  using ::__gnu_cxx::lldiv;

  using ::__gnu_cxx::atoll;
  using ::__gnu_cxx::strtof;
  using ::__gnu_cxx::strtoll;
  using ::__gnu_cxx::strtoull;
  using ::__gnu_cxx::strtold;
}



}
# 37 "/usr/include/c++/10.2.0/stdlib.h" 2 3

using std::abort;
using std::atexit;
using std::exit;


  using std::at_quick_exit;


  using std::quick_exit;




using std::div_t;
using std::ldiv_t;

using std::abs;
using std::atof;
using std::atoi;
using std::atol;
using std::bsearch;
using std::calloc;
using std::div;
using std::free;
using std::getenv;
using std::labs;
using std::ldiv;
using std::malloc;

using std::mblen;
using std::mbstowcs;
using std::mbtowc;

using std::qsort;
using std::rand;
using std::realloc;
using std::srand;
using std::strtod;
using std::strtol;
using std::strtoul;
using std::system;

using std::wcstombs;
using std::wctomb;
# 3 "4coder_sam.cpp" 2
# 1 "/usr/include/c++/10.2.0/math.h" 1 3
# 36 "/usr/include/c++/10.2.0/math.h" 3
# 1 "/usr/include/c++/10.2.0/cmath" 1 3
# 39 "/usr/include/c++/10.2.0/cmath" 3
       
# 40 "/usr/include/c++/10.2.0/cmath" 3


# 1 "/usr/include/c++/10.2.0/bits/cpp_type_traits.h" 1 3
# 35 "/usr/include/c++/10.2.0/bits/cpp_type_traits.h" 3
       
# 36 "/usr/include/c++/10.2.0/bits/cpp_type_traits.h" 3
# 67 "/usr/include/c++/10.2.0/bits/cpp_type_traits.h" 3
extern "C++" {

namespace std __attribute__ ((__visibility__ ("default")))
{


  struct __true_type { };
  struct __false_type { };

  template<bool>
    struct __truth_type
    { typedef __false_type __type; };

  template<>
    struct __truth_type<true>
    { typedef __true_type __type; };



  template<class _Sp, class _Tp>
    struct __traitor
    {
      enum { __value = bool(_Sp::__value) || bool(_Tp::__value) };
      typedef typename __truth_type<__value>::__type __type;
    };


  template<typename, typename>
    struct __are_same
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<typename _Tp>
    struct __are_same<_Tp, _Tp>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<typename _Tp>
    struct __is_void
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<>
    struct __is_void<void>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };




  template<typename _Tp>
    struct __is_integer
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };





  template<>
    struct __is_integer<bool>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<signed char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<>
    struct __is_integer<wchar_t>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };
# 184 "/usr/include/c++/10.2.0/bits/cpp_type_traits.h" 3
  template<>
    struct __is_integer<char16_t>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<char32_t>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<>
    struct __is_integer<short>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned short>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<int>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned int>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<long>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned long>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<long long>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned long long>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };
# 287 "/usr/include/c++/10.2.0/bits/cpp_type_traits.h" 3
  template<typename _Tp>
    struct __is_floating
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };


  template<>
    struct __is_floating<float>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_floating<double>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_floating<long double>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };




  template<typename _Tp>
    struct __is_pointer
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<typename _Tp>
    struct __is_pointer<_Tp*>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };




  template<typename _Tp>
    struct __is_arithmetic
    : public __traitor<__is_integer<_Tp>, __is_floating<_Tp> >
    { };




  template<typename _Tp>
    struct __is_scalar
    : public __traitor<__is_arithmetic<_Tp>, __is_pointer<_Tp> >
    { };




  template<typename _Tp>
    struct __is_char
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<>
    struct __is_char<char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<>
    struct __is_char<wchar_t>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<typename _Tp>
    struct __is_byte
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<>
    struct __is_byte<char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_byte<signed char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_byte<unsigned char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };
# 423 "/usr/include/c++/10.2.0/bits/cpp_type_traits.h" 3
  template<typename> struct iterator_traits;


  template<typename _Tp>
    struct __is_nonvolatile_trivially_copyable
    {
      enum { __value = __is_trivially_copyable(_Tp) };
    };




  template<typename _Tp>
    struct __is_nonvolatile_trivially_copyable<volatile _Tp>
    {
      enum { __value = 0 };
    };


  template<typename _OutputIter, typename _InputIter>
    struct __memcpyable
    {
      enum { __value = 0 };
    };

  template<typename _Tp>
    struct __memcpyable<_Tp*, _Tp*>
    : __is_nonvolatile_trivially_copyable<_Tp>
    { };

  template<typename _Tp>
    struct __memcpyable<_Tp*, const _Tp*>
    : __is_nonvolatile_trivially_copyable<_Tp>
    { };






  template<typename _Iter1, typename _Iter2>
    struct __memcmpable
    {
      enum { __value = 0 };
    };


  template<typename _Tp>
    struct __memcmpable<_Tp*, _Tp*>
    : __is_nonvolatile_trivially_copyable<_Tp>
    { };

  template<typename _Tp>
    struct __memcmpable<const _Tp*, _Tp*>
    : __is_nonvolatile_trivially_copyable<_Tp>
    { };

  template<typename _Tp>
    struct __memcmpable<_Tp*, const _Tp*>
    : __is_nonvolatile_trivially_copyable<_Tp>
    { };




  template<typename _Tp>
    struct __is_move_iterator
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };



  template<typename _Iterator>
   
    inline _Iterator
    __miter_base(_Iterator __it)
    { return __it; }


}
}
# 43 "/usr/include/c++/10.2.0/cmath" 2 3
# 1 "/usr/include/c++/10.2.0/ext/type_traits.h" 1 3
# 32 "/usr/include/c++/10.2.0/ext/type_traits.h" 3
       
# 33 "/usr/include/c++/10.2.0/ext/type_traits.h" 3




extern "C++" {

namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{



  template<bool, typename>
    struct __enable_if
    { };

  template<typename _Tp>
    struct __enable_if<true, _Tp>
    { typedef _Tp __type; };



  template<bool _Cond, typename _Iftrue, typename _Iffalse>
    struct __conditional_type
    { typedef _Iftrue __type; };

  template<typename _Iftrue, typename _Iffalse>
    struct __conditional_type<false, _Iftrue, _Iffalse>
    { typedef _Iffalse __type; };



  template<typename _Tp>
    struct __add_unsigned
    {
    private:
      typedef __enable_if<std::__is_integer<_Tp>::__value, _Tp> __if_type;

    public:
      typedef typename __if_type::__type __type;
    };

  template<>
    struct __add_unsigned<char>
    { typedef unsigned char __type; };

  template<>
    struct __add_unsigned<signed char>
    { typedef unsigned char __type; };

  template<>
    struct __add_unsigned<short>
    { typedef unsigned short __type; };

  template<>
    struct __add_unsigned<int>
    { typedef unsigned int __type; };

  template<>
    struct __add_unsigned<long>
    { typedef unsigned long __type; };

  template<>
    struct __add_unsigned<long long>
    { typedef unsigned long long __type; };


  template<>
    struct __add_unsigned<bool>;

  template<>
    struct __add_unsigned<wchar_t>;



  template<typename _Tp>
    struct __remove_unsigned
    {
    private:
      typedef __enable_if<std::__is_integer<_Tp>::__value, _Tp> __if_type;

    public:
      typedef typename __if_type::__type __type;
    };

  template<>
    struct __remove_unsigned<char>
    { typedef signed char __type; };

  template<>
    struct __remove_unsigned<unsigned char>
    { typedef signed char __type; };

  template<>
    struct __remove_unsigned<unsigned short>
    { typedef short __type; };

  template<>
    struct __remove_unsigned<unsigned int>
    { typedef int __type; };

  template<>
    struct __remove_unsigned<unsigned long>
    { typedef long __type; };

  template<>
    struct __remove_unsigned<unsigned long long>
    { typedef long long __type; };


  template<>
    struct __remove_unsigned<bool>;

  template<>
    struct __remove_unsigned<wchar_t>;



  template<typename _Type>
    inline bool
    __is_null_pointer(_Type* __ptr)
    { return __ptr == 0; }

  template<typename _Type>
    inline bool
    __is_null_pointer(_Type)
    { return false; }


  inline bool
  __is_null_pointer(std::nullptr_t)
  { return true; }



  template<typename _Tp, bool = std::__is_integer<_Tp>::__value>
    struct __promote
    { typedef double __type; };




  template<typename _Tp>
    struct __promote<_Tp, false>
    { };

  template<>
    struct __promote<long double>
    { typedef long double __type; };

  template<>
    struct __promote<double>
    { typedef double __type; };

  template<>
    struct __promote<float>
    { typedef float __type; };

  template<typename _Tp, typename _Up,
           typename _Tp2 = typename __promote<_Tp>::__type,
           typename _Up2 = typename __promote<_Up>::__type>
    struct __promote_2
    {
      typedef __typeof__(_Tp2() + _Up2()) __type;
    };

  template<typename _Tp, typename _Up, typename _Vp,
           typename _Tp2 = typename __promote<_Tp>::__type,
           typename _Up2 = typename __promote<_Up>::__type,
           typename _Vp2 = typename __promote<_Vp>::__type>
    struct __promote_3
    {
      typedef __typeof__(_Tp2() + _Up2() + _Vp2()) __type;
    };

  template<typename _Tp, typename _Up, typename _Vp, typename _Wp,
           typename _Tp2 = typename __promote<_Tp>::__type,
           typename _Up2 = typename __promote<_Up>::__type,
           typename _Vp2 = typename __promote<_Vp>::__type,
           typename _Wp2 = typename __promote<_Wp>::__type>
    struct __promote_4
    {
      typedef __typeof__(_Tp2() + _Up2() + _Vp2() + _Wp2()) __type;
    };


}
}
# 44 "/usr/include/c++/10.2.0/cmath" 2 3

# 1 "/usr/include/math.h" 1 3 4
# 27 "/usr/include/math.h" 3 4
# 1 "/usr/include/bits/libc-header-start.h" 1 3 4
# 28 "/usr/include/math.h" 2 3 4






extern "C" {





# 1 "/usr/include/bits/math-vector.h" 1 3 4
# 25 "/usr/include/bits/math-vector.h" 3 4
# 1 "/usr/include/bits/libm-simd-decl-stubs.h" 1 3 4
# 26 "/usr/include/bits/math-vector.h" 2 3 4
# 41 "/usr/include/math.h" 2 3 4
# 138 "/usr/include/math.h" 3 4
# 1 "/usr/include/bits/flt-eval-method.h" 1 3 4
# 139 "/usr/include/math.h" 2 3 4
# 149 "/usr/include/math.h" 3 4
typedef float float_t;
typedef double double_t;
# 190 "/usr/include/math.h" 3 4
# 1 "/usr/include/bits/fp-logb.h" 1 3 4
# 191 "/usr/include/math.h" 2 3 4
# 233 "/usr/include/math.h" 3 4
# 1 "/usr/include/bits/fp-fast.h" 1 3 4
# 234 "/usr/include/math.h" 2 3 4



enum
  {
    FP_INT_UPWARD =

      0,
    FP_INT_DOWNWARD =

      1,
    FP_INT_TOWARDZERO =

      2,
    FP_INT_TONEARESTFROMZERO =

      3,
    FP_INT_TONEAREST =

      4,
  };
# 298 "/usr/include/math.h" 3 4
# 1 "/usr/include/bits/mathcalls-helper-functions.h" 1 3 4
# 20 "/usr/include/bits/mathcalls-helper-functions.h" 3 4
extern int __fpclassify (double __value) throw ()
     __attribute__ ((__const__));


extern int __signbit (double __value) throw ()
     __attribute__ ((__const__));



extern int __isinf (double __value) throw ()
  __attribute__ ((__const__));


extern int __finite (double __value) throw ()
  __attribute__ ((__const__));


extern int __isnan (double __value) throw ()
  __attribute__ ((__const__));


extern int __iseqsig (double __x, double __y) throw ();


extern int __issignaling (double __value) throw ()
     __attribute__ ((__const__));
# 299 "/usr/include/math.h" 2 3 4
# 1 "/usr/include/bits/mathcalls.h" 1 3 4
# 53 "/usr/include/bits/mathcalls.h" 3 4
extern double acos (double __x) throw (); extern double __acos (double __x) throw ();

extern double asin (double __x) throw (); extern double __asin (double __x) throw ();

extern double atan (double __x) throw (); extern double __atan (double __x) throw ();

extern double atan2 (double __y, double __x) throw (); extern double __atan2 (double __y, double __x) throw ();


 extern double cos (double __x) throw (); extern double __cos (double __x) throw ();

 extern double sin (double __x) throw (); extern double __sin (double __x) throw ();

extern double tan (double __x) throw (); extern double __tan (double __x) throw ();




extern double cosh (double __x) throw (); extern double __cosh (double __x) throw ();

extern double sinh (double __x) throw (); extern double __sinh (double __x) throw ();

extern double tanh (double __x) throw (); extern double __tanh (double __x) throw ();



 extern void sincos (double __x, double *__sinx, double *__cosx) throw (); extern void __sincos (double __x, double *__sinx, double *__cosx) throw ()
                                                        ;




extern double acosh (double __x) throw (); extern double __acosh (double __x) throw ();

extern double asinh (double __x) throw (); extern double __asinh (double __x) throw ();

extern double atanh (double __x) throw (); extern double __atanh (double __x) throw ();





 extern double exp (double __x) throw (); extern double __exp (double __x) throw ();


extern double frexp (double __x, int *__exponent) throw (); extern double __frexp (double __x, int *__exponent) throw ();


extern double ldexp (double __x, int __exponent) throw (); extern double __ldexp (double __x, int __exponent) throw ();


 extern double log (double __x) throw (); extern double __log (double __x) throw ();


extern double log10 (double __x) throw (); extern double __log10 (double __x) throw ();


extern double modf (double __x, double *__iptr) throw (); extern double __modf (double __x, double *__iptr) throw () __attribute__ ((__nonnull__ (2)));



extern double exp10 (double __x) throw (); extern double __exp10 (double __x) throw ();




extern double expm1 (double __x) throw (); extern double __expm1 (double __x) throw ();


extern double log1p (double __x) throw (); extern double __log1p (double __x) throw ();


extern double logb (double __x) throw (); extern double __logb (double __x) throw ();




extern double exp2 (double __x) throw (); extern double __exp2 (double __x) throw ();


extern double log2 (double __x) throw (); extern double __log2 (double __x) throw ();






 extern double pow (double __x, double __y) throw (); extern double __pow (double __x, double __y) throw ();


extern double sqrt (double __x) throw (); extern double __sqrt (double __x) throw ();



extern double hypot (double __x, double __y) throw (); extern double __hypot (double __x, double __y) throw ();




extern double cbrt (double __x) throw (); extern double __cbrt (double __x) throw ();






extern double ceil (double __x) throw () __attribute__ ((__const__)); extern double __ceil (double __x) throw () __attribute__ ((__const__));


extern double fabs (double __x) throw () __attribute__ ((__const__)); extern double __fabs (double __x) throw () __attribute__ ((__const__));


extern double floor (double __x) throw () __attribute__ ((__const__)); extern double __floor (double __x) throw () __attribute__ ((__const__));


extern double fmod (double __x, double __y) throw (); extern double __fmod (double __x, double __y) throw ();
# 183 "/usr/include/bits/mathcalls.h" 3 4
extern int finite (double __value) throw ()
  __attribute__ ((__const__));


extern double drem (double __x, double __y) throw (); extern double __drem (double __x, double __y) throw ();



extern double significand (double __x) throw (); extern double __significand (double __x) throw ();






extern double copysign (double __x, double __y) throw () __attribute__ ((__const__)); extern double __copysign (double __x, double __y) throw () __attribute__ ((__const__));




extern double nan (const char *__tagb) throw (); extern double __nan (const char *__tagb) throw ();
# 220 "/usr/include/bits/mathcalls.h" 3 4
extern double j0 (double) throw (); extern double __j0 (double) throw ();
extern double j1 (double) throw (); extern double __j1 (double) throw ();
extern double jn (int, double) throw (); extern double __jn (int, double) throw ();
extern double y0 (double) throw (); extern double __y0 (double) throw ();
extern double y1 (double) throw (); extern double __y1 (double) throw ();
extern double yn (int, double) throw (); extern double __yn (int, double) throw ();





extern double erf (double) throw (); extern double __erf (double) throw ();
extern double erfc (double) throw (); extern double __erfc (double) throw ();
extern double lgamma (double) throw (); extern double __lgamma (double) throw ();




extern double tgamma (double) throw (); extern double __tgamma (double) throw ();





extern double gamma (double) throw (); extern double __gamma (double) throw ();







extern double lgamma_r (double, int *__signgamp) throw (); extern double __lgamma_r (double, int *__signgamp) throw ();






extern double rint (double __x) throw (); extern double __rint (double __x) throw ();


extern double nextafter (double __x, double __y) throw (); extern double __nextafter (double __x, double __y) throw ();

extern double nexttoward (double __x, long double __y) throw (); extern double __nexttoward (double __x, long double __y) throw ();




extern double nextdown (double __x) throw (); extern double __nextdown (double __x) throw ();

extern double nextup (double __x) throw (); extern double __nextup (double __x) throw ();



extern double remainder (double __x, double __y) throw (); extern double __remainder (double __x, double __y) throw ();



extern double scalbn (double __x, int __n) throw (); extern double __scalbn (double __x, int __n) throw ();



extern int ilogb (double __x) throw (); extern int __ilogb (double __x) throw ();




extern long int llogb (double __x) throw (); extern long int __llogb (double __x) throw ();




extern double scalbln (double __x, long int __n) throw (); extern double __scalbln (double __x, long int __n) throw ();



extern double nearbyint (double __x) throw (); extern double __nearbyint (double __x) throw ();



extern double round (double __x) throw () __attribute__ ((__const__)); extern double __round (double __x) throw () __attribute__ ((__const__));



extern double trunc (double __x) throw () __attribute__ ((__const__)); extern double __trunc (double __x) throw () __attribute__ ((__const__));




extern double remquo (double __x, double __y, int *__quo) throw (); extern double __remquo (double __x, double __y, int *__quo) throw ();






extern long int lrint (double __x) throw (); extern long int __lrint (double __x) throw ();
__extension__
extern long long int llrint (double __x) throw (); extern long long int __llrint (double __x) throw ();



extern long int lround (double __x) throw (); extern long int __lround (double __x) throw ();
__extension__
extern long long int llround (double __x) throw (); extern long long int __llround (double __x) throw ();



extern double fdim (double __x, double __y) throw (); extern double __fdim (double __x, double __y) throw ();


extern double fmax (double __x, double __y) throw () __attribute__ ((__const__)); extern double __fmax (double __x, double __y) throw () __attribute__ ((__const__));


extern double fmin (double __x, double __y) throw () __attribute__ ((__const__)); extern double __fmin (double __x, double __y) throw () __attribute__ ((__const__));


extern double fma (double __x, double __y, double __z) throw (); extern double __fma (double __x, double __y, double __z) throw ();




extern double roundeven (double __x) throw () __attribute__ ((__const__)); extern double __roundeven (double __x) throw () __attribute__ ((__const__));



extern __intmax_t fromfp (double __x, int __round, unsigned int __width) throw (); extern __intmax_t __fromfp (double __x, int __round, unsigned int __width) throw ()
                            ;



extern __uintmax_t ufromfp (double __x, int __round, unsigned int __width) throw (); extern __uintmax_t __ufromfp (double __x, int __round, unsigned int __width) throw ()
                              ;




extern __intmax_t fromfpx (double __x, int __round, unsigned int __width) throw (); extern __intmax_t __fromfpx (double __x, int __round, unsigned int __width) throw ()
                             ;




extern __uintmax_t ufromfpx (double __x, int __round, unsigned int __width) throw (); extern __uintmax_t __ufromfpx (double __x, int __round, unsigned int __width) throw ()
                               ;


extern double fmaxmag (double __x, double __y) throw () __attribute__ ((__const__)); extern double __fmaxmag (double __x, double __y) throw () __attribute__ ((__const__));


extern double fminmag (double __x, double __y) throw () __attribute__ ((__const__)); extern double __fminmag (double __x, double __y) throw () __attribute__ ((__const__));


extern int canonicalize (double *__cx, const double *__x) throw ();




extern int totalorder (const double *__x, const double *__y) throw ()

     __attribute__ ((__pure__));


extern int totalordermag (const double *__x, const double *__y) throw ()

     __attribute__ ((__pure__));


extern double getpayload (const double *__x) throw (); extern double __getpayload (const double *__x) throw ();


extern int setpayload (double *__x, double __payload) throw ();


extern int setpayloadsig (double *__x, double __payload) throw ();







extern double scalb (double __x, double __n) throw (); extern double __scalb (double __x, double __n) throw ();
# 300 "/usr/include/math.h" 2 3 4
# 315 "/usr/include/math.h" 3 4
# 1 "/usr/include/bits/mathcalls-helper-functions.h" 1 3 4
# 20 "/usr/include/bits/mathcalls-helper-functions.h" 3 4
extern int __fpclassifyf (float __value) throw ()
     __attribute__ ((__const__));


extern int __signbitf (float __value) throw ()
     __attribute__ ((__const__));



extern int __isinff (float __value) throw ()
  __attribute__ ((__const__));


extern int __finitef (float __value) throw ()
  __attribute__ ((__const__));


extern int __isnanf (float __value) throw ()
  __attribute__ ((__const__));


extern int __iseqsigf (float __x, float __y) throw ();


extern int __issignalingf (float __value) throw ()
     __attribute__ ((__const__));
# 316 "/usr/include/math.h" 2 3 4
# 1 "/usr/include/bits/mathcalls.h" 1 3 4
# 53 "/usr/include/bits/mathcalls.h" 3 4
extern float acosf (float __x) throw (); extern float __acosf (float __x) throw ();

extern float asinf (float __x) throw (); extern float __asinf (float __x) throw ();

extern float atanf (float __x) throw (); extern float __atanf (float __x) throw ();

extern float atan2f (float __y, float __x) throw (); extern float __atan2f (float __y, float __x) throw ();


 extern float cosf (float __x) throw (); extern float __cosf (float __x) throw ();

 extern float sinf (float __x) throw (); extern float __sinf (float __x) throw ();

extern float tanf (float __x) throw (); extern float __tanf (float __x) throw ();




extern float coshf (float __x) throw (); extern float __coshf (float __x) throw ();

extern float sinhf (float __x) throw (); extern float __sinhf (float __x) throw ();

extern float tanhf (float __x) throw (); extern float __tanhf (float __x) throw ();



 extern void sincosf (float __x, float *__sinx, float *__cosx) throw (); extern void __sincosf (float __x, float *__sinx, float *__cosx) throw ()
                                                        ;




extern float acoshf (float __x) throw (); extern float __acoshf (float __x) throw ();

extern float asinhf (float __x) throw (); extern float __asinhf (float __x) throw ();

extern float atanhf (float __x) throw (); extern float __atanhf (float __x) throw ();





 extern float expf (float __x) throw (); extern float __expf (float __x) throw ();


extern float frexpf (float __x, int *__exponent) throw (); extern float __frexpf (float __x, int *__exponent) throw ();


extern float ldexpf (float __x, int __exponent) throw (); extern float __ldexpf (float __x, int __exponent) throw ();


 extern float logf (float __x) throw (); extern float __logf (float __x) throw ();


extern float log10f (float __x) throw (); extern float __log10f (float __x) throw ();


extern float modff (float __x, float *__iptr) throw (); extern float __modff (float __x, float *__iptr) throw () __attribute__ ((__nonnull__ (2)));



extern float exp10f (float __x) throw (); extern float __exp10f (float __x) throw ();




extern float expm1f (float __x) throw (); extern float __expm1f (float __x) throw ();


extern float log1pf (float __x) throw (); extern float __log1pf (float __x) throw ();


extern float logbf (float __x) throw (); extern float __logbf (float __x) throw ();




extern float exp2f (float __x) throw (); extern float __exp2f (float __x) throw ();


extern float log2f (float __x) throw (); extern float __log2f (float __x) throw ();






 extern float powf (float __x, float __y) throw (); extern float __powf (float __x, float __y) throw ();


extern float sqrtf (float __x) throw (); extern float __sqrtf (float __x) throw ();



extern float hypotf (float __x, float __y) throw (); extern float __hypotf (float __x, float __y) throw ();




extern float cbrtf (float __x) throw (); extern float __cbrtf (float __x) throw ();






extern float ceilf (float __x) throw () __attribute__ ((__const__)); extern float __ceilf (float __x) throw () __attribute__ ((__const__));


extern float fabsf (float __x) throw () __attribute__ ((__const__)); extern float __fabsf (float __x) throw () __attribute__ ((__const__));


extern float floorf (float __x) throw () __attribute__ ((__const__)); extern float __floorf (float __x) throw () __attribute__ ((__const__));


extern float fmodf (float __x, float __y) throw (); extern float __fmodf (float __x, float __y) throw ();
# 177 "/usr/include/bits/mathcalls.h" 3 4
extern int isinff (float __value) throw ()
  __attribute__ ((__const__));




extern int finitef (float __value) throw ()
  __attribute__ ((__const__));


extern float dremf (float __x, float __y) throw (); extern float __dremf (float __x, float __y) throw ();



extern float significandf (float __x) throw (); extern float __significandf (float __x) throw ();






extern float copysignf (float __x, float __y) throw () __attribute__ ((__const__)); extern float __copysignf (float __x, float __y) throw () __attribute__ ((__const__));




extern float nanf (const char *__tagb) throw (); extern float __nanf (const char *__tagb) throw ();
# 213 "/usr/include/bits/mathcalls.h" 3 4
extern int isnanf (float __value) throw ()
  __attribute__ ((__const__));





extern float j0f (float) throw (); extern float __j0f (float) throw ();
extern float j1f (float) throw (); extern float __j1f (float) throw ();
extern float jnf (int, float) throw (); extern float __jnf (int, float) throw ();
extern float y0f (float) throw (); extern float __y0f (float) throw ();
extern float y1f (float) throw (); extern float __y1f (float) throw ();
extern float ynf (int, float) throw (); extern float __ynf (int, float) throw ();





extern float erff (float) throw (); extern float __erff (float) throw ();
extern float erfcf (float) throw (); extern float __erfcf (float) throw ();
extern float lgammaf (float) throw (); extern float __lgammaf (float) throw ();




extern float tgammaf (float) throw (); extern float __tgammaf (float) throw ();





extern float gammaf (float) throw (); extern float __gammaf (float) throw ();







extern float lgammaf_r (float, int *__signgamp) throw (); extern float __lgammaf_r (float, int *__signgamp) throw ();






extern float rintf (float __x) throw (); extern float __rintf (float __x) throw ();


extern float nextafterf (float __x, float __y) throw (); extern float __nextafterf (float __x, float __y) throw ();

extern float nexttowardf (float __x, long double __y) throw (); extern float __nexttowardf (float __x, long double __y) throw ();




extern float nextdownf (float __x) throw (); extern float __nextdownf (float __x) throw ();

extern float nextupf (float __x) throw (); extern float __nextupf (float __x) throw ();



extern float remainderf (float __x, float __y) throw (); extern float __remainderf (float __x, float __y) throw ();



extern float scalbnf (float __x, int __n) throw (); extern float __scalbnf (float __x, int __n) throw ();



extern int ilogbf (float __x) throw (); extern int __ilogbf (float __x) throw ();




extern long int llogbf (float __x) throw (); extern long int __llogbf (float __x) throw ();




extern float scalblnf (float __x, long int __n) throw (); extern float __scalblnf (float __x, long int __n) throw ();



extern float nearbyintf (float __x) throw (); extern float __nearbyintf (float __x) throw ();



extern float roundf (float __x) throw () __attribute__ ((__const__)); extern float __roundf (float __x) throw () __attribute__ ((__const__));



extern float truncf (float __x) throw () __attribute__ ((__const__)); extern float __truncf (float __x) throw () __attribute__ ((__const__));




extern float remquof (float __x, float __y, int *__quo) throw (); extern float __remquof (float __x, float __y, int *__quo) throw ();






extern long int lrintf (float __x) throw (); extern long int __lrintf (float __x) throw ();
__extension__
extern long long int llrintf (float __x) throw (); extern long long int __llrintf (float __x) throw ();



extern long int lroundf (float __x) throw (); extern long int __lroundf (float __x) throw ();
__extension__
extern long long int llroundf (float __x) throw (); extern long long int __llroundf (float __x) throw ();



extern float fdimf (float __x, float __y) throw (); extern float __fdimf (float __x, float __y) throw ();


extern float fmaxf (float __x, float __y) throw () __attribute__ ((__const__)); extern float __fmaxf (float __x, float __y) throw () __attribute__ ((__const__));


extern float fminf (float __x, float __y) throw () __attribute__ ((__const__)); extern float __fminf (float __x, float __y) throw () __attribute__ ((__const__));


extern float fmaf (float __x, float __y, float __z) throw (); extern float __fmaf (float __x, float __y, float __z) throw ();




extern float roundevenf (float __x) throw () __attribute__ ((__const__)); extern float __roundevenf (float __x) throw () __attribute__ ((__const__));



extern __intmax_t fromfpf (float __x, int __round, unsigned int __width) throw (); extern __intmax_t __fromfpf (float __x, int __round, unsigned int __width) throw ()
                            ;



extern __uintmax_t ufromfpf (float __x, int __round, unsigned int __width) throw (); extern __uintmax_t __ufromfpf (float __x, int __round, unsigned int __width) throw ()
                              ;




extern __intmax_t fromfpxf (float __x, int __round, unsigned int __width) throw (); extern __intmax_t __fromfpxf (float __x, int __round, unsigned int __width) throw ()
                             ;




extern __uintmax_t ufromfpxf (float __x, int __round, unsigned int __width) throw (); extern __uintmax_t __ufromfpxf (float __x, int __round, unsigned int __width) throw ()
                               ;


extern float fmaxmagf (float __x, float __y) throw () __attribute__ ((__const__)); extern float __fmaxmagf (float __x, float __y) throw () __attribute__ ((__const__));


extern float fminmagf (float __x, float __y) throw () __attribute__ ((__const__)); extern float __fminmagf (float __x, float __y) throw () __attribute__ ((__const__));


extern int canonicalizef (float *__cx, const float *__x) throw ();




extern int totalorderf (const float *__x, const float *__y) throw ()

     __attribute__ ((__pure__));


extern int totalordermagf (const float *__x, const float *__y) throw ()

     __attribute__ ((__pure__));


extern float getpayloadf (const float *__x) throw (); extern float __getpayloadf (const float *__x) throw ();


extern int setpayloadf (float *__x, float __payload) throw ();


extern int setpayloadsigf (float *__x, float __payload) throw ();







extern float scalbf (float __x, float __n) throw (); extern float __scalbf (float __x, float __n) throw ();
# 317 "/usr/include/math.h" 2 3 4
# 384 "/usr/include/math.h" 3 4
# 1 "/usr/include/bits/mathcalls-helper-functions.h" 1 3 4
# 20 "/usr/include/bits/mathcalls-helper-functions.h" 3 4
extern int __fpclassifyl (long double __value) throw ()
     __attribute__ ((__const__));


extern int __signbitl (long double __value) throw ()
     __attribute__ ((__const__));



extern int __isinfl (long double __value) throw ()
  __attribute__ ((__const__));


extern int __finitel (long double __value) throw ()
  __attribute__ ((__const__));


extern int __isnanl (long double __value) throw ()
  __attribute__ ((__const__));


extern int __iseqsigl (long double __x, long double __y) throw ();


extern int __issignalingl (long double __value) throw ()
     __attribute__ ((__const__));
# 385 "/usr/include/math.h" 2 3 4
# 1 "/usr/include/bits/mathcalls.h" 1 3 4
# 53 "/usr/include/bits/mathcalls.h" 3 4
extern long double acosl (long double __x) throw (); extern long double __acosl (long double __x) throw ();

extern long double asinl (long double __x) throw (); extern long double __asinl (long double __x) throw ();

extern long double atanl (long double __x) throw (); extern long double __atanl (long double __x) throw ();

extern long double atan2l (long double __y, long double __x) throw (); extern long double __atan2l (long double __y, long double __x) throw ();


 extern long double cosl (long double __x) throw (); extern long double __cosl (long double __x) throw ();

 extern long double sinl (long double __x) throw (); extern long double __sinl (long double __x) throw ();

extern long double tanl (long double __x) throw (); extern long double __tanl (long double __x) throw ();




extern long double coshl (long double __x) throw (); extern long double __coshl (long double __x) throw ();

extern long double sinhl (long double __x) throw (); extern long double __sinhl (long double __x) throw ();

extern long double tanhl (long double __x) throw (); extern long double __tanhl (long double __x) throw ();



 extern void sincosl (long double __x, long double *__sinx, long double *__cosx) throw (); extern void __sincosl (long double __x, long double *__sinx, long double *__cosx) throw ()
                                                        ;




extern long double acoshl (long double __x) throw (); extern long double __acoshl (long double __x) throw ();

extern long double asinhl (long double __x) throw (); extern long double __asinhl (long double __x) throw ();

extern long double atanhl (long double __x) throw (); extern long double __atanhl (long double __x) throw ();





 extern long double expl (long double __x) throw (); extern long double __expl (long double __x) throw ();


extern long double frexpl (long double __x, int *__exponent) throw (); extern long double __frexpl (long double __x, int *__exponent) throw ();


extern long double ldexpl (long double __x, int __exponent) throw (); extern long double __ldexpl (long double __x, int __exponent) throw ();


 extern long double logl (long double __x) throw (); extern long double __logl (long double __x) throw ();


extern long double log10l (long double __x) throw (); extern long double __log10l (long double __x) throw ();


extern long double modfl (long double __x, long double *__iptr) throw (); extern long double __modfl (long double __x, long double *__iptr) throw () __attribute__ ((__nonnull__ (2)));



extern long double exp10l (long double __x) throw (); extern long double __exp10l (long double __x) throw ();




extern long double expm1l (long double __x) throw (); extern long double __expm1l (long double __x) throw ();


extern long double log1pl (long double __x) throw (); extern long double __log1pl (long double __x) throw ();


extern long double logbl (long double __x) throw (); extern long double __logbl (long double __x) throw ();




extern long double exp2l (long double __x) throw (); extern long double __exp2l (long double __x) throw ();


extern long double log2l (long double __x) throw (); extern long double __log2l (long double __x) throw ();






 extern long double powl (long double __x, long double __y) throw (); extern long double __powl (long double __x, long double __y) throw ();


extern long double sqrtl (long double __x) throw (); extern long double __sqrtl (long double __x) throw ();



extern long double hypotl (long double __x, long double __y) throw (); extern long double __hypotl (long double __x, long double __y) throw ();




extern long double cbrtl (long double __x) throw (); extern long double __cbrtl (long double __x) throw ();






extern long double ceill (long double __x) throw () __attribute__ ((__const__)); extern long double __ceill (long double __x) throw () __attribute__ ((__const__));


extern long double fabsl (long double __x) throw () __attribute__ ((__const__)); extern long double __fabsl (long double __x) throw () __attribute__ ((__const__));


extern long double floorl (long double __x) throw () __attribute__ ((__const__)); extern long double __floorl (long double __x) throw () __attribute__ ((__const__));


extern long double fmodl (long double __x, long double __y) throw (); extern long double __fmodl (long double __x, long double __y) throw ();
# 177 "/usr/include/bits/mathcalls.h" 3 4
extern int isinfl (long double __value) throw ()
  __attribute__ ((__const__));




extern int finitel (long double __value) throw ()
  __attribute__ ((__const__));


extern long double dreml (long double __x, long double __y) throw (); extern long double __dreml (long double __x, long double __y) throw ();



extern long double significandl (long double __x) throw (); extern long double __significandl (long double __x) throw ();






extern long double copysignl (long double __x, long double __y) throw () __attribute__ ((__const__)); extern long double __copysignl (long double __x, long double __y) throw () __attribute__ ((__const__));




extern long double nanl (const char *__tagb) throw (); extern long double __nanl (const char *__tagb) throw ();
# 213 "/usr/include/bits/mathcalls.h" 3 4
extern int isnanl (long double __value) throw ()
  __attribute__ ((__const__));





extern long double j0l (long double) throw (); extern long double __j0l (long double) throw ();
extern long double j1l (long double) throw (); extern long double __j1l (long double) throw ();
extern long double jnl (int, long double) throw (); extern long double __jnl (int, long double) throw ();
extern long double y0l (long double) throw (); extern long double __y0l (long double) throw ();
extern long double y1l (long double) throw (); extern long double __y1l (long double) throw ();
extern long double ynl (int, long double) throw (); extern long double __ynl (int, long double) throw ();





extern long double erfl (long double) throw (); extern long double __erfl (long double) throw ();
extern long double erfcl (long double) throw (); extern long double __erfcl (long double) throw ();
extern long double lgammal (long double) throw (); extern long double __lgammal (long double) throw ();




extern long double tgammal (long double) throw (); extern long double __tgammal (long double) throw ();





extern long double gammal (long double) throw (); extern long double __gammal (long double) throw ();







extern long double lgammal_r (long double, int *__signgamp) throw (); extern long double __lgammal_r (long double, int *__signgamp) throw ();






extern long double rintl (long double __x) throw (); extern long double __rintl (long double __x) throw ();


extern long double nextafterl (long double __x, long double __y) throw (); extern long double __nextafterl (long double __x, long double __y) throw ();

extern long double nexttowardl (long double __x, long double __y) throw (); extern long double __nexttowardl (long double __x, long double __y) throw ();




extern long double nextdownl (long double __x) throw (); extern long double __nextdownl (long double __x) throw ();

extern long double nextupl (long double __x) throw (); extern long double __nextupl (long double __x) throw ();



extern long double remainderl (long double __x, long double __y) throw (); extern long double __remainderl (long double __x, long double __y) throw ();



extern long double scalbnl (long double __x, int __n) throw (); extern long double __scalbnl (long double __x, int __n) throw ();



extern int ilogbl (long double __x) throw (); extern int __ilogbl (long double __x) throw ();




extern long int llogbl (long double __x) throw (); extern long int __llogbl (long double __x) throw ();




extern long double scalblnl (long double __x, long int __n) throw (); extern long double __scalblnl (long double __x, long int __n) throw ();



extern long double nearbyintl (long double __x) throw (); extern long double __nearbyintl (long double __x) throw ();



extern long double roundl (long double __x) throw () __attribute__ ((__const__)); extern long double __roundl (long double __x) throw () __attribute__ ((__const__));



extern long double truncl (long double __x) throw () __attribute__ ((__const__)); extern long double __truncl (long double __x) throw () __attribute__ ((__const__));




extern long double remquol (long double __x, long double __y, int *__quo) throw (); extern long double __remquol (long double __x, long double __y, int *__quo) throw ();






extern long int lrintl (long double __x) throw (); extern long int __lrintl (long double __x) throw ();
__extension__
extern long long int llrintl (long double __x) throw (); extern long long int __llrintl (long double __x) throw ();



extern long int lroundl (long double __x) throw (); extern long int __lroundl (long double __x) throw ();
__extension__
extern long long int llroundl (long double __x) throw (); extern long long int __llroundl (long double __x) throw ();



extern long double fdiml (long double __x, long double __y) throw (); extern long double __fdiml (long double __x, long double __y) throw ();


extern long double fmaxl (long double __x, long double __y) throw () __attribute__ ((__const__)); extern long double __fmaxl (long double __x, long double __y) throw () __attribute__ ((__const__));


extern long double fminl (long double __x, long double __y) throw () __attribute__ ((__const__)); extern long double __fminl (long double __x, long double __y) throw () __attribute__ ((__const__));


extern long double fmal (long double __x, long double __y, long double __z) throw (); extern long double __fmal (long double __x, long double __y, long double __z) throw ();




extern long double roundevenl (long double __x) throw () __attribute__ ((__const__)); extern long double __roundevenl (long double __x) throw () __attribute__ ((__const__));



extern __intmax_t fromfpl (long double __x, int __round, unsigned int __width) throw (); extern __intmax_t __fromfpl (long double __x, int __round, unsigned int __width) throw ()
                            ;



extern __uintmax_t ufromfpl (long double __x, int __round, unsigned int __width) throw (); extern __uintmax_t __ufromfpl (long double __x, int __round, unsigned int __width) throw ()
                              ;




extern __intmax_t fromfpxl (long double __x, int __round, unsigned int __width) throw (); extern __intmax_t __fromfpxl (long double __x, int __round, unsigned int __width) throw ()
                             ;




extern __uintmax_t ufromfpxl (long double __x, int __round, unsigned int __width) throw (); extern __uintmax_t __ufromfpxl (long double __x, int __round, unsigned int __width) throw ()
                               ;


extern long double fmaxmagl (long double __x, long double __y) throw () __attribute__ ((__const__)); extern long double __fmaxmagl (long double __x, long double __y) throw () __attribute__ ((__const__));


extern long double fminmagl (long double __x, long double __y) throw () __attribute__ ((__const__)); extern long double __fminmagl (long double __x, long double __y) throw () __attribute__ ((__const__));


extern int canonicalizel (long double *__cx, const long double *__x) throw ();




extern int totalorderl (const long double *__x, const long double *__y) throw ()

     __attribute__ ((__pure__));


extern int totalordermagl (const long double *__x, const long double *__y) throw ()

     __attribute__ ((__pure__));


extern long double getpayloadl (const long double *__x) throw (); extern long double __getpayloadl (const long double *__x) throw ();


extern int setpayloadl (long double *__x, long double __payload) throw ();


extern int setpayloadsigl (long double *__x, long double __payload) throw ();







extern long double scalbl (long double __x, long double __n) throw (); extern long double __scalbl (long double __x, long double __n) throw ();
# 386 "/usr/include/math.h" 2 3 4
# 436 "/usr/include/math.h" 3 4
# 1 "/usr/include/bits/mathcalls.h" 1 3 4
# 53 "/usr/include/bits/mathcalls.h" 3 4
extern _Float32 acosf32 (_Float32 __x) throw (); extern _Float32 __acosf32 (_Float32 __x) throw ();

extern _Float32 asinf32 (_Float32 __x) throw (); extern _Float32 __asinf32 (_Float32 __x) throw ();

extern _Float32 atanf32 (_Float32 __x) throw (); extern _Float32 __atanf32 (_Float32 __x) throw ();

extern _Float32 atan2f32 (_Float32 __y, _Float32 __x) throw (); extern _Float32 __atan2f32 (_Float32 __y, _Float32 __x) throw ();


 extern _Float32 cosf32 (_Float32 __x) throw (); extern _Float32 __cosf32 (_Float32 __x) throw ();

 extern _Float32 sinf32 (_Float32 __x) throw (); extern _Float32 __sinf32 (_Float32 __x) throw ();

extern _Float32 tanf32 (_Float32 __x) throw (); extern _Float32 __tanf32 (_Float32 __x) throw ();




extern _Float32 coshf32 (_Float32 __x) throw (); extern _Float32 __coshf32 (_Float32 __x) throw ();

extern _Float32 sinhf32 (_Float32 __x) throw (); extern _Float32 __sinhf32 (_Float32 __x) throw ();

extern _Float32 tanhf32 (_Float32 __x) throw (); extern _Float32 __tanhf32 (_Float32 __x) throw ();



 extern void sincosf32 (_Float32 __x, _Float32 *__sinx, _Float32 *__cosx) throw (); extern void __sincosf32 (_Float32 __x, _Float32 *__sinx, _Float32 *__cosx) throw ()
                                                        ;




extern _Float32 acoshf32 (_Float32 __x) throw (); extern _Float32 __acoshf32 (_Float32 __x) throw ();

extern _Float32 asinhf32 (_Float32 __x) throw (); extern _Float32 __asinhf32 (_Float32 __x) throw ();

extern _Float32 atanhf32 (_Float32 __x) throw (); extern _Float32 __atanhf32 (_Float32 __x) throw ();





 extern _Float32 expf32 (_Float32 __x) throw (); extern _Float32 __expf32 (_Float32 __x) throw ();


extern _Float32 frexpf32 (_Float32 __x, int *__exponent) throw (); extern _Float32 __frexpf32 (_Float32 __x, int *__exponent) throw ();


extern _Float32 ldexpf32 (_Float32 __x, int __exponent) throw (); extern _Float32 __ldexpf32 (_Float32 __x, int __exponent) throw ();


 extern _Float32 logf32 (_Float32 __x) throw (); extern _Float32 __logf32 (_Float32 __x) throw ();


extern _Float32 log10f32 (_Float32 __x) throw (); extern _Float32 __log10f32 (_Float32 __x) throw ();


extern _Float32 modff32 (_Float32 __x, _Float32 *__iptr) throw (); extern _Float32 __modff32 (_Float32 __x, _Float32 *__iptr) throw () __attribute__ ((__nonnull__ (2)));



extern _Float32 exp10f32 (_Float32 __x) throw (); extern _Float32 __exp10f32 (_Float32 __x) throw ();




extern _Float32 expm1f32 (_Float32 __x) throw (); extern _Float32 __expm1f32 (_Float32 __x) throw ();


extern _Float32 log1pf32 (_Float32 __x) throw (); extern _Float32 __log1pf32 (_Float32 __x) throw ();


extern _Float32 logbf32 (_Float32 __x) throw (); extern _Float32 __logbf32 (_Float32 __x) throw ();




extern _Float32 exp2f32 (_Float32 __x) throw (); extern _Float32 __exp2f32 (_Float32 __x) throw ();


extern _Float32 log2f32 (_Float32 __x) throw (); extern _Float32 __log2f32 (_Float32 __x) throw ();






 extern _Float32 powf32 (_Float32 __x, _Float32 __y) throw (); extern _Float32 __powf32 (_Float32 __x, _Float32 __y) throw ();


extern _Float32 sqrtf32 (_Float32 __x) throw (); extern _Float32 __sqrtf32 (_Float32 __x) throw ();



extern _Float32 hypotf32 (_Float32 __x, _Float32 __y) throw (); extern _Float32 __hypotf32 (_Float32 __x, _Float32 __y) throw ();




extern _Float32 cbrtf32 (_Float32 __x) throw (); extern _Float32 __cbrtf32 (_Float32 __x) throw ();






extern _Float32 ceilf32 (_Float32 __x) throw () __attribute__ ((__const__)); extern _Float32 __ceilf32 (_Float32 __x) throw () __attribute__ ((__const__));


extern _Float32 fabsf32 (_Float32 __x) throw () __attribute__ ((__const__)); extern _Float32 __fabsf32 (_Float32 __x) throw () __attribute__ ((__const__));


extern _Float32 floorf32 (_Float32 __x) throw () __attribute__ ((__const__)); extern _Float32 __floorf32 (_Float32 __x) throw () __attribute__ ((__const__));


extern _Float32 fmodf32 (_Float32 __x, _Float32 __y) throw (); extern _Float32 __fmodf32 (_Float32 __x, _Float32 __y) throw ();
# 198 "/usr/include/bits/mathcalls.h" 3 4
extern _Float32 copysignf32 (_Float32 __x, _Float32 __y) throw () __attribute__ ((__const__)); extern _Float32 __copysignf32 (_Float32 __x, _Float32 __y) throw () __attribute__ ((__const__));




extern _Float32 nanf32 (const char *__tagb) throw (); extern _Float32 __nanf32 (const char *__tagb) throw ();
# 220 "/usr/include/bits/mathcalls.h" 3 4
extern _Float32 j0f32 (_Float32) throw (); extern _Float32 __j0f32 (_Float32) throw ();
extern _Float32 j1f32 (_Float32) throw (); extern _Float32 __j1f32 (_Float32) throw ();
extern _Float32 jnf32 (int, _Float32) throw (); extern _Float32 __jnf32 (int, _Float32) throw ();
extern _Float32 y0f32 (_Float32) throw (); extern _Float32 __y0f32 (_Float32) throw ();
extern _Float32 y1f32 (_Float32) throw (); extern _Float32 __y1f32 (_Float32) throw ();
extern _Float32 ynf32 (int, _Float32) throw (); extern _Float32 __ynf32 (int, _Float32) throw ();





extern _Float32 erff32 (_Float32) throw (); extern _Float32 __erff32 (_Float32) throw ();
extern _Float32 erfcf32 (_Float32) throw (); extern _Float32 __erfcf32 (_Float32) throw ();
extern _Float32 lgammaf32 (_Float32) throw (); extern _Float32 __lgammaf32 (_Float32) throw ();




extern _Float32 tgammaf32 (_Float32) throw (); extern _Float32 __tgammaf32 (_Float32) throw ();
# 252 "/usr/include/bits/mathcalls.h" 3 4
extern _Float32 lgammaf32_r (_Float32, int *__signgamp) throw (); extern _Float32 __lgammaf32_r (_Float32, int *__signgamp) throw ();






extern _Float32 rintf32 (_Float32 __x) throw (); extern _Float32 __rintf32 (_Float32 __x) throw ();


extern _Float32 nextafterf32 (_Float32 __x, _Float32 __y) throw (); extern _Float32 __nextafterf32 (_Float32 __x, _Float32 __y) throw ();






extern _Float32 nextdownf32 (_Float32 __x) throw (); extern _Float32 __nextdownf32 (_Float32 __x) throw ();

extern _Float32 nextupf32 (_Float32 __x) throw (); extern _Float32 __nextupf32 (_Float32 __x) throw ();



extern _Float32 remainderf32 (_Float32 __x, _Float32 __y) throw (); extern _Float32 __remainderf32 (_Float32 __x, _Float32 __y) throw ();



extern _Float32 scalbnf32 (_Float32 __x, int __n) throw (); extern _Float32 __scalbnf32 (_Float32 __x, int __n) throw ();



extern int ilogbf32 (_Float32 __x) throw (); extern int __ilogbf32 (_Float32 __x) throw ();




extern long int llogbf32 (_Float32 __x) throw (); extern long int __llogbf32 (_Float32 __x) throw ();




extern _Float32 scalblnf32 (_Float32 __x, long int __n) throw (); extern _Float32 __scalblnf32 (_Float32 __x, long int __n) throw ();



extern _Float32 nearbyintf32 (_Float32 __x) throw (); extern _Float32 __nearbyintf32 (_Float32 __x) throw ();



extern _Float32 roundf32 (_Float32 __x) throw () __attribute__ ((__const__)); extern _Float32 __roundf32 (_Float32 __x) throw () __attribute__ ((__const__));



extern _Float32 truncf32 (_Float32 __x) throw () __attribute__ ((__const__)); extern _Float32 __truncf32 (_Float32 __x) throw () __attribute__ ((__const__));




extern _Float32 remquof32 (_Float32 __x, _Float32 __y, int *__quo) throw (); extern _Float32 __remquof32 (_Float32 __x, _Float32 __y, int *__quo) throw ();






extern long int lrintf32 (_Float32 __x) throw (); extern long int __lrintf32 (_Float32 __x) throw ();
__extension__
extern long long int llrintf32 (_Float32 __x) throw (); extern long long int __llrintf32 (_Float32 __x) throw ();



extern long int lroundf32 (_Float32 __x) throw (); extern long int __lroundf32 (_Float32 __x) throw ();
__extension__
extern long long int llroundf32 (_Float32 __x) throw (); extern long long int __llroundf32 (_Float32 __x) throw ();



extern _Float32 fdimf32 (_Float32 __x, _Float32 __y) throw (); extern _Float32 __fdimf32 (_Float32 __x, _Float32 __y) throw ();


extern _Float32 fmaxf32 (_Float32 __x, _Float32 __y) throw () __attribute__ ((__const__)); extern _Float32 __fmaxf32 (_Float32 __x, _Float32 __y) throw () __attribute__ ((__const__));


extern _Float32 fminf32 (_Float32 __x, _Float32 __y) throw () __attribute__ ((__const__)); extern _Float32 __fminf32 (_Float32 __x, _Float32 __y) throw () __attribute__ ((__const__));


extern _Float32 fmaf32 (_Float32 __x, _Float32 __y, _Float32 __z) throw (); extern _Float32 __fmaf32 (_Float32 __x, _Float32 __y, _Float32 __z) throw ();




extern _Float32 roundevenf32 (_Float32 __x) throw () __attribute__ ((__const__)); extern _Float32 __roundevenf32 (_Float32 __x) throw () __attribute__ ((__const__));



extern __intmax_t fromfpf32 (_Float32 __x, int __round, unsigned int __width) throw (); extern __intmax_t __fromfpf32 (_Float32 __x, int __round, unsigned int __width) throw ()
                            ;



extern __uintmax_t ufromfpf32 (_Float32 __x, int __round, unsigned int __width) throw (); extern __uintmax_t __ufromfpf32 (_Float32 __x, int __round, unsigned int __width) throw ()
                              ;




extern __intmax_t fromfpxf32 (_Float32 __x, int __round, unsigned int __width) throw (); extern __intmax_t __fromfpxf32 (_Float32 __x, int __round, unsigned int __width) throw ()
                             ;




extern __uintmax_t ufromfpxf32 (_Float32 __x, int __round, unsigned int __width) throw (); extern __uintmax_t __ufromfpxf32 (_Float32 __x, int __round, unsigned int __width) throw ()
                               ;


extern _Float32 fmaxmagf32 (_Float32 __x, _Float32 __y) throw () __attribute__ ((__const__)); extern _Float32 __fmaxmagf32 (_Float32 __x, _Float32 __y) throw () __attribute__ ((__const__));


extern _Float32 fminmagf32 (_Float32 __x, _Float32 __y) throw () __attribute__ ((__const__)); extern _Float32 __fminmagf32 (_Float32 __x, _Float32 __y) throw () __attribute__ ((__const__));


extern int canonicalizef32 (_Float32 *__cx, const _Float32 *__x) throw ();




extern int totalorderf32 (const _Float32 *__x, const _Float32 *__y) throw ()

     __attribute__ ((__pure__));


extern int totalordermagf32 (const _Float32 *__x, const _Float32 *__y) throw ()

     __attribute__ ((__pure__));


extern _Float32 getpayloadf32 (const _Float32 *__x) throw (); extern _Float32 __getpayloadf32 (const _Float32 *__x) throw ();


extern int setpayloadf32 (_Float32 *__x, _Float32 __payload) throw ();


extern int setpayloadsigf32 (_Float32 *__x, _Float32 __payload) throw ();
# 437 "/usr/include/math.h" 2 3 4
# 453 "/usr/include/math.h" 3 4
# 1 "/usr/include/bits/mathcalls.h" 1 3 4
# 53 "/usr/include/bits/mathcalls.h" 3 4
extern _Float64 acosf64 (_Float64 __x) throw (); extern _Float64 __acosf64 (_Float64 __x) throw ();

extern _Float64 asinf64 (_Float64 __x) throw (); extern _Float64 __asinf64 (_Float64 __x) throw ();

extern _Float64 atanf64 (_Float64 __x) throw (); extern _Float64 __atanf64 (_Float64 __x) throw ();

extern _Float64 atan2f64 (_Float64 __y, _Float64 __x) throw (); extern _Float64 __atan2f64 (_Float64 __y, _Float64 __x) throw ();


 extern _Float64 cosf64 (_Float64 __x) throw (); extern _Float64 __cosf64 (_Float64 __x) throw ();

 extern _Float64 sinf64 (_Float64 __x) throw (); extern _Float64 __sinf64 (_Float64 __x) throw ();

extern _Float64 tanf64 (_Float64 __x) throw (); extern _Float64 __tanf64 (_Float64 __x) throw ();




extern _Float64 coshf64 (_Float64 __x) throw (); extern _Float64 __coshf64 (_Float64 __x) throw ();

extern _Float64 sinhf64 (_Float64 __x) throw (); extern _Float64 __sinhf64 (_Float64 __x) throw ();

extern _Float64 tanhf64 (_Float64 __x) throw (); extern _Float64 __tanhf64 (_Float64 __x) throw ();



 extern void sincosf64 (_Float64 __x, _Float64 *__sinx, _Float64 *__cosx) throw (); extern void __sincosf64 (_Float64 __x, _Float64 *__sinx, _Float64 *__cosx) throw ()
                                                        ;




extern _Float64 acoshf64 (_Float64 __x) throw (); extern _Float64 __acoshf64 (_Float64 __x) throw ();

extern _Float64 asinhf64 (_Float64 __x) throw (); extern _Float64 __asinhf64 (_Float64 __x) throw ();

extern _Float64 atanhf64 (_Float64 __x) throw (); extern _Float64 __atanhf64 (_Float64 __x) throw ();





 extern _Float64 expf64 (_Float64 __x) throw (); extern _Float64 __expf64 (_Float64 __x) throw ();


extern _Float64 frexpf64 (_Float64 __x, int *__exponent) throw (); extern _Float64 __frexpf64 (_Float64 __x, int *__exponent) throw ();


extern _Float64 ldexpf64 (_Float64 __x, int __exponent) throw (); extern _Float64 __ldexpf64 (_Float64 __x, int __exponent) throw ();


 extern _Float64 logf64 (_Float64 __x) throw (); extern _Float64 __logf64 (_Float64 __x) throw ();


extern _Float64 log10f64 (_Float64 __x) throw (); extern _Float64 __log10f64 (_Float64 __x) throw ();


extern _Float64 modff64 (_Float64 __x, _Float64 *__iptr) throw (); extern _Float64 __modff64 (_Float64 __x, _Float64 *__iptr) throw () __attribute__ ((__nonnull__ (2)));



extern _Float64 exp10f64 (_Float64 __x) throw (); extern _Float64 __exp10f64 (_Float64 __x) throw ();




extern _Float64 expm1f64 (_Float64 __x) throw (); extern _Float64 __expm1f64 (_Float64 __x) throw ();


extern _Float64 log1pf64 (_Float64 __x) throw (); extern _Float64 __log1pf64 (_Float64 __x) throw ();


extern _Float64 logbf64 (_Float64 __x) throw (); extern _Float64 __logbf64 (_Float64 __x) throw ();




extern _Float64 exp2f64 (_Float64 __x) throw (); extern _Float64 __exp2f64 (_Float64 __x) throw ();


extern _Float64 log2f64 (_Float64 __x) throw (); extern _Float64 __log2f64 (_Float64 __x) throw ();






 extern _Float64 powf64 (_Float64 __x, _Float64 __y) throw (); extern _Float64 __powf64 (_Float64 __x, _Float64 __y) throw ();


extern _Float64 sqrtf64 (_Float64 __x) throw (); extern _Float64 __sqrtf64 (_Float64 __x) throw ();



extern _Float64 hypotf64 (_Float64 __x, _Float64 __y) throw (); extern _Float64 __hypotf64 (_Float64 __x, _Float64 __y) throw ();




extern _Float64 cbrtf64 (_Float64 __x) throw (); extern _Float64 __cbrtf64 (_Float64 __x) throw ();






extern _Float64 ceilf64 (_Float64 __x) throw () __attribute__ ((__const__)); extern _Float64 __ceilf64 (_Float64 __x) throw () __attribute__ ((__const__));


extern _Float64 fabsf64 (_Float64 __x) throw () __attribute__ ((__const__)); extern _Float64 __fabsf64 (_Float64 __x) throw () __attribute__ ((__const__));


extern _Float64 floorf64 (_Float64 __x) throw () __attribute__ ((__const__)); extern _Float64 __floorf64 (_Float64 __x) throw () __attribute__ ((__const__));


extern _Float64 fmodf64 (_Float64 __x, _Float64 __y) throw (); extern _Float64 __fmodf64 (_Float64 __x, _Float64 __y) throw ();
# 198 "/usr/include/bits/mathcalls.h" 3 4
extern _Float64 copysignf64 (_Float64 __x, _Float64 __y) throw () __attribute__ ((__const__)); extern _Float64 __copysignf64 (_Float64 __x, _Float64 __y) throw () __attribute__ ((__const__));




extern _Float64 nanf64 (const char *__tagb) throw (); extern _Float64 __nanf64 (const char *__tagb) throw ();
# 220 "/usr/include/bits/mathcalls.h" 3 4
extern _Float64 j0f64 (_Float64) throw (); extern _Float64 __j0f64 (_Float64) throw ();
extern _Float64 j1f64 (_Float64) throw (); extern _Float64 __j1f64 (_Float64) throw ();
extern _Float64 jnf64 (int, _Float64) throw (); extern _Float64 __jnf64 (int, _Float64) throw ();
extern _Float64 y0f64 (_Float64) throw (); extern _Float64 __y0f64 (_Float64) throw ();
extern _Float64 y1f64 (_Float64) throw (); extern _Float64 __y1f64 (_Float64) throw ();
extern _Float64 ynf64 (int, _Float64) throw (); extern _Float64 __ynf64 (int, _Float64) throw ();





extern _Float64 erff64 (_Float64) throw (); extern _Float64 __erff64 (_Float64) throw ();
extern _Float64 erfcf64 (_Float64) throw (); extern _Float64 __erfcf64 (_Float64) throw ();
extern _Float64 lgammaf64 (_Float64) throw (); extern _Float64 __lgammaf64 (_Float64) throw ();




extern _Float64 tgammaf64 (_Float64) throw (); extern _Float64 __tgammaf64 (_Float64) throw ();
# 252 "/usr/include/bits/mathcalls.h" 3 4
extern _Float64 lgammaf64_r (_Float64, int *__signgamp) throw (); extern _Float64 __lgammaf64_r (_Float64, int *__signgamp) throw ();






extern _Float64 rintf64 (_Float64 __x) throw (); extern _Float64 __rintf64 (_Float64 __x) throw ();


extern _Float64 nextafterf64 (_Float64 __x, _Float64 __y) throw (); extern _Float64 __nextafterf64 (_Float64 __x, _Float64 __y) throw ();






extern _Float64 nextdownf64 (_Float64 __x) throw (); extern _Float64 __nextdownf64 (_Float64 __x) throw ();

extern _Float64 nextupf64 (_Float64 __x) throw (); extern _Float64 __nextupf64 (_Float64 __x) throw ();



extern _Float64 remainderf64 (_Float64 __x, _Float64 __y) throw (); extern _Float64 __remainderf64 (_Float64 __x, _Float64 __y) throw ();



extern _Float64 scalbnf64 (_Float64 __x, int __n) throw (); extern _Float64 __scalbnf64 (_Float64 __x, int __n) throw ();



extern int ilogbf64 (_Float64 __x) throw (); extern int __ilogbf64 (_Float64 __x) throw ();




extern long int llogbf64 (_Float64 __x) throw (); extern long int __llogbf64 (_Float64 __x) throw ();




extern _Float64 scalblnf64 (_Float64 __x, long int __n) throw (); extern _Float64 __scalblnf64 (_Float64 __x, long int __n) throw ();



extern _Float64 nearbyintf64 (_Float64 __x) throw (); extern _Float64 __nearbyintf64 (_Float64 __x) throw ();



extern _Float64 roundf64 (_Float64 __x) throw () __attribute__ ((__const__)); extern _Float64 __roundf64 (_Float64 __x) throw () __attribute__ ((__const__));



extern _Float64 truncf64 (_Float64 __x) throw () __attribute__ ((__const__)); extern _Float64 __truncf64 (_Float64 __x) throw () __attribute__ ((__const__));




extern _Float64 remquof64 (_Float64 __x, _Float64 __y, int *__quo) throw (); extern _Float64 __remquof64 (_Float64 __x, _Float64 __y, int *__quo) throw ();






extern long int lrintf64 (_Float64 __x) throw (); extern long int __lrintf64 (_Float64 __x) throw ();
__extension__
extern long long int llrintf64 (_Float64 __x) throw (); extern long long int __llrintf64 (_Float64 __x) throw ();



extern long int lroundf64 (_Float64 __x) throw (); extern long int __lroundf64 (_Float64 __x) throw ();
__extension__
extern long long int llroundf64 (_Float64 __x) throw (); extern long long int __llroundf64 (_Float64 __x) throw ();



extern _Float64 fdimf64 (_Float64 __x, _Float64 __y) throw (); extern _Float64 __fdimf64 (_Float64 __x, _Float64 __y) throw ();


extern _Float64 fmaxf64 (_Float64 __x, _Float64 __y) throw () __attribute__ ((__const__)); extern _Float64 __fmaxf64 (_Float64 __x, _Float64 __y) throw () __attribute__ ((__const__));


extern _Float64 fminf64 (_Float64 __x, _Float64 __y) throw () __attribute__ ((__const__)); extern _Float64 __fminf64 (_Float64 __x, _Float64 __y) throw () __attribute__ ((__const__));


extern _Float64 fmaf64 (_Float64 __x, _Float64 __y, _Float64 __z) throw (); extern _Float64 __fmaf64 (_Float64 __x, _Float64 __y, _Float64 __z) throw ();




extern _Float64 roundevenf64 (_Float64 __x) throw () __attribute__ ((__const__)); extern _Float64 __roundevenf64 (_Float64 __x) throw () __attribute__ ((__const__));



extern __intmax_t fromfpf64 (_Float64 __x, int __round, unsigned int __width) throw (); extern __intmax_t __fromfpf64 (_Float64 __x, int __round, unsigned int __width) throw ()
                            ;



extern __uintmax_t ufromfpf64 (_Float64 __x, int __round, unsigned int __width) throw (); extern __uintmax_t __ufromfpf64 (_Float64 __x, int __round, unsigned int __width) throw ()
                              ;




extern __intmax_t fromfpxf64 (_Float64 __x, int __round, unsigned int __width) throw (); extern __intmax_t __fromfpxf64 (_Float64 __x, int __round, unsigned int __width) throw ()
                             ;




extern __uintmax_t ufromfpxf64 (_Float64 __x, int __round, unsigned int __width) throw (); extern __uintmax_t __ufromfpxf64 (_Float64 __x, int __round, unsigned int __width) throw ()
                               ;


extern _Float64 fmaxmagf64 (_Float64 __x, _Float64 __y) throw () __attribute__ ((__const__)); extern _Float64 __fmaxmagf64 (_Float64 __x, _Float64 __y) throw () __attribute__ ((__const__));


extern _Float64 fminmagf64 (_Float64 __x, _Float64 __y) throw () __attribute__ ((__const__)); extern _Float64 __fminmagf64 (_Float64 __x, _Float64 __y) throw () __attribute__ ((__const__));


extern int canonicalizef64 (_Float64 *__cx, const _Float64 *__x) throw ();




extern int totalorderf64 (const _Float64 *__x, const _Float64 *__y) throw ()

     __attribute__ ((__pure__));


extern int totalordermagf64 (const _Float64 *__x, const _Float64 *__y) throw ()

     __attribute__ ((__pure__));


extern _Float64 getpayloadf64 (const _Float64 *__x) throw (); extern _Float64 __getpayloadf64 (const _Float64 *__x) throw ();


extern int setpayloadf64 (_Float64 *__x, _Float64 __payload) throw ();


extern int setpayloadsigf64 (_Float64 *__x, _Float64 __payload) throw ();
# 454 "/usr/include/math.h" 2 3 4
# 467 "/usr/include/math.h" 3 4
# 1 "/usr/include/bits/mathcalls-helper-functions.h" 1 3 4
# 20 "/usr/include/bits/mathcalls-helper-functions.h" 3 4
extern int __fpclassifyf128 (_Float128 __value) throw ()
     __attribute__ ((__const__));


extern int __signbitf128 (_Float128 __value) throw ()
     __attribute__ ((__const__));



extern int __isinff128 (_Float128 __value) throw ()
  __attribute__ ((__const__));


extern int __finitef128 (_Float128 __value) throw ()
  __attribute__ ((__const__));


extern int __isnanf128 (_Float128 __value) throw ()
  __attribute__ ((__const__));


extern int __iseqsigf128 (_Float128 __x, _Float128 __y) throw ();


extern int __issignalingf128 (_Float128 __value) throw ()
     __attribute__ ((__const__));
# 468 "/usr/include/math.h" 2 3 4


# 1 "/usr/include/bits/mathcalls.h" 1 3 4
# 53 "/usr/include/bits/mathcalls.h" 3 4
extern _Float128 acosf128 (_Float128 __x) throw (); extern _Float128 __acosf128 (_Float128 __x) throw ();

extern _Float128 asinf128 (_Float128 __x) throw (); extern _Float128 __asinf128 (_Float128 __x) throw ();

extern _Float128 atanf128 (_Float128 __x) throw (); extern _Float128 __atanf128 (_Float128 __x) throw ();

extern _Float128 atan2f128 (_Float128 __y, _Float128 __x) throw (); extern _Float128 __atan2f128 (_Float128 __y, _Float128 __x) throw ();


 extern _Float128 cosf128 (_Float128 __x) throw (); extern _Float128 __cosf128 (_Float128 __x) throw ();

 extern _Float128 sinf128 (_Float128 __x) throw (); extern _Float128 __sinf128 (_Float128 __x) throw ();

extern _Float128 tanf128 (_Float128 __x) throw (); extern _Float128 __tanf128 (_Float128 __x) throw ();




extern _Float128 coshf128 (_Float128 __x) throw (); extern _Float128 __coshf128 (_Float128 __x) throw ();

extern _Float128 sinhf128 (_Float128 __x) throw (); extern _Float128 __sinhf128 (_Float128 __x) throw ();

extern _Float128 tanhf128 (_Float128 __x) throw (); extern _Float128 __tanhf128 (_Float128 __x) throw ();



 extern void sincosf128 (_Float128 __x, _Float128 *__sinx, _Float128 *__cosx) throw (); extern void __sincosf128 (_Float128 __x, _Float128 *__sinx, _Float128 *__cosx) throw ()
                                                        ;




extern _Float128 acoshf128 (_Float128 __x) throw (); extern _Float128 __acoshf128 (_Float128 __x) throw ();

extern _Float128 asinhf128 (_Float128 __x) throw (); extern _Float128 __asinhf128 (_Float128 __x) throw ();

extern _Float128 atanhf128 (_Float128 __x) throw (); extern _Float128 __atanhf128 (_Float128 __x) throw ();





 extern _Float128 expf128 (_Float128 __x) throw (); extern _Float128 __expf128 (_Float128 __x) throw ();


extern _Float128 frexpf128 (_Float128 __x, int *__exponent) throw (); extern _Float128 __frexpf128 (_Float128 __x, int *__exponent) throw ();


extern _Float128 ldexpf128 (_Float128 __x, int __exponent) throw (); extern _Float128 __ldexpf128 (_Float128 __x, int __exponent) throw ();


 extern _Float128 logf128 (_Float128 __x) throw (); extern _Float128 __logf128 (_Float128 __x) throw ();


extern _Float128 log10f128 (_Float128 __x) throw (); extern _Float128 __log10f128 (_Float128 __x) throw ();


extern _Float128 modff128 (_Float128 __x, _Float128 *__iptr) throw (); extern _Float128 __modff128 (_Float128 __x, _Float128 *__iptr) throw () __attribute__ ((__nonnull__ (2)));



extern _Float128 exp10f128 (_Float128 __x) throw (); extern _Float128 __exp10f128 (_Float128 __x) throw ();




extern _Float128 expm1f128 (_Float128 __x) throw (); extern _Float128 __expm1f128 (_Float128 __x) throw ();


extern _Float128 log1pf128 (_Float128 __x) throw (); extern _Float128 __log1pf128 (_Float128 __x) throw ();


extern _Float128 logbf128 (_Float128 __x) throw (); extern _Float128 __logbf128 (_Float128 __x) throw ();




extern _Float128 exp2f128 (_Float128 __x) throw (); extern _Float128 __exp2f128 (_Float128 __x) throw ();


extern _Float128 log2f128 (_Float128 __x) throw (); extern _Float128 __log2f128 (_Float128 __x) throw ();






 extern _Float128 powf128 (_Float128 __x, _Float128 __y) throw (); extern _Float128 __powf128 (_Float128 __x, _Float128 __y) throw ();


extern _Float128 sqrtf128 (_Float128 __x) throw (); extern _Float128 __sqrtf128 (_Float128 __x) throw ();



extern _Float128 hypotf128 (_Float128 __x, _Float128 __y) throw (); extern _Float128 __hypotf128 (_Float128 __x, _Float128 __y) throw ();




extern _Float128 cbrtf128 (_Float128 __x) throw (); extern _Float128 __cbrtf128 (_Float128 __x) throw ();






extern _Float128 ceilf128 (_Float128 __x) throw () __attribute__ ((__const__)); extern _Float128 __ceilf128 (_Float128 __x) throw () __attribute__ ((__const__));


extern _Float128 fabsf128 (_Float128 __x) throw () __attribute__ ((__const__)); extern _Float128 __fabsf128 (_Float128 __x) throw () __attribute__ ((__const__));


extern _Float128 floorf128 (_Float128 __x) throw () __attribute__ ((__const__)); extern _Float128 __floorf128 (_Float128 __x) throw () __attribute__ ((__const__));


extern _Float128 fmodf128 (_Float128 __x, _Float128 __y) throw (); extern _Float128 __fmodf128 (_Float128 __x, _Float128 __y) throw ();
# 198 "/usr/include/bits/mathcalls.h" 3 4
extern _Float128 copysignf128 (_Float128 __x, _Float128 __y) throw () __attribute__ ((__const__)); extern _Float128 __copysignf128 (_Float128 __x, _Float128 __y) throw () __attribute__ ((__const__));




extern _Float128 nanf128 (const char *__tagb) throw (); extern _Float128 __nanf128 (const char *__tagb) throw ();
# 220 "/usr/include/bits/mathcalls.h" 3 4
extern _Float128 j0f128 (_Float128) throw (); extern _Float128 __j0f128 (_Float128) throw ();
extern _Float128 j1f128 (_Float128) throw (); extern _Float128 __j1f128 (_Float128) throw ();
extern _Float128 jnf128 (int, _Float128) throw (); extern _Float128 __jnf128 (int, _Float128) throw ();
extern _Float128 y0f128 (_Float128) throw (); extern _Float128 __y0f128 (_Float128) throw ();
extern _Float128 y1f128 (_Float128) throw (); extern _Float128 __y1f128 (_Float128) throw ();
extern _Float128 ynf128 (int, _Float128) throw (); extern _Float128 __ynf128 (int, _Float128) throw ();





extern _Float128 erff128 (_Float128) throw (); extern _Float128 __erff128 (_Float128) throw ();
extern _Float128 erfcf128 (_Float128) throw (); extern _Float128 __erfcf128 (_Float128) throw ();
extern _Float128 lgammaf128 (_Float128) throw (); extern _Float128 __lgammaf128 (_Float128) throw ();




extern _Float128 tgammaf128 (_Float128) throw (); extern _Float128 __tgammaf128 (_Float128) throw ();
# 252 "/usr/include/bits/mathcalls.h" 3 4
extern _Float128 lgammaf128_r (_Float128, int *__signgamp) throw (); extern _Float128 __lgammaf128_r (_Float128, int *__signgamp) throw ();






extern _Float128 rintf128 (_Float128 __x) throw (); extern _Float128 __rintf128 (_Float128 __x) throw ();


extern _Float128 nextafterf128 (_Float128 __x, _Float128 __y) throw (); extern _Float128 __nextafterf128 (_Float128 __x, _Float128 __y) throw ();






extern _Float128 nextdownf128 (_Float128 __x) throw (); extern _Float128 __nextdownf128 (_Float128 __x) throw ();

extern _Float128 nextupf128 (_Float128 __x) throw (); extern _Float128 __nextupf128 (_Float128 __x) throw ();



extern _Float128 remainderf128 (_Float128 __x, _Float128 __y) throw (); extern _Float128 __remainderf128 (_Float128 __x, _Float128 __y) throw ();



extern _Float128 scalbnf128 (_Float128 __x, int __n) throw (); extern _Float128 __scalbnf128 (_Float128 __x, int __n) throw ();



extern int ilogbf128 (_Float128 __x) throw (); extern int __ilogbf128 (_Float128 __x) throw ();




extern long int llogbf128 (_Float128 __x) throw (); extern long int __llogbf128 (_Float128 __x) throw ();




extern _Float128 scalblnf128 (_Float128 __x, long int __n) throw (); extern _Float128 __scalblnf128 (_Float128 __x, long int __n) throw ();



extern _Float128 nearbyintf128 (_Float128 __x) throw (); extern _Float128 __nearbyintf128 (_Float128 __x) throw ();



extern _Float128 roundf128 (_Float128 __x) throw () __attribute__ ((__const__)); extern _Float128 __roundf128 (_Float128 __x) throw () __attribute__ ((__const__));



extern _Float128 truncf128 (_Float128 __x) throw () __attribute__ ((__const__)); extern _Float128 __truncf128 (_Float128 __x) throw () __attribute__ ((__const__));




extern _Float128 remquof128 (_Float128 __x, _Float128 __y, int *__quo) throw (); extern _Float128 __remquof128 (_Float128 __x, _Float128 __y, int *__quo) throw ();






extern long int lrintf128 (_Float128 __x) throw (); extern long int __lrintf128 (_Float128 __x) throw ();
__extension__
extern long long int llrintf128 (_Float128 __x) throw (); extern long long int __llrintf128 (_Float128 __x) throw ();



extern long int lroundf128 (_Float128 __x) throw (); extern long int __lroundf128 (_Float128 __x) throw ();
__extension__
extern long long int llroundf128 (_Float128 __x) throw (); extern long long int __llroundf128 (_Float128 __x) throw ();



extern _Float128 fdimf128 (_Float128 __x, _Float128 __y) throw (); extern _Float128 __fdimf128 (_Float128 __x, _Float128 __y) throw ();


extern _Float128 fmaxf128 (_Float128 __x, _Float128 __y) throw () __attribute__ ((__const__)); extern _Float128 __fmaxf128 (_Float128 __x, _Float128 __y) throw () __attribute__ ((__const__));


extern _Float128 fminf128 (_Float128 __x, _Float128 __y) throw () __attribute__ ((__const__)); extern _Float128 __fminf128 (_Float128 __x, _Float128 __y) throw () __attribute__ ((__const__));


extern _Float128 fmaf128 (_Float128 __x, _Float128 __y, _Float128 __z) throw (); extern _Float128 __fmaf128 (_Float128 __x, _Float128 __y, _Float128 __z) throw ();




extern _Float128 roundevenf128 (_Float128 __x) throw () __attribute__ ((__const__)); extern _Float128 __roundevenf128 (_Float128 __x) throw () __attribute__ ((__const__));



extern __intmax_t fromfpf128 (_Float128 __x, int __round, unsigned int __width) throw (); extern __intmax_t __fromfpf128 (_Float128 __x, int __round, unsigned int __width) throw ()
                            ;



extern __uintmax_t ufromfpf128 (_Float128 __x, int __round, unsigned int __width) throw (); extern __uintmax_t __ufromfpf128 (_Float128 __x, int __round, unsigned int __width) throw ()
                              ;




extern __intmax_t fromfpxf128 (_Float128 __x, int __round, unsigned int __width) throw (); extern __intmax_t __fromfpxf128 (_Float128 __x, int __round, unsigned int __width) throw ()
                             ;




extern __uintmax_t ufromfpxf128 (_Float128 __x, int __round, unsigned int __width) throw (); extern __uintmax_t __ufromfpxf128 (_Float128 __x, int __round, unsigned int __width) throw ()
                               ;


extern _Float128 fmaxmagf128 (_Float128 __x, _Float128 __y) throw () __attribute__ ((__const__)); extern _Float128 __fmaxmagf128 (_Float128 __x, _Float128 __y) throw () __attribute__ ((__const__));


extern _Float128 fminmagf128 (_Float128 __x, _Float128 __y) throw () __attribute__ ((__const__)); extern _Float128 __fminmagf128 (_Float128 __x, _Float128 __y) throw () __attribute__ ((__const__));


extern int canonicalizef128 (_Float128 *__cx, const _Float128 *__x) throw ();




extern int totalorderf128 (const _Float128 *__x, const _Float128 *__y) throw ()

     __attribute__ ((__pure__));


extern int totalordermagf128 (const _Float128 *__x, const _Float128 *__y) throw ()

     __attribute__ ((__pure__));


extern _Float128 getpayloadf128 (const _Float128 *__x) throw (); extern _Float128 __getpayloadf128 (const _Float128 *__x) throw ();


extern int setpayloadf128 (_Float128 *__x, _Float128 __payload) throw ();


extern int setpayloadsigf128 (_Float128 *__x, _Float128 __payload) throw ();
# 471 "/usr/include/math.h" 2 3 4
# 487 "/usr/include/math.h" 3 4
# 1 "/usr/include/bits/mathcalls.h" 1 3 4
# 53 "/usr/include/bits/mathcalls.h" 3 4
extern _Float32x acosf32x (_Float32x __x) throw (); extern _Float32x __acosf32x (_Float32x __x) throw ();

extern _Float32x asinf32x (_Float32x __x) throw (); extern _Float32x __asinf32x (_Float32x __x) throw ();

extern _Float32x atanf32x (_Float32x __x) throw (); extern _Float32x __atanf32x (_Float32x __x) throw ();

extern _Float32x atan2f32x (_Float32x __y, _Float32x __x) throw (); extern _Float32x __atan2f32x (_Float32x __y, _Float32x __x) throw ();


 extern _Float32x cosf32x (_Float32x __x) throw (); extern _Float32x __cosf32x (_Float32x __x) throw ();

 extern _Float32x sinf32x (_Float32x __x) throw (); extern _Float32x __sinf32x (_Float32x __x) throw ();

extern _Float32x tanf32x (_Float32x __x) throw (); extern _Float32x __tanf32x (_Float32x __x) throw ();




extern _Float32x coshf32x (_Float32x __x) throw (); extern _Float32x __coshf32x (_Float32x __x) throw ();

extern _Float32x sinhf32x (_Float32x __x) throw (); extern _Float32x __sinhf32x (_Float32x __x) throw ();

extern _Float32x tanhf32x (_Float32x __x) throw (); extern _Float32x __tanhf32x (_Float32x __x) throw ();



 extern void sincosf32x (_Float32x __x, _Float32x *__sinx, _Float32x *__cosx) throw (); extern void __sincosf32x (_Float32x __x, _Float32x *__sinx, _Float32x *__cosx) throw ()
                                                        ;




extern _Float32x acoshf32x (_Float32x __x) throw (); extern _Float32x __acoshf32x (_Float32x __x) throw ();

extern _Float32x asinhf32x (_Float32x __x) throw (); extern _Float32x __asinhf32x (_Float32x __x) throw ();

extern _Float32x atanhf32x (_Float32x __x) throw (); extern _Float32x __atanhf32x (_Float32x __x) throw ();





 extern _Float32x expf32x (_Float32x __x) throw (); extern _Float32x __expf32x (_Float32x __x) throw ();


extern _Float32x frexpf32x (_Float32x __x, int *__exponent) throw (); extern _Float32x __frexpf32x (_Float32x __x, int *__exponent) throw ();


extern _Float32x ldexpf32x (_Float32x __x, int __exponent) throw (); extern _Float32x __ldexpf32x (_Float32x __x, int __exponent) throw ();


 extern _Float32x logf32x (_Float32x __x) throw (); extern _Float32x __logf32x (_Float32x __x) throw ();


extern _Float32x log10f32x (_Float32x __x) throw (); extern _Float32x __log10f32x (_Float32x __x) throw ();


extern _Float32x modff32x (_Float32x __x, _Float32x *__iptr) throw (); extern _Float32x __modff32x (_Float32x __x, _Float32x *__iptr) throw () __attribute__ ((__nonnull__ (2)));



extern _Float32x exp10f32x (_Float32x __x) throw (); extern _Float32x __exp10f32x (_Float32x __x) throw ();




extern _Float32x expm1f32x (_Float32x __x) throw (); extern _Float32x __expm1f32x (_Float32x __x) throw ();


extern _Float32x log1pf32x (_Float32x __x) throw (); extern _Float32x __log1pf32x (_Float32x __x) throw ();


extern _Float32x logbf32x (_Float32x __x) throw (); extern _Float32x __logbf32x (_Float32x __x) throw ();




extern _Float32x exp2f32x (_Float32x __x) throw (); extern _Float32x __exp2f32x (_Float32x __x) throw ();


extern _Float32x log2f32x (_Float32x __x) throw (); extern _Float32x __log2f32x (_Float32x __x) throw ();






 extern _Float32x powf32x (_Float32x __x, _Float32x __y) throw (); extern _Float32x __powf32x (_Float32x __x, _Float32x __y) throw ();


extern _Float32x sqrtf32x (_Float32x __x) throw (); extern _Float32x __sqrtf32x (_Float32x __x) throw ();



extern _Float32x hypotf32x (_Float32x __x, _Float32x __y) throw (); extern _Float32x __hypotf32x (_Float32x __x, _Float32x __y) throw ();




extern _Float32x cbrtf32x (_Float32x __x) throw (); extern _Float32x __cbrtf32x (_Float32x __x) throw ();






extern _Float32x ceilf32x (_Float32x __x) throw () __attribute__ ((__const__)); extern _Float32x __ceilf32x (_Float32x __x) throw () __attribute__ ((__const__));


extern _Float32x fabsf32x (_Float32x __x) throw () __attribute__ ((__const__)); extern _Float32x __fabsf32x (_Float32x __x) throw () __attribute__ ((__const__));


extern _Float32x floorf32x (_Float32x __x) throw () __attribute__ ((__const__)); extern _Float32x __floorf32x (_Float32x __x) throw () __attribute__ ((__const__));


extern _Float32x fmodf32x (_Float32x __x, _Float32x __y) throw (); extern _Float32x __fmodf32x (_Float32x __x, _Float32x __y) throw ();
# 198 "/usr/include/bits/mathcalls.h" 3 4
extern _Float32x copysignf32x (_Float32x __x, _Float32x __y) throw () __attribute__ ((__const__)); extern _Float32x __copysignf32x (_Float32x __x, _Float32x __y) throw () __attribute__ ((__const__));




extern _Float32x nanf32x (const char *__tagb) throw (); extern _Float32x __nanf32x (const char *__tagb) throw ();
# 220 "/usr/include/bits/mathcalls.h" 3 4
extern _Float32x j0f32x (_Float32x) throw (); extern _Float32x __j0f32x (_Float32x) throw ();
extern _Float32x j1f32x (_Float32x) throw (); extern _Float32x __j1f32x (_Float32x) throw ();
extern _Float32x jnf32x (int, _Float32x) throw (); extern _Float32x __jnf32x (int, _Float32x) throw ();
extern _Float32x y0f32x (_Float32x) throw (); extern _Float32x __y0f32x (_Float32x) throw ();
extern _Float32x y1f32x (_Float32x) throw (); extern _Float32x __y1f32x (_Float32x) throw ();
extern _Float32x ynf32x (int, _Float32x) throw (); extern _Float32x __ynf32x (int, _Float32x) throw ();





extern _Float32x erff32x (_Float32x) throw (); extern _Float32x __erff32x (_Float32x) throw ();
extern _Float32x erfcf32x (_Float32x) throw (); extern _Float32x __erfcf32x (_Float32x) throw ();
extern _Float32x lgammaf32x (_Float32x) throw (); extern _Float32x __lgammaf32x (_Float32x) throw ();




extern _Float32x tgammaf32x (_Float32x) throw (); extern _Float32x __tgammaf32x (_Float32x) throw ();
# 252 "/usr/include/bits/mathcalls.h" 3 4
extern _Float32x lgammaf32x_r (_Float32x, int *__signgamp) throw (); extern _Float32x __lgammaf32x_r (_Float32x, int *__signgamp) throw ();






extern _Float32x rintf32x (_Float32x __x) throw (); extern _Float32x __rintf32x (_Float32x __x) throw ();


extern _Float32x nextafterf32x (_Float32x __x, _Float32x __y) throw (); extern _Float32x __nextafterf32x (_Float32x __x, _Float32x __y) throw ();






extern _Float32x nextdownf32x (_Float32x __x) throw (); extern _Float32x __nextdownf32x (_Float32x __x) throw ();

extern _Float32x nextupf32x (_Float32x __x) throw (); extern _Float32x __nextupf32x (_Float32x __x) throw ();



extern _Float32x remainderf32x (_Float32x __x, _Float32x __y) throw (); extern _Float32x __remainderf32x (_Float32x __x, _Float32x __y) throw ();



extern _Float32x scalbnf32x (_Float32x __x, int __n) throw (); extern _Float32x __scalbnf32x (_Float32x __x, int __n) throw ();



extern int ilogbf32x (_Float32x __x) throw (); extern int __ilogbf32x (_Float32x __x) throw ();




extern long int llogbf32x (_Float32x __x) throw (); extern long int __llogbf32x (_Float32x __x) throw ();




extern _Float32x scalblnf32x (_Float32x __x, long int __n) throw (); extern _Float32x __scalblnf32x (_Float32x __x, long int __n) throw ();



extern _Float32x nearbyintf32x (_Float32x __x) throw (); extern _Float32x __nearbyintf32x (_Float32x __x) throw ();



extern _Float32x roundf32x (_Float32x __x) throw () __attribute__ ((__const__)); extern _Float32x __roundf32x (_Float32x __x) throw () __attribute__ ((__const__));



extern _Float32x truncf32x (_Float32x __x) throw () __attribute__ ((__const__)); extern _Float32x __truncf32x (_Float32x __x) throw () __attribute__ ((__const__));




extern _Float32x remquof32x (_Float32x __x, _Float32x __y, int *__quo) throw (); extern _Float32x __remquof32x (_Float32x __x, _Float32x __y, int *__quo) throw ();






extern long int lrintf32x (_Float32x __x) throw (); extern long int __lrintf32x (_Float32x __x) throw ();
__extension__
extern long long int llrintf32x (_Float32x __x) throw (); extern long long int __llrintf32x (_Float32x __x) throw ();



extern long int lroundf32x (_Float32x __x) throw (); extern long int __lroundf32x (_Float32x __x) throw ();
__extension__
extern long long int llroundf32x (_Float32x __x) throw (); extern long long int __llroundf32x (_Float32x __x) throw ();



extern _Float32x fdimf32x (_Float32x __x, _Float32x __y) throw (); extern _Float32x __fdimf32x (_Float32x __x, _Float32x __y) throw ();


extern _Float32x fmaxf32x (_Float32x __x, _Float32x __y) throw () __attribute__ ((__const__)); extern _Float32x __fmaxf32x (_Float32x __x, _Float32x __y) throw () __attribute__ ((__const__));


extern _Float32x fminf32x (_Float32x __x, _Float32x __y) throw () __attribute__ ((__const__)); extern _Float32x __fminf32x (_Float32x __x, _Float32x __y) throw () __attribute__ ((__const__));


extern _Float32x fmaf32x (_Float32x __x, _Float32x __y, _Float32x __z) throw (); extern _Float32x __fmaf32x (_Float32x __x, _Float32x __y, _Float32x __z) throw ();




extern _Float32x roundevenf32x (_Float32x __x) throw () __attribute__ ((__const__)); extern _Float32x __roundevenf32x (_Float32x __x) throw () __attribute__ ((__const__));



extern __intmax_t fromfpf32x (_Float32x __x, int __round, unsigned int __width) throw (); extern __intmax_t __fromfpf32x (_Float32x __x, int __round, unsigned int __width) throw ()
                            ;



extern __uintmax_t ufromfpf32x (_Float32x __x, int __round, unsigned int __width) throw (); extern __uintmax_t __ufromfpf32x (_Float32x __x, int __round, unsigned int __width) throw ()
                              ;




extern __intmax_t fromfpxf32x (_Float32x __x, int __round, unsigned int __width) throw (); extern __intmax_t __fromfpxf32x (_Float32x __x, int __round, unsigned int __width) throw ()
                             ;




extern __uintmax_t ufromfpxf32x (_Float32x __x, int __round, unsigned int __width) throw (); extern __uintmax_t __ufromfpxf32x (_Float32x __x, int __round, unsigned int __width) throw ()
                               ;


extern _Float32x fmaxmagf32x (_Float32x __x, _Float32x __y) throw () __attribute__ ((__const__)); extern _Float32x __fmaxmagf32x (_Float32x __x, _Float32x __y) throw () __attribute__ ((__const__));


extern _Float32x fminmagf32x (_Float32x __x, _Float32x __y) throw () __attribute__ ((__const__)); extern _Float32x __fminmagf32x (_Float32x __x, _Float32x __y) throw () __attribute__ ((__const__));


extern int canonicalizef32x (_Float32x *__cx, const _Float32x *__x) throw ();




extern int totalorderf32x (const _Float32x *__x, const _Float32x *__y) throw ()

     __attribute__ ((__pure__));


extern int totalordermagf32x (const _Float32x *__x, const _Float32x *__y) throw ()

     __attribute__ ((__pure__));


extern _Float32x getpayloadf32x (const _Float32x *__x) throw (); extern _Float32x __getpayloadf32x (const _Float32x *__x) throw ();


extern int setpayloadf32x (_Float32x *__x, _Float32x __payload) throw ();


extern int setpayloadsigf32x (_Float32x *__x, _Float32x __payload) throw ();
# 488 "/usr/include/math.h" 2 3 4
# 504 "/usr/include/math.h" 3 4
# 1 "/usr/include/bits/mathcalls.h" 1 3 4
# 53 "/usr/include/bits/mathcalls.h" 3 4
extern _Float64x acosf64x (_Float64x __x) throw (); extern _Float64x __acosf64x (_Float64x __x) throw ();

extern _Float64x asinf64x (_Float64x __x) throw (); extern _Float64x __asinf64x (_Float64x __x) throw ();

extern _Float64x atanf64x (_Float64x __x) throw (); extern _Float64x __atanf64x (_Float64x __x) throw ();

extern _Float64x atan2f64x (_Float64x __y, _Float64x __x) throw (); extern _Float64x __atan2f64x (_Float64x __y, _Float64x __x) throw ();


 extern _Float64x cosf64x (_Float64x __x) throw (); extern _Float64x __cosf64x (_Float64x __x) throw ();

 extern _Float64x sinf64x (_Float64x __x) throw (); extern _Float64x __sinf64x (_Float64x __x) throw ();

extern _Float64x tanf64x (_Float64x __x) throw (); extern _Float64x __tanf64x (_Float64x __x) throw ();




extern _Float64x coshf64x (_Float64x __x) throw (); extern _Float64x __coshf64x (_Float64x __x) throw ();

extern _Float64x sinhf64x (_Float64x __x) throw (); extern _Float64x __sinhf64x (_Float64x __x) throw ();

extern _Float64x tanhf64x (_Float64x __x) throw (); extern _Float64x __tanhf64x (_Float64x __x) throw ();



 extern void sincosf64x (_Float64x __x, _Float64x *__sinx, _Float64x *__cosx) throw (); extern void __sincosf64x (_Float64x __x, _Float64x *__sinx, _Float64x *__cosx) throw ()
                                                        ;




extern _Float64x acoshf64x (_Float64x __x) throw (); extern _Float64x __acoshf64x (_Float64x __x) throw ();

extern _Float64x asinhf64x (_Float64x __x) throw (); extern _Float64x __asinhf64x (_Float64x __x) throw ();

extern _Float64x atanhf64x (_Float64x __x) throw (); extern _Float64x __atanhf64x (_Float64x __x) throw ();





 extern _Float64x expf64x (_Float64x __x) throw (); extern _Float64x __expf64x (_Float64x __x) throw ();


extern _Float64x frexpf64x (_Float64x __x, int *__exponent) throw (); extern _Float64x __frexpf64x (_Float64x __x, int *__exponent) throw ();


extern _Float64x ldexpf64x (_Float64x __x, int __exponent) throw (); extern _Float64x __ldexpf64x (_Float64x __x, int __exponent) throw ();


 extern _Float64x logf64x (_Float64x __x) throw (); extern _Float64x __logf64x (_Float64x __x) throw ();


extern _Float64x log10f64x (_Float64x __x) throw (); extern _Float64x __log10f64x (_Float64x __x) throw ();


extern _Float64x modff64x (_Float64x __x, _Float64x *__iptr) throw (); extern _Float64x __modff64x (_Float64x __x, _Float64x *__iptr) throw () __attribute__ ((__nonnull__ (2)));



extern _Float64x exp10f64x (_Float64x __x) throw (); extern _Float64x __exp10f64x (_Float64x __x) throw ();




extern _Float64x expm1f64x (_Float64x __x) throw (); extern _Float64x __expm1f64x (_Float64x __x) throw ();


extern _Float64x log1pf64x (_Float64x __x) throw (); extern _Float64x __log1pf64x (_Float64x __x) throw ();


extern _Float64x logbf64x (_Float64x __x) throw (); extern _Float64x __logbf64x (_Float64x __x) throw ();




extern _Float64x exp2f64x (_Float64x __x) throw (); extern _Float64x __exp2f64x (_Float64x __x) throw ();


extern _Float64x log2f64x (_Float64x __x) throw (); extern _Float64x __log2f64x (_Float64x __x) throw ();






 extern _Float64x powf64x (_Float64x __x, _Float64x __y) throw (); extern _Float64x __powf64x (_Float64x __x, _Float64x __y) throw ();


extern _Float64x sqrtf64x (_Float64x __x) throw (); extern _Float64x __sqrtf64x (_Float64x __x) throw ();



extern _Float64x hypotf64x (_Float64x __x, _Float64x __y) throw (); extern _Float64x __hypotf64x (_Float64x __x, _Float64x __y) throw ();




extern _Float64x cbrtf64x (_Float64x __x) throw (); extern _Float64x __cbrtf64x (_Float64x __x) throw ();






extern _Float64x ceilf64x (_Float64x __x) throw () __attribute__ ((__const__)); extern _Float64x __ceilf64x (_Float64x __x) throw () __attribute__ ((__const__));


extern _Float64x fabsf64x (_Float64x __x) throw () __attribute__ ((__const__)); extern _Float64x __fabsf64x (_Float64x __x) throw () __attribute__ ((__const__));


extern _Float64x floorf64x (_Float64x __x) throw () __attribute__ ((__const__)); extern _Float64x __floorf64x (_Float64x __x) throw () __attribute__ ((__const__));


extern _Float64x fmodf64x (_Float64x __x, _Float64x __y) throw (); extern _Float64x __fmodf64x (_Float64x __x, _Float64x __y) throw ();
# 198 "/usr/include/bits/mathcalls.h" 3 4
extern _Float64x copysignf64x (_Float64x __x, _Float64x __y) throw () __attribute__ ((__const__)); extern _Float64x __copysignf64x (_Float64x __x, _Float64x __y) throw () __attribute__ ((__const__));




extern _Float64x nanf64x (const char *__tagb) throw (); extern _Float64x __nanf64x (const char *__tagb) throw ();
# 220 "/usr/include/bits/mathcalls.h" 3 4
extern _Float64x j0f64x (_Float64x) throw (); extern _Float64x __j0f64x (_Float64x) throw ();
extern _Float64x j1f64x (_Float64x) throw (); extern _Float64x __j1f64x (_Float64x) throw ();
extern _Float64x jnf64x (int, _Float64x) throw (); extern _Float64x __jnf64x (int, _Float64x) throw ();
extern _Float64x y0f64x (_Float64x) throw (); extern _Float64x __y0f64x (_Float64x) throw ();
extern _Float64x y1f64x (_Float64x) throw (); extern _Float64x __y1f64x (_Float64x) throw ();
extern _Float64x ynf64x (int, _Float64x) throw (); extern _Float64x __ynf64x (int, _Float64x) throw ();





extern _Float64x erff64x (_Float64x) throw (); extern _Float64x __erff64x (_Float64x) throw ();
extern _Float64x erfcf64x (_Float64x) throw (); extern _Float64x __erfcf64x (_Float64x) throw ();
extern _Float64x lgammaf64x (_Float64x) throw (); extern _Float64x __lgammaf64x (_Float64x) throw ();




extern _Float64x tgammaf64x (_Float64x) throw (); extern _Float64x __tgammaf64x (_Float64x) throw ();
# 252 "/usr/include/bits/mathcalls.h" 3 4
extern _Float64x lgammaf64x_r (_Float64x, int *__signgamp) throw (); extern _Float64x __lgammaf64x_r (_Float64x, int *__signgamp) throw ();






extern _Float64x rintf64x (_Float64x __x) throw (); extern _Float64x __rintf64x (_Float64x __x) throw ();


extern _Float64x nextafterf64x (_Float64x __x, _Float64x __y) throw (); extern _Float64x __nextafterf64x (_Float64x __x, _Float64x __y) throw ();






extern _Float64x nextdownf64x (_Float64x __x) throw (); extern _Float64x __nextdownf64x (_Float64x __x) throw ();

extern _Float64x nextupf64x (_Float64x __x) throw (); extern _Float64x __nextupf64x (_Float64x __x) throw ();



extern _Float64x remainderf64x (_Float64x __x, _Float64x __y) throw (); extern _Float64x __remainderf64x (_Float64x __x, _Float64x __y) throw ();



extern _Float64x scalbnf64x (_Float64x __x, int __n) throw (); extern _Float64x __scalbnf64x (_Float64x __x, int __n) throw ();



extern int ilogbf64x (_Float64x __x) throw (); extern int __ilogbf64x (_Float64x __x) throw ();




extern long int llogbf64x (_Float64x __x) throw (); extern long int __llogbf64x (_Float64x __x) throw ();




extern _Float64x scalblnf64x (_Float64x __x, long int __n) throw (); extern _Float64x __scalblnf64x (_Float64x __x, long int __n) throw ();



extern _Float64x nearbyintf64x (_Float64x __x) throw (); extern _Float64x __nearbyintf64x (_Float64x __x) throw ();



extern _Float64x roundf64x (_Float64x __x) throw () __attribute__ ((__const__)); extern _Float64x __roundf64x (_Float64x __x) throw () __attribute__ ((__const__));



extern _Float64x truncf64x (_Float64x __x) throw () __attribute__ ((__const__)); extern _Float64x __truncf64x (_Float64x __x) throw () __attribute__ ((__const__));




extern _Float64x remquof64x (_Float64x __x, _Float64x __y, int *__quo) throw (); extern _Float64x __remquof64x (_Float64x __x, _Float64x __y, int *__quo) throw ();






extern long int lrintf64x (_Float64x __x) throw (); extern long int __lrintf64x (_Float64x __x) throw ();
__extension__
extern long long int llrintf64x (_Float64x __x) throw (); extern long long int __llrintf64x (_Float64x __x) throw ();



extern long int lroundf64x (_Float64x __x) throw (); extern long int __lroundf64x (_Float64x __x) throw ();
__extension__
extern long long int llroundf64x (_Float64x __x) throw (); extern long long int __llroundf64x (_Float64x __x) throw ();



extern _Float64x fdimf64x (_Float64x __x, _Float64x __y) throw (); extern _Float64x __fdimf64x (_Float64x __x, _Float64x __y) throw ();


extern _Float64x fmaxf64x (_Float64x __x, _Float64x __y) throw () __attribute__ ((__const__)); extern _Float64x __fmaxf64x (_Float64x __x, _Float64x __y) throw () __attribute__ ((__const__));


extern _Float64x fminf64x (_Float64x __x, _Float64x __y) throw () __attribute__ ((__const__)); extern _Float64x __fminf64x (_Float64x __x, _Float64x __y) throw () __attribute__ ((__const__));


extern _Float64x fmaf64x (_Float64x __x, _Float64x __y, _Float64x __z) throw (); extern _Float64x __fmaf64x (_Float64x __x, _Float64x __y, _Float64x __z) throw ();




extern _Float64x roundevenf64x (_Float64x __x) throw () __attribute__ ((__const__)); extern _Float64x __roundevenf64x (_Float64x __x) throw () __attribute__ ((__const__));



extern __intmax_t fromfpf64x (_Float64x __x, int __round, unsigned int __width) throw (); extern __intmax_t __fromfpf64x (_Float64x __x, int __round, unsigned int __width) throw ()
                            ;



extern __uintmax_t ufromfpf64x (_Float64x __x, int __round, unsigned int __width) throw (); extern __uintmax_t __ufromfpf64x (_Float64x __x, int __round, unsigned int __width) throw ()
                              ;




extern __intmax_t fromfpxf64x (_Float64x __x, int __round, unsigned int __width) throw (); extern __intmax_t __fromfpxf64x (_Float64x __x, int __round, unsigned int __width) throw ()
                             ;




extern __uintmax_t ufromfpxf64x (_Float64x __x, int __round, unsigned int __width) throw (); extern __uintmax_t __ufromfpxf64x (_Float64x __x, int __round, unsigned int __width) throw ()
                               ;


extern _Float64x fmaxmagf64x (_Float64x __x, _Float64x __y) throw () __attribute__ ((__const__)); extern _Float64x __fmaxmagf64x (_Float64x __x, _Float64x __y) throw () __attribute__ ((__const__));


extern _Float64x fminmagf64x (_Float64x __x, _Float64x __y) throw () __attribute__ ((__const__)); extern _Float64x __fminmagf64x (_Float64x __x, _Float64x __y) throw () __attribute__ ((__const__));


extern int canonicalizef64x (_Float64x *__cx, const _Float64x *__x) throw ();




extern int totalorderf64x (const _Float64x *__x, const _Float64x *__y) throw ()

     __attribute__ ((__pure__));


extern int totalordermagf64x (const _Float64x *__x, const _Float64x *__y) throw ()

     __attribute__ ((__pure__));


extern _Float64x getpayloadf64x (const _Float64x *__x) throw (); extern _Float64x __getpayloadf64x (const _Float64x *__x) throw ();


extern int setpayloadf64x (_Float64x *__x, _Float64x __payload) throw ();


extern int setpayloadsigf64x (_Float64x *__x, _Float64x __payload) throw ();
# 505 "/usr/include/math.h" 2 3 4
# 552 "/usr/include/math.h" 3 4
# 1 "/usr/include/bits/mathcalls-narrow.h" 1 3 4
# 24 "/usr/include/bits/mathcalls-narrow.h" 3 4
extern float fadd (double __x, double __y) throw ();


extern float fdiv (double __x, double __y) throw ();


extern float fmul (double __x, double __y) throw ();


extern float fsub (double __x, double __y) throw ();
# 553 "/usr/include/math.h" 2 3 4
# 571 "/usr/include/math.h" 3 4
# 1 "/usr/include/bits/mathcalls-narrow.h" 1 3 4
# 24 "/usr/include/bits/mathcalls-narrow.h" 3 4
extern float faddl (long double __x, long double __y) throw ();


extern float fdivl (long double __x, long double __y) throw ();


extern float fmull (long double __x, long double __y) throw ();


extern float fsubl (long double __x, long double __y) throw ();
# 572 "/usr/include/math.h" 2 3 4
# 597 "/usr/include/math.h" 3 4
# 1 "/usr/include/bits/mathcalls-narrow.h" 1 3 4
# 24 "/usr/include/bits/mathcalls-narrow.h" 3 4
extern double daddl (long double __x, long double __y) throw ();


extern double ddivl (long double __x, long double __y) throw ();


extern double dmull (long double __x, long double __y) throw ();


extern double dsubl (long double __x, long double __y) throw ();
# 598 "/usr/include/math.h" 2 3 4
# 677 "/usr/include/math.h" 3 4
# 1 "/usr/include/bits/mathcalls-narrow.h" 1 3 4
# 24 "/usr/include/bits/mathcalls-narrow.h" 3 4
extern _Float32 f32addf32x (_Float32x __x, _Float32x __y) throw ();


extern _Float32 f32divf32x (_Float32x __x, _Float32x __y) throw ();


extern _Float32 f32mulf32x (_Float32x __x, _Float32x __y) throw ();


extern _Float32 f32subf32x (_Float32x __x, _Float32x __y) throw ();
# 678 "/usr/include/math.h" 2 3 4
# 687 "/usr/include/math.h" 3 4
# 1 "/usr/include/bits/mathcalls-narrow.h" 1 3 4
# 24 "/usr/include/bits/mathcalls-narrow.h" 3 4
extern _Float32 f32addf64 (_Float64 __x, _Float64 __y) throw ();


extern _Float32 f32divf64 (_Float64 __x, _Float64 __y) throw ();


extern _Float32 f32mulf64 (_Float64 __x, _Float64 __y) throw ();


extern _Float32 f32subf64 (_Float64 __x, _Float64 __y) throw ();
# 688 "/usr/include/math.h" 2 3 4
# 697 "/usr/include/math.h" 3 4
# 1 "/usr/include/bits/mathcalls-narrow.h" 1 3 4
# 24 "/usr/include/bits/mathcalls-narrow.h" 3 4
extern _Float32 f32addf64x (_Float64x __x, _Float64x __y) throw ();


extern _Float32 f32divf64x (_Float64x __x, _Float64x __y) throw ();


extern _Float32 f32mulf64x (_Float64x __x, _Float64x __y) throw ();


extern _Float32 f32subf64x (_Float64x __x, _Float64x __y) throw ();
# 698 "/usr/include/math.h" 2 3 4
# 707 "/usr/include/math.h" 3 4
# 1 "/usr/include/bits/mathcalls-narrow.h" 1 3 4
# 24 "/usr/include/bits/mathcalls-narrow.h" 3 4
extern _Float32 f32addf128 (_Float128 __x, _Float128 __y) throw ();


extern _Float32 f32divf128 (_Float128 __x, _Float128 __y) throw ();


extern _Float32 f32mulf128 (_Float128 __x, _Float128 __y) throw ();


extern _Float32 f32subf128 (_Float128 __x, _Float128 __y) throw ();
# 708 "/usr/include/math.h" 2 3 4
# 727 "/usr/include/math.h" 3 4
# 1 "/usr/include/bits/mathcalls-narrow.h" 1 3 4
# 24 "/usr/include/bits/mathcalls-narrow.h" 3 4
extern _Float32x f32xaddf64 (_Float64 __x, _Float64 __y) throw ();


extern _Float32x f32xdivf64 (_Float64 __x, _Float64 __y) throw ();


extern _Float32x f32xmulf64 (_Float64 __x, _Float64 __y) throw ();


extern _Float32x f32xsubf64 (_Float64 __x, _Float64 __y) throw ();
# 728 "/usr/include/math.h" 2 3 4
# 737 "/usr/include/math.h" 3 4
# 1 "/usr/include/bits/mathcalls-narrow.h" 1 3 4
# 24 "/usr/include/bits/mathcalls-narrow.h" 3 4
extern _Float32x f32xaddf64x (_Float64x __x, _Float64x __y) throw ();


extern _Float32x f32xdivf64x (_Float64x __x, _Float64x __y) throw ();


extern _Float32x f32xmulf64x (_Float64x __x, _Float64x __y) throw ();


extern _Float32x f32xsubf64x (_Float64x __x, _Float64x __y) throw ();
# 738 "/usr/include/math.h" 2 3 4
# 747 "/usr/include/math.h" 3 4
# 1 "/usr/include/bits/mathcalls-narrow.h" 1 3 4
# 24 "/usr/include/bits/mathcalls-narrow.h" 3 4
extern _Float32x f32xaddf128 (_Float128 __x, _Float128 __y) throw ();


extern _Float32x f32xdivf128 (_Float128 __x, _Float128 __y) throw ();


extern _Float32x f32xmulf128 (_Float128 __x, _Float128 __y) throw ();


extern _Float32x f32xsubf128 (_Float128 __x, _Float128 __y) throw ();
# 748 "/usr/include/math.h" 2 3 4
# 767 "/usr/include/math.h" 3 4
# 1 "/usr/include/bits/mathcalls-narrow.h" 1 3 4
# 24 "/usr/include/bits/mathcalls-narrow.h" 3 4
extern _Float64 f64addf64x (_Float64x __x, _Float64x __y) throw ();


extern _Float64 f64divf64x (_Float64x __x, _Float64x __y) throw ();


extern _Float64 f64mulf64x (_Float64x __x, _Float64x __y) throw ();


extern _Float64 f64subf64x (_Float64x __x, _Float64x __y) throw ();
# 768 "/usr/include/math.h" 2 3 4
# 777 "/usr/include/math.h" 3 4
# 1 "/usr/include/bits/mathcalls-narrow.h" 1 3 4
# 24 "/usr/include/bits/mathcalls-narrow.h" 3 4
extern _Float64 f64addf128 (_Float128 __x, _Float128 __y) throw ();


extern _Float64 f64divf128 (_Float128 __x, _Float128 __y) throw ();


extern _Float64 f64mulf128 (_Float128 __x, _Float128 __y) throw ();


extern _Float64 f64subf128 (_Float128 __x, _Float128 __y) throw ();
# 778 "/usr/include/math.h" 2 3 4
# 797 "/usr/include/math.h" 3 4
# 1 "/usr/include/bits/mathcalls-narrow.h" 1 3 4
# 24 "/usr/include/bits/mathcalls-narrow.h" 3 4
extern _Float64x f64xaddf128 (_Float128 __x, _Float128 __y) throw ();


extern _Float64x f64xdivf128 (_Float128 __x, _Float128 __y) throw ();


extern _Float64x f64xmulf128 (_Float128 __x, _Float128 __y) throw ();


extern _Float64x f64xsubf128 (_Float128 __x, _Float128 __y) throw ();
# 798 "/usr/include/math.h" 2 3 4
# 834 "/usr/include/math.h" 3 4
extern int signgam;
# 914 "/usr/include/math.h" 3 4
enum
  {
    FP_NAN =

      0,
    FP_INFINITE =

      1,
    FP_ZERO =

      2,
    FP_SUBNORMAL =

      3,
    FP_NORMAL =

      4
  };
# 1034 "/usr/include/math.h" 3 4
# 1 "/usr/include/bits/iscanonical.h" 1 3 4
# 23 "/usr/include/bits/iscanonical.h" 3 4
extern int __iscanonicall (long double __x)
     throw () __attribute__ ((__const__));
# 46 "/usr/include/bits/iscanonical.h" 3 4
extern "C++" {
inline int iscanonical (float __val) { return ((void) (__typeof (__val)) (__val), 1); }
inline int iscanonical (double __val) { return ((void) (__typeof (__val)) (__val), 1); }
inline int iscanonical (long double __val) { return __iscanonicall (__val); }

inline int iscanonical (_Float128 __val) { return ((void) (__typeof (__val)) (__val), 1); }

}
# 1035 "/usr/include/math.h" 2 3 4
# 1046 "/usr/include/math.h" 3 4
extern "C++" {
inline int issignaling (float __val) { return __issignalingf (__val); }
inline int issignaling (double __val) { return __issignaling (__val); }
inline int
issignaling (long double __val)
{



  return __issignalingl (__val);

}



inline int issignaling (_Float128 __val) { return __issignalingf128 (__val); }

}
# 1077 "/usr/include/math.h" 3 4
extern "C++" {
# 1108 "/usr/include/math.h" 3 4
template <class __T> inline bool
iszero (__T __val)
{
  return __val == 0;
}

}
# 1326 "/usr/include/math.h" 3 4
extern "C++" {
template<typename> struct __iseqsig_type;

template<> struct __iseqsig_type<float>
{
  static int __call (float __x, float __y) throw ()
  {
    return __iseqsigf (__x, __y);
  }
};

template<> struct __iseqsig_type<double>
{
  static int __call (double __x, double __y) throw ()
  {
    return __iseqsig (__x, __y);
  }
};

template<> struct __iseqsig_type<long double>
{
  static int __call (long double __x, long double __y) throw ()
  {

    return __iseqsigl (__x, __y);



  }
};




template<> struct __iseqsig_type<_Float128>
{
  static int __call (_Float128 __x, _Float128 __y) throw ()
  {
    return __iseqsigf128 (__x, __y);
  }
};


template<typename _T1, typename _T2>
inline int
iseqsig (_T1 __x, _T2 __y) throw ()
{

  typedef decltype (((__x) + (__y) + 0.0f)) _T3;



  return __iseqsig_type<_T3>::__call (__x, __y);
}

}




}
# 46 "/usr/include/c++/10.2.0/cmath" 2 3
# 77 "/usr/include/c++/10.2.0/cmath" 3
extern "C++"
{
namespace std __attribute__ ((__visibility__ ("default")))
{


  using ::acos;


  inline constexpr float
  acos(float __x)
  { return __builtin_acosf(__x); }

  inline constexpr long double
  acos(long double __x)
  { return __builtin_acosl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    acos(_Tp __x)
    { return __builtin_acos(__x); }

  using ::asin;


  inline constexpr float
  asin(float __x)
  { return __builtin_asinf(__x); }

  inline constexpr long double
  asin(long double __x)
  { return __builtin_asinl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    asin(_Tp __x)
    { return __builtin_asin(__x); }

  using ::atan;


  inline constexpr float
  atan(float __x)
  { return __builtin_atanf(__x); }

  inline constexpr long double
  atan(long double __x)
  { return __builtin_atanl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    atan(_Tp __x)
    { return __builtin_atan(__x); }

  using ::atan2;


  inline constexpr float
  atan2(float __y, float __x)
  { return __builtin_atan2f(__y, __x); }

  inline constexpr long double
  atan2(long double __y, long double __x)
  { return __builtin_atan2l(__y, __x); }


  template<typename _Tp, typename _Up>
    inline constexpr
    typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    atan2(_Tp __y, _Up __x)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return atan2(__type(__y), __type(__x));
    }

  using ::ceil;


  inline constexpr float
  ceil(float __x)
  { return __builtin_ceilf(__x); }

  inline constexpr long double
  ceil(long double __x)
  { return __builtin_ceill(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    ceil(_Tp __x)
    { return __builtin_ceil(__x); }

  using ::cos;


  inline constexpr float
  cos(float __x)
  { return __builtin_cosf(__x); }

  inline constexpr long double
  cos(long double __x)
  { return __builtin_cosl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    cos(_Tp __x)
    { return __builtin_cos(__x); }

  using ::cosh;


  inline constexpr float
  cosh(float __x)
  { return __builtin_coshf(__x); }

  inline constexpr long double
  cosh(long double __x)
  { return __builtin_coshl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    cosh(_Tp __x)
    { return __builtin_cosh(__x); }

  using ::exp;


  inline constexpr float
  exp(float __x)
  { return __builtin_expf(__x); }

  inline constexpr long double
  exp(long double __x)
  { return __builtin_expl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    exp(_Tp __x)
    { return __builtin_exp(__x); }

  using ::fabs;


  inline constexpr float
  fabs(float __x)
  { return __builtin_fabsf(__x); }

  inline constexpr long double
  fabs(long double __x)
  { return __builtin_fabsl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    fabs(_Tp __x)
    { return __builtin_fabs(__x); }

  using ::floor;


  inline constexpr float
  floor(float __x)
  { return __builtin_floorf(__x); }

  inline constexpr long double
  floor(long double __x)
  { return __builtin_floorl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    floor(_Tp __x)
    { return __builtin_floor(__x); }

  using ::fmod;


  inline constexpr float
  fmod(float __x, float __y)
  { return __builtin_fmodf(__x, __y); }

  inline constexpr long double
  fmod(long double __x, long double __y)
  { return __builtin_fmodl(__x, __y); }


  template<typename _Tp, typename _Up>
    inline constexpr
    typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    fmod(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return fmod(__type(__x), __type(__y));
    }

  using ::frexp;


  inline float
  frexp(float __x, int* __exp)
  { return __builtin_frexpf(__x, __exp); }

  inline long double
  frexp(long double __x, int* __exp)
  { return __builtin_frexpl(__x, __exp); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    frexp(_Tp __x, int* __exp)
    { return __builtin_frexp(__x, __exp); }

  using ::ldexp;


  inline constexpr float
  ldexp(float __x, int __exp)
  { return __builtin_ldexpf(__x, __exp); }

  inline constexpr long double
  ldexp(long double __x, int __exp)
  { return __builtin_ldexpl(__x, __exp); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    ldexp(_Tp __x, int __exp)
    { return __builtin_ldexp(__x, __exp); }

  using ::log;


  inline constexpr float
  log(float __x)
  { return __builtin_logf(__x); }

  inline constexpr long double
  log(long double __x)
  { return __builtin_logl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    log(_Tp __x)
    { return __builtin_log(__x); }

  using ::log10;


  inline constexpr float
  log10(float __x)
  { return __builtin_log10f(__x); }

  inline constexpr long double
  log10(long double __x)
  { return __builtin_log10l(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    log10(_Tp __x)
    { return __builtin_log10(__x); }

  using ::modf;


  inline float
  modf(float __x, float* __iptr)
  { return __builtin_modff(__x, __iptr); }

  inline long double
  modf(long double __x, long double* __iptr)
  { return __builtin_modfl(__x, __iptr); }


  using ::pow;


  inline constexpr float
  pow(float __x, float __y)
  { return __builtin_powf(__x, __y); }

  inline constexpr long double
  pow(long double __x, long double __y)
  { return __builtin_powl(__x, __y); }
# 412 "/usr/include/c++/10.2.0/cmath" 3
  template<typename _Tp, typename _Up>
    inline constexpr
    typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    pow(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return pow(__type(__x), __type(__y));
    }

  using ::sin;


  inline constexpr float
  sin(float __x)
  { return __builtin_sinf(__x); }

  inline constexpr long double
  sin(long double __x)
  { return __builtin_sinl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    sin(_Tp __x)
    { return __builtin_sin(__x); }

  using ::sinh;


  inline constexpr float
  sinh(float __x)
  { return __builtin_sinhf(__x); }

  inline constexpr long double
  sinh(long double __x)
  { return __builtin_sinhl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    sinh(_Tp __x)
    { return __builtin_sinh(__x); }

  using ::sqrt;


  inline constexpr float
  sqrt(float __x)
  { return __builtin_sqrtf(__x); }

  inline constexpr long double
  sqrt(long double __x)
  { return __builtin_sqrtl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    sqrt(_Tp __x)
    { return __builtin_sqrt(__x); }

  using ::tan;


  inline constexpr float
  tan(float __x)
  { return __builtin_tanf(__x); }

  inline constexpr long double
  tan(long double __x)
  { return __builtin_tanl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    tan(_Tp __x)
    { return __builtin_tan(__x); }

  using ::tanh;


  inline constexpr float
  tanh(float __x)
  { return __builtin_tanhf(__x); }

  inline constexpr long double
  tanh(long double __x)
  { return __builtin_tanhl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    tanh(_Tp __x)
    { return __builtin_tanh(__x); }
# 536 "/usr/include/c++/10.2.0/cmath" 3
  constexpr int
  fpclassify(float __x)
  { return __builtin_fpclassify(0, 1, 4,
    3, 2, __x); }

  constexpr int
  fpclassify(double __x)
  { return __builtin_fpclassify(0, 1, 4,
    3, 2, __x); }

  constexpr int
  fpclassify(long double __x)
  { return __builtin_fpclassify(0, 1, 4,
    3, 2, __x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              int>::__type
    fpclassify(_Tp __x)
    { return __x != 0 ? 4 : 2; }



  constexpr bool
  isfinite(float __x)
  { return __builtin_isfinite(__x); }

  constexpr bool
  isfinite(double __x)
  { return __builtin_isfinite(__x); }

  constexpr bool
  isfinite(long double __x)
  { return __builtin_isfinite(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              bool>::__type
    isfinite(_Tp __x)
    { return true; }



  constexpr bool
  isinf(float __x)
  { return __builtin_isinf(__x); }





  constexpr bool
  isinf(double __x)
  { return __builtin_isinf(__x); }


  constexpr bool
  isinf(long double __x)
  { return __builtin_isinf(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              bool>::__type
    isinf(_Tp __x)
    { return false; }



  constexpr bool
  isnan(float __x)
  { return __builtin_isnan(__x); }





  constexpr bool
  isnan(double __x)
  { return __builtin_isnan(__x); }


  constexpr bool
  isnan(long double __x)
  { return __builtin_isnan(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              bool>::__type
    isnan(_Tp __x)
    { return false; }



  constexpr bool
  isnormal(float __x)
  { return __builtin_isnormal(__x); }

  constexpr bool
  isnormal(double __x)
  { return __builtin_isnormal(__x); }

  constexpr bool
  isnormal(long double __x)
  { return __builtin_isnormal(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              bool>::__type
    isnormal(_Tp __x)
    { return __x != 0 ? true : false; }




  constexpr bool
  signbit(float __x)
  { return __builtin_signbit(__x); }

  constexpr bool
  signbit(double __x)
  { return __builtin_signbit(__x); }

  constexpr bool
  signbit(long double __x)
  { return __builtin_signbit(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              bool>::__type
    signbit(_Tp __x)
    { return __x < 0 ? true : false; }



  constexpr bool
  isgreater(float __x, float __y)
  { return __builtin_isgreater(__x, __y); }

  constexpr bool
  isgreater(double __x, double __y)
  { return __builtin_isgreater(__x, __y); }

  constexpr bool
  isgreater(long double __x, long double __y)
  { return __builtin_isgreater(__x, __y); }



  template<typename _Tp, typename _Up>
    constexpr typename
    __gnu_cxx::__enable_if<(__is_arithmetic<_Tp>::__value
       && __is_arithmetic<_Up>::__value), bool>::__type
    isgreater(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return __builtin_isgreater(__type(__x), __type(__y));
    }



  constexpr bool
  isgreaterequal(float __x, float __y)
  { return __builtin_isgreaterequal(__x, __y); }

  constexpr bool
  isgreaterequal(double __x, double __y)
  { return __builtin_isgreaterequal(__x, __y); }

  constexpr bool
  isgreaterequal(long double __x, long double __y)
  { return __builtin_isgreaterequal(__x, __y); }



  template<typename _Tp, typename _Up>
    constexpr typename
    __gnu_cxx::__enable_if<(__is_arithmetic<_Tp>::__value
       && __is_arithmetic<_Up>::__value), bool>::__type
    isgreaterequal(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return __builtin_isgreaterequal(__type(__x), __type(__y));
    }



  constexpr bool
  isless(float __x, float __y)
  { return __builtin_isless(__x, __y); }

  constexpr bool
  isless(double __x, double __y)
  { return __builtin_isless(__x, __y); }

  constexpr bool
  isless(long double __x, long double __y)
  { return __builtin_isless(__x, __y); }



  template<typename _Tp, typename _Up>
    constexpr typename
    __gnu_cxx::__enable_if<(__is_arithmetic<_Tp>::__value
       && __is_arithmetic<_Up>::__value), bool>::__type
    isless(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return __builtin_isless(__type(__x), __type(__y));
    }



  constexpr bool
  islessequal(float __x, float __y)
  { return __builtin_islessequal(__x, __y); }

  constexpr bool
  islessequal(double __x, double __y)
  { return __builtin_islessequal(__x, __y); }

  constexpr bool
  islessequal(long double __x, long double __y)
  { return __builtin_islessequal(__x, __y); }



  template<typename _Tp, typename _Up>
    constexpr typename
    __gnu_cxx::__enable_if<(__is_arithmetic<_Tp>::__value
       && __is_arithmetic<_Up>::__value), bool>::__type
    islessequal(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return __builtin_islessequal(__type(__x), __type(__y));
    }



  constexpr bool
  islessgreater(float __x, float __y)
  { return __builtin_islessgreater(__x, __y); }

  constexpr bool
  islessgreater(double __x, double __y)
  { return __builtin_islessgreater(__x, __y); }

  constexpr bool
  islessgreater(long double __x, long double __y)
  { return __builtin_islessgreater(__x, __y); }



  template<typename _Tp, typename _Up>
    constexpr typename
    __gnu_cxx::__enable_if<(__is_arithmetic<_Tp>::__value
       && __is_arithmetic<_Up>::__value), bool>::__type
    islessgreater(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return __builtin_islessgreater(__type(__x), __type(__y));
    }



  constexpr bool
  isunordered(float __x, float __y)
  { return __builtin_isunordered(__x, __y); }

  constexpr bool
  isunordered(double __x, double __y)
  { return __builtin_isunordered(__x, __y); }

  constexpr bool
  isunordered(long double __x, long double __y)
  { return __builtin_isunordered(__x, __y); }



  template<typename _Tp, typename _Up>
    constexpr typename
    __gnu_cxx::__enable_if<(__is_arithmetic<_Tp>::__value
       && __is_arithmetic<_Up>::__value), bool>::__type
    isunordered(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return __builtin_isunordered(__type(__x), __type(__y));
    }
# 1065 "/usr/include/c++/10.2.0/cmath" 3
  using ::double_t;
  using ::float_t;


  using ::acosh;
  using ::acoshf;
  using ::acoshl;

  using ::asinh;
  using ::asinhf;
  using ::asinhl;

  using ::atanh;
  using ::atanhf;
  using ::atanhl;

  using ::cbrt;
  using ::cbrtf;
  using ::cbrtl;

  using ::copysign;
  using ::copysignf;
  using ::copysignl;

  using ::erf;
  using ::erff;
  using ::erfl;

  using ::erfc;
  using ::erfcf;
  using ::erfcl;

  using ::exp2;
  using ::exp2f;
  using ::exp2l;

  using ::expm1;
  using ::expm1f;
  using ::expm1l;

  using ::fdim;
  using ::fdimf;
  using ::fdiml;

  using ::fma;
  using ::fmaf;
  using ::fmal;

  using ::fmax;
  using ::fmaxf;
  using ::fmaxl;

  using ::fmin;
  using ::fminf;
  using ::fminl;

  using ::hypot;
  using ::hypotf;
  using ::hypotl;

  using ::ilogb;
  using ::ilogbf;
  using ::ilogbl;

  using ::lgamma;
  using ::lgammaf;
  using ::lgammal;


  using ::llrint;
  using ::llrintf;
  using ::llrintl;

  using ::llround;
  using ::llroundf;
  using ::llroundl;


  using ::log1p;
  using ::log1pf;
  using ::log1pl;

  using ::log2;
  using ::log2f;
  using ::log2l;

  using ::logb;
  using ::logbf;
  using ::logbl;

  using ::lrint;
  using ::lrintf;
  using ::lrintl;

  using ::lround;
  using ::lroundf;
  using ::lroundl;

  using ::nan;
  using ::nanf;
  using ::nanl;

  using ::nearbyint;
  using ::nearbyintf;
  using ::nearbyintl;

  using ::nextafter;
  using ::nextafterf;
  using ::nextafterl;

  using ::nexttoward;
  using ::nexttowardf;
  using ::nexttowardl;

  using ::remainder;
  using ::remainderf;
  using ::remainderl;

  using ::remquo;
  using ::remquof;
  using ::remquol;

  using ::rint;
  using ::rintf;
  using ::rintl;

  using ::round;
  using ::roundf;
  using ::roundl;

  using ::scalbln;
  using ::scalblnf;
  using ::scalblnl;

  using ::scalbn;
  using ::scalbnf;
  using ::scalbnl;

  using ::tgamma;
  using ::tgammaf;
  using ::tgammal;

  using ::trunc;
  using ::truncf;
  using ::truncl;



  constexpr float
  acosh(float __x)
  { return __builtin_acoshf(__x); }

  constexpr long double
  acosh(long double __x)
  { return __builtin_acoshl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    acosh(_Tp __x)
    { return __builtin_acosh(__x); }



  constexpr float
  asinh(float __x)
  { return __builtin_asinhf(__x); }

  constexpr long double
  asinh(long double __x)
  { return __builtin_asinhl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    asinh(_Tp __x)
    { return __builtin_asinh(__x); }



  constexpr float
  atanh(float __x)
  { return __builtin_atanhf(__x); }

  constexpr long double
  atanh(long double __x)
  { return __builtin_atanhl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    atanh(_Tp __x)
    { return __builtin_atanh(__x); }



  constexpr float
  cbrt(float __x)
  { return __builtin_cbrtf(__x); }

  constexpr long double
  cbrt(long double __x)
  { return __builtin_cbrtl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    cbrt(_Tp __x)
    { return __builtin_cbrt(__x); }



  constexpr float
  copysign(float __x, float __y)
  { return __builtin_copysignf(__x, __y); }

  constexpr long double
  copysign(long double __x, long double __y)
  { return __builtin_copysignl(__x, __y); }



  template<typename _Tp, typename _Up>
    constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    copysign(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return copysign(__type(__x), __type(__y));
    }



  constexpr float
  erf(float __x)
  { return __builtin_erff(__x); }

  constexpr long double
  erf(long double __x)
  { return __builtin_erfl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    erf(_Tp __x)
    { return __builtin_erf(__x); }



  constexpr float
  erfc(float __x)
  { return __builtin_erfcf(__x); }

  constexpr long double
  erfc(long double __x)
  { return __builtin_erfcl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    erfc(_Tp __x)
    { return __builtin_erfc(__x); }



  constexpr float
  exp2(float __x)
  { return __builtin_exp2f(__x); }

  constexpr long double
  exp2(long double __x)
  { return __builtin_exp2l(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    exp2(_Tp __x)
    { return __builtin_exp2(__x); }



  constexpr float
  expm1(float __x)
  { return __builtin_expm1f(__x); }

  constexpr long double
  expm1(long double __x)
  { return __builtin_expm1l(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    expm1(_Tp __x)
    { return __builtin_expm1(__x); }



  constexpr float
  fdim(float __x, float __y)
  { return __builtin_fdimf(__x, __y); }

  constexpr long double
  fdim(long double __x, long double __y)
  { return __builtin_fdiml(__x, __y); }



  template<typename _Tp, typename _Up>
    constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    fdim(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return fdim(__type(__x), __type(__y));
    }



  constexpr float
  fma(float __x, float __y, float __z)
  { return __builtin_fmaf(__x, __y, __z); }

  constexpr long double
  fma(long double __x, long double __y, long double __z)
  { return __builtin_fmal(__x, __y, __z); }



  template<typename _Tp, typename _Up, typename _Vp>
    constexpr typename __gnu_cxx::__promote_3<_Tp, _Up, _Vp>::__type
    fma(_Tp __x, _Up __y, _Vp __z)
    {
      typedef typename __gnu_cxx::__promote_3<_Tp, _Up, _Vp>::__type __type;
      return fma(__type(__x), __type(__y), __type(__z));
    }



  constexpr float
  fmax(float __x, float __y)
  { return __builtin_fmaxf(__x, __y); }

  constexpr long double
  fmax(long double __x, long double __y)
  { return __builtin_fmaxl(__x, __y); }



  template<typename _Tp, typename _Up>
    constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    fmax(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return fmax(__type(__x), __type(__y));
    }



  constexpr float
  fmin(float __x, float __y)
  { return __builtin_fminf(__x, __y); }

  constexpr long double
  fmin(long double __x, long double __y)
  { return __builtin_fminl(__x, __y); }



  template<typename _Tp, typename _Up>
    constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    fmin(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return fmin(__type(__x), __type(__y));
    }



  constexpr float
  hypot(float __x, float __y)
  { return __builtin_hypotf(__x, __y); }

  constexpr long double
  hypot(long double __x, long double __y)
  { return __builtin_hypotl(__x, __y); }



  template<typename _Tp, typename _Up>
    constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    hypot(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return hypot(__type(__x), __type(__y));
    }



  constexpr int
  ilogb(float __x)
  { return __builtin_ilogbf(__x); }

  constexpr int
  ilogb(long double __x)
  { return __builtin_ilogbl(__x); }



  template<typename _Tp>
    constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    int>::__type
    ilogb(_Tp __x)
    { return __builtin_ilogb(__x); }



  constexpr float
  lgamma(float __x)
  { return __builtin_lgammaf(__x); }

  constexpr long double
  lgamma(long double __x)
  { return __builtin_lgammal(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    lgamma(_Tp __x)
    { return __builtin_lgamma(__x); }



  constexpr long long
  llrint(float __x)
  { return __builtin_llrintf(__x); }

  constexpr long long
  llrint(long double __x)
  { return __builtin_llrintl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              long long>::__type
    llrint(_Tp __x)
    { return __builtin_llrint(__x); }



  constexpr long long
  llround(float __x)
  { return __builtin_llroundf(__x); }

  constexpr long long
  llround(long double __x)
  { return __builtin_llroundl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              long long>::__type
    llround(_Tp __x)
    { return __builtin_llround(__x); }



  constexpr float
  log1p(float __x)
  { return __builtin_log1pf(__x); }

  constexpr long double
  log1p(long double __x)
  { return __builtin_log1pl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    log1p(_Tp __x)
    { return __builtin_log1p(__x); }




  constexpr float
  log2(float __x)
  { return __builtin_log2f(__x); }

  constexpr long double
  log2(long double __x)
  { return __builtin_log2l(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    log2(_Tp __x)
    { return __builtin_log2(__x); }



  constexpr float
  logb(float __x)
  { return __builtin_logbf(__x); }

  constexpr long double
  logb(long double __x)
  { return __builtin_logbl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    logb(_Tp __x)
    { return __builtin_logb(__x); }



  constexpr long
  lrint(float __x)
  { return __builtin_lrintf(__x); }

  constexpr long
  lrint(long double __x)
  { return __builtin_lrintl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              long>::__type
    lrint(_Tp __x)
    { return __builtin_lrint(__x); }



  constexpr long
  lround(float __x)
  { return __builtin_lroundf(__x); }

  constexpr long
  lround(long double __x)
  { return __builtin_lroundl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              long>::__type
    lround(_Tp __x)
    { return __builtin_lround(__x); }



  constexpr float
  nearbyint(float __x)
  { return __builtin_nearbyintf(__x); }

  constexpr long double
  nearbyint(long double __x)
  { return __builtin_nearbyintl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    nearbyint(_Tp __x)
    { return __builtin_nearbyint(__x); }



  constexpr float
  nextafter(float __x, float __y)
  { return __builtin_nextafterf(__x, __y); }

  constexpr long double
  nextafter(long double __x, long double __y)
  { return __builtin_nextafterl(__x, __y); }



  template<typename _Tp, typename _Up>
    constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    nextafter(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return nextafter(__type(__x), __type(__y));
    }



  constexpr float
  nexttoward(float __x, long double __y)
  { return __builtin_nexttowardf(__x, __y); }

  constexpr long double
  nexttoward(long double __x, long double __y)
  { return __builtin_nexttowardl(__x, __y); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    nexttoward(_Tp __x, long double __y)
    { return __builtin_nexttoward(__x, __y); }



  constexpr float
  remainder(float __x, float __y)
  { return __builtin_remainderf(__x, __y); }

  constexpr long double
  remainder(long double __x, long double __y)
  { return __builtin_remainderl(__x, __y); }



  template<typename _Tp, typename _Up>
    constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    remainder(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return remainder(__type(__x), __type(__y));
    }



  inline float
  remquo(float __x, float __y, int* __pquo)
  { return __builtin_remquof(__x, __y, __pquo); }

  inline long double
  remquo(long double __x, long double __y, int* __pquo)
  { return __builtin_remquol(__x, __y, __pquo); }



  template<typename _Tp, typename _Up>
    inline typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    remquo(_Tp __x, _Up __y, int* __pquo)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return remquo(__type(__x), __type(__y), __pquo);
    }



  constexpr float
  rint(float __x)
  { return __builtin_rintf(__x); }

  constexpr long double
  rint(long double __x)
  { return __builtin_rintl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    rint(_Tp __x)
    { return __builtin_rint(__x); }



  constexpr float
  round(float __x)
  { return __builtin_roundf(__x); }

  constexpr long double
  round(long double __x)
  { return __builtin_roundl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    round(_Tp __x)
    { return __builtin_round(__x); }



  constexpr float
  scalbln(float __x, long __ex)
  { return __builtin_scalblnf(__x, __ex); }

  constexpr long double
  scalbln(long double __x, long __ex)
  { return __builtin_scalblnl(__x, __ex); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    scalbln(_Tp __x, long __ex)
    { return __builtin_scalbln(__x, __ex); }



  constexpr float
  scalbn(float __x, int __ex)
  { return __builtin_scalbnf(__x, __ex); }

  constexpr long double
  scalbn(long double __x, int __ex)
  { return __builtin_scalbnl(__x, __ex); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    scalbn(_Tp __x, int __ex)
    { return __builtin_scalbn(__x, __ex); }



  constexpr float
  tgamma(float __x)
  { return __builtin_tgammaf(__x); }

  constexpr long double
  tgamma(long double __x)
  { return __builtin_tgammal(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    tgamma(_Tp __x)
    { return __builtin_tgamma(__x); }



  constexpr float
  trunc(float __x)
  { return __builtin_truncf(__x); }

  constexpr long double
  trunc(long double __x)
  { return __builtin_truncl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    trunc(_Tp __x)
    { return __builtin_trunc(__x); }
# 1923 "/usr/include/c++/10.2.0/cmath" 3

}





}
# 37 "/usr/include/c++/10.2.0/math.h" 2 3

using std::abs;
using std::acos;
using std::asin;
using std::atan;
using std::atan2;
using std::cos;
using std::sin;
using std::tan;
using std::cosh;
using std::sinh;
using std::tanh;
using std::exp;
using std::frexp;
using std::ldexp;
using std::log;
using std::log10;
using std::modf;
using std::pow;
using std::sqrt;
using std::ceil;
using std::fabs;
using std::floor;
using std::fmod;


using std::fpclassify;
using std::isfinite;
using std::isinf;
using std::isnan;
using std::isnormal;
using std::signbit;
using std::isgreater;
using std::isgreaterequal;
using std::isless;
using std::islessequal;
using std::islessgreater;
using std::isunordered;



using std::acosh;
using std::asinh;
using std::atanh;
using std::cbrt;
using std::copysign;
using std::erf;
using std::erfc;
using std::exp2;
using std::expm1;
using std::fdim;
using std::fma;
using std::fmax;
using std::fmin;
using std::hypot;
using std::ilogb;
using std::lgamma;
using std::llrint;
using std::llround;
using std::log1p;
using std::log2;
using std::logb;
using std::lrint;
using std::lround;
using std::nearbyint;
using std::nextafter;
using std::nexttoward;
using std::remainder;
using std::remquo;
using std::rint;
using std::round;
using std::scalbln;
using std::scalbn;
using std::tgamma;
using std::trunc;
# 4 "4coder_sam.cpp" 2
# 1 "/usr/include/string.h" 1 3 4
# 26 "/usr/include/string.h" 3 4
# 1 "/usr/include/bits/libc-header-start.h" 1 3 4
# 27 "/usr/include/string.h" 2 3 4

extern "C" {




# 1 "/usr/lib/gcc/x86_64-pc-linux-gnu/10.2.0/include/stddef.h" 1 3 4
# 34 "/usr/include/string.h" 2 3 4
# 43 "/usr/include/string.h" 3 4
extern void *memcpy (void *__restrict __dest, const void *__restrict __src,
       size_t __n) throw () __attribute__ ((__nonnull__ (1, 2)));


extern void *memmove (void *__dest, const void *__src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));





extern void *memccpy (void *__restrict __dest, const void *__restrict __src,
        int __c, size_t __n)
    throw () __attribute__ ((__nonnull__ (1, 2))) __attribute__ ((__access__ (__write_only__, 1, 4)));




extern void *memset (void *__s, int __c, size_t __n) throw () __attribute__ ((__nonnull__ (1)));


extern int memcmp (const void *__s1, const void *__s2, size_t __n)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));



extern "C++"
{
extern void *memchr (void *__s, int __c, size_t __n)
      throw () __asm ("memchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern const void *memchr (const void *__s, int __c, size_t __n)
      throw () __asm ("memchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 89 "/usr/include/string.h" 3 4
}
# 99 "/usr/include/string.h" 3 4
extern "C++" void *rawmemchr (void *__s, int __c)
     throw () __asm ("rawmemchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern "C++" const void *rawmemchr (const void *__s, int __c)
     throw () __asm ("rawmemchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));







extern "C++" void *memrchr (void *__s, int __c, size_t __n)
      throw () __asm ("memrchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)))
      __attribute__ ((__access__ (__read_only__, 1, 3)));
extern "C++" const void *memrchr (const void *__s, int __c, size_t __n)
      throw () __asm ("memrchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)))
      __attribute__ ((__access__ (__read_only__, 1, 3)));
# 125 "/usr/include/string.h" 3 4
extern char *strcpy (char *__restrict __dest, const char *__restrict __src)
     throw () __attribute__ ((__nonnull__ (1, 2)));

extern char *strncpy (char *__restrict __dest,
        const char *__restrict __src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern char *strcat (char *__restrict __dest, const char *__restrict __src)
     throw () __attribute__ ((__nonnull__ (1, 2)));

extern char *strncat (char *__restrict __dest, const char *__restrict __src,
        size_t __n) throw () __attribute__ ((__nonnull__ (1, 2)));


extern int strcmp (const char *__s1, const char *__s2)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));

extern int strncmp (const char *__s1, const char *__s2, size_t __n)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern int strcoll (const char *__s1, const char *__s2)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));

extern size_t strxfrm (char *__restrict __dest,
         const char *__restrict __src, size_t __n)
    throw () __attribute__ ((__nonnull__ (2))) __attribute__ ((__access__ (__write_only__, 1, 3)));






extern int strcoll_l (const char *__s1, const char *__s2, locale_t __l)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 3)));


extern size_t strxfrm_l (char *__dest, const char *__src, size_t __n,
    locale_t __l) throw () __attribute__ ((__nonnull__ (2, 4)))
     __attribute__ ((__access__ (__write_only__, 1, 3)));





extern char *strdup (const char *__s)
     throw () __attribute__ ((__malloc__)) __attribute__ ((__nonnull__ (1)));






extern char *strndup (const char *__string, size_t __n)
     throw () __attribute__ ((__malloc__)) __attribute__ ((__nonnull__ (1)));
# 208 "/usr/include/string.h" 3 4
extern "C++"
{
extern char *strchr (char *__s, int __c)
     throw () __asm ("strchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern const char *strchr (const char *__s, int __c)
     throw () __asm ("strchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 228 "/usr/include/string.h" 3 4
}






extern "C++"
{
extern char *strrchr (char *__s, int __c)
     throw () __asm ("strrchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern const char *strrchr (const char *__s, int __c)
     throw () __asm ("strrchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 255 "/usr/include/string.h" 3 4
}
# 265 "/usr/include/string.h" 3 4
extern "C++" char *strchrnul (char *__s, int __c)
     throw () __asm ("strchrnul") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern "C++" const char *strchrnul (const char *__s, int __c)
     throw () __asm ("strchrnul") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 277 "/usr/include/string.h" 3 4
extern size_t strcspn (const char *__s, const char *__reject)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern size_t strspn (const char *__s, const char *__accept)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern "C++"
{
extern char *strpbrk (char *__s, const char *__accept)
     throw () __asm ("strpbrk") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
extern const char *strpbrk (const char *__s, const char *__accept)
     throw () __asm ("strpbrk") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 305 "/usr/include/string.h" 3 4
}






extern "C++"
{
extern char *strstr (char *__haystack, const char *__needle)
     throw () __asm ("strstr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
extern const char *strstr (const char *__haystack, const char *__needle)
     throw () __asm ("strstr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 332 "/usr/include/string.h" 3 4
}







extern char *strtok (char *__restrict __s, const char *__restrict __delim)
     throw () __attribute__ ((__nonnull__ (2)));



extern char *__strtok_r (char *__restrict __s,
    const char *__restrict __delim,
    char **__restrict __save_ptr)
     throw () __attribute__ ((__nonnull__ (2, 3)));

extern char *strtok_r (char *__restrict __s, const char *__restrict __delim,
         char **__restrict __save_ptr)
     throw () __attribute__ ((__nonnull__ (2, 3)));





extern "C++" char *strcasestr (char *__haystack, const char *__needle)
     throw () __asm ("strcasestr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
extern "C++" const char *strcasestr (const char *__haystack,
         const char *__needle)
     throw () __asm ("strcasestr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 373 "/usr/include/string.h" 3 4
extern void *memmem (const void *__haystack, size_t __haystacklen,
       const void *__needle, size_t __needlelen)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 3)))
    __attribute__ ((__access__ (__read_only__, 1, 2)))
    __attribute__ ((__access__ (__read_only__, 3, 4)));



extern void *__mempcpy (void *__restrict __dest,
   const void *__restrict __src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));
extern void *mempcpy (void *__restrict __dest,
        const void *__restrict __src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));




extern size_t strlen (const char *__s)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));




extern size_t strnlen (const char *__string, size_t __maxlen)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));




extern char *strerror (int __errnum) throw ();
# 428 "/usr/include/string.h" 3 4
extern char *strerror_r (int __errnum, char *__buf, size_t __buflen)
     throw () __attribute__ ((__nonnull__ (2))) __attribute__ ((__access__ (__write_only__, 2, 3)));




extern const char *strerrordesc_np (int __err) throw ();

extern const char *strerrorname_np (int __err) throw ();





extern char *strerror_l (int __errnum, locale_t __l) throw ();



# 1 "/usr/include/strings.h" 1 3 4
# 23 "/usr/include/strings.h" 3 4
# 1 "/usr/lib/gcc/x86_64-pc-linux-gnu/10.2.0/include/stddef.h" 1 3 4
# 24 "/usr/include/strings.h" 2 3 4






extern "C" {



extern int bcmp (const void *__s1, const void *__s2, size_t __n)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern void bcopy (const void *__src, void *__dest, size_t __n)
  throw () __attribute__ ((__nonnull__ (1, 2)));


extern void bzero (void *__s, size_t __n) throw () __attribute__ ((__nonnull__ (1)));



extern "C++"
{
extern char *index (char *__s, int __c)
     throw () __asm ("index") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern const char *index (const char *__s, int __c)
     throw () __asm ("index") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 66 "/usr/include/strings.h" 3 4
}







extern "C++"
{
extern char *rindex (char *__s, int __c)
     throw () __asm ("rindex") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern const char *rindex (const char *__s, int __c)
     throw () __asm ("rindex") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 94 "/usr/include/strings.h" 3 4
}
# 104 "/usr/include/strings.h" 3 4
extern int ffs (int __i) throw () __attribute__ ((__const__));





extern int ffsl (long int __l) throw () __attribute__ ((__const__));
__extension__ extern int ffsll (long long int __ll)
     throw () __attribute__ ((__const__));



extern int strcasecmp (const char *__s1, const char *__s2)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern int strncasecmp (const char *__s1, const char *__s2, size_t __n)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));






extern int strcasecmp_l (const char *__s1, const char *__s2, locale_t __loc)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 3)));



extern int strncasecmp_l (const char *__s1, const char *__s2,
     size_t __n, locale_t __loc)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 4)));


}
# 447 "/usr/include/string.h" 2 3 4



extern void explicit_bzero (void *__s, size_t __n) throw () __attribute__ ((__nonnull__ (1)))
    __attribute__ ((__access__ (__write_only__, 1, 2)));



extern char *strsep (char **__restrict __stringp,
       const char *__restrict __delim)
     throw () __attribute__ ((__nonnull__ (1, 2)));




extern char *strsignal (int __sig) throw ();



extern const char *sigabbrev_np (int __sig) throw ();


extern const char *sigdescr_np (int __sig) throw ();



extern char *__stpcpy (char *__restrict __dest, const char *__restrict __src)
     throw () __attribute__ ((__nonnull__ (1, 2)));
extern char *stpcpy (char *__restrict __dest, const char *__restrict __src)
     throw () __attribute__ ((__nonnull__ (1, 2)));



extern char *__stpncpy (char *__restrict __dest,
   const char *__restrict __src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));
extern char *stpncpy (char *__restrict __dest,
        const char *__restrict __src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));




extern int strverscmp (const char *__s1, const char *__s2)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern char *strfry (char *__string) throw () __attribute__ ((__nonnull__ (1)));


extern void *memfrob (void *__s, size_t __n) throw () __attribute__ ((__nonnull__ (1)))
    __attribute__ ((__access__ (__write_only__, 1, 2)));







extern "C++" char *basename (char *__filename)
     throw () __asm ("basename") __attribute__ ((__nonnull__ (1)));
extern "C++" const char *basename (const char *__filename)
     throw () __asm ("basename") __attribute__ ((__nonnull__ (1)));
# 523 "/usr/include/string.h" 3 4
}
# 5 "4coder_sam.cpp" 2




# 1 "/home/sam/.bin/4coder/custom/4coder_default_include.cpp" 1
# 14 "/home/sam/.bin/4coder/custom/4coder_default_include.cpp"
# 1 "/home/sam/.bin/4coder/custom/4coder_base_types.h" 1
# 165 "/home/sam/.bin/4coder/custom/4coder_base_types.h"
# 1 "/usr/lib/gcc/x86_64-pc-linux-gnu/10.2.0/include/stdint.h" 1 3 4
# 9 "/usr/lib/gcc/x86_64-pc-linux-gnu/10.2.0/include/stdint.h" 3 4
# 1 "/usr/include/stdint.h" 1 3 4
# 26 "/usr/include/stdint.h" 3 4
# 1 "/usr/include/bits/libc-header-start.h" 1 3 4
# 27 "/usr/include/stdint.h" 2 3 4

# 1 "/usr/include/bits/wchar.h" 1 3 4
# 29 "/usr/include/stdint.h" 2 3 4
# 1 "/usr/include/bits/wordsize.h" 1 3 4
# 30 "/usr/include/stdint.h" 2 3 4







# 1 "/usr/include/bits/stdint-uintn.h" 1 3 4
# 24 "/usr/include/bits/stdint-uintn.h" 3 4
typedef __uint8_t uint8_t;
typedef __uint16_t uint16_t;
typedef __uint32_t uint32_t;
typedef __uint64_t uint64_t;
# 38 "/usr/include/stdint.h" 2 3 4





typedef __int_least8_t int_least8_t;
typedef __int_least16_t int_least16_t;
typedef __int_least32_t int_least32_t;
typedef __int_least64_t int_least64_t;


typedef __uint_least8_t uint_least8_t;
typedef __uint_least16_t uint_least16_t;
typedef __uint_least32_t uint_least32_t;
typedef __uint_least64_t uint_least64_t;





typedef signed char int_fast8_t;

typedef long int int_fast16_t;
typedef long int int_fast32_t;
typedef long int int_fast64_t;
# 71 "/usr/include/stdint.h" 3 4
typedef unsigned char uint_fast8_t;

typedef unsigned long int uint_fast16_t;
typedef unsigned long int uint_fast32_t;
typedef unsigned long int uint_fast64_t;
# 87 "/usr/include/stdint.h" 3 4
typedef long int intptr_t;


typedef unsigned long int uintptr_t;
# 101 "/usr/include/stdint.h" 3 4
typedef __intmax_t intmax_t;
typedef __uintmax_t uintmax_t;
# 10 "/usr/lib/gcc/x86_64-pc-linux-gnu/10.2.0/include/stdint.h" 2 3 4
# 166 "/home/sam/.bin/4coder/custom/4coder_base_types.h" 2


# 167 "/home/sam/.bin/4coder/custom/4coder_base_types.h"
typedef int8_t i8;
typedef int16_t i16;
typedef int32_t i32;
typedef int64_t i64;

typedef uint8_t u8;
typedef uint16_t u16;
typedef uint32_t u32;
typedef uint64_t u64;


typedef i8 b8;
typedef i32 b32;
typedef i64 b64;

typedef float f32;
typedef double f64;

typedef void Void_Func(void);

typedef i32 Generated_Group;
enum{
    GeneratedGroup_Core,
    GeneratedGroup_Custom
};
# 300 "/home/sam/.bin/4coder/custom/4coder_base_types.h"
static const u8 max_u8 = 0xFF;
static const u16 max_u16 = 0xFFFF;
static const u32 max_u32 = 0xFFFFFFFF;
static const u64 max_u64 = 0xFFFFFFFFFFFFFFFF;

static const i8 max_i8 = 127;
static const i16 max_i16 = 32767;
static const i32 max_i32 = 2147483647;
static const i64 max_i64 = 9223372036854775807;

static const i8 min_i8 = -127 - 1;
static const i16 min_i16 = -32767 - 1;
static const i32 min_i32 = -2147483647 - 1;
static const i64 min_i64 = -9223372036854775807 - 1;

static const f32 max_f32 = 3.402823466e+38f;
static const f32 min_f32 = -max_f32;
static const f32 smallest_positive_f32 = 1.1754943508e-38f;
static const f32 epsilon_f32 = 5.96046448e-8f;

static const f32 pi_f32 = 3.14159265359f;
static const f32 half_pi_f32 = 1.5707963267f;

static const f64 max_f64 = 1.79769313486231e+308;
static const f64 min_f64 = -max_f64;
static const f64 smallest_positive_f64 = 4.94065645841247e-324;
static const f64 epsilon_f64 = 1.11022302462515650e-16;
# 352 "/home/sam/.bin/4coder/custom/4coder_base_types.h"
static const u32 bit_1 = 0x00000001;
static const u32 bit_2 = 0x00000002;
static const u32 bit_3 = 0x00000004;
static const u32 bit_4 = 0x00000008;
static const u32 bit_5 = 0x00000010;
static const u32 bit_6 = 0x00000020;
static const u32 bit_7 = 0x00000040;
static const u32 bit_8 = 0x00000080;
static const u32 bit_9 = 0x00000100;
static const u32 bit_10 = 0x00000200;
static const u32 bit_11 = 0x00000400;
static const u32 bit_12 = 0x00000800;
static const u32 bit_13 = 0x00001000;
static const u32 bit_14 = 0x00002000;
static const u32 bit_15 = 0x00004000;
static const u32 bit_16 = 0x00008000;
static const u32 bit_17 = 0x00010000;
static const u32 bit_18 = 0x00020000;
static const u32 bit_19 = 0x00040000;
static const u32 bit_20 = 0x00080000;
static const u32 bit_21 = 0x00100000;
static const u32 bit_22 = 0x00200000;
static const u32 bit_23 = 0x00400000;
static const u32 bit_24 = 0x00800000;
static const u32 bit_25 = 0x01000000;
static const u32 bit_26 = 0x02000000;
static const u32 bit_27 = 0x04000000;
static const u32 bit_28 = 0x08000000;
static const u32 bit_29 = 0x10000000;
static const u32 bit_30 = 0x20000000;
static const u32 bit_31 = 0x40000000;
static const u32 bit_32 = 0x80000000;

static const u64 bit_33 = 0x0000000100000000;
static const u64 bit_34 = 0x0000000200000000;
static const u64 bit_35 = 0x0000000400000000;
static const u64 bit_36 = 0x0000000800000000;
static const u64 bit_37 = 0x0000001000000000;
static const u64 bit_38 = 0x0000002000000000;
static const u64 bit_39 = 0x0000004000000000;
static const u64 bit_40 = 0x0000008000000000;
static const u64 bit_41 = 0x0000010000000000;
static const u64 bit_42 = 0x0000020000000000;
static const u64 bit_43 = 0x0000040000000000;
static const u64 bit_44 = 0x0000080000000000;
static const u64 bit_45 = 0x0000100000000000;
static const u64 bit_46 = 0x0000200000000000;
static const u64 bit_47 = 0x0000400000000000;
static const u64 bit_48 = 0x0000800000000000;
static const u64 bit_49 = 0x0001000000000000;
static const u64 bit_50 = 0x0002000000000000;
static const u64 bit_51 = 0x0004000000000000;
static const u64 bit_52 = 0x0008000000000000;
static const u64 bit_53 = 0x0010000000000000;
static const u64 bit_54 = 0x0020000000000000;
static const u64 bit_55 = 0x0040000000000000;
static const u64 bit_56 = 0x0080000000000000;
static const u64 bit_57 = 0x0100000000000000;
static const u64 bit_58 = 0x0200000000000000;
static const u64 bit_59 = 0x0400000000000000;
static const u64 bit_60 = 0x0800000000000000;
static const u64 bit_61 = 0x1000000000000000;
static const u64 bit_62 = 0x2000000000000000;
static const u64 bit_63 = 0x4000000000000000;
static const u64 bit_64 = 0x8000000000000000;

static const u32 bitmask_1 = 0x00000001;
static const u32 bitmask_2 = 0x00000003;
static const u32 bitmask_3 = 0x00000007;
static const u32 bitmask_4 = 0x0000000f;
static const u32 bitmask_5 = 0x0000001f;
static const u32 bitmask_6 = 0x0000003f;
static const u32 bitmask_7 = 0x0000007f;
static const u32 bitmask_8 = 0x000000ff;
static const u32 bitmask_9 = 0x000001ff;
static const u32 bitmask_10 = 0x000003ff;
static const u32 bitmask_11 = 0x000007ff;
static const u32 bitmask_12 = 0x00000fff;
static const u32 bitmask_13 = 0x00001fff;
static const u32 bitmask_14 = 0x00003fff;
static const u32 bitmask_15 = 0x00007fff;
static const u32 bitmask_16 = 0x0000ffff;
static const u32 bitmask_17 = 0x0001ffff;
static const u32 bitmask_18 = 0x0003ffff;
static const u32 bitmask_19 = 0x0007ffff;
static const u32 bitmask_20 = 0x000fffff;
static const u32 bitmask_21 = 0x001fffff;
static const u32 bitmask_22 = 0x003fffff;
static const u32 bitmask_23 = 0x007fffff;
static const u32 bitmask_24 = 0x00ffffff;
static const u32 bitmask_25 = 0x01ffffff;
static const u32 bitmask_26 = 0x03ffffff;
static const u32 bitmask_27 = 0x07ffffff;
static const u32 bitmask_28 = 0x0fffffff;
static const u32 bitmask_29 = 0x1fffffff;
static const u32 bitmask_30 = 0x3fffffff;
static const u32 bitmask_31 = 0x7fffffff;

static const u64 bitmask_32 = 0x00000000ffffffff;
static const u64 bitmask_33 = 0x00000001ffffffff;
static const u64 bitmask_34 = 0x00000003ffffffff;
static const u64 bitmask_35 = 0x00000007ffffffff;
static const u64 bitmask_36 = 0x0000000fffffffff;
static const u64 bitmask_37 = 0x0000001fffffffff;
static const u64 bitmask_38 = 0x0000003fffffffff;
static const u64 bitmask_39 = 0x0000007fffffffff;
static const u64 bitmask_40 = 0x000000ffffffffff;
static const u64 bitmask_41 = 0x000001ffffffffff;
static const u64 bitmask_42 = 0x000003ffffffffff;
static const u64 bitmask_43 = 0x000007ffffffffff;
static const u64 bitmask_44 = 0x00000fffffffffff;
static const u64 bitmask_45 = 0x00001fffffffffff;
static const u64 bitmask_46 = 0x00003fffffffffff;
static const u64 bitmask_47 = 0x00007fffffffffff;
static const u64 bitmask_48 = 0x0000ffffffffffff;
static const u64 bitmask_49 = 0x0001ffffffffffff;
static const u64 bitmask_50 = 0x0003ffffffffffff;
static const u64 bitmask_51 = 0x0007ffffffffffff;
static const u64 bitmask_52 = 0x000fffffffffffff;
static const u64 bitmask_53 = 0x001fffffffffffff;
static const u64 bitmask_54 = 0x003fffffffffffff;
static const u64 bitmask_55 = 0x007fffffffffffff;
static const u64 bitmask_56 = 0x00ffffffffffffff;
static const u64 bitmask_57 = 0x01ffffffffffffff;
static const u64 bitmask_58 = 0x03ffffffffffffff;
static const u64 bitmask_59 = 0x07ffffffffffffff;
static const u64 bitmask_60 = 0x0fffffffffffffff;
static const u64 bitmask_61 = 0x1fffffffffffffff;
static const u64 bitmask_62 = 0x3fffffffffffffff;
static const u64 bitmask_63 = 0x7fffffffffffffff;



struct Node{
    Node *next;
    Node *prev;
};
union SNode{
    SNode *next;
    SNode *prev;
};
# 544 "/home/sam/.bin/4coder/custom/4coder_base_types.h"
union Vec2_i8{
    struct{
        i8 x;
        i8 y;
    };
    i8 v[2];
};
union Vec3_i8{
    struct{
        i8 x;
        i8 y;
        i8 z;
    };
    struct{
        i8 r;
        i8 g;
        i8 b;
    };
    i8 v[3];
};
union Vec4_i8{
    struct{
        i8 x;
        i8 y;
        i8 z;
        i8 w;
    };
    struct{
        i8 r;
        i8 g;
        i8 b;
        i8 a;
    };
    i8 v[4];
};
union Vec2_i16{
    struct{
        i16 x;
        i16 y;
    };
    i16 v[2];
};
union Vec3_i16{
    struct{
        i16 x;
        i16 y;
        i16 z;
    };
    struct{
        i16 r;
        i16 g;
        i16 b;
    };
    i16 v[3];
};
union Vec4_i16{
    struct{
        i16 x;
        i16 y;
        i16 z;
        i16 w;
    };
    struct{
        i16 r;
        i16 g;
        i16 b;
        i16 a;
    };
    i16 v[4];
};
union Vec2_i32{
    struct{
        i32 x;
        i32 y;
    };
    i32 v[2];
};
union Vec3_i32{
    struct{
        i32 x;
        i32 y;
        i32 z;
    };
    struct{
        i32 r;
        i32 g;
        i32 b;
    };
    i32 v[3];
};
union Vec4_i32{
    struct{
        i32 x;
        i32 y;
        i32 z;
        i32 w;
    };
    struct{
        i32 r;
        i32 g;
        i32 b;
        i32 a;
    };
    i32 v[4];
};
union Vec2_f32{
    struct{
        f32 x;
        f32 y;
    };
    f32 v[2];
};
union Vec3_f32{
    struct{
        f32 x;
        f32 y;
        f32 z;
    };
    struct{
        f32 r;
        f32 g;
        f32 b;
    };
    f32 v[3];
};
union Vec4_f32{
    struct{
        f32 x;
        f32 y;
        f32 z;
        f32 w;
    };
    struct{
        f32 r;
        f32 g;
        f32 b;
        f32 a;
    };
    struct{
        f32 h;
        f32 s;
        f32 l;
        f32 __a;
    };
    f32 v[4];
};

union Range_i32{
    struct{
        i32 min;
        i32 max;
    };
    struct{
        i32 start;
        i32 end;
    };
    struct{
        i32 first;
        i32 one_past_last;
    };
};
union Range_i64{
    struct{
        i64 min;
        i64 max;
    };
    struct{
        i64 start;
        i64 end;
    };
    struct{
        i64 first;
        i64 one_past_last;
    };
};
union Range_u64{
    struct{
        u64 min;
        u64 max;
    };
    struct{
        u64 start;
        u64 end;
    };
    struct{
        u64 first;
        u64 one_past_last;
    };
};
union Range_f32{
    struct{
        f32 min;
        f32 max;
    };
    struct{
        f32 start;
        f32 end;
    };
    struct{
        f32 first;
        f32 one_past_last;
    };
};

struct Range_i32_Array{
    Range_i32 *ranges;
    i32 count;
};
struct Range_i64_Array{
    Range_i64 *ranges;
    i32 count;
};
struct Range_u64_Array{
    Range_u64 *ranges;
    i32 count;
};
struct Range_f32_Array{
    Range_f32 *ranges;
    i32 count;
};

union Rect_i32{
    struct{
        i32 x0;
        i32 y0;
        i32 x1;
        i32 y1;
    };
    struct{
        Vec2_i32 p0;
        Vec2_i32 p1;
    };
    Vec2_i32 p[2];
};
union Rect_f32{
    struct{
        f32 x0;
        f32 y0;
        f32 x1;
        f32 y1;
    };
    struct{
        Vec2_f32 p0;
        Vec2_f32 p1;
    };
    Vec2_f32 p[2];
};

union Rect_f32_Pair{
    struct{
        Rect_f32 a;
        Rect_f32 b;
    };
    struct{
        Rect_f32 min;
        Rect_f32 max;
    };
    struct{
        Rect_f32 e[2];
    };
};

typedef u32 ARGB_Color;



struct i8_Array{
    i8 *vals;
    i32 count;
};
struct i16_Array{
    i16 *vals;
    i32 count;
};
struct i32_Array{
    i32 *vals;
    i32 count;
};
struct i64_Array{
    i64 *vals;
    i32 count;
};

struct u8_Array{
    u8 *vals;
    i32 count;
};
struct u16_Array{
    u16 *vals;
    i32 count;
};
struct u32_Array{
    u32 *vals;
    i32 count;
};
struct u64_Array{
    u64 *vals;
    i32 count;
};



typedef i32 String_Fill_Terminate_Rule;
enum{
    StringFill_NoTerminate = 0,
    StringFill_NullTerminate = 1,
};
typedef u32 String_Separator_Flag;
enum{
    StringSeparator_NoFlags = 0,
};
enum{
    StringSeparator_BeforeFirst = 1,
    StringSeparator_AfterLast = 2,
};
typedef i32 String_Match_Rule;
enum{
    StringMatch_Exact = 0,
    StringMatch_CaseInsensitive = 1,
};

struct String_Const_char{
    char *str;
    u64 size;
};
struct String_Const_u8{
    union{
        void *data;
        u8 *str;
    };
    u64 size;
};
struct String_Const_u16{
    u16 *str;
    u64 size;
};
struct String_Const_u32{
    u32 *str;
    u64 size;
};

struct String_Const_char_Array{
    union{
        String_Const_char *strings;
        String_Const_char *vals;
    };
    i32 count;
};
struct String_Const_u8_Array{
    union{
        String_Const_u8 *strings;
        String_Const_u8 *vals;
    };
    i32 count;
};
struct String_Const_u16_Array{
    union{
        String_Const_u16 *strings;
        String_Const_u16 *vals;
    };
    i32 count;
};
struct String_Const_u32_Array{
    union{
        String_Const_u32 *strings;
        String_Const_u32 *vals;
    };
    i32 count;
};

typedef i32 String_Encoding;
enum{
    StringEncoding_ASCII = 0,
    StringEncoding_UTF8 = 1,
    StringEncoding_UTF16 = 2,
    StringEncoding_UTF32 = 3,
};

struct String_Const_Any{
    String_Encoding encoding;
    union{
        struct{
            void *str;
            u64 size;
        };
        String_Const_char s_char;
        String_Const_u8 s_u8;
        String_Const_u16 s_u16;
        String_Const_u32 s_u32;
    };
};




struct Node_String_Const_char{
    Node_String_Const_char *next;
    String_Const_char string;
};
struct Node_String_Const_u8{
    Node_String_Const_u8 *next;
    String_Const_u8 string;
};
struct Node_String_Const_u16{
    Node_String_Const_u16 *next;
    String_Const_u16 string;
};
struct Node_String_Const_u32{
    Node_String_Const_u32 *next;
    String_Const_u32 string;
};
struct List_String_Const_char{
    Node_String_Const_char *first;
    Node_String_Const_char *last;
    u64 total_size;
    i32 node_count;
};
struct List_String_Const_u8{
    Node_String_Const_u8 *first;
    Node_String_Const_u8 *last;
    u64 total_size;
    i32 node_count;
};
struct List_String_Const_u16{
    Node_String_Const_u16 *first;
    Node_String_Const_u16 *last;
    u64 total_size;
    i32 node_count;
};
struct List_String_Const_u32{
    Node_String_Const_u32 *first;
    Node_String_Const_u32 *last;
    u64 total_size;
    i32 node_count;
};

struct Node_String_Const_Any{
    Node_String_Const_Any *next;
    String_Const_Any string;
};
struct List_String_Const_Any{
    Node_String_Const_Any *first;
    Node_String_Const_Any *last;
    u64 total_size;
    i32 node_count;
};

struct String_char{
    union{
        String_Const_char string;
        struct{
            char *str;
            u64 size;
        };
    };
    u64 cap;
};
struct String_u8{
    union{
        String_Const_u8 string;
        struct{
            u8 *str;
            u64 size;
        };
    };
    u64 cap;
};
struct String_u16{
    union{
        String_Const_u16 string;
        struct{
            u16 *str;
            u64 size;
        };
    };
    u64 cap;
};
struct String_u32{
    union{
        String_Const_u32 string;
        struct{
            u32 *str;
            u64 size;
        };
    };
    u64 cap;
};

struct String_Any{
    String_Encoding encoding;
    union{
        struct{
            void *str;
            u64 size;
            u64 cap;
        };
        String_char s_char;
        String_u8 s_u8;
        String_u16 s_u16;
        String_u32 s_u32;
    };
};

typedef i32 Line_Ending_Kind;
enum{
    LineEndingKind_Binary,
    LineEndingKind_LF,
    LineEndingKind_CRLF,
};

struct Character_Consume_Result{
    u32 inc;
    u32 codepoint;
};

static u32 surrogate_min = 0xD800;
static u32 surrogate_max = 0xDFFF;

static u32 nonchar_min = 0xFDD0;
static u32 nonchar_max = 0xFDEF;

struct Data{
    u8 *data;
    u64 size;
};



typedef u32 Access_Flag;
enum{
    AccessFlag_Read = 1,
    AccessFlag_Write = 2,
    AccessFlag_Exec = 4,
};

typedef i32 Dimension;
enum{
    Dimension_X = 0,
    Dimension_Y = 1,
    Dimension_Z = 2,
    Dimension_W = 3,
};

typedef i32 Coordinate;
enum{
    Coordinate_X = 0,
    Coordinate_Y = 1,
    Coordinate_Z = 2,
    Coordinate_W = 3,
};

typedef i32 Side;
enum{
    Side_Min = 0,
    Side_Max = 1,
};

typedef i32 Scan_Direction;
enum{
    Scan_Backward = -1,
    Scan_Forward = 1,
};



struct Date_Time{
    u32 year;
    u8 mon;
    u8 day;
    u8 hour;
    u8 min;
    u8 sec;
    u16 msec;
};

static String_Const_u8 month_full_name[] = {
    {(u8*)("January"), sizeof("January") - 1},
    {(u8*)("February"), sizeof("February") - 1},
    {(u8*)("March"), sizeof("March") - 1},
    {(u8*)("April"), sizeof("April") - 1},
    {(u8*)("May"), sizeof("May") - 1},
    {(u8*)("June"), sizeof("June") - 1},
    {(u8*)("July"), sizeof("July") - 1},
    {(u8*)("August"), sizeof("August") - 1},
    {(u8*)("September"), sizeof("September") - 1},
    {(u8*)("October"), sizeof("October") - 1},
    {(u8*)("November"), sizeof("November") - 1},
    {(u8*)("December"), sizeof("December") - 1},
};

static String_Const_u8 month_abrev_name[] = {
    {(u8*)("Jan"), sizeof("Jan") - 1},
    {(u8*)("Feb"), sizeof("Feb") - 1},
    {(u8*)("Mar"), sizeof("Mar") - 1},
    {(u8*)("Apr"), sizeof("Apr") - 1},
    {(u8*)("May"), sizeof("May") - 1},
    {(u8*)("Jun"), sizeof("Jun") - 1},
    {(u8*)("Jul"), sizeof("Jul") - 1},
    {(u8*)("Aug"), sizeof("Aug") - 1},
    {(u8*)("Sep"), sizeof("Sep") - 1},
    {(u8*)("Oct"), sizeof("Oct") - 1},
    {(u8*)("Nov"), sizeof("Nov") - 1},
    {(u8*)("Dec"), sizeof("Dec") - 1},
};

static String_Const_u8 ordinal_numeric_name[] = {
    {(u8*)("1st"), sizeof("1st") - 1},
    {(u8*)("2nd"), sizeof("2nd") - 1},
    {(u8*)("3rd"), sizeof("3rd") - 1},
    {(u8*)("4th"), sizeof("4th") - 1},
    {(u8*)("5th"), sizeof("5th") - 1},
    {(u8*)("6th"), sizeof("6th") - 1},
    {(u8*)("7th"), sizeof("7th") - 1},
    {(u8*)("8th"), sizeof("8th") - 1},
    {(u8*)("9th"), sizeof("9th") - 1},
    {(u8*)("10th"), sizeof("10th") - 1},
    {(u8*)("11th"), sizeof("11th") - 1},
    {(u8*)("12th"), sizeof("12th") - 1},
    {(u8*)("13th"), sizeof("13th") - 1},
    {(u8*)("14th"), sizeof("14th") - 1},
    {(u8*)("15th"), sizeof("15th") - 1},
    {(u8*)("16th"), sizeof("16th") - 1},
    {(u8*)("17th"), sizeof("17th") - 1},
    {(u8*)("18th"), sizeof("18th") - 1},
    {(u8*)("19th"), sizeof("19th") - 1},
    {(u8*)("20th"), sizeof("20th") - 1},
    {(u8*)("21st"), sizeof("21st") - 1},
    {(u8*)("22nd"), sizeof("22nd") - 1},
    {(u8*)("23rd"), sizeof("23rd") - 1},
    {(u8*)("24th"), sizeof("24th") - 1},
    {(u8*)("25th"), sizeof("25th") - 1},
    {(u8*)("26th"), sizeof("26th") - 1},
    {(u8*)("27th"), sizeof("27th") - 1},
    {(u8*)("28th"), sizeof("28th") - 1},
    {(u8*)("29th"), sizeof("29th") - 1},
    {(u8*)("30th"), sizeof("30th") - 1},
    {(u8*)("31st"), sizeof("31st") - 1},
    {(u8*)("32nd"), sizeof("32nd") - 1},
    {(u8*)("33rd"), sizeof("33rd") - 1},
    {(u8*)("34th"), sizeof("34th") - 1},
    {(u8*)("35th"), sizeof("35th") - 1},
    {(u8*)("36th"), sizeof("36th") - 1},
    {(u8*)("37th"), sizeof("37th") - 1},
    {(u8*)("38th"), sizeof("38th") - 1},
    {(u8*)("39th"), sizeof("39th") - 1},
    {(u8*)("40th"), sizeof("40th") - 1},
    {(u8*)("41st"), sizeof("41st") - 1},
    {(u8*)("42nd"), sizeof("42nd") - 1},
    {(u8*)("43rd"), sizeof("43rd") - 1},
    {(u8*)("44th"), sizeof("44th") - 1},
    {(u8*)("45th"), sizeof("45th") - 1},
    {(u8*)("46th"), sizeof("46th") - 1},
    {(u8*)("47th"), sizeof("47th") - 1},
    {(u8*)("48th"), sizeof("48th") - 1},
    {(u8*)("49th"), sizeof("49th") - 1},
    {(u8*)("50th"), sizeof("50th") - 1},
    {(u8*)("51st"), sizeof("51st") - 1},
    {(u8*)("52nd"), sizeof("52nd") - 1},
    {(u8*)("53rd"), sizeof("53rd") - 1},
    {(u8*)("54th"), sizeof("54th") - 1},
    {(u8*)("55th"), sizeof("55th") - 1},
    {(u8*)("56th"), sizeof("56th") - 1},
    {(u8*)("57th"), sizeof("57th") - 1},
    {(u8*)("58th"), sizeof("58th") - 1},
    {(u8*)("59th"), sizeof("59th") - 1},
    {(u8*)("60th"), sizeof("60th") - 1},
    {(u8*)("61st"), sizeof("61st") - 1},
    {(u8*)("62nd"), sizeof("62nd") - 1},
    {(u8*)("63rd"), sizeof("63rd") - 1},
    {(u8*)("64th"), sizeof("64th") - 1},
    {(u8*)("65th"), sizeof("65th") - 1},
    {(u8*)("66th"), sizeof("66th") - 1},
    {(u8*)("67th"), sizeof("67th") - 1},
    {(u8*)("68th"), sizeof("68th") - 1},
    {(u8*)("69th"), sizeof("69th") - 1},
    {(u8*)("70th"), sizeof("70th") - 1},
    {(u8*)("71st"), sizeof("71st") - 1},
    {(u8*)("72nd"), sizeof("72nd") - 1},
    {(u8*)("73rd"), sizeof("73rd") - 1},
    {(u8*)("74th"), sizeof("74th") - 1},
    {(u8*)("75th"), sizeof("75th") - 1},
    {(u8*)("76th"), sizeof("76th") - 1},
    {(u8*)("77th"), sizeof("77th") - 1},
    {(u8*)("78th"), sizeof("78th") - 1},
    {(u8*)("79th"), sizeof("79th") - 1},
    {(u8*)("80th"), sizeof("80th") - 1},
    {(u8*)("81st"), sizeof("81st") - 1},
    {(u8*)("82nd"), sizeof("82nd") - 1},
    {(u8*)("83rd"), sizeof("83rd") - 1},
    {(u8*)("84th"), sizeof("84th") - 1},
    {(u8*)("85th"), sizeof("85th") - 1},
    {(u8*)("86th"), sizeof("86th") - 1},
    {(u8*)("87th"), sizeof("87th") - 1},
    {(u8*)("88th"), sizeof("88th") - 1},
    {(u8*)("89th"), sizeof("89th") - 1},
    {(u8*)("90th"), sizeof("90th") - 1},
    {(u8*)("91st"), sizeof("91st") - 1},
    {(u8*)("92nd"), sizeof("92nd") - 1},
    {(u8*)("93rd"), sizeof("93rd") - 1},
    {(u8*)("94th"), sizeof("94th") - 1},
    {(u8*)("95th"), sizeof("95th") - 1},
    {(u8*)("96th"), sizeof("96th") - 1},
    {(u8*)("97th"), sizeof("97th") - 1},
    {(u8*)("98th"), sizeof("98th") - 1},
    {(u8*)("99th"), sizeof("99th") - 1},
    {(u8*)("100th"), sizeof("100th") - 1},
};



typedef void *Base_Allocator_Reserve_Signature(void *user_data, u64 size, u64 *size_out, String_Const_u8 location);
typedef void Base_Allocator_Commit_Signature(void *user_data, void *ptr, u64 size);
typedef void Base_Allocator_Uncommit_Signature(void *user_data, void *ptr, u64 size);
typedef void Base_Allocator_Free_Signature(void *user_data, void *ptr);
typedef void Base_Allocator_Set_Access_Signature(void *user_data, void *ptr, u64 size, Access_Flag flags);
struct Base_Allocator{
    Base_Allocator_Reserve_Signature *reserve;
    Base_Allocator_Commit_Signature *commit;
    Base_Allocator_Uncommit_Signature *uncommit;
    Base_Allocator_Free_Signature *free;
    Base_Allocator_Set_Access_Signature *set_access;
    void *user_data;
};

struct Cursor{
    u8 *base;
    u64 pos;
    u64 cap;
};
struct Temp_Memory_Cursor{
    Cursor *cursor;
    u64 pos;
};
struct Cursor_Node{
    union{
        Cursor_Node *next;
        Cursor_Node *prev;
    };
    Cursor cursor;
};
struct Arena{
    Base_Allocator *base_allocator;
    Cursor_Node *cursor_node;
    u64 chunk_size;
    u64 alignment;
};
struct Temp_Memory_Arena{
    Arena *arena;
    Cursor_Node *cursor_node;
    u64 pos;
};
typedef i32 Linear_Allocator_Kind;
enum{
    LinearAllocatorKind_Cursor,
    LinearAllocatorKind_Arena,
};
struct Temp_Memory{
    Linear_Allocator_Kind kind;
    union{
        Temp_Memory_Cursor temp_memory_cursor;
        Temp_Memory_Arena temp_memory_arena;
    };
};



typedef u64 Profile_ID;
struct Profile_Record{
    Profile_Record *next;
    Profile_ID id;
    u64 time;
    String_Const_u8 location;
    String_Const_u8 name;
};

struct Profile_Thread{
    Profile_Thread *next;
    Profile_Record *first_record;
    Profile_Record *last_record;
    i32 record_count;
    i32 thread_id;
    String_Const_u8 name;
};

typedef u32 Profile_Enable_Flag;
enum{
    ProfileEnable_UserBit = 0x1,
    ProfileEnable_InspectBit = 0x2,
};


struct Profile_Global_List;



typedef i32 Thread_Kind;
enum{
    ThreadKind_Main,
    ThreadKind_MainCoroutine,
    ThreadKind_AsyncTasks,
};

struct Arena_Node{
    Arena_Node *next;
    Arena_Node *prev;
    Arena arena;
    i32 ref_counter;
};

struct Thread_Context{
    Thread_Kind kind;
    Base_Allocator *allocator;
    Arena node_arena;
    Arena_Node *used_first;
    Arena_Node *used_last;
    Arena_Node *free_arenas;

    Base_Allocator *prof_allocator;
    Profile_ID prof_id_counter;
    Arena prof_arena;
    Profile_Record *prof_first;
    Profile_Record *prof_last;
    i32 prof_record_count;

    void *user_data;
};

struct Scratch_Block{
    Thread_Context *tctx;
    Arena *arena;
    Temp_Memory temp;

    Scratch_Block(struct Thread_Context *tctx);
    Scratch_Block(struct Thread_Context *tctx, Arena *a1);
    Scratch_Block(struct Thread_Context *tctx, Arena *a1, Arena *a2);
    Scratch_Block(struct Thread_Context *tctx, Arena *a1, Arena *a2, Arena *a3);
    Scratch_Block(struct Application_Links *app);
    Scratch_Block(struct Application_Links *app, Arena *a1);
    Scratch_Block(struct Application_Links *app, Arena *a1, Arena *a2);
    Scratch_Block(struct Application_Links *app, Arena *a1, Arena *a2, Arena *a3);
    ~Scratch_Block();
    operator Arena*();
    void restore(void);
};

struct Temp_Memory_Block{
    Temp_Memory temp;
    Temp_Memory_Block(Temp_Memory temp);
    Temp_Memory_Block(Arena *arena);
    ~Temp_Memory_Block();
    void restore(void);
};



struct Heap_Basic_Node{
    Heap_Basic_Node *next;
    Heap_Basic_Node *prev;
};

struct Heap_Node{
    union{
        struct{
            Heap_Basic_Node order;
            Heap_Basic_Node alloc;
            u64 size;
        };
        u8 force_size__[64];
    };
};

struct Heap{
    Arena arena_;
    Arena *arena;
    Heap_Basic_Node in_order;
    Heap_Basic_Node free_nodes;
    u64 used_space;
    u64 total_space;
};
# 15 "/home/sam/.bin/4coder/custom/4coder_default_include.cpp" 2
# 1 "/home/sam/.bin/4coder/custom/4coder_version.h" 1
# 16 "/home/sam/.bin/4coder/custom/4coder_default_include.cpp" 2
# 1 "/home/sam/.bin/4coder/custom/4coder_table.h" 1
# 10 "/home/sam/.bin/4coder/custom/4coder_table.h"
struct Table_Lookup{
    u64 hash;
    u32 index;
    b8 found_match;
    b8 found_empty_slot;
    b8 found_erased_slot;
};

struct Table_u64_u64{
    Base_Allocator *allocator;
    void *memory;
    u64 *keys;
    u64 *vals;
    u32 slot_count;
    u32 used_count;
    u32 dirty_count;
};

struct Table_u32_u16{
    Base_Allocator *allocator;
    void *memory;
    u32 *keys;
    u16 *vals;
    u32 slot_count;
    u32 used_count;
    u32 dirty_count;
};

struct Table_Data_u64{
    Base_Allocator *allocator;
    void *memory;
    u64 *hashes;
    Data *keys;
    u64 *vals;
    u32 slot_count;
    u32 used_count;
    u32 dirty_count;
};

struct Table_u64_Data{
    Base_Allocator *allocator;
    void *memory;
    u64 *keys;
    Data *vals;
    u32 slot_count;
    u32 used_count;
    u32 dirty_count;
};

struct Table_Data_Data{
    Base_Allocator *allocator;
    void *memory;
    u64 *hashes;
    Data *keys;
    Data *vals;
    u32 slot_count;
    u32 used_count;
    u32 dirty_count;
};
# 17 "/home/sam/.bin/4coder/custom/4coder_default_include.cpp" 2
# 1 "/home/sam/.bin/4coder/custom/4coder_events.h" 1
# 10 "/home/sam/.bin/4coder/custom/4coder_events.h"
typedef void Custom_Command_Function(struct Application_Links *app);

typedef u32 Key_Code;
typedef u32 Mouse_Code;
typedef u32 Core_Code;
# 1 "/home/sam/.bin/4coder/custom/generated/4coder_event_codes.h" 1
enum{
    KeyCode_A = 1,
    KeyCode_B = 2,
    KeyCode_C = 3,
    KeyCode_D = 4,
    KeyCode_E = 5,
    KeyCode_F = 6,
    KeyCode_G = 7,
    KeyCode_H = 8,
    KeyCode_I = 9,
    KeyCode_J = 10,
    KeyCode_K = 11,
    KeyCode_L = 12,
    KeyCode_M = 13,
    KeyCode_N = 14,
    KeyCode_O = 15,
    KeyCode_P = 16,
    KeyCode_Q = 17,
    KeyCode_R = 18,
    KeyCode_S = 19,
    KeyCode_T = 20,
    KeyCode_U = 21,
    KeyCode_V = 22,
    KeyCode_W = 23,
    KeyCode_X = 24,
    KeyCode_Y = 25,
    KeyCode_Z = 26,
    KeyCode_0 = 27,
    KeyCode_1 = 28,
    KeyCode_2 = 29,
    KeyCode_3 = 30,
    KeyCode_4 = 31,
    KeyCode_5 = 32,
    KeyCode_6 = 33,
    KeyCode_7 = 34,
    KeyCode_8 = 35,
    KeyCode_9 = 36,
    KeyCode_Space = 37,
    KeyCode_Tick = 38,
    KeyCode_Minus = 39,
    KeyCode_Equal = 40,
    KeyCode_LeftBracket = 41,
    KeyCode_RightBracket = 42,
    KeyCode_Semicolon = 43,
    KeyCode_Quote = 44,
    KeyCode_Comma = 45,
    KeyCode_Period = 46,
    KeyCode_ForwardSlash = 47,
    KeyCode_BackwardSlash = 48,
    KeyCode_Tab = 49,
    KeyCode_Escape = 50,
    KeyCode_Pause = 51,
    KeyCode_Up = 52,
    KeyCode_Down = 53,
    KeyCode_Left = 54,
    KeyCode_Right = 55,
    KeyCode_Backspace = 56,
    KeyCode_Return = 57,
    KeyCode_Delete = 58,
    KeyCode_Insert = 59,
    KeyCode_Home = 60,
    KeyCode_End = 61,
    KeyCode_PageUp = 62,
    KeyCode_PageDown = 63,
    KeyCode_CapsLock = 64,
    KeyCode_NumLock = 65,
    KeyCode_ScrollLock = 66,
    KeyCode_Menu = 67,
    KeyCode_Shift = 68,
    KeyCode_Control = 69,
    KeyCode_Alt = 70,
    KeyCode_Command = 71,
    KeyCode_F1 = 72,
    KeyCode_F2 = 73,
    KeyCode_F3 = 74,
    KeyCode_F4 = 75,
    KeyCode_F5 = 76,
    KeyCode_F6 = 77,
    KeyCode_F7 = 78,
    KeyCode_F8 = 79,
    KeyCode_F9 = 80,
    KeyCode_F10 = 81,
    KeyCode_F11 = 82,
    KeyCode_F12 = 83,
    KeyCode_F13 = 84,
    KeyCode_F14 = 85,
    KeyCode_F15 = 86,
    KeyCode_F16 = 87,
    KeyCode_F17 = 88,
    KeyCode_F18 = 89,
    KeyCode_F19 = 90,
    KeyCode_F20 = 91,
    KeyCode_F21 = 92,
    KeyCode_F22 = 93,
    KeyCode_F23 = 94,
    KeyCode_F24 = 95,
    KeyCode_NumPad0 = 96,
    KeyCode_NumPad1 = 97,
    KeyCode_NumPad2 = 98,
    KeyCode_NumPad3 = 99,
    KeyCode_NumPad4 = 100,
    KeyCode_NumPad5 = 101,
    KeyCode_NumPad6 = 102,
    KeyCode_NumPad7 = 103,
    KeyCode_NumPad8 = 104,
    KeyCode_NumPad9 = 105,
    KeyCode_NumPadStar = 106,
    KeyCode_NumPadPlus = 107,
    KeyCode_NumPadMinus = 108,
    KeyCode_NumPadDot = 109,
    KeyCode_NumPadSlash = 110,
    KeyCode_Ex0 = 111,
    KeyCode_Ex1 = 112,
    KeyCode_Ex2 = 113,
    KeyCode_Ex3 = 114,
    KeyCode_Ex4 = 115,
    KeyCode_Ex5 = 116,
    KeyCode_Ex6 = 117,
    KeyCode_Ex7 = 118,
    KeyCode_Ex8 = 119,
    KeyCode_Ex9 = 120,
    KeyCode_Ex10 = 121,
    KeyCode_Ex11 = 122,
    KeyCode_Ex12 = 123,
    KeyCode_Ex13 = 124,
    KeyCode_Ex14 = 125,
    KeyCode_Ex15 = 126,
    KeyCode_Ex16 = 127,
    KeyCode_Ex17 = 128,
    KeyCode_Ex18 = 129,
    KeyCode_Ex19 = 130,
    KeyCode_Ex20 = 131,
    KeyCode_Ex21 = 132,
    KeyCode_Ex22 = 133,
    KeyCode_Ex23 = 134,
    KeyCode_Ex24 = 135,
    KeyCode_Ex25 = 136,
    KeyCode_Ex26 = 137,
    KeyCode_Ex27 = 138,
    KeyCode_Ex28 = 139,
    KeyCode_Ex29 = 140,
    KeyCode_COUNT = 141,
};
static char* key_code_name[KeyCode_COUNT] = {
    "None",
    "A",
    "B",
    "C",
    "D",
    "E",
    "F",
    "G",
    "H",
    "I",
    "J",
    "K",
    "L",
    "M",
    "N",
    "O",
    "P",
    "Q",
    "R",
    "S",
    "T",
    "U",
    "V",
    "W",
    "X",
    "Y",
    "Z",
    "0",
    "1",
    "2",
    "3",
    "4",
    "5",
    "6",
    "7",
    "8",
    "9",
    "Space",
    "Tick",
    "Minus",
    "Equal",
    "LeftBracket",
    "RightBracket",
    "Semicolon",
    "Quote",
    "Comma",
    "Period",
    "ForwardSlash",
    "BackwardSlash",
    "Tab",
    "Escape",
    "Pause",
    "Up",
    "Down",
    "Left",
    "Right",
    "Backspace",
    "Return",
    "Delete",
    "Insert",
    "Home",
    "End",
    "PageUp",
    "PageDown",
    "CapsLock",
    "NumLock",
    "ScrollLock",
    "Menu",
    "Shift",
    "Control",
    "Alt",
    "Command",
    "F1",
    "F2",
    "F3",
    "F4",
    "F5",
    "F6",
    "F7",
    "F8",
    "F9",
    "F10",
    "F11",
    "F12",
    "F13",
    "F14",
    "F15",
    "F16",
    "F17",
    "F18",
    "F19",
    "F20",
    "F21",
    "F22",
    "F23",
    "F24",
    "NumPad0",
    "NumPad1",
    "NumPad2",
    "NumPad3",
    "NumPad4",
    "NumPad5",
    "NumPad6",
    "NumPad7",
    "NumPad8",
    "NumPad9",
    "NumPadStar",
    "NumPadPlus",
    "NumPadMinus",
    "NumPadDot",
    "NumPadSlash",
    "Ex0",
    "Ex1",
    "Ex2",
    "Ex3",
    "Ex4",
    "Ex5",
    "Ex6",
    "Ex7",
    "Ex8",
    "Ex9",
    "Ex10",
    "Ex11",
    "Ex12",
    "Ex13",
    "Ex14",
    "Ex15",
    "Ex16",
    "Ex17",
    "Ex18",
    "Ex19",
    "Ex20",
    "Ex21",
    "Ex22",
    "Ex23",
    "Ex24",
    "Ex25",
    "Ex26",
    "Ex27",
    "Ex28",
    "Ex29",
};
enum{
    MouseCode_Left = 1,
    MouseCode_Middle = 2,
    MouseCode_Right = 3,
    MouseCode_COUNT = 4,
};
static char* mouse_code_name[MouseCode_COUNT] = {
    "None",
    "Left",
    "Middle",
    "Right",
};
enum{
    CoreCode_Startup = 1,
    CoreCode_Animate = 2,
    CoreCode_ClickActivateView = 3,
    CoreCode_ClickDeactivateView = 4,
    CoreCode_TryExit = 5,
    CoreCode_FileExternallyModified = 6,
    CoreCode_NewClipboardContents = 7,
    CoreCode_COUNT = 8,
};
static char* core_code_name[CoreCode_COUNT] = {
    "None",
    "Startup",
    "Animate",
    "ClickActivateView",
    "ClickDeactivateView",
    "TryExit",
    "FileExternallyModified",
    "NewClipboardContents",
};
# 16 "/home/sam/.bin/4coder/custom/4coder_events.h" 2

typedef u32 Input_Event_Kind;
enum{
    InputEventKind_None,
    InputEventKind_TextInsert,
    InputEventKind_KeyStroke,
    InputEventKind_KeyRelease,
    InputEventKind_MouseButton,
    InputEventKind_MouseButtonRelease,
    InputEventKind_MouseWheel,
    InputEventKind_MouseMove,
    InputEventKind_Core,
    InputEventKind_CustomFunction,

    InputEventKind_COUNT,
};

typedef u32 Key_Flags;
enum{
    KeyFlag_IsDeadKey = (1 << 0),
};

static const i32 Input_MaxModifierCount = 8;

struct Input_Modifier_Set{
    Key_Code *mods;
    i32 count;
};

struct Input_Modifier_Set_Fixed{
    Key_Code mods[Input_MaxModifierCount];
    i32 count;
};

struct Input_Event{
    Input_Event_Kind kind;
    b32 virtual_event;
    union{
        struct{
            String_Const_u8 string;


            Input_Event *next_text;
            b32 blocked;
        } text;
        struct{
            Key_Code code;
            Key_Flags flags;
            Input_Modifier_Set modifiers;


            Input_Event *first_dependent_text;
        } key;
        struct{
            Mouse_Code code;
            Vec2_i32 p;
            Input_Modifier_Set modifiers;
        } mouse;
        struct{
            f32 value;
            Vec2_i32 p;
            Input_Modifier_Set modifiers;
        } mouse_wheel;
        struct{
            Vec2_i32 p;
            Input_Modifier_Set modifiers;
        } mouse_move;
        struct{
            Core_Code code;
            union{
                String_Const_u8 string;
                i32 id;
                struct{
                    String_Const_u8_Array flag_strings;
                    String_Const_u8_Array file_names;
                };
            };
        } core;
        Custom_Command_Function *custom_func;
    };
};

struct Input_Event_Node{
    Input_Event_Node *next;
    Input_Event event;
};

struct Input_List{
    Input_Event_Node *first;
    Input_Event_Node *last;
    i32 count;
};

typedef u32 Event_Property;
enum{
    EventProperty_AnyKey = 0x0001,
    EventProperty_Escape = 0x0002,
    EventProperty_AnyKeyRelease = 0x0004,
    EventProperty_MouseButton = 0x0008,
    EventProperty_MouseRelease = 0x0010,
    EventProperty_MouseWheel = 0x0020,
    EventProperty_MouseMove = 0x0040,
    EventProperty_Animate = 0x0080,
    EventProperty_ViewActivation = 0x0100,
    EventProperty_TextInsert = 0x0200,
    EventProperty_AnyFile = 0x0400,
    EventProperty_Startup = 0x0800,
    EventProperty_Exit = 0x1000,
    EventProperty_Clipboard = 0x2000,
    EventProperty_CustomFunction = 0x4000,
};
enum{
    EventPropertyGroup_AnyKeyboardEvent =
        EventProperty_AnyKey|
        EventProperty_Escape|
        EventProperty_AnyKeyRelease|
        EventProperty_TextInsert,
    EventPropertyGroup_AnyMouseEvent =
        EventProperty_MouseButton|
        EventProperty_MouseRelease|
        EventProperty_MouseWheel|
        EventProperty_MouseMove,
    EventPropertyGroup_AnyUserInput =
        EventPropertyGroup_AnyKeyboardEvent|
        EventPropertyGroup_AnyMouseEvent,
    EventPropertyGroup_AnyCore =
        EventProperty_Animate|
        EventProperty_ViewActivation|
        EventProperty_AnyFile|
        EventProperty_Startup|
        EventProperty_Exit|
        EventProperty_Clipboard|
        EventProperty_Animate,
    EventPropertyGroup_Any =
        EventPropertyGroup_AnyUserInput|
        EventPropertyGroup_AnyCore|
        EventProperty_CustomFunction,
};
# 18 "/home/sam/.bin/4coder/custom/4coder_default_include.cpp" 2
# 1 "/home/sam/.bin/4coder/custom/4coder_types.h" 1




struct Thread_Context_Extra_Info{
    void *coroutine;
    void *async_thread;
};

struct Application_Links{
    Thread_Context *tctx;
    void *cmd_context;
};

typedef void Custom_Layer_Init_Type(Application_Links *app);
void custom_layer_init(Application_Links *app);


typedef b32 _Get_Version_Type(i32 maj, i32 min, i32 patch);

typedef Custom_Layer_Init_Type *_Init_APIs_Type(struct API_VTable_custom *custom_vtable,
                                                struct API_VTable_system *system_vtable);




typedef u16 ID_Color;


union FColor{
    struct{
        u8 padding__[3];
        u8 a_byte;
    };
    ARGB_Color argb;
    struct{
        ID_Color id;
        u8 sub_index;
        u8 padding_;
    };
};


struct Theme_Color{
    ID_Color tag;
    ARGB_Color color;
};


struct Color_Array{
    ARGB_Color *vals;
    i32 count;
};


struct Color_Table{
    Color_Array *arrays;
    i32 count;
};


struct Color_Picker{
    String_Const_u8 title;
    ARGB_Color *dest;
    b32 *finished;
};




typedef u32 Face_ID;


struct Fancy_String{
    Fancy_String *next;
    String_Const_u8 value;
    Face_ID face;
    FColor fore;
    f32 pre_margin;
    f32 post_margin;
};


struct Fancy_Line{
    Fancy_Line *next;
    Face_ID face;
    FColor fore;
    Fancy_String *first;
    Fancy_String *last;
};


struct Fancy_Block{
    Fancy_Line *first;
    Fancy_Line *last;
    i32 line_count;
};




typedef i32 Buffer_ID;


typedef i32 View_ID;


typedef i32 Panel_ID;


typedef u32 Text_Layout_ID;


typedef u32 Child_Process_ID;


typedef i32 UI_Highlight_Level;
enum{
    UIHighlight_None,
    UIHighlight_Hover,
    UIHighlight_Active,
};


struct Buffer_Point{
    i64 line_number;
    Vec2_f32 pixel_shift;
};


struct Line_Shift_Vertical{
    i64 line;
    f32 y_delta;
};


struct Line_Shift_Character{
    i64 line;
    i64 character_delta;
};


typedef u32 Child_Process_Set_Target_Flags;
enum{
    ChildProcessSet_FailIfBufferAlreadyAttachedToAProcess = 1,
    ChildProcessSet_FailIfProcessAlreadyAttachedToABuffer = 2,
    ChildProcessSet_NeverOverrideExistingAttachment = 3,
    ChildProcessSet_CursorAtEnd = 4,
};


typedef u32 Memory_Protect_Flags;
enum{
    MemProtect_Read = 0x1,
    MemProtect_Write = 0x2,
    MemProtect_Execute = 0x4,
};


typedef i32 Wrap_Indicator_Mode;
enum{
    WrapIndicator_Hide,
    WrapIndicator_Show_After_Line,
    WrapIndicator_Show_At_Wrap_Edge,
};


typedef i32 Global_Setting_ID;
enum{
    GlobalSetting_Null,
    GlobalSetting_LAltLCtrlIsAltGr,
};


typedef i32 Buffer_Setting_ID;
enum{
    BufferSetting_Null,
    BufferSetting_Unimportant,
    BufferSetting_ReadOnly,
    BufferSetting_RecordsHistory,
    BufferSetting_Unkillable,
};


struct Character_Predicate{
    u8 b[32];
};


struct Frame_Info{
    i32 index;
    f32 literal_dt;
    f32 animation_dt;
};


typedef i32 View_Setting_ID;
enum{
    ViewSetting_Null,
    ViewSetting_ShowWhitespace,
    ViewSetting_ShowScrollbar,
    ViewSetting_ShowFileBar,
};


typedef u32 Buffer_Create_Flag;
enum{
    BufferCreate_Background = 0x1,
    BufferCreate_AlwaysNew = 0x2,
    BufferCreate_NeverNew = 0x4,
    BufferCreate_JustChangedFile = 0x8,
    BufferCreate_MustAttachToFile = 0x10,
    BufferCreate_NeverAttachToFile = 0x20,
    BufferCreate_SuppressNewFileHook = 0x40,
};


typedef u32 Buffer_Save_Flag;
enum{
    BufferSave_IgnoreDirtyFlag = 0x1,
};


typedef u32 Buffer_Kill_Flag;
enum{
    BufferKill_AlwaysKill = 0x2,
};


typedef u32 Buffer_Reopen_Flag;
enum{};


typedef u32 Buffer_Kill_Result;
enum{
    BufferKillResult_Killed = 0,
    BufferKillResult_Dirty = 1,
    BufferKillResult_Unkillable = 2,
    BufferKillResult_DoesNotExist = 3,
};


typedef u32 Buffer_Reopen_Result;
enum{
    BufferReopenResult_Reopened = 0,
    BufferReopenResult_Failed = 1,
};


typedef u32 Access_Flag;
enum{
    Access_Write = 0x1,
    Access_Read = 0x2,
    Access_Visible = 0x4,
};
enum{
    Access_Always = 0,
    Access_ReadWrite = Access_Write|Access_Read,
    Access_ReadVisible = Access_Read|Access_Visible,
    Access_ReadWriteVisible = Access_Write|Access_Read|Access_Visible,
};


typedef i32 Dirty_State;
enum{
    DirtyState_UpToDate = 0,
    DirtyState_UnsavedChanges = 1,
    DirtyState_UnloadedChanges = 2,
    DirtyState_UnsavedChangesAndUnloadedChanges = 3,
};


typedef u32 Command_Line_Interface_Flag;
enum{
    CLI_OverlapWithConflict = 0x1,
    CLI_AlwaysBindToView = 0x2,
    CLI_CursorAtEnd = 0x4,
    CLI_SendEndSignal = 0x8,
};


typedef u32 Set_Buffer_Flag;
enum{
    SetBuffer_KeepOriginalGUI = 0x1
};


typedef i32 Mouse_Cursor_Show_Type;
enum{
    MouseCursorShow_Never,
    MouseCursorShow_Always,
};


typedef i32 View_Split_Position;
enum{
    ViewSplit_Top,
    ViewSplit_Bottom,
    ViewSplit_Left,
    ViewSplit_Right,
};


typedef i32 Panel_Split_Kind;
enum{
    PanelSplitKind_Ratio_Min = 0,
    PanelSplitKind_Ratio_Max = 1,
    PanelSplitKind_FixedPixels_Min = 2,
    PanelSplitKind_FixedPixels_Max = 3,
};


typedef u8 Key_Modifier;


struct Mouse_State{
    b8 l;
    b8 r;
    b8 press_l;
    b8 press_r;
    b8 release_l;
    b8 release_r;
    b8 out_of_window;
    i32 wheel;
    union{
        struct{
            i32 x;
            i32 y;
        };
        Vec2_i32 p;
    };
};


struct Parser_String_And_Type{
    char *str;
    u32 length;
    u32 type;
};


typedef u32 File_Attribute_Flag;
enum{
    FileAttribute_IsDirectory = 1,
};


struct File_Attributes{
    u64 size;
    u64 last_write_time;
    File_Attribute_Flag flags;
};


struct File_Info{
    File_Info *next;
    String_Const_u8 file_name;
    File_Attributes attributes;
};


struct File_List{
    File_Info **infos;
    u32 count;
};


struct Buffer_Identifier{
    char *name;
    i32 name_len;
    Buffer_ID id;
};


typedef i32 Set_Buffer_Scroll_Rule;
enum{
    SetBufferScroll_NoCursorChange,
    SetBufferScroll_SnapCursorIntoView,
};


struct Buffer_Scroll{
    Buffer_Point position;
    Buffer_Point target;
};


struct Basic_Scroll{
    Vec2_f32 position;
    Vec2_f32 target;
};


typedef i32 Buffer_Seek_Type;
enum{
    buffer_seek_pos,
    buffer_seek_line_col,
};


struct Buffer_Seek{
    Buffer_Seek_Type type;
    union{
        struct{
            i64 pos;
        };
        struct{
            i64 line;
            i64 col;
        };
    };
};


struct Buffer_Cursor{
    i64 pos;
    i64 line;
    i64 col;
};


union Range_Cursor{
    struct{
        Buffer_Cursor min;
        Buffer_Cursor max;
    };
    struct{
        Buffer_Cursor start;
        Buffer_Cursor end;
    };
    struct{
        Buffer_Cursor first;
        Buffer_Cursor one_past_last;
    };
};


struct Marker{
    i64 pos;
    b32 lean_right;
};


typedef i32 Managed_Object_Type;
enum{
    ManagedObjectType_Error = 0,
    ManagedObjectType_Memory = 1,
    ManagedObjectType_Markers = 2,

    ManagedObjectType_COUNT = 4,
};


typedef u64 Managed_ID;


typedef u64 Managed_Scope;

typedef u64 Managed_Object;


struct Marker_Visual{
    Managed_Scope scope;
    u32 slot_id;
    u32 gen_id;
};


typedef u32 Glyph_Flag;
enum{
    GlyphFlag_None = 0x0,
};


struct Query_Bar{
    String_Const_u8 prompt;
    String_Const_u8 string;
    u64 string_capacity;
};


struct Query_Bar_Ptr_Array{
    Query_Bar **ptrs;
    i32 count;
};


struct Query_Bar_Group{
    Application_Links *app;
    View_ID view;

    Query_Bar_Group(Application_Links *app);
    Query_Bar_Group(Application_Links *app, View_ID view);
    ~Query_Bar_Group();
};


struct Font_Load_Location{
    String_Const_u8 file_name;
};


struct Face_Load_Parameters{
    u32 pt_size;
    b32 bold;
    b32 italic;
    b32 underline;
    b32 hinting;
};


struct Face_Description{
    Font_Load_Location font;
    Face_Load_Parameters parameters;
};


struct Face_Metrics{
    f32 text_height;
    f32 line_height;
    f32 ascent;
    f32 descent;
    f32 line_skip;

    f32 underline_yoff1;
    f32 underline_yoff2;

    f32 max_advance;
    f32 space_advance;
    f32 decimal_digit_advance;
    f32 hex_digit_advance;
    f32 byte_advance;
    f32 byte_sub_advances[3];
    f32 normal_lowercase_advance;
    f32 normal_uppercase_advance;
    f32 normal_advance;
};


struct Codepoint_Index_Map{
    b32 has_zero_index;
    u16 zero_index;
    u16 max_index;
    Table_u32_u16 table;
};


struct Face_Advance_Map{
    Codepoint_Index_Map codepoint_to_index;
    f32 *advance;
    u16 index_count;
};


struct Edit{
    String_Const_u8 text;
    Range_i64 range;
};


struct Batch_Edit{
    Batch_Edit *next;
    Edit edit;
};


typedef i32 Record_Kind;
enum{
    RecordKind_Single,
    RecordKind_Group,
};


typedef i32 Record_Error;
enum{
    RecordError_NoError,
    RecordError_InvalidBuffer,
    RecordError_NoHistoryAttached,
    RecordError_IndexOutOfBounds,
    RecordError_SubIndexOutOfBounds,
    RecordError_InitialStateDummyRecord,
    RecordError_WrongRecordTypeAtIndex,
};


typedef u32 Record_Merge_Flag;
enum{
    RecordMergeFlag_StateInRange_MoveStateForward = 0x0,
    RecordMergeFlag_StateInRange_MoveStateBackward = 0x1,
    RecordMergeFlag_StateInRange_ErrorOut = 0x2,
};


typedef i32 History_Record_Index;


struct Record_Info{
    Record_Error error;
    Record_Kind kind;
    i64 pos_before_edit;
    i32 edit_number;
    union{
        struct{
            String_Const_u8 single_string_forward;
            String_Const_u8 single_string_backward;
            i64 single_first;
        };
        struct{
            i32 group_count;
        };
    };
};
# 630 "/home/sam/.bin/4coder/custom/4coder_types.h"

struct User_Input{
    Input_Event event;
    b32 abort;
};


typedef i32 Hook_ID;
enum{
    HookID_Tick,
    HookID_RenderCaller,
    HookID_WholeScreenRenderCaller,
    HookID_DeltaRule,
    HookID_BufferViewerUpdate,
    HookID_ViewEventHandler,
    HookID_BufferNameResolver,
    HookID_BeginBuffer,
    HookID_EndBuffer,
    HookID_NewFile,
    HookID_SaveFile,
    HookID_BufferEditRange,
    HookID_BufferRegion,
    HookID_Layout,
    HookID_ViewChangeBuffer,
};


typedef i32 Hook_Function(Application_Links *app);



struct Buffer_Name_Conflict_Entry{
    Buffer_ID buffer_id;
    String_Const_u8 file_name;
    String_Const_u8 base_name;
    u8 *unique_name_in_out;
    u64 unique_name_len_in_out;
    u64 unique_name_capacity;
};


typedef void Buffer_Name_Resolver_Function(Application_Links *app, Buffer_Name_Conflict_Entry *conflicts, i32 conflict_count);



typedef i32 Buffer_Hook_Function(Application_Links *app, Buffer_ID buffer_id);



typedef i32 Buffer_Edit_Range_Function(Application_Links *app, Buffer_ID buffer_id,
                                       Range_i64 new_range, Range_Cursor old_range);



typedef Vec2_f32 Delta_Rule_Function(Vec2_f32 pending, b32 is_new_target, f32 dt, void *data);



typedef Rect_f32 Buffer_Region_Function(Application_Links *app, View_ID view_id, Rect_f32 region);


typedef void New_Clipboard_Contents_Function(Application_Links *app, String_Const_u8 contents);



typedef void Tick_Function(Application_Links *app, Frame_Info frame_info);


typedef void Render_Caller_Function(Application_Links *app, Frame_Info frame_info, View_ID view);


typedef void Whole_Screen_Render_Caller_Function(Application_Links *app, Frame_Info frame_info);


typedef void View_Change_Buffer_Function(Application_Links *app, View_ID view_id,
                                         Buffer_ID old_buffer_id, Buffer_ID new_buffer_id);


typedef u32 Layout_Item_Flag;
enum{
    LayoutItemFlag_Special_Character = (1 << 0),
    LayoutItemFlag_Ghost_Character = (1 << 1)
};


struct Layout_Item{
    i64 index;
    u32 codepoint;
    Layout_Item_Flag flags;
    Rect_f32 rect;
    f32 padded_y1;
};


struct Layout_Item_Block{
    Layout_Item_Block *next;
    Layout_Item *items;
    i64 item_count;
    i64 character_count;
    Face_ID face;
};


struct Layout_Item_List{
    Layout_Item_Block *first;
    Layout_Item_Block *last;
    i64 item_count;
    i64 character_count;
    i32 node_count;
    f32 height;
    f32 bottom_padding;
    Range_i64 input_index_range;
    Range_i64 manifested_index_range;
};


typedef Layout_Item_List Layout_Function(Application_Links *app, Arena *arena, Buffer_ID buffer, Range_i64 range, Face_ID face, f32 width);


struct View_Context{
    Render_Caller_Function *render_caller;
    Delta_Rule_Function *delta_rule;
    u64 delta_rule_memory_size;
    b32 hides_buffer;
    struct Mapping *mapping;
    i64 map_id;
};


typedef u32 String_Match_Flag;
enum{
    StringMatch_CaseSensitive = 1,
    StringMatch_LeftSideSloppy = 2,
    StringMatch_RightSideSloppy = 4,
    StringMatch_Straddled = 8,
};


struct String_Match{
    String_Match *next;
    Buffer_ID buffer;
    i32 string_id;
    String_Match_Flag flags;
    Range_i64 range;
};


struct String_Match_List{
    String_Match *first;
    String_Match *last;
    i32 count;
};


struct Process_State{
    b32 valid;
    b32 is_updating;
    i64 return_code;
};
# 19 "/home/sam/.bin/4coder/custom/4coder_default_include.cpp" 2
# 1 "/home/sam/.bin/4coder/custom/4coder_doc_content_types.h" 1
# 10 "/home/sam/.bin/4coder/custom/4coder_doc_content_types.h"
typedef i32 Doc_Month;
enum{
    None,
     January,
     February,
     March,
     April,
     May,
     June,
     July,
     August,
     September,
     October,
     November,
     December,
};
char *doc_month_names[] = {
    "None",
    "January",
    "February",
    "March",
    "April",
    "May",
    "June",
    "July",
    "August",
    "September",
    "October",
    "November",
    "December",
};
char *doc_day_names[] = {
    "0",
    "1st",
    "2nd",
    "3rd",
    "4th",
    "5th",
    "6th",
    "7th",
    "8th",
    "9th",
    "10th",
    "11th",
    "12th",
    "13th",
    "14th",
    "15th",
    "16th",
    "17th",
    "18th",
    "19th",
    "20th",
    "21st",
    "22nd",
    "23rd",
    "24th",
    "25th",
    "26th",
    "27th",
    "28th",
    "29th",
    "30th",
    "31st",
};

struct Doc_Date{
    i32 day;
    Doc_Month month;
    i32 year;
};

typedef i32 Doc_Content_Emphasis;
enum{
    DocContentEmphasis_Normal,
    DocContentEmphasis_SmallHeader,
    DocContentEmphasis_Heavy,
    DocContentEmphasis_Stylish,
    DocContentEmphasis_Code,
};
struct Doc_Content{
    Doc_Content *next;
    String_Const_u8 text;
    String_Const_u8 page_link;
    String_Const_u8 block_link;
    Doc_Content_Emphasis emphasis;
};
struct Doc_Content_List{
    Doc_Content *first;
    Doc_Content *last;
    u64 total_size;
    i32 node_count;
};

typedef i32 Doc_Code_Language;
enum{
    DocCodeLanguage_None,
    DocCodeLanguage_Cpp,
    DocCodeLanguage_Bat,
};
char *doc_language_name[] = {
    "none",
    "C++",
    "Batch",
};
struct Doc_Code_Sample{
    Doc_Code_Sample *next;
    String_Const_u8 contents;
    Doc_Code_Language language;
};
struct Doc_Code_Sample_List{
    Doc_Code_Sample *first;
    Doc_Code_Sample *last;
    i32 count;
};

typedef i32 Doc_Paragraph_Kind;
enum{
    DocParagraphKind_Text,
    DocParagraphKind_Code,
    DocParagraphKind_Table,
};
struct Doc_Paragraph{
    Doc_Paragraph *next;
    Doc_Paragraph_Kind kind;
    union{
        Doc_Content_List text;
        Doc_Code_Sample_List code;
        struct{
            Vec2_i32 dim;
            Doc_Content_List *vals;
        } table;
    };
};

struct Doc_Block{
    Doc_Block *next;

    struct Doc_Page *owner;

    String_Const_u8 name;

    Doc_Paragraph *first_par;
    Doc_Paragraph *last_par;
    i32 par_count;
};

struct Doc_Block_Ptr{
    Doc_Block_Ptr *next;
    Doc_Block *block;
};

struct Doc_Block_List{
    Doc_Block_Ptr *first;
    Doc_Block_Ptr *last;
    i32 count;
};

struct Doc_Page{
    Doc_Page *next;

    struct Doc_Cluster *owner;

    String_Const_u8 title;
    String_Const_u8 name;

    Doc_Block *first_block;
    Doc_Block *last_block;
    i32 block_count;

    Doc_Block_List quick_jumps;
};

struct Doc_Log{
    Doc_Log *next;
    String_Const_u8 content;
};

struct Doc_Cluster{
    String_Const_u8 title;
    String_Const_u8 name;
    Doc_Date gen_date;

    Doc_Page *first_page;
    Doc_Page *last_page;
    i32 page_count;

    Doc_Log *first_log;
    Doc_Log *last_log;
};
# 20 "/home/sam/.bin/4coder/custom/4coder_default_include.cpp" 2
# 1 "/home/sam/.bin/4coder/custom/4coder_default_colors.h" 1
# 10 "/home/sam/.bin/4coder/custom/4coder_default_colors.h"
CUSTOM_ID(colors, defcolor_bar);
CUSTOM_ID(colors, defcolor_base);
CUSTOM_ID(colors, defcolor_pop1);
CUSTOM_ID(colors, defcolor_pop2);
CUSTOM_ID(colors, defcolor_back);
CUSTOM_ID(colors, defcolor_margin);
CUSTOM_ID(colors, defcolor_margin_hover);
CUSTOM_ID(colors, defcolor_margin_active);
CUSTOM_ID(colors, defcolor_list_item);
CUSTOM_ID(colors, defcolor_list_item_hover);
CUSTOM_ID(colors, defcolor_list_item_active);
CUSTOM_ID(colors, defcolor_cursor);
CUSTOM_ID(colors, defcolor_at_cursor);
CUSTOM_ID(colors, defcolor_highlight_cursor_line);
CUSTOM_ID(colors, defcolor_highlight);
CUSTOM_ID(colors, defcolor_at_highlight);
CUSTOM_ID(colors, defcolor_mark);
CUSTOM_ID(colors, defcolor_text_default);
CUSTOM_ID(colors, defcolor_comment);
CUSTOM_ID(colors, defcolor_comment_pop);
CUSTOM_ID(colors, defcolor_keyword);
CUSTOM_ID(colors, defcolor_str_constant);
CUSTOM_ID(colors, defcolor_char_constant);
CUSTOM_ID(colors, defcolor_int_constant);
CUSTOM_ID(colors, defcolor_float_constant);
CUSTOM_ID(colors, defcolor_bool_constant);
CUSTOM_ID(colors, defcolor_preproc);
CUSTOM_ID(colors, defcolor_include);
CUSTOM_ID(colors, defcolor_special_character);
CUSTOM_ID(colors, defcolor_ghost_character);
CUSTOM_ID(colors, defcolor_highlight_junk);
CUSTOM_ID(colors, defcolor_highlight_white);
CUSTOM_ID(colors, defcolor_paste);
CUSTOM_ID(colors, defcolor_undo);
CUSTOM_ID(colors, defcolor_back_cycle);
CUSTOM_ID(colors, defcolor_text_cycle);
CUSTOM_ID(colors, defcolor_line_numbers_back);
CUSTOM_ID(colors, defcolor_line_numbers_text);

struct Color_Table_Node{
    Color_Table_Node *next;
    String_Const_u8 name;
    Color_Table table;
};

struct Color_Table_List{
    Color_Table_Node *first;
    Color_Table_Node *last;
    i32 count;
};

static Color_Table active_color_table = {};
static Color_Table default_color_table = {};

static Arena global_theme_arena = {};
static Color_Table_List global_theme_list = {};
# 21 "/home/sam/.bin/4coder/custom/4coder_default_include.cpp" 2

# 1 "/home/sam/.bin/4coder/custom/generated/custom_api.h" 1
# 180 "/home/sam/.bin/4coder/custom/generated/custom_api.h"
typedef b32 custom_global_set_setting_type(Application_Links* app, Global_Setting_ID setting, i64 value);
typedef Rect_f32 custom_global_get_screen_rectangle_type(Application_Links* app);
typedef Thread_Context* custom_get_thread_context_type(Application_Links* app);
typedef Child_Process_ID custom_create_child_process_type(Application_Links* app, String_Const_u8 path, String_Const_u8 command);
typedef b32 custom_child_process_set_target_buffer_type(Application_Links* app, Child_Process_ID child_process_id, Buffer_ID buffer_id, Child_Process_Set_Target_Flags flags);
typedef Child_Process_ID custom_buffer_get_attached_child_process_type(Application_Links* app, Buffer_ID buffer_id);
typedef Buffer_ID custom_child_process_get_attached_buffer_type(Application_Links* app, Child_Process_ID child_process_id);
typedef Process_State custom_child_process_get_state_type(Application_Links* app, Child_Process_ID child_process_id);
typedef b32 custom_enqueue_virtual_event_type(Application_Links* app, Input_Event* event);
typedef i32 custom_get_buffer_count_type(Application_Links* app);
typedef Buffer_ID custom_get_buffer_next_type(Application_Links* app, Buffer_ID buffer_id, Access_Flag access);
typedef Buffer_ID custom_get_buffer_by_name_type(Application_Links* app, String_Const_u8 name, Access_Flag access);
typedef Buffer_ID custom_get_buffer_by_file_name_type(Application_Links* app, String_Const_u8 file_name, Access_Flag access);
typedef b32 custom_buffer_read_range_type(Application_Links* app, Buffer_ID buffer_id, Range_i64 range, u8* out);
typedef b32 custom_buffer_replace_range_type(Application_Links* app, Buffer_ID buffer_id, Range_i64 range, String_Const_u8 string);
typedef b32 custom_buffer_batch_edit_type(Application_Links* app, Buffer_ID buffer_id, Batch_Edit* batch);
typedef String_Match custom_buffer_seek_string_type(Application_Links* app, Buffer_ID buffer, String_Const_u8 needle, Scan_Direction direction, i64 start_pos);
typedef String_Match custom_buffer_seek_character_class_type(Application_Links* app, Buffer_ID buffer, Character_Predicate* predicate, Scan_Direction direction, i64 start_pos);
typedef f32 custom_buffer_line_y_difference_type(Application_Links* app, Buffer_ID buffer_id, f32 width, Face_ID face_id, i64 line_a, i64 line_b);
typedef Line_Shift_Vertical custom_buffer_line_shift_y_type(Application_Links* app, Buffer_ID buffer_id, f32 width, Face_ID face_id, i64 line, f32 y_shift);
typedef i64 custom_buffer_pos_at_relative_xy_type(Application_Links* app, Buffer_ID buffer_id, f32 width, Face_ID face_id, i64 base_line, Vec2_f32 relative_xy);
typedef Rect_f32 custom_buffer_relative_box_of_pos_type(Application_Links* app, Buffer_ID buffer_id, f32 width, Face_ID face_id, i64 base_line, i64 pos);
typedef Rect_f32 custom_buffer_padded_box_of_pos_type(Application_Links* app, Buffer_ID buffer_id, f32 width, Face_ID face_id, i64 base_line, i64 pos);
typedef i64 custom_buffer_relative_character_from_pos_type(Application_Links* app, Buffer_ID buffer_id, f32 width, Face_ID face_id, i64 base_line, i64 pos);
typedef i64 custom_buffer_pos_from_relative_character_type(Application_Links* app, Buffer_ID buffer_id, f32 width, Face_ID face_id, i64 base_line, i64 relative_character);
typedef f32 custom_view_line_y_difference_type(Application_Links* app, View_ID view_id, i64 line_a, i64 line_b);
typedef Line_Shift_Vertical custom_view_line_shift_y_type(Application_Links* app, View_ID view_id, i64 line, f32 y_shift);
typedef i64 custom_view_pos_at_relative_xy_type(Application_Links* app, View_ID view_id, i64 base_line, Vec2_f32 relative_xy);
typedef Rect_f32 custom_view_relative_box_of_pos_type(Application_Links* app, View_ID view_id, i64 base_line, i64 pos);
typedef Rect_f32 custom_view_padded_box_of_pos_type(Application_Links* app, View_ID view_id, i64 base_line, i64 pos);
typedef i64 custom_view_relative_character_from_pos_type(Application_Links* app, View_ID view_id, i64 base_line, i64 pos);
typedef i64 custom_view_pos_from_relative_character_type(Application_Links* app, View_ID view_id, i64 base_line, i64 character);
typedef b32 custom_buffer_exists_type(Application_Links* app, Buffer_ID buffer_id);
typedef Access_Flag custom_buffer_get_access_flags_type(Application_Links* app, Buffer_ID buffer_id);
typedef i64 custom_buffer_get_size_type(Application_Links* app, Buffer_ID buffer_id);
typedef i64 custom_buffer_get_line_count_type(Application_Links* app, Buffer_ID buffer_id);
typedef String_Const_u8 custom_push_buffer_base_name_type(Application_Links* app, Arena* arena, Buffer_ID buffer_id);
typedef String_Const_u8 custom_push_buffer_unique_name_type(Application_Links* app, Arena* out, Buffer_ID buffer_id);
typedef String_Const_u8 custom_push_buffer_file_name_type(Application_Links* app, Arena* arena, Buffer_ID buffer_id);
typedef Dirty_State custom_buffer_get_dirty_state_type(Application_Links* app, Buffer_ID buffer_id);
typedef b32 custom_buffer_set_dirty_state_type(Application_Links* app, Buffer_ID buffer_id, Dirty_State dirty_state);
typedef b32 custom_buffer_set_layout_type(Application_Links* app, Buffer_ID buffer_id, Layout_Function* layout_func);
typedef b32 custom_buffer_clear_layout_cache_type(Application_Links* app, Buffer_ID buffer_id);
typedef Layout_Function* custom_buffer_get_layout_type(Application_Links* app, Buffer_ID buffer_id);
typedef b32 custom_buffer_get_setting_type(Application_Links* app, Buffer_ID buffer_id, Buffer_Setting_ID setting, i64* value_out);
typedef b32 custom_buffer_set_setting_type(Application_Links* app, Buffer_ID buffer_id, Buffer_Setting_ID setting, i64 value);
typedef Managed_Scope custom_buffer_get_managed_scope_type(Application_Links* app, Buffer_ID buffer_id);
typedef b32 custom_buffer_send_end_signal_type(Application_Links* app, Buffer_ID buffer_id);
typedef Buffer_ID custom_create_buffer_type(Application_Links* app, String_Const_u8 file_name, Buffer_Create_Flag flags);
typedef b32 custom_buffer_save_type(Application_Links* app, Buffer_ID buffer_id, String_Const_u8 file_name, Buffer_Save_Flag flags);
typedef Buffer_Kill_Result custom_buffer_kill_type(Application_Links* app, Buffer_ID buffer_id, Buffer_Kill_Flag flags);
typedef Buffer_Reopen_Result custom_buffer_reopen_type(Application_Links* app, Buffer_ID buffer_id, Buffer_Reopen_Flag flags);
typedef File_Attributes custom_buffer_get_file_attributes_type(Application_Links* app, Buffer_ID buffer_id);
typedef View_ID custom_get_view_next_type(Application_Links* app, View_ID view_id, Access_Flag access);
typedef View_ID custom_get_view_prev_type(Application_Links* app, View_ID view_id, Access_Flag access);
typedef View_ID custom_get_this_ctx_view_type(Application_Links* app, Access_Flag access);
typedef View_ID custom_get_active_view_type(Application_Links* app, Access_Flag access);
typedef b32 custom_view_exists_type(Application_Links* app, View_ID view_id);
typedef Buffer_ID custom_view_get_buffer_type(Application_Links* app, View_ID view_id, Access_Flag access);
typedef i64 custom_view_get_cursor_pos_type(Application_Links* app, View_ID view_id);
typedef i64 custom_view_get_mark_pos_type(Application_Links* app, View_ID view_id);
typedef f32 custom_view_get_preferred_x_type(Application_Links* app, View_ID view_id);
typedef b32 custom_view_set_preferred_x_type(Application_Links* app, View_ID view_id, f32 x);
typedef Rect_f32 custom_view_get_screen_rect_type(Application_Links* app, View_ID view_id);
typedef Panel_ID custom_view_get_panel_type(Application_Links* app, View_ID view_id);
typedef View_ID custom_panel_get_view_type(Application_Links* app, Panel_ID panel_id, Access_Flag access);
typedef b32 custom_panel_is_split_type(Application_Links* app, Panel_ID panel_id);
typedef b32 custom_panel_is_leaf_type(Application_Links* app, Panel_ID panel_id);
typedef b32 custom_panel_split_type(Application_Links* app, Panel_ID panel_id, Dimension split_dim);
typedef b32 custom_panel_set_split_type(Application_Links* app, Panel_ID panel_id, Panel_Split_Kind kind, f32 t);
typedef b32 custom_panel_swap_children_type(Application_Links* app, Panel_ID panel_id);
typedef Panel_ID custom_panel_get_root_type(Application_Links* app);
typedef Panel_ID custom_panel_get_parent_type(Application_Links* app, Panel_ID panel_id);
typedef Panel_ID custom_panel_get_child_type(Application_Links* app, Panel_ID panel_id, Side which_child);
typedef b32 custom_view_close_type(Application_Links* app, View_ID view_id);
typedef Rect_f32 custom_view_get_buffer_region_type(Application_Links* app, View_ID view_id);
typedef Buffer_Scroll custom_view_get_buffer_scroll_type(Application_Links* app, View_ID view_id);
typedef b32 custom_view_set_active_type(Application_Links* app, View_ID view_id);
typedef b32 custom_view_enqueue_command_function_type(Application_Links* app, View_ID view_id, Custom_Command_Function* custom_func);
typedef b32 custom_view_get_setting_type(Application_Links* app, View_ID view_id, View_Setting_ID setting, i64* value_out);
typedef b32 custom_view_set_setting_type(Application_Links* app, View_ID view_id, View_Setting_ID setting, i64 value);
typedef Managed_Scope custom_view_get_managed_scope_type(Application_Links* app, View_ID view_id);
typedef Buffer_Cursor custom_buffer_compute_cursor_type(Application_Links* app, Buffer_ID buffer, Buffer_Seek seek);
typedef Buffer_Cursor custom_view_compute_cursor_type(Application_Links* app, View_ID view_id, Buffer_Seek seek);
typedef b32 custom_view_set_camera_bounds_type(Application_Links* app, View_ID view_id, Vec2_f32 margin, Vec2_f32 push_in_multiplier);
typedef b32 custom_view_get_camera_bounds_type(Application_Links* app, View_ID view_id, Vec2_f32* margin, Vec2_f32* push_in_multiplier);
typedef b32 custom_view_set_cursor_type(Application_Links* app, View_ID view_id, Buffer_Seek seek);
typedef b32 custom_view_set_buffer_scroll_type(Application_Links* app, View_ID view_id, Buffer_Scroll scroll, Set_Buffer_Scroll_Rule rule);
typedef b32 custom_view_set_mark_type(Application_Links* app, View_ID view_id, Buffer_Seek seek);
typedef b32 custom_view_quit_ui_type(Application_Links* app, View_ID view_id);
typedef b32 custom_view_set_buffer_type(Application_Links* app, View_ID view_id, Buffer_ID buffer_id, Set_Buffer_Flag flags);
typedef b32 custom_view_push_context_type(Application_Links* app, View_ID view_id, View_Context* ctx);
typedef b32 custom_view_pop_context_type(Application_Links* app, View_ID view_id);
typedef b32 custom_view_alter_context_type(Application_Links* app, View_ID view_id, View_Context* ctx);
typedef View_Context custom_view_current_context_type(Application_Links* app, View_ID view_id);
typedef Data custom_view_current_context_hook_memory_type(Application_Links* app, View_ID view_id, Hook_ID hook_id);
typedef Managed_Scope custom_create_user_managed_scope_type(Application_Links* app);
typedef b32 custom_destroy_user_managed_scope_type(Application_Links* app, Managed_Scope scope);
typedef Managed_Scope custom_get_global_managed_scope_type(Application_Links* app);
typedef Managed_Scope custom_get_managed_scope_with_multiple_dependencies_type(Application_Links* app, Managed_Scope* scopes, i32 count);
typedef b32 custom_managed_scope_clear_contents_type(Application_Links* app, Managed_Scope scope);
typedef b32 custom_managed_scope_clear_self_all_dependent_scopes_type(Application_Links* app, Managed_Scope scope);
typedef Base_Allocator* custom_managed_scope_allocator_type(Application_Links* app, Managed_Scope scope);
typedef u64 custom_managed_id_group_highest_id_type(Application_Links* app, String_Const_u8 group);
typedef Managed_ID custom_managed_id_declare_type(Application_Links* app, String_Const_u8 group, String_Const_u8 name);
typedef Managed_ID custom_managed_id_get_type(Application_Links* app, String_Const_u8 group, String_Const_u8 name);
typedef void* custom_managed_scope_get_attachment_type(Application_Links* app, Managed_Scope scope, Managed_ID id, u64 size);
typedef b32 custom_managed_scope_attachment_erase_type(Application_Links* app, Managed_Scope scope, Managed_ID id);
typedef Managed_Object custom_alloc_managed_memory_in_scope_type(Application_Links* app, Managed_Scope scope, i32 item_size, i32 count);
typedef Managed_Object custom_alloc_buffer_markers_on_buffer_type(Application_Links* app, Buffer_ID buffer_id, i32 count, Managed_Scope* optional_extra_scope);
typedef u32 custom_managed_object_get_item_size_type(Application_Links* app, Managed_Object object);
typedef u32 custom_managed_object_get_item_count_type(Application_Links* app, Managed_Object object);
typedef void* custom_managed_object_get_pointer_type(Application_Links* app, Managed_Object object);
typedef Managed_Object_Type custom_managed_object_get_type_type(Application_Links* app, Managed_Object object);
typedef Managed_Scope custom_managed_object_get_containing_scope_type(Application_Links* app, Managed_Object object);
typedef b32 custom_managed_object_free_type(Application_Links* app, Managed_Object object);
typedef b32 custom_managed_object_store_data_type(Application_Links* app, Managed_Object object, u32 first_index, u32 count, void* mem);
typedef b32 custom_managed_object_load_data_type(Application_Links* app, Managed_Object object, u32 first_index, u32 count, void* mem_out);
typedef User_Input custom_get_next_input_raw_type(Application_Links* app);
typedef i64 custom_get_current_input_sequence_number_type(Application_Links* app);
typedef User_Input custom_get_current_input_type(Application_Links* app);
typedef void custom_set_current_input_type(Application_Links* app, User_Input* input);
typedef void custom_leave_current_input_unhandled_type(Application_Links* app);
typedef void custom_set_custom_hook_type(Application_Links* app, Hook_ID hook_id, Void_Func* func_ptr);
typedef Void_Func* custom_get_custom_hook_type(Application_Links* app, Hook_ID hook_id);
typedef b32 custom_set_custom_hook_memory_size_type(Application_Links* app, Hook_ID hook_id, u64 size);
typedef Mouse_State custom_get_mouse_state_type(Application_Links* app);
typedef b32 custom_get_active_query_bars_type(Application_Links* app, View_ID view_id, i32 max_result_count, Query_Bar_Ptr_Array* array_out);
typedef b32 custom_start_query_bar_type(Application_Links* app, Query_Bar* bar, u32 flags);
typedef void custom_end_query_bar_type(Application_Links* app, Query_Bar* bar, u32 flags);
typedef void custom_clear_all_query_bars_type(Application_Links* app, View_ID view_id);
typedef void custom_print_message_type(Application_Links* app, String_Const_u8 message);
typedef b32 custom_log_string_type(Application_Links* app, String_Const_u8 str);
typedef Face_ID custom_get_largest_face_id_type(Application_Links* app);
typedef b32 custom_set_global_face_type(Application_Links* app, Face_ID id);
typedef History_Record_Index custom_buffer_history_get_max_record_index_type(Application_Links* app, Buffer_ID buffer_id);
typedef Record_Info custom_buffer_history_get_record_info_type(Application_Links* app, Buffer_ID buffer_id, History_Record_Index index);
typedef Record_Info custom_buffer_history_get_group_sub_record_type(Application_Links* app, Buffer_ID buffer_id, History_Record_Index index, i32 sub_index);
typedef History_Record_Index custom_buffer_history_get_current_state_index_type(Application_Links* app, Buffer_ID buffer_id);
typedef b32 custom_buffer_history_set_current_state_index_type(Application_Links* app, Buffer_ID buffer_id, History_Record_Index index);
typedef b32 custom_buffer_history_merge_record_range_type(Application_Links* app, Buffer_ID buffer_id, History_Record_Index first_index, History_Record_Index last_index, Record_Merge_Flag flags);
typedef b32 custom_buffer_history_clear_after_current_state_type(Application_Links* app, Buffer_ID buffer_id);
typedef void custom_global_history_edit_group_begin_type(Application_Links* app);
typedef void custom_global_history_edit_group_end_type(Application_Links* app);
typedef b32 custom_buffer_set_face_type(Application_Links* app, Buffer_ID buffer_id, Face_ID id);
typedef Face_Description custom_get_face_description_type(Application_Links* app, Face_ID face_id);
typedef Face_Metrics custom_get_face_metrics_type(Application_Links* app, Face_ID face_id);
typedef Face_Advance_Map custom_get_face_advance_map_type(Application_Links* app, Face_ID face_id);
typedef Face_ID custom_get_face_id_type(Application_Links* app, Buffer_ID buffer_id);
typedef Face_ID custom_try_create_new_face_type(Application_Links* app, Face_Description* description);
typedef b32 custom_try_modify_face_type(Application_Links* app, Face_ID id, Face_Description* description);
typedef b32 custom_try_release_face_type(Application_Links* app, Face_ID id, Face_ID replacement_id);
typedef String_Const_u8 custom_push_hot_directory_type(Application_Links* app, Arena* arena);
typedef void custom_set_hot_directory_type(Application_Links* app, String_Const_u8 string);
typedef void custom_send_exit_signal_type(Application_Links* app);
typedef void custom_hard_exit_type(Application_Links* app);
typedef void custom_set_window_title_type(Application_Links* app, String_Const_u8 title);
typedef void custom_acquire_global_frame_mutex_type(Application_Links* app);
typedef void custom_release_global_frame_mutex_type(Application_Links* app);
typedef Vec2_f32 custom_draw_string_oriented_type(Application_Links* app, Face_ID font_id, ARGB_Color color, String_Const_u8 str, Vec2_f32 point, u32 flags, Vec2_f32 delta);
typedef f32 custom_get_string_advance_type(Application_Links* app, Face_ID font_id, String_Const_u8 str);
typedef void custom_draw_rectangle_type(Application_Links* app, Rect_f32 rect, f32 roundness, ARGB_Color color);
typedef void custom_draw_rectangle_outline_type(Application_Links* app, Rect_f32 rect, f32 roundness, f32 thickness, ARGB_Color color);
typedef Rect_f32 custom_draw_set_clip_type(Application_Links* app, Rect_f32 new_clip);
typedef Text_Layout_ID custom_text_layout_create_type(Application_Links* app, Buffer_ID buffer_id, Rect_f32 rect, Buffer_Point buffer_point);
typedef Rect_f32 custom_text_layout_region_type(Application_Links* app, Text_Layout_ID text_layout_id);
typedef Buffer_ID custom_text_layout_get_buffer_type(Application_Links* app, Text_Layout_ID text_layout_id);
typedef Range_i64 custom_text_layout_get_visible_range_type(Application_Links* app, Text_Layout_ID text_layout_id);
typedef Range_f32 custom_text_layout_line_on_screen_type(Application_Links* app, Text_Layout_ID layout_id, i64 line_number);
typedef Rect_f32 custom_text_layout_character_on_screen_type(Application_Links* app, Text_Layout_ID layout_id, i64 pos);
typedef void custom_paint_text_color_type(Application_Links* app, Text_Layout_ID layout_id, Range_i64 range, ARGB_Color color);
typedef void custom_paint_text_color_blend_type(Application_Links* app, Text_Layout_ID layout_id, Range_i64 range, ARGB_Color color, f32 blend);
typedef b32 custom_text_layout_free_type(Application_Links* app, Text_Layout_ID text_layout_id);
typedef void custom_draw_text_layout_type(Application_Links* app, Text_Layout_ID layout_id, ARGB_Color special_color, ARGB_Color ghost_color);
typedef void custom_open_color_picker_type(Application_Links* app, Color_Picker* picker);
typedef void custom_animate_in_n_milliseconds_type(Application_Links* app, u32 n);
typedef String_Match_List custom_buffer_find_all_matches_type(Application_Links* app, Arena* arena, Buffer_ID buffer, i32 string_id, Range_i64 range, String_Const_u8 needle, Character_Predicate* predicate, Scan_Direction direction);
typedef Profile_Global_List* custom_get_core_profile_list_type(Application_Links* app);
typedef Doc_Cluster* custom_get_custom_layer_boundary_docs_type(Application_Links* app, Arena* arena);
struct API_VTable_custom{
custom_global_set_setting_type *global_set_setting;
custom_global_get_screen_rectangle_type *global_get_screen_rectangle;
custom_get_thread_context_type *get_thread_context;
custom_create_child_process_type *create_child_process;
custom_child_process_set_target_buffer_type *child_process_set_target_buffer;
custom_buffer_get_attached_child_process_type *buffer_get_attached_child_process;
custom_child_process_get_attached_buffer_type *child_process_get_attached_buffer;
custom_child_process_get_state_type *child_process_get_state;
custom_enqueue_virtual_event_type *enqueue_virtual_event;
custom_get_buffer_count_type *get_buffer_count;
custom_get_buffer_next_type *get_buffer_next;
custom_get_buffer_by_name_type *get_buffer_by_name;
custom_get_buffer_by_file_name_type *get_buffer_by_file_name;
custom_buffer_read_range_type *buffer_read_range;
custom_buffer_replace_range_type *buffer_replace_range;
custom_buffer_batch_edit_type *buffer_batch_edit;
custom_buffer_seek_string_type *buffer_seek_string;
custom_buffer_seek_character_class_type *buffer_seek_character_class;
custom_buffer_line_y_difference_type *buffer_line_y_difference;
custom_buffer_line_shift_y_type *buffer_line_shift_y;
custom_buffer_pos_at_relative_xy_type *buffer_pos_at_relative_xy;
custom_buffer_relative_box_of_pos_type *buffer_relative_box_of_pos;
custom_buffer_padded_box_of_pos_type *buffer_padded_box_of_pos;
custom_buffer_relative_character_from_pos_type *buffer_relative_character_from_pos;
custom_buffer_pos_from_relative_character_type *buffer_pos_from_relative_character;
custom_view_line_y_difference_type *view_line_y_difference;
custom_view_line_shift_y_type *view_line_shift_y;
custom_view_pos_at_relative_xy_type *view_pos_at_relative_xy;
custom_view_relative_box_of_pos_type *view_relative_box_of_pos;
custom_view_padded_box_of_pos_type *view_padded_box_of_pos;
custom_view_relative_character_from_pos_type *view_relative_character_from_pos;
custom_view_pos_from_relative_character_type *view_pos_from_relative_character;
custom_buffer_exists_type *buffer_exists;
custom_buffer_get_access_flags_type *buffer_get_access_flags;
custom_buffer_get_size_type *buffer_get_size;
custom_buffer_get_line_count_type *buffer_get_line_count;
custom_push_buffer_base_name_type *push_buffer_base_name;
custom_push_buffer_unique_name_type *push_buffer_unique_name;
custom_push_buffer_file_name_type *push_buffer_file_name;
custom_buffer_get_dirty_state_type *buffer_get_dirty_state;
custom_buffer_set_dirty_state_type *buffer_set_dirty_state;
custom_buffer_set_layout_type *buffer_set_layout;
custom_buffer_clear_layout_cache_type *buffer_clear_layout_cache;
custom_buffer_get_layout_type *buffer_get_layout;
custom_buffer_get_setting_type *buffer_get_setting;
custom_buffer_set_setting_type *buffer_set_setting;
custom_buffer_get_managed_scope_type *buffer_get_managed_scope;
custom_buffer_send_end_signal_type *buffer_send_end_signal;
custom_create_buffer_type *create_buffer;
custom_buffer_save_type *buffer_save;
custom_buffer_kill_type *buffer_kill;
custom_buffer_reopen_type *buffer_reopen;
custom_buffer_get_file_attributes_type *buffer_get_file_attributes;
custom_get_view_next_type *get_view_next;
custom_get_view_prev_type *get_view_prev;
custom_get_this_ctx_view_type *get_this_ctx_view;
custom_get_active_view_type *get_active_view;
custom_view_exists_type *view_exists;
custom_view_get_buffer_type *view_get_buffer;
custom_view_get_cursor_pos_type *view_get_cursor_pos;
custom_view_get_mark_pos_type *view_get_mark_pos;
custom_view_get_preferred_x_type *view_get_preferred_x;
custom_view_set_preferred_x_type *view_set_preferred_x;
custom_view_get_screen_rect_type *view_get_screen_rect;
custom_view_get_panel_type *view_get_panel;
custom_panel_get_view_type *panel_get_view;
custom_panel_is_split_type *panel_is_split;
custom_panel_is_leaf_type *panel_is_leaf;
custom_panel_split_type *panel_split;
custom_panel_set_split_type *panel_set_split;
custom_panel_swap_children_type *panel_swap_children;
custom_panel_get_root_type *panel_get_root;
custom_panel_get_parent_type *panel_get_parent;
custom_panel_get_child_type *panel_get_child;
custom_view_close_type *view_close;
custom_view_get_buffer_region_type *view_get_buffer_region;
custom_view_get_buffer_scroll_type *view_get_buffer_scroll;
custom_view_set_active_type *view_set_active;
custom_view_enqueue_command_function_type *view_enqueue_command_function;
custom_view_get_setting_type *view_get_setting;
custom_view_set_setting_type *view_set_setting;
custom_view_get_managed_scope_type *view_get_managed_scope;
custom_buffer_compute_cursor_type *buffer_compute_cursor;
custom_view_compute_cursor_type *view_compute_cursor;
custom_view_set_camera_bounds_type *view_set_camera_bounds;
custom_view_get_camera_bounds_type *view_get_camera_bounds;
custom_view_set_cursor_type *view_set_cursor;
custom_view_set_buffer_scroll_type *view_set_buffer_scroll;
custom_view_set_mark_type *view_set_mark;
custom_view_quit_ui_type *view_quit_ui;
custom_view_set_buffer_type *view_set_buffer;
custom_view_push_context_type *view_push_context;
custom_view_pop_context_type *view_pop_context;
custom_view_alter_context_type *view_alter_context;
custom_view_current_context_type *view_current_context;
custom_view_current_context_hook_memory_type *view_current_context_hook_memory;
custom_create_user_managed_scope_type *create_user_managed_scope;
custom_destroy_user_managed_scope_type *destroy_user_managed_scope;
custom_get_global_managed_scope_type *get_global_managed_scope;
custom_get_managed_scope_with_multiple_dependencies_type *get_managed_scope_with_multiple_dependencies;
custom_managed_scope_clear_contents_type *managed_scope_clear_contents;
custom_managed_scope_clear_self_all_dependent_scopes_type *managed_scope_clear_self_all_dependent_scopes;
custom_managed_scope_allocator_type *managed_scope_allocator;
custom_managed_id_group_highest_id_type *managed_id_group_highest_id;
custom_managed_id_declare_type *managed_id_declare;
custom_managed_id_get_type *managed_id_get;
custom_managed_scope_get_attachment_type *managed_scope_get_attachment;
custom_managed_scope_attachment_erase_type *managed_scope_attachment_erase;
custom_alloc_managed_memory_in_scope_type *alloc_managed_memory_in_scope;
custom_alloc_buffer_markers_on_buffer_type *alloc_buffer_markers_on_buffer;
custom_managed_object_get_item_size_type *managed_object_get_item_size;
custom_managed_object_get_item_count_type *managed_object_get_item_count;
custom_managed_object_get_pointer_type *managed_object_get_pointer;
custom_managed_object_get_type_type *managed_object_get_type;
custom_managed_object_get_containing_scope_type *managed_object_get_containing_scope;
custom_managed_object_free_type *managed_object_free;
custom_managed_object_store_data_type *managed_object_store_data;
custom_managed_object_load_data_type *managed_object_load_data;
custom_get_next_input_raw_type *get_next_input_raw;
custom_get_current_input_sequence_number_type *get_current_input_sequence_number;
custom_get_current_input_type *get_current_input;
custom_set_current_input_type *set_current_input;
custom_leave_current_input_unhandled_type *leave_current_input_unhandled;
custom_set_custom_hook_type *set_custom_hook;
custom_get_custom_hook_type *get_custom_hook;
custom_set_custom_hook_memory_size_type *set_custom_hook_memory_size;
custom_get_mouse_state_type *get_mouse_state;
custom_get_active_query_bars_type *get_active_query_bars;
custom_start_query_bar_type *start_query_bar;
custom_end_query_bar_type *end_query_bar;
custom_clear_all_query_bars_type *clear_all_query_bars;
custom_print_message_type *print_message;
custom_log_string_type *log_string;
custom_get_largest_face_id_type *get_largest_face_id;
custom_set_global_face_type *set_global_face;
custom_buffer_history_get_max_record_index_type *buffer_history_get_max_record_index;
custom_buffer_history_get_record_info_type *buffer_history_get_record_info;
custom_buffer_history_get_group_sub_record_type *buffer_history_get_group_sub_record;
custom_buffer_history_get_current_state_index_type *buffer_history_get_current_state_index;
custom_buffer_history_set_current_state_index_type *buffer_history_set_current_state_index;
custom_buffer_history_merge_record_range_type *buffer_history_merge_record_range;
custom_buffer_history_clear_after_current_state_type *buffer_history_clear_after_current_state;
custom_global_history_edit_group_begin_type *global_history_edit_group_begin;
custom_global_history_edit_group_end_type *global_history_edit_group_end;
custom_buffer_set_face_type *buffer_set_face;
custom_get_face_description_type *get_face_description;
custom_get_face_metrics_type *get_face_metrics;
custom_get_face_advance_map_type *get_face_advance_map;
custom_get_face_id_type *get_face_id;
custom_try_create_new_face_type *try_create_new_face;
custom_try_modify_face_type *try_modify_face;
custom_try_release_face_type *try_release_face;
custom_push_hot_directory_type *push_hot_directory;
custom_set_hot_directory_type *set_hot_directory;
custom_send_exit_signal_type *send_exit_signal;
custom_hard_exit_type *hard_exit;
custom_set_window_title_type *set_window_title;
custom_acquire_global_frame_mutex_type *acquire_global_frame_mutex;
custom_release_global_frame_mutex_type *release_global_frame_mutex;
custom_draw_string_oriented_type *draw_string_oriented;
custom_get_string_advance_type *get_string_advance;
custom_draw_rectangle_type *draw_rectangle;
custom_draw_rectangle_outline_type *draw_rectangle_outline;
custom_draw_set_clip_type *draw_set_clip;
custom_text_layout_create_type *text_layout_create;
custom_text_layout_region_type *text_layout_region;
custom_text_layout_get_buffer_type *text_layout_get_buffer;
custom_text_layout_get_visible_range_type *text_layout_get_visible_range;
custom_text_layout_line_on_screen_type *text_layout_line_on_screen;
custom_text_layout_character_on_screen_type *text_layout_character_on_screen;
custom_paint_text_color_type *paint_text_color;
custom_paint_text_color_blend_type *paint_text_color_blend;
custom_text_layout_free_type *text_layout_free;
custom_draw_text_layout_type *draw_text_layout;
custom_open_color_picker_type *open_color_picker;
custom_animate_in_n_milliseconds_type *animate_in_n_milliseconds;
custom_buffer_find_all_matches_type *buffer_find_all_matches;
custom_get_core_profile_list_type *get_core_profile_list;
custom_get_custom_layer_boundary_docs_type *get_custom_layer_boundary_docs;
};
# 722 "/home/sam/.bin/4coder/custom/generated/custom_api.h"
static custom_global_set_setting_type *global_set_setting = 0;
static custom_global_get_screen_rectangle_type *global_get_screen_rectangle = 0;
static custom_get_thread_context_type *get_thread_context = 0;
static custom_create_child_process_type *create_child_process = 0;
static custom_child_process_set_target_buffer_type *child_process_set_target_buffer = 0;
static custom_buffer_get_attached_child_process_type *buffer_get_attached_child_process = 0;
static custom_child_process_get_attached_buffer_type *child_process_get_attached_buffer = 0;
static custom_child_process_get_state_type *child_process_get_state = 0;
static custom_enqueue_virtual_event_type *enqueue_virtual_event = 0;
static custom_get_buffer_count_type *get_buffer_count = 0;
static custom_get_buffer_next_type *get_buffer_next = 0;
static custom_get_buffer_by_name_type *get_buffer_by_name = 0;
static custom_get_buffer_by_file_name_type *get_buffer_by_file_name = 0;
static custom_buffer_read_range_type *buffer_read_range = 0;
static custom_buffer_replace_range_type *buffer_replace_range = 0;
static custom_buffer_batch_edit_type *buffer_batch_edit = 0;
static custom_buffer_seek_string_type *buffer_seek_string = 0;
static custom_buffer_seek_character_class_type *buffer_seek_character_class = 0;
static custom_buffer_line_y_difference_type *buffer_line_y_difference = 0;
static custom_buffer_line_shift_y_type *buffer_line_shift_y = 0;
static custom_buffer_pos_at_relative_xy_type *buffer_pos_at_relative_xy = 0;
static custom_buffer_relative_box_of_pos_type *buffer_relative_box_of_pos = 0;
static custom_buffer_padded_box_of_pos_type *buffer_padded_box_of_pos = 0;
static custom_buffer_relative_character_from_pos_type *buffer_relative_character_from_pos = 0;
static custom_buffer_pos_from_relative_character_type *buffer_pos_from_relative_character = 0;
static custom_view_line_y_difference_type *view_line_y_difference = 0;
static custom_view_line_shift_y_type *view_line_shift_y = 0;
static custom_view_pos_at_relative_xy_type *view_pos_at_relative_xy = 0;
static custom_view_relative_box_of_pos_type *view_relative_box_of_pos = 0;
static custom_view_padded_box_of_pos_type *view_padded_box_of_pos = 0;
static custom_view_relative_character_from_pos_type *view_relative_character_from_pos = 0;
static custom_view_pos_from_relative_character_type *view_pos_from_relative_character = 0;
static custom_buffer_exists_type *buffer_exists = 0;
static custom_buffer_get_access_flags_type *buffer_get_access_flags = 0;
static custom_buffer_get_size_type *buffer_get_size = 0;
static custom_buffer_get_line_count_type *buffer_get_line_count = 0;
static custom_push_buffer_base_name_type *push_buffer_base_name = 0;
static custom_push_buffer_unique_name_type *push_buffer_unique_name = 0;
static custom_push_buffer_file_name_type *push_buffer_file_name = 0;
static custom_buffer_get_dirty_state_type *buffer_get_dirty_state = 0;
static custom_buffer_set_dirty_state_type *buffer_set_dirty_state = 0;
static custom_buffer_set_layout_type *buffer_set_layout = 0;
static custom_buffer_clear_layout_cache_type *buffer_clear_layout_cache = 0;
static custom_buffer_get_layout_type *buffer_get_layout = 0;
static custom_buffer_get_setting_type *buffer_get_setting = 0;
static custom_buffer_set_setting_type *buffer_set_setting = 0;
static custom_buffer_get_managed_scope_type *buffer_get_managed_scope = 0;
static custom_buffer_send_end_signal_type *buffer_send_end_signal = 0;
static custom_create_buffer_type *create_buffer = 0;
static custom_buffer_save_type *buffer_save = 0;
static custom_buffer_kill_type *buffer_kill = 0;
static custom_buffer_reopen_type *buffer_reopen = 0;
static custom_buffer_get_file_attributes_type *buffer_get_file_attributes = 0;
static custom_get_view_next_type *get_view_next = 0;
static custom_get_view_prev_type *get_view_prev = 0;
static custom_get_this_ctx_view_type *get_this_ctx_view = 0;
static custom_get_active_view_type *get_active_view = 0;
static custom_view_exists_type *view_exists = 0;
static custom_view_get_buffer_type *view_get_buffer = 0;
static custom_view_get_cursor_pos_type *view_get_cursor_pos = 0;
static custom_view_get_mark_pos_type *view_get_mark_pos = 0;
static custom_view_get_preferred_x_type *view_get_preferred_x = 0;
static custom_view_set_preferred_x_type *view_set_preferred_x = 0;
static custom_view_get_screen_rect_type *view_get_screen_rect = 0;
static custom_view_get_panel_type *view_get_panel = 0;
static custom_panel_get_view_type *panel_get_view = 0;
static custom_panel_is_split_type *panel_is_split = 0;
static custom_panel_is_leaf_type *panel_is_leaf = 0;
static custom_panel_split_type *panel_split = 0;
static custom_panel_set_split_type *panel_set_split = 0;
static custom_panel_swap_children_type *panel_swap_children = 0;
static custom_panel_get_root_type *panel_get_root = 0;
static custom_panel_get_parent_type *panel_get_parent = 0;
static custom_panel_get_child_type *panel_get_child = 0;
static custom_view_close_type *view_close = 0;
static custom_view_get_buffer_region_type *view_get_buffer_region = 0;
static custom_view_get_buffer_scroll_type *view_get_buffer_scroll = 0;
static custom_view_set_active_type *view_set_active = 0;
static custom_view_enqueue_command_function_type *view_enqueue_command_function = 0;
static custom_view_get_setting_type *view_get_setting = 0;
static custom_view_set_setting_type *view_set_setting = 0;
static custom_view_get_managed_scope_type *view_get_managed_scope = 0;
static custom_buffer_compute_cursor_type *buffer_compute_cursor = 0;
static custom_view_compute_cursor_type *view_compute_cursor = 0;
static custom_view_set_camera_bounds_type *view_set_camera_bounds = 0;
static custom_view_get_camera_bounds_type *view_get_camera_bounds = 0;
static custom_view_set_cursor_type *view_set_cursor = 0;
static custom_view_set_buffer_scroll_type *view_set_buffer_scroll = 0;
static custom_view_set_mark_type *view_set_mark = 0;
static custom_view_quit_ui_type *view_quit_ui = 0;
static custom_view_set_buffer_type *view_set_buffer = 0;
static custom_view_push_context_type *view_push_context = 0;
static custom_view_pop_context_type *view_pop_context = 0;
static custom_view_alter_context_type *view_alter_context = 0;
static custom_view_current_context_type *view_current_context = 0;
static custom_view_current_context_hook_memory_type *view_current_context_hook_memory = 0;
static custom_create_user_managed_scope_type *create_user_managed_scope = 0;
static custom_destroy_user_managed_scope_type *destroy_user_managed_scope = 0;
static custom_get_global_managed_scope_type *get_global_managed_scope = 0;
static custom_get_managed_scope_with_multiple_dependencies_type *get_managed_scope_with_multiple_dependencies = 0;
static custom_managed_scope_clear_contents_type *managed_scope_clear_contents = 0;
static custom_managed_scope_clear_self_all_dependent_scopes_type *managed_scope_clear_self_all_dependent_scopes = 0;
static custom_managed_scope_allocator_type *managed_scope_allocator = 0;
static custom_managed_id_group_highest_id_type *managed_id_group_highest_id = 0;
static custom_managed_id_declare_type *managed_id_declare = 0;
static custom_managed_id_get_type *managed_id_get = 0;
static custom_managed_scope_get_attachment_type *managed_scope_get_attachment = 0;
static custom_managed_scope_attachment_erase_type *managed_scope_attachment_erase = 0;
static custom_alloc_managed_memory_in_scope_type *alloc_managed_memory_in_scope = 0;
static custom_alloc_buffer_markers_on_buffer_type *alloc_buffer_markers_on_buffer = 0;
static custom_managed_object_get_item_size_type *managed_object_get_item_size = 0;
static custom_managed_object_get_item_count_type *managed_object_get_item_count = 0;
static custom_managed_object_get_pointer_type *managed_object_get_pointer = 0;
static custom_managed_object_get_type_type *managed_object_get_type = 0;
static custom_managed_object_get_containing_scope_type *managed_object_get_containing_scope = 0;
static custom_managed_object_free_type *managed_object_free = 0;
static custom_managed_object_store_data_type *managed_object_store_data = 0;
static custom_managed_object_load_data_type *managed_object_load_data = 0;
static custom_get_next_input_raw_type *get_next_input_raw = 0;
static custom_get_current_input_sequence_number_type *get_current_input_sequence_number = 0;
static custom_get_current_input_type *get_current_input = 0;
static custom_set_current_input_type *set_current_input = 0;
static custom_leave_current_input_unhandled_type *leave_current_input_unhandled = 0;
static custom_set_custom_hook_type *set_custom_hook = 0;
static custom_get_custom_hook_type *get_custom_hook = 0;
static custom_set_custom_hook_memory_size_type *set_custom_hook_memory_size = 0;
static custom_get_mouse_state_type *get_mouse_state = 0;
static custom_get_active_query_bars_type *get_active_query_bars = 0;
static custom_start_query_bar_type *start_query_bar = 0;
static custom_end_query_bar_type *end_query_bar = 0;
static custom_clear_all_query_bars_type *clear_all_query_bars = 0;
static custom_print_message_type *print_message = 0;
static custom_log_string_type *log_string = 0;
static custom_get_largest_face_id_type *get_largest_face_id = 0;
static custom_set_global_face_type *set_global_face = 0;
static custom_buffer_history_get_max_record_index_type *buffer_history_get_max_record_index = 0;
static custom_buffer_history_get_record_info_type *buffer_history_get_record_info = 0;
static custom_buffer_history_get_group_sub_record_type *buffer_history_get_group_sub_record = 0;
static custom_buffer_history_get_current_state_index_type *buffer_history_get_current_state_index = 0;
static custom_buffer_history_set_current_state_index_type *buffer_history_set_current_state_index = 0;
static custom_buffer_history_merge_record_range_type *buffer_history_merge_record_range = 0;
static custom_buffer_history_clear_after_current_state_type *buffer_history_clear_after_current_state = 0;
static custom_global_history_edit_group_begin_type *global_history_edit_group_begin = 0;
static custom_global_history_edit_group_end_type *global_history_edit_group_end = 0;
static custom_buffer_set_face_type *buffer_set_face = 0;
static custom_get_face_description_type *get_face_description = 0;
static custom_get_face_metrics_type *get_face_metrics = 0;
static custom_get_face_advance_map_type *get_face_advance_map = 0;
static custom_get_face_id_type *get_face_id = 0;
static custom_try_create_new_face_type *try_create_new_face = 0;
static custom_try_modify_face_type *try_modify_face = 0;
static custom_try_release_face_type *try_release_face = 0;
static custom_push_hot_directory_type *push_hot_directory = 0;
static custom_set_hot_directory_type *set_hot_directory = 0;
static custom_send_exit_signal_type *send_exit_signal = 0;
static custom_hard_exit_type *hard_exit = 0;
static custom_set_window_title_type *set_window_title = 0;
static custom_acquire_global_frame_mutex_type *acquire_global_frame_mutex = 0;
static custom_release_global_frame_mutex_type *release_global_frame_mutex = 0;
static custom_draw_string_oriented_type *draw_string_oriented = 0;
static custom_get_string_advance_type *get_string_advance = 0;
static custom_draw_rectangle_type *draw_rectangle = 0;
static custom_draw_rectangle_outline_type *draw_rectangle_outline = 0;
static custom_draw_set_clip_type *draw_set_clip = 0;
static custom_text_layout_create_type *text_layout_create = 0;
static custom_text_layout_region_type *text_layout_region = 0;
static custom_text_layout_get_buffer_type *text_layout_get_buffer = 0;
static custom_text_layout_get_visible_range_type *text_layout_get_visible_range = 0;
static custom_text_layout_line_on_screen_type *text_layout_line_on_screen = 0;
static custom_text_layout_character_on_screen_type *text_layout_character_on_screen = 0;
static custom_paint_text_color_type *paint_text_color = 0;
static custom_paint_text_color_blend_type *paint_text_color_blend = 0;
static custom_text_layout_free_type *text_layout_free = 0;
static custom_draw_text_layout_type *draw_text_layout = 0;
static custom_open_color_picker_type *open_color_picker = 0;
static custom_animate_in_n_milliseconds_type *animate_in_n_milliseconds = 0;
static custom_buffer_find_all_matches_type *buffer_find_all_matches = 0;
static custom_get_core_profile_list_type *get_core_profile_list = 0;
static custom_get_custom_layer_boundary_docs_type *get_custom_layer_boundary_docs = 0;
# 23 "/home/sam/.bin/4coder/custom/4coder_default_include.cpp" 2
# 1 "/home/sam/.bin/4coder/custom/4coder_system_types.h" 1
# 10 "/home/sam/.bin/4coder/custom/4coder_system_types.h"
typedef i32 Key_Mode;
enum{
    KeyMode_LanguageArranged,
    KeyMode_Physical,
};

struct Plat_Handle{
    u32 d[4];
};
typedef Plat_Handle System_Library;
typedef Plat_Handle System_Thread;
typedef Plat_Handle System_Mutex;
typedef Plat_Handle System_Condition_Variable;
typedef void Thread_Function(void *ptr);
struct CLI_Handles{
    Plat_Handle proc;
    Plat_Handle out_read;
    Plat_Handle out_write;
    Plat_Handle in_read;
    Plat_Handle in_write;
    u32 scratch_space[4];
    i32 exit;
};

typedef i32 System_Path_Code;
enum{
    SystemPath_CurrentDirectory,
    SystemPath_Binary,
};

struct Memory_Annotation_Node{
    Memory_Annotation_Node *next;
    String_Const_u8 location;
    void *address;
    u64 size;
};

struct Memory_Annotation{
    Memory_Annotation_Node *first;
    Memory_Annotation_Node *last;
    i32 count;
};

struct Mutex_Lock{
    Mutex_Lock(System_Mutex mutex);
    ~Mutex_Lock();
    operator System_Mutex();
    System_Mutex mutex;
};
# 24 "/home/sam/.bin/4coder/custom/4coder_default_include.cpp" 2

# 1 "/home/sam/.bin/4coder/custom/generated/system_api.h" 1
# 55 "/home/sam/.bin/4coder/custom/generated/system_api.h"
typedef String_Const_u8 system_get_path_type(Arena* arena, System_Path_Code path_code);
typedef String_Const_u8 system_get_canonical_type(Arena* arena, String_Const_u8 name);
typedef File_List system_get_file_list_type(Arena* arena, String_Const_u8 directory);
typedef File_Attributes system_quick_file_attributes_type(Arena* scratch, String_Const_u8 file_name);
typedef b32 system_load_handle_type(Arena* scratch, char* file_name, Plat_Handle* out);
typedef File_Attributes system_load_attributes_type(Plat_Handle handle);
typedef b32 system_load_file_type(Plat_Handle handle, char* buffer, u32 size);
typedef b32 system_load_close_type(Plat_Handle handle);
typedef File_Attributes system_save_file_type(Arena* scratch, char* file_name, String_Const_u8 data);
typedef b32 system_load_library_type(Arena* scratch, String_Const_u8 file_name, System_Library* out);
typedef b32 system_release_library_type(System_Library handle);
typedef Void_Func* system_get_proc_type(System_Library handle, char* proc_name);
typedef u64 system_now_time_type(void);
typedef Date_Time system_now_date_time_universal_type(void);
typedef Date_Time system_local_date_time_from_universal_type(Date_Time* date_time);
typedef Date_Time system_universal_date_time_from_local_type(Date_Time* date_time);
typedef Plat_Handle system_wake_up_timer_create_type(void);
typedef void system_wake_up_timer_release_type(Plat_Handle handle);
typedef void system_wake_up_timer_set_type(Plat_Handle handle, u32 time_milliseconds);
typedef void system_signal_step_type(u32 code);
typedef void system_sleep_type(u64 microseconds);
typedef String_Const_u8 system_get_clipboard_type(Arena* arena, i32 index);
typedef void system_post_clipboard_type(String_Const_u8 str, i32 index);
typedef void system_set_clipboard_catch_all_type(b32 enabled);
typedef b32 system_get_clipboard_catch_all_type(void);
typedef b32 system_cli_call_type(Arena* scratch, char* path, char* script, CLI_Handles* cli_out);
typedef void system_cli_begin_update_type(CLI_Handles* cli);
typedef b32 system_cli_update_step_type(CLI_Handles* cli, char* dest, u32 max, u32* amount);
typedef b32 system_cli_end_update_type(CLI_Handles* cli);
typedef void system_open_color_picker_type(Color_Picker* picker);
typedef f32 system_get_screen_scale_factor_type(void);
typedef System_Thread system_thread_launch_type(Thread_Function* proc, void* ptr);
typedef void system_thread_join_type(System_Thread thread);
typedef void system_thread_free_type(System_Thread thread);
typedef i32 system_thread_get_id_type(void);
typedef void system_acquire_global_frame_mutex_type(Thread_Context* tctx);
typedef void system_release_global_frame_mutex_type(Thread_Context* tctx);
typedef System_Mutex system_mutex_make_type(void);
typedef void system_mutex_acquire_type(System_Mutex mutex);
typedef void system_mutex_release_type(System_Mutex mutex);
typedef void system_mutex_free_type(System_Mutex mutex);
typedef System_Condition_Variable system_condition_variable_make_type(void);
typedef void system_condition_variable_wait_type(System_Condition_Variable cv, System_Mutex mutex);
typedef void system_condition_variable_signal_type(System_Condition_Variable cv);
typedef void system_condition_variable_free_type(System_Condition_Variable cv);
typedef void* system_memory_allocate_type(u64 size, String_Const_u8 location);
typedef b32 system_memory_set_protection_type(void* ptr, u64 size, u32 flags);
typedef void system_memory_free_type(void* ptr, u64 size);
typedef Memory_Annotation system_memory_annotation_type(Arena* arena);
typedef void system_show_mouse_cursor_type(i32 show);
typedef b32 system_set_fullscreen_type(b32 full_screen);
typedef b32 system_is_fullscreen_type(void);
typedef Input_Modifier_Set system_get_keyboard_modifiers_type(Arena* arena);
typedef void system_set_key_mode_type(Key_Mode mode);
struct API_VTable_system{
system_get_path_type *get_path;
system_get_canonical_type *get_canonical;
system_get_file_list_type *get_file_list;
system_quick_file_attributes_type *quick_file_attributes;
system_load_handle_type *load_handle;
system_load_attributes_type *load_attributes;
system_load_file_type *load_file;
system_load_close_type *load_close;
system_save_file_type *save_file;
system_load_library_type *load_library;
system_release_library_type *release_library;
system_get_proc_type *get_proc;
system_now_time_type *now_time;
system_now_date_time_universal_type *now_date_time_universal;
system_local_date_time_from_universal_type *local_date_time_from_universal;
system_universal_date_time_from_local_type *universal_date_time_from_local;
system_wake_up_timer_create_type *wake_up_timer_create;
system_wake_up_timer_release_type *wake_up_timer_release;
system_wake_up_timer_set_type *wake_up_timer_set;
system_signal_step_type *signal_step;
system_sleep_type *sleep;
system_get_clipboard_type *get_clipboard;
system_post_clipboard_type *post_clipboard;
system_set_clipboard_catch_all_type *set_clipboard_catch_all;
system_get_clipboard_catch_all_type *get_clipboard_catch_all;
system_cli_call_type *cli_call;
system_cli_begin_update_type *cli_begin_update;
system_cli_update_step_type *cli_update_step;
system_cli_end_update_type *cli_end_update;
system_open_color_picker_type *open_color_picker;
system_get_screen_scale_factor_type *get_screen_scale_factor;
system_thread_launch_type *thread_launch;
system_thread_join_type *thread_join;
system_thread_free_type *thread_free;
system_thread_get_id_type *thread_get_id;
system_acquire_global_frame_mutex_type *acquire_global_frame_mutex;
system_release_global_frame_mutex_type *release_global_frame_mutex;
system_mutex_make_type *mutex_make;
system_mutex_acquire_type *mutex_acquire;
system_mutex_release_type *mutex_release;
system_mutex_free_type *mutex_free;
system_condition_variable_make_type *condition_variable_make;
system_condition_variable_wait_type *condition_variable_wait;
system_condition_variable_signal_type *condition_variable_signal;
system_condition_variable_free_type *condition_variable_free;
system_memory_allocate_type *memory_allocate;
system_memory_set_protection_type *memory_set_protection;
system_memory_free_type *memory_free;
system_memory_annotation_type *memory_annotation;
system_show_mouse_cursor_type *show_mouse_cursor;
system_set_fullscreen_type *set_fullscreen;
system_is_fullscreen_type *is_fullscreen;
system_get_keyboard_modifiers_type *get_keyboard_modifiers;
system_set_key_mode_type *set_key_mode;
};
# 222 "/home/sam/.bin/4coder/custom/generated/system_api.h"
static system_get_path_type *system_get_path = 0;
static system_get_canonical_type *system_get_canonical = 0;
static system_get_file_list_type *system_get_file_list = 0;
static system_quick_file_attributes_type *system_quick_file_attributes = 0;
static system_load_handle_type *system_load_handle = 0;
static system_load_attributes_type *system_load_attributes = 0;
static system_load_file_type *system_load_file = 0;
static system_load_close_type *system_load_close = 0;
static system_save_file_type *system_save_file = 0;
static system_load_library_type *system_load_library = 0;
static system_release_library_type *system_release_library = 0;
static system_get_proc_type *system_get_proc = 0;
static system_now_time_type *system_now_time = 0;
static system_now_date_time_universal_type *system_now_date_time_universal = 0;
static system_local_date_time_from_universal_type *system_local_date_time_from_universal = 0;
static system_universal_date_time_from_local_type *system_universal_date_time_from_local = 0;
static system_wake_up_timer_create_type *system_wake_up_timer_create = 0;
static system_wake_up_timer_release_type *system_wake_up_timer_release = 0;
static system_wake_up_timer_set_type *system_wake_up_timer_set = 0;
static system_signal_step_type *system_signal_step = 0;
static system_sleep_type *system_sleep = 0;
static system_get_clipboard_type *system_get_clipboard = 0;
static system_post_clipboard_type *system_post_clipboard = 0;
static system_set_clipboard_catch_all_type *system_set_clipboard_catch_all = 0;
static system_get_clipboard_catch_all_type *system_get_clipboard_catch_all = 0;
static system_cli_call_type *system_cli_call = 0;
static system_cli_begin_update_type *system_cli_begin_update = 0;
static system_cli_update_step_type *system_cli_update_step = 0;
static system_cli_end_update_type *system_cli_end_update = 0;
static system_open_color_picker_type *system_open_color_picker = 0;
static system_get_screen_scale_factor_type *system_get_screen_scale_factor = 0;
static system_thread_launch_type *system_thread_launch = 0;
static system_thread_join_type *system_thread_join = 0;
static system_thread_free_type *system_thread_free = 0;
static system_thread_get_id_type *system_thread_get_id = 0;
static system_acquire_global_frame_mutex_type *system_acquire_global_frame_mutex = 0;
static system_release_global_frame_mutex_type *system_release_global_frame_mutex = 0;
static system_mutex_make_type *system_mutex_make = 0;
static system_mutex_acquire_type *system_mutex_acquire = 0;
static system_mutex_release_type *system_mutex_release = 0;
static system_mutex_free_type *system_mutex_free = 0;
static system_condition_variable_make_type *system_condition_variable_make = 0;
static system_condition_variable_wait_type *system_condition_variable_wait = 0;
static system_condition_variable_signal_type *system_condition_variable_signal = 0;
static system_condition_variable_free_type *system_condition_variable_free = 0;
static system_memory_allocate_type *system_memory_allocate = 0;
static system_memory_set_protection_type *system_memory_set_protection = 0;
static system_memory_free_type *system_memory_free = 0;
static system_memory_annotation_type *system_memory_annotation = 0;
static system_show_mouse_cursor_type *system_show_mouse_cursor = 0;
static system_set_fullscreen_type *system_set_fullscreen = 0;
static system_is_fullscreen_type *system_is_fullscreen = 0;
static system_get_keyboard_modifiers_type *system_get_keyboard_modifiers = 0;
static system_set_key_mode_type *system_set_key_mode = 0;
# 26 "/home/sam/.bin/4coder/custom/4coder_default_include.cpp" 2




# 1 "/home/sam/.bin/4coder/custom/4coder_profile.h" 1
# 10 "/home/sam/.bin/4coder/custom/4coder_profile.h"
struct Profile_Global_List{
    System_Mutex mutex;
    Arena node_arena;
    Arena_Node *first_arena;
    Arena_Node *last_arena;
    Profile_Thread *first_thread;
    Profile_Thread *last_thread;
    i32 thread_count;
    Profile_Enable_Flag disable_bits;
};

struct Profile_Block{
    Thread_Context *tctx;
    Profile_Global_List *list;
    b32 is_closed;
    Profile_ID id;

    Profile_Block(Thread_Context *tctx, Profile_Global_List *list,
                  String_Const_u8 name, String_Const_u8 location);
    Profile_Block(Application_Links *app, String_Const_u8 name, String_Const_u8 location);
    ~Profile_Block();
    void close_now();
};

struct Profile_Scope_Block{
    Thread_Context *tctx;
    Profile_Global_List *list;
    b32 is_closed;
    Profile_ID id;

    Profile_Scope_Block(Thread_Context *tctx, Profile_Global_List *list,
                        String_Const_u8 name, String_Const_u8 location);
    Profile_Scope_Block(Application_Links *app, String_Const_u8 name, String_Const_u8 location);
    ~Profile_Scope_Block();
    void close_now();
};
# 31 "/home/sam/.bin/4coder/custom/4coder_default_include.cpp" 2
# 1 "/home/sam/.bin/4coder/custom/4coder_async_tasks.h" 1
# 10 "/home/sam/.bin/4coder/custom/4coder_async_tasks.h"
typedef void Async_Task_Function_Type(struct Async_Context *actx, Data data);
typedef u64 Async_Task;

struct Async_Thread{
    struct Async_System *async_system;
    System_Thread thread;
    struct Async_Node *node;
    Async_Task task;
    b32 cancel_signal;
};

struct Async_Node{
    union{
        Async_Node *next;
        Node node;
    };
    Async_Task task;
    Async_Thread *thread;
    Async_Task_Function_Type *func;
    Data data;
};

struct Async_System{
    void *cmd_context;

    Heap node_heap;
    Arena node_arena;
    System_Mutex mutex;
    System_Condition_Variable cv;
    System_Condition_Variable join_cv;
    Async_Task task_id_counter;
    Async_Node *free_nodes;
    Node task_sent;
    i32 task_count;

    Async_Thread thread;
};

struct Async_Context{
    Application_Links *app;
    Async_Thread *thread;
};
# 32 "/home/sam/.bin/4coder/custom/4coder_default_include.cpp" 2
# 1 "/home/sam/.bin/4coder/custom/4coder_token.h" 1
# 10 "/home/sam/.bin/4coder/custom/4coder_token.h"
typedef i16 Token_Base_Kind;
enum{
    TokenBaseKind_EOF = 0,
    TokenBaseKind_Whitespace = 1,
    TokenBaseKind_LexError = 2,
    TokenBaseKind_Comment = 3,
    TokenBaseKind_Keyword = 4,
    TokenBaseKind_Preprocessor = 5,
    TokenBaseKind_Identifier = 6,
    TokenBaseKind_Operator = 7,
    TokenBaseKind_LiteralInteger = 8,
    TokenBaseKind_LiteralFloat = 9,
    TokenBaseKind_LiteralString = 10,
    TokenBaseKind_ScopeOpen = 11,
    TokenBaseKind_ScopeClose = 12,
    TokenBaseKind_ParentheticalOpen = 13,
    TokenBaseKind_ParentheticalClose = 14,
    TokenBaseKind_StatementClose = 15,

    TokenBaseKind_COUNT = 16,
};

char *token_base_kind_names[] ={
    "EOF",
    "Whitespace",
    "LexError",
    "Comment",
    "Keyword",
    "Preprocessor",
    "Identifier",
    "Operator",
    "LiteralInteger",
    "LiteralFloat",
    "LiteralString",
    "ScopeOpen",
    "ScopeClose",
    "ParentheticalOpen",
    "ParentheticalClose",
};

typedef u16 Token_Base_Flag;
enum{
    TokenBaseFlag_PreprocessorBody = 1,
};

struct Token{
    i64 pos;
    i64 size;
    Token_Base_Kind kind;
    Token_Base_Flag flags;
    i16 sub_kind;
    u16 sub_flags;
};

struct Token_Pair{
    Token a;
    Token b;
};

struct Token_Array{
    Token *tokens;
    i64 count;
    i64 max;
};

struct Token_Block{
    Token_Block *next;
    Token_Block *prev;
    Token *tokens;
    i64 count;
    i64 max;
};

struct Token_List{
    Token_Block *first;
    Token_Block *last;
    i64 node_count;
    i64 total_count;
};

struct Token_Relex{
    b32 successful_resync;
    i64 first_resync_index;
};

struct Token_Iterator_Array{
    u64 user_id;
    Token *ptr;
    Token *tokens;
    i64 count;
};

struct Token_Iterator_List{
    u64 user_id;
    i64 index;
    Token *ptr;
    Token_Block *block;
    Token_Block *first;
    Token_Block *last;
    i64 node_count;
    i64 total_count;
};

typedef i32 Token_Iterator_Kind;
enum{
    TokenIterator_Array,
    TokenIterator_List,
};

struct Token_Iterator{
    Token_Iterator_Kind kind;
    union{
        Token_Iterator_Array array;
        Token_Iterator_List list;
    };
};
# 33 "/home/sam/.bin/4coder/custom/4coder_default_include.cpp" 2
# 1 "/home/sam/.bin/4coder/custom/4coder_string_match.h" 1
# 15 "/home/sam/.bin/4coder/custom/4coder_string_match.h"
typedef b32 Buffer_Predicate(Application_Links *app, Buffer_ID buffer);
# 34 "/home/sam/.bin/4coder/custom/4coder_default_include.cpp" 2
# 1 "/home/sam/.bin/4coder/custom/4coder_helper.h" 1
# 10 "/home/sam/.bin/4coder/custom/4coder_helper.h"
struct File_Name_Data{
    String_Const_u8 file_name;
    Data data;
};

struct View_Context_Block{
    Application_Links *app;
    View_ID view;

    View_Context_Block(Application_Links *app, View_ID view, View_Context *ctx);
    ~View_Context_Block();
};



typedef i32 Position_Within_Line;
enum{
    PositionWithinLine_Start,
    PositionWithinLine_SkipLeadingWhitespace,
    PositionWithinLine_End,
};

typedef u32 Buffer_Seek_String_Flags;
enum{
    BufferSeekString_Backward = 1,
    BufferSeekString_CaseInsensitive = 2,
};



typedef b8 Character_Predicate_Function(u8 c);

static Character_Predicate character_predicate_alpha = { {
        0, 0, 0, 0, 0, 0, 0, 0,
        254, 255, 255, 7, 254, 255, 255, 7,
        0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0,
    } };

static Character_Predicate character_predicate_alpha_numeric = { {
        0, 0, 0, 0, 0, 0, 255, 3,
        254, 255, 255, 7, 254, 255, 255, 7,
        0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0,
    } };

static Character_Predicate character_predicate_alpha_numeric_underscore = { {
        0, 0, 0, 0, 0, 0, 255, 3,
        254, 255, 255, 135, 254, 255, 255, 7,
        0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0,
    } };

static Character_Predicate character_predicate_uppercase = { {
        0, 0, 0, 0, 0, 0, 0, 0,
        254, 255, 255, 7, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0,
    } };

static Character_Predicate character_predicate_lowercase = { {
        0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 254, 255, 255, 7,
        0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0,
    } };

static Character_Predicate character_predicate_base10 = { {
        0, 0, 0, 0, 0, 0, 255, 3,
        0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0,
    } };

static Character_Predicate character_predicate_base16 = { {
        0, 0, 0, 0, 0, 0, 255, 3,
        126, 0, 0, 0, 126, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0,
    } };

static Character_Predicate character_predicate_whitespace = { {
        0, 62, 0, 0, 1, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0,
    } };

static Character_Predicate character_predicate_non_whitespace = { {
        255, 193, 255, 255, 254, 255, 255, 255,
        255, 255, 255, 255, 255, 255, 255, 255,
        255, 255, 255, 255, 255, 255, 255, 255,
        255, 255, 255, 255, 255, 255, 255, 255,
    } };

static Character_Predicate character_predicate_utf8_byte = { {
        0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0,
        255, 255, 255, 255, 255, 255, 255, 255,
        255, 255, 255, 255, 255, 255, 255, 255,
    } };

static Character_Predicate character_predicate_alpha_numeric_underscore_utf8 = { {
        0, 0, 0, 0, 0, 0, 255, 3,
        254, 255, 255, 135, 254, 255, 255, 7,
        255, 255, 255, 255, 255, 255, 255, 255,
        255, 255, 255, 255, 255, 255, 255, 255,
    } };

typedef i64 Boundary_Function(Application_Links *app, Buffer_ID buffer, Side side, Scan_Direction direction, i64 pos);

struct Boundary_Function_Node{
    Boundary_Function_Node *next;
    Boundary_Function *func;
};
struct Boundary_Function_List{
    Boundary_Function_Node *first;
    Boundary_Function_Node *last;
    i32 count;
};

typedef Range_i64 Enclose_Function(Application_Links *app, Buffer_ID buffer, Range_i64 range);

struct Indent_Info{
    i64 first_char_pos;
    i32 indent_pos;
    b32 is_blank;
    b32 all_space;
};



struct Sort_Pair_i32{
    i32 index;
    i32 key;
};



struct History_Group{
    Application_Links *app;
    Buffer_ID buffer;
    History_Record_Index first;
};



typedef i32 View_Split_Kind;
enum{
    ViewSplitKind_Ratio,
    ViewSplitKind_FixedPixels,
};



typedef i32 Nest_Delimiter_Kind;
enum{
    NestDelim_None = 0,
    NestDelim_Open = 1,
    NestDelim_Close = 2,
};

typedef u32 Find_Nest_Flag;
enum{
    FindNest_Scope = 1,
    FindNest_Paren = 2,
    FindNest_EndOfToken = 4,
    FindNest_Balanced = 8,
};
# 35 "/home/sam/.bin/4coder/custom/4coder_default_include.cpp" 2
# 1 "/home/sam/.bin/4coder/custom/4coder_delta_rule.h" 1
# 10 "/home/sam/.bin/4coder/custom/4coder_delta_rule.h"
union Delta_Context_Header{
    Buffer_Point point;
    Vec2_f32 p;
};
struct Buffer_Point_Delta_Result{
    Buffer_Point point;
    b32 still_animating;
};
struct Vec2_f32_Delta_Result{
    Vec2_f32 p;
    b32 still_animating;
};

struct Smooth_Step{
    f32 p;
    f32 v;
};
# 36 "/home/sam/.bin/4coder/custom/4coder_default_include.cpp" 2
# 1 "/home/sam/.bin/4coder/custom/4coder_layout_rule.h" 1
# 10 "/home/sam/.bin/4coder/custom/4coder_layout_rule.h"
struct Newline_Layout_Vars{
    i64 newline_character_index;
    b32 consuming_newline_characters;
    b32 prev_did_emit_newline;
};

struct LefRig_TopBot_Layout_Vars{
    Face_Advance_Map *advance_map;
    Face_Metrics *metrics;
    f32 line_to_text_shift;

    Vec2_f32 blank_dim;

    Vec2_f32 p;
    f32 line_y;
    f32 text_y;
    f32 width;
};

struct Layout_Reflex{
    Layout_Item_List *list;
    Buffer_ID buffer;
    f32 width;
    Face_ID face;
};

typedef i32 Layout_Wrap_Kind;
enum{
    Layout_Unwrapped,
    Layout_Wrapped,
};

typedef i32 Layout_Virtual_Indent;
enum{
    LayoutVirtualIndent_Off,
    LayoutVirtualIndent_On,
};
# 37 "/home/sam/.bin/4coder/custom/4coder_default_include.cpp" 2
# 1 "/home/sam/.bin/4coder/custom/4coder_code_index.h" 1
# 10 "/home/sam/.bin/4coder/custom/4coder_code_index.h"
struct Code_Index_Nest_List{
    struct Code_Index_Nest *first;
    struct Code_Index_Nest *last;
    i32 count;
};

struct Code_Index_Nest_Ptr_Array{
    struct Code_Index_Nest **ptrs;
    i32 count;
};

typedef i32 Code_Index_Nest_Kind;
enum{
    CodeIndexNest_Scope,
    CodeIndexNest_Paren,
    CodeIndexNest_Preprocessor,
    CodeIndexNest_Statement,
};

struct Code_Index_Nest{
    Code_Index_Nest *next;

    Code_Index_Nest_Kind kind;
    b32 is_closed;
    Range_i64 open;
    Range_i64 close;

    struct Code_Index_File *file;
    Code_Index_Nest *parent;

    Code_Index_Nest_List nest_list;
    Code_Index_Nest_Ptr_Array nest_array;
};

typedef i64 Code_Index_Note_Kind;
enum{
    CodeIndexNote_Type,
    CodeIndexNote_Function,
    CodeIndexNote_Macro,
    CodeIndexNote_4coderCommand,
};

struct Code_Index_Note{
    Code_Index_Note *next;
    Code_Index_Note_Kind note_kind;
    Range_i64 pos;
    String_Const_u8 text;
    struct Code_Index_File *file;
    Code_Index_Nest *parent;
};

struct Code_Index_Note_List{
    Code_Index_Note *first;
    Code_Index_Note *last;
    i32 count;
};

struct Code_Index_Note_Ptr_Array{
    Code_Index_Note **ptrs;
    i32 count;
};

struct Code_Index_File{
    Code_Index_Nest_List nest_list;
    Code_Index_Nest_Ptr_Array nest_array;
    Code_Index_Note_List note_list;
    Code_Index_Note_Ptr_Array note_array;
    Buffer_ID buffer;
};

struct Code_Index_File_Storage{
    Code_Index_File_Storage *next;
    Code_Index_File_Storage *prev;
    Arena arena;
    Code_Index_File *file;
};

struct Code_Index{
    System_Mutex mutex;
    Arena node_arena;
    Table_u64_u64 buffer_to_index_file;
    Code_Index_File_Storage *free_storage;
    Code_Index_File_Storage *storage_first;
    Code_Index_File_Storage *storage_last;
    i32 storage_count;
};



typedef void Generic_Parse_Comment_Function(Application_Links *app, Arena *arena, Code_Index_File *index,
                                            Token *token, String_Const_u8 contents);

struct Generic_Parse_State{
    Application_Links *app;
    Arena *arena;
    String_Const_u8 contents;
    Token_Iterator_Array it;
    Generic_Parse_Comment_Function *handle_comment;
    u8 *prev_line_start;
    b32 finished;

    i32 scope_counter;
    i32 paren_counter;
    b32 in_preprocessor;
    b32 in_statement;

    b32 do_cpp_parse;
};
# 38 "/home/sam/.bin/4coder/custom/4coder_default_include.cpp" 2
# 1 "/home/sam/.bin/4coder/custom/4coder_draw.h" 1
# 10 "/home/sam/.bin/4coder/custom/4coder_draw.h"
struct Comment_Highlight_Pair{
    String_Const_u8 needle;
     ARGB_Color color;
};

typedef i32 Range_Highlight_Kind;
enum{
    RangeHighlightKind_LineHighlight,
    RangeHighlightKind_CharacterHighlight,
};
# 39 "/home/sam/.bin/4coder/custom/4coder_default_include.cpp" 2
# 1 "/home/sam/.bin/4coder/custom/4coder_insertion.h" 1
# 10 "/home/sam/.bin/4coder/custom/4coder_insertion.h"
struct Buffer_Insertion{
    Application_Links *app;
    Buffer_ID buffer;
    i64 at;
    b32 buffering;
    Cursor *cursor;
    Temp_Memory temp;
};
# 40 "/home/sam/.bin/4coder/custom/4coder_default_include.cpp" 2
# 1 "/home/sam/.bin/4coder/custom/4coder_command_map.h" 1
# 10 "/home/sam/.bin/4coder/custom/4coder_command_map.h"
typedef i64 Command_Map_ID;

struct Command_Trigger{
    Command_Trigger *next;
    Input_Event_Kind kind;
    u32 sub_code;
    Input_Modifier_Set mods;
};

struct Command_Trigger_List{
    Command_Trigger *first;
    Command_Trigger *last;
};

struct Command_Binding{
    union{
        Custom_Command_Function *custom;
        char *name;
    };

    Command_Binding();
    Command_Binding(Custom_Command_Function *c);
    Command_Binding(char *n);

    operator Custom_Command_Function*();
    operator char*();
};

struct Command_Modified_Binding{
    Command_Modified_Binding *next;
    SNode order_node;
    Input_Modifier_Set mods;
    Command_Binding binding;
};

struct Command_Binding_List{
    Command_Binding_List *next;
    SNode *first;
    SNode *last;
    i32 count;
};

struct Command_Map{
    Command_Map *next;
    Command_Map *prev;
    Command_Map_ID id;
    Command_Map_ID parent;
    Command_Binding text_input_command;
    Arena node_arena;
    Table_u64_u64 event_code_to_binding_list;
    Table_u64_u64 cmd_to_binding_trigger;
    Command_Modified_Binding *binding_first;
    Command_Modified_Binding *binding_last;
    Command_Binding_List *list_first;
    Command_Binding_List *list_last;

    struct Binding_Unit *real_beginning;
};

struct Mapping{
    Arena node_arena;
    Heap heap;
    Base_Allocator heap_wrapper;
    Table_u64_u64 id_to_map;
    Command_Map_ID id_counter;
    Command_Map *first_map;
    Command_Map *last_map;
    Command_Map *free_maps;
    Command_Modified_Binding *free_bindings;
    Command_Binding_List *free_lists;
};

typedef i32 Binding_Match_Rule;
enum{
    BindingMatchRule_Strict,
    BindingMatchRule_Loose,
};

struct Map_Event_Breakdown{
    Input_Modifier_Set *mod_set;
    u64 key;
    Key_Code skip_self_mod;
};
# 41 "/home/sam/.bin/4coder/custom/4coder_default_include.cpp" 2
# 1 "/home/sam/.bin/4coder/custom/4coder_lister_base.h" 1
# 10 "/home/sam/.bin/4coder/custom/4coder_lister_base.h"
typedef i32 Lister_Activation_Code;
enum{
    ListerActivation_Finished = 0,
    ListerActivation_Continue = 1,
    ListerActivation_ContinueAndRefresh = 2,
};

typedef void Lister_Regenerate_List_Function_Type(Application_Links *app, struct Lister *lister);

struct Lister_Node{
    Lister_Node *next;
    Lister_Node *prev;
    String_Const_u8 string;
    union{
        String_Const_u8 status;
        i32 index;
    };
    void *user_data;
    i32 raw_index;
};

struct Lister_Node_List{
    Lister_Node *first;
    Lister_Node *last;
    i32 count;
};

struct Lister_Node_Ptr_Array{
    Lister_Node **node_ptrs;
    i32 count;
};

typedef Lister_Activation_Code Lister_Write_Character_Function(Application_Links *app);
typedef Lister_Activation_Code Lister_Key_Stroke_Function(Application_Links *app);
typedef void Lister_Navigate_Function(Application_Links *app,
                                      View_ID view, struct Lister *lister,
                                      i32 index_delta);

struct Lister_Handlers{
    Lister_Regenerate_List_Function_Type *refresh;
    Lister_Write_Character_Function *write_character;
    Custom_Command_Function *backspace;
    Lister_Navigate_Function *navigate;
    Lister_Key_Stroke_Function *key_stroke;
};

struct Lister_Result{
    b32 canceled;
    b32 activated_by_click;
    String_Const_u8 text_field;
    void *user_data;
};

struct Lister{
    Arena *arena;
    Temp_Memory restore_all_point;

    Lister_Handlers handlers;

    Mapping *mapping;
    Command_Map *map;

    u8 query_space[256];
    u8 text_field_space[256];
    u8 key_string_space[256];
    String_u8 query;
    String_u8 text_field;
    String_u8 key_string;

    Lister_Node_List options;
    Temp_Memory filter_restore_point;
    Lister_Node_Ptr_Array filtered;

    b32 set_vertical_focus_to_item;
    Lister_Node *highlighted_node;
    void *hot_user_data;
    i32 item_index;
    i32 raw_item_index;

    Basic_Scroll scroll;
    i32 visible_count;

    Lister_Result out;
};

struct Lister_Prev_Current{
    Lister *prev;
    Lister *current;
};

struct Lister_Block{
    Application_Links *app;
    Lister_Prev_Current lister;
    Lister_Block(Application_Links *app, Arena *arena);
    ~Lister_Block();
    operator Lister *();
};

struct Lister_Prealloced_String{
    String_Const_u8 string;
};

struct Lister_Filtered{
    Lister_Node_Ptr_Array exact_matches;
    Lister_Node_Ptr_Array before_extension_matches;
    Lister_Node_Ptr_Array substring_matches;
};



struct Lister_Choice{
    Lister_Choice *next;
    String_Const_u8 string;
    String_Const_u8 status;
    Key_Code key_code;
    union{
        u64 user_data;
        void *user_data_ptr;
    };
};

struct Lister_Choice_List{
    Lister_Choice *first;
    Lister_Choice *last;
};
# 42 "/home/sam/.bin/4coder/custom/4coder_default_include.cpp" 2
# 1 "/home/sam/.bin/4coder/custom/4coder_clipboard.h" 1
# 10 "/home/sam/.bin/4coder/custom/4coder_clipboard.h"
struct Clipboard{
    Arena arena;
    Heap heap;
    String_Const_u8 *clips;
    u32 clip_index;
    u32 clip_capacity;
};
# 43 "/home/sam/.bin/4coder/custom/4coder_default_include.cpp" 2
# 1 "/home/sam/.bin/4coder/custom/4coder_default_framework.h" 1
# 12 "/home/sam/.bin/4coder/custom/4coder_default_framework.h"
typedef i64 Rewrite_Type;
enum{
    Rewrite_None,
    Rewrite_NoChange,
    Rewrite_Paste,
    Rewrite_WordComplete
};



struct ID_Line_Column_Jump_Location{
    Buffer_ID buffer_id;
    i32 line;
    i32 column;
};
typedef ID_Line_Column_Jump_Location ID_Based_Jump_Location;

struct ID_Pos_Jump_Location{
    Buffer_ID buffer_id;
    i64 pos;
};

struct Name_Line_Column_Location{
    String_Const_u8 file;
    i32 line;
    i32 column;
};

struct Parsed_Jump{
    b32 success;
    Name_Line_Column_Location location;
    i32 colon_position;
    b32 is_sub_jump;
    b32 sub_jump_indented;
    b32 sub_jump_note;
    b32 is_ms_style;
    b32 has_rust_arrow;
};

struct ID_Pos_Jump_Location_Array{
    struct ID_Pos_Jump_Location *jumps;
    i32 count;
};





struct Point_Stack_Slot{
    Buffer_ID buffer;
    Managed_Object object;
};

struct Point_Stack{
    Point_Stack_Slot markers[100 + 1];
    i32 top;
    i32 bot;
};



typedef i32 Fallback_Dispatch_Result_Code;
enum{
    FallbackDispatch_Unhandled,
    FallbackDispatch_DidCall,
    FallbackDispatch_DelayedUICall,
};

struct Fallback_Dispatch_Result{
    Fallback_Dispatch_Result_Code code;
    Custom_Command_Function *func;
};



typedef void View_Render_Hook(Application_Links *app, View_ID view, Frame_Info frame_info, Rect_f32 inner);



static b32
do_buffer_kill_user_check(Application_Links *app, Buffer_ID buffer, View_ID view);

static b32
do_4coder_close_user_check(Application_Links *app, View_ID view);



struct Buffer_Modified_Node{
    Buffer_Modified_Node *next;
    Buffer_Modified_Node *prev;
    Buffer_ID buffer;
};

struct Buffer_Modified_Set{
    Arena arena;
    Buffer_Modified_Node *free;
    Buffer_Modified_Node *first;
    Buffer_Modified_Node *last;
    Table_u64_u64 id_to_node;
};



struct Fade_Range{
    Fade_Range *next;
    Buffer_ID buffer_id;
    f32 t;
    f32 full_t;
    ARGB_Color color;
    b32 negate_fade_direction;
    Range_i64 range;

    void (*finish_call)(Application_Links *app, struct Fade_Range *range);
    void *opaque[4];
};

struct Fade_Range_List{
    Fade_Range *first;
    Fade_Range *last;
    i32 count;
};
# 44 "/home/sam/.bin/4coder/custom/4coder_default_include.cpp" 2
# 1 "/home/sam/.bin/4coder/custom/4coder_config.h" 1
# 14 "/home/sam/.bin/4coder/custom/4coder_config.h"
struct Error_Location{
    i32 line_number;
    i32 column_number;
};

struct Config_Error{
    Config_Error *next;
    Config_Error *prev;
    String_Const_u8 file_name;
    u8 *pos;
    String_Const_u8 text;
};

struct Config_Error_List{
    Config_Error *first;
    Config_Error *last;
    i32 count;
};

struct Config_Parser{
    Token *start;
    Token *token;
    Token *end;

    String_Const_u8 file_name;
    String_Const_u8 data;

    Arena *arena;

    Config_Error_List errors;
};

struct Config_LValue{
    String_Const_u8 identifier;
    i32 index;
};

typedef i32 Config_RValue_Type;
enum{
    ConfigRValueType_LValue = 0,
    ConfigRValueType_Boolean = 1,
    ConfigRValueType_Integer = 2,
    ConfigRValueType_Float = 3,
    ConfigRValueType_String = 4,
    ConfigRValueType_Character = 5,
    ConfigRValueType_Compound = 6,
    ConfigRValueType_NoType = 7,
};
enum{
    ConfigRValueType_COUNT = ConfigRValueType_NoType,
};

struct Config_Compound{
    struct Config_Compound_Element *first;
    struct Config_Compound_Element *last;
    i32 count;
};

struct Config_RValue{
    Config_RValue_Type type;
    union{
        Config_LValue *lvalue;
        b32 boolean;
        i32 integer;
        u32 uinteger;
        String_Const_u8 string;
        char character;
        Config_Compound *compound;
    };
};

struct Config_Integer{
    b32 is_signed;
    union{
        i32 integer;
        u32 uinteger;
    };
};

typedef i32 Config_Layout_Type;
enum{
    ConfigLayoutType_Unset = 0,
    ConfigLayoutType_Identifier = 1,
    ConfigLayoutType_Integer = 2,
    ConfigLayoutType_COUNT = 3,
};
struct Config_Layout{
    Config_Layout_Type type;
    u8 *pos;
    union{
        String_Const_u8 identifier;
        i32 integer;
    };
};

struct Config_Compound_Element{
    Config_Compound_Element *next;
    Config_Compound_Element *prev;

    Config_Layout l;
    Config_RValue *r;
};

struct Config_Assignment{
    Config_Assignment *next;
    Config_Assignment *prev;

    u8 *pos;
    Config_LValue *l;
    Config_RValue *r;

    b32 visited;
};

struct Config{
    i32 *version;
    Config_Assignment *first;
    Config_Assignment *last;
    i32 count;

    Config_Error_List errors;

    String_Const_u8 file_name;
    String_Const_u8 data;
};



typedef i32 Iteration_Step_Result;
enum{
    Iteration_Good = 0,
    Iteration_Skip = 1,
    Iteration_Quit = 2,
};

struct Config_Get_Result{
    b32 success;
    Config_RValue_Type type;
    u8 *pos;
    union{
        b32 boolean;
        i32 integer;
        u32 uinteger;
        String_Const_u8 string;
        char character;
        Config_Compound *compound;
    };
};

struct Config_Iteration_Step_Result{
    Iteration_Step_Result step;
    Config_Get_Result get;
};

struct Config_Get_Result_Node{
    Config_Get_Result_Node *next;
    Config_Get_Result_Node *prev;
    Config_Get_Result result;
};

struct Config_Get_Result_List{
    Config_Get_Result_Node *first;
    Config_Get_Result_Node *last;
    i32 count;
};



struct Config_Data{
    u8 user_name_space[256];
    String_Const_u8 user_name;

    String_Const_u8_Array code_exts;

    u8 mapping_space[64];
    String_Const_u8 mapping;

    u8 mode_space[64];
    String_Const_u8 mode;

    b8 bind_by_physical_key;
    b8 use_scroll_bars;
    b8 use_file_bars;
    b8 hide_file_bar_in_ui;
    b8 use_error_highlight;
    b8 use_jump_highlight;
    b8 use_scope_highlight;
    b8 use_paren_helper;
    b8 use_comment_keyword;
    b8 lister_whole_word_backspace_when_modified;
    b8 show_line_number_margins;
    b8 enable_output_wrapping;
    b8 indent_with_tabs;
    b8 enable_undo_fade_out;

    b8 enable_virtual_whitespace;
    b8 enable_code_wrapping;
    b8 automatically_indent_text_on_save;
    b8 automatically_save_changes_on_build;
    b8 automatically_load_project;

    f32 cursor_roundness;
    f32 mark_thickness;
    f32 lister_roundness;

    i32 virtual_whitespace_regular_indent;

    i32 indent_width;
    i32 default_tab_width;

    u8 default_theme_name_space[256];
    String_Const_u8 default_theme_name;

    b8 highlight_line_at_cursor;

    u8 default_font_name_space[256];
    String_Const_u8 default_font_name;
    i32 default_font_size;
    b8 default_font_hinting;

    u8 default_compiler_bat_space[256];
    String_Const_u8 default_compiler_bat;

    u8 default_flags_bat_space[1024];
    String_Const_u8 default_flags_bat;

    u8 default_compiler_sh_space[256];
    String_Const_u8 default_compiler_sh;

    u8 default_flags_sh_space[1024];
    String_Const_u8 default_flags_sh;

    b8 lalt_lctrl_is_altgr;
};
# 45 "/home/sam/.bin/4coder/custom/4coder_default_include.cpp" 2
# 1 "/home/sam/.bin/4coder/custom/4coder_auto_indent.h" 1
# 10 "/home/sam/.bin/4coder/custom/4coder_auto_indent.h"
typedef u32 Indent_Flag;
enum{
    Indent_ClearLine = 0x1,
    Indent_UseTab = 0x2,
    Indent_FullTokens = 0x4,
};

struct Nest{
    Nest *next;
    Token_Base_Kind kind;
    i64 indent;
};

struct Nest_Alloc{
    Nest *free_nest;
};

struct Indent_Line_Cache{
    i64 where_token_starts;
    i64 line_number_for_cached_indent;
    i64 start_pos;
    i64 one_past_last_pos;
    Indent_Info indent_info;
};
# 46 "/home/sam/.bin/4coder/custom/4coder_default_include.cpp" 2
# 1 "/home/sam/.bin/4coder/custom/4coder_search.h" 1
# 10 "/home/sam/.bin/4coder/custom/4coder_search.h"
typedef u32 List_All_Locations_Flag;
enum{
    ListAllLocationsFlag_CaseSensitive = 1,
    ListAllLocationsFlag_MatchSubstring = 2,
};

struct Word_Complete_Iterator{
    Application_Links *app;
    Arena *arena;

    Temp_Memory arena_restore;
    Buffer_ID first_buffer;
    Buffer_ID current_buffer;
    b32 scan_all_buffers;
    String_Const_u8 needle;

    List_String_Const_u8 list;
    Node_String_Const_u8 *node;
    Table_Data_u64 already_used_table;
};

struct Word_Complete_Menu{
    Render_Caller_Function *prev_render_caller;
    Word_Complete_Iterator *it;
    String_Const_u8 options[8];
    i32 count;
};
# 47 "/home/sam/.bin/4coder/custom/4coder_default_include.cpp" 2
# 1 "/home/sam/.bin/4coder/custom/4coder_build_commands.h" 1
# 48 "/home/sam/.bin/4coder/custom/4coder_default_include.cpp" 2
# 1 "/home/sam/.bin/4coder/custom/4coder_jumping.h" 1
# 10 "/home/sam/.bin/4coder/custom/4coder_jumping.h"
typedef u32 Jump_Flag;
enum{
    JumpFlag_SkipSubs = 1,
};
# 49 "/home/sam/.bin/4coder/custom/4coder_default_include.cpp" 2
# 1 "/home/sam/.bin/4coder/custom/4coder_jump_sticky.h" 1
# 10 "/home/sam/.bin/4coder/custom/4coder_jump_sticky.h"
struct Sticky_Jump{
    i64 list_line;
    i64 list_colon_index;
    b32 is_sub_error;
    Buffer_ID jump_buffer_id;
    i64 jump_pos;
};

struct Sticky_Jump_Stored{
    i64 list_line;
    i64 list_colon_index;
    b32 is_sub_error;
    Buffer_ID jump_buffer_id;
    i32 index_into_marker_array;
};

struct Sticky_Jump_Node{
    Sticky_Jump_Node *next;
    Sticky_Jump jump;
};

struct Sticky_Jump_Array{
    Sticky_Jump *jumps;
    i32 count;
};

struct Sticky_Jump_Node_Header{
    Managed_Object memory;
    Managed_Object markers;
    i32 first_index;
    i32 count;
};

enum Jump_Location_Flag{
    JumpFlag_IsSubJump = 0x1,
};

struct Marker_List{
    Managed_Object jump_array;
    i32 jump_count;
    i32 previous_size;
    Buffer_ID buffer_id;
};

struct Marker_List_Node{
    Marker_List_Node *next;
    Marker_List_Node *prev;
    Marker_List list;
    Buffer_ID buffer_id;
};

struct Locked_Jump_State{
    View_ID view;
    Marker_List *list;
    i32 list_index;
};
# 50 "/home/sam/.bin/4coder/custom/4coder_default_include.cpp" 2
# 1 "/home/sam/.bin/4coder/custom/4coder_jump_lister.h" 1
# 10 "/home/sam/.bin/4coder/custom/4coder_jump_lister.h"
typedef i32 Jump_Lister_Activation_Rule;
enum{
    JumpListerActivation_OpenInUIView = 0,
    JumpListerActivation_OpenInTargetViewKeepUI = 1,
    JumpListerActivation_OpenInTargetViewCloseUI = 2,
    JumpListerActivation_OpenInNextViewKeepUI = 3,
    JumpListerActivation_OpenInNextViewCloseUI = 4,
};

struct Jump_Lister_Parameters{
    Buffer_ID list_buffer_id;
    Jump_Lister_Activation_Rule activation_rule;
    View_ID target_view_id;
};

struct Jump_Lister_Result{
    b32 success;
    i32 index;
};
# 51 "/home/sam/.bin/4coder/custom/4coder_default_include.cpp" 2
# 1 "/home/sam/.bin/4coder/custom/4coder_project_commands.h" 1
# 10 "/home/sam/.bin/4coder/custom/4coder_project_commands.h"
enum{
    OpenAllFilesFlag_Recursive = 1,
};



struct Project_File_Pattern{
    List_String_Const_u8 absolutes;
};

struct Project_File_Pattern_Array{
    Project_File_Pattern *patterns;
    i32 count;
};

struct Project_File_Load_Path{
    String_Const_u8 path;
    b32 recursive;
    b32 relative;
};

struct Project_File_Load_Path_Array{
    Project_File_Load_Path *paths;
    i32 count;
};

struct Project_Command{
    String_Const_u8 name;
    String_Const_u8 cmd;
    String_Const_u8 out;
    b32 footer_panel;
    b32 save_dirty_files;
    b32 cursor_at_end;
};

struct Project_Command_Array{
    Project_Command *commands;
    i32 count;
};

struct Project{
    b32 loaded;

    String_Const_u8 dir;
    String_Const_u8 name;

    Project_File_Pattern_Array pattern_array;
    Project_File_Pattern_Array blacklist_pattern_array;
    Project_File_Load_Path_Array load_path_array;
    Project_Command_Array command_array;

    i32 fkey_commands[16];
};

typedef i32 Project_OS_Match_Level;
enum{
    ProjectOSMatchLevel_NoMatch = 0,
    ProjectOSMatchLevel_PassiveMatch = 1,
    ProjectOSMatchLevel_ActiveMatch = 2,
};

struct Project_Parse_Result{
    Config *parsed;
    Project *project;
};



struct Project_Setup_Status{
    b32 bat_exists;
    b32 sh_exists;
    b32 project_exists;
    b32 everything_exists;
};

struct Project_Key_Strings{
    b32 success;
    String_Const_u8 script_file;
    String_Const_u8 code_file;
    String_Const_u8 output_dir;
    String_Const_u8 binary_file;
};



struct Project_Command_Lister_Result{
    b32 success;
    i32 index;
};
# 52 "/home/sam/.bin/4coder/custom/4coder_default_include.cpp" 2
# 1 "/home/sam/.bin/4coder/custom/4coder_function_list.h" 1
# 10 "/home/sam/.bin/4coder/custom/4coder_function_list.h"
struct Function_Positions{
    i64 sig_start_index;
    i64 sig_end_index;
    i64 open_paren_pos;
};

struct Get_Positions_Results{
    i64 positions_count;
    i64 next_token_index;
    b32 still_looping;
};
# 53 "/home/sam/.bin/4coder/custom/4coder_default_include.cpp" 2
# 1 "/home/sam/.bin/4coder/custom/4coder_scope_commands.h" 1
# 54 "/home/sam/.bin/4coder/custom/4coder_default_include.cpp" 2
# 1 "/home/sam/.bin/4coder/custom/4coder_combined_write_commands.h" 1






struct Snippet{
    char *name;
    char *text;
    i32 cursor_offset;
    i32 mark_offset;
};

struct Snippet_Array{
    Snippet *snippets;
    i32 count;
};
# 55 "/home/sam/.bin/4coder/custom/4coder_default_include.cpp" 2
# 1 "/home/sam/.bin/4coder/custom/4coder_log_parser.h" 1
# 15 "/home/sam/.bin/4coder/custom/4coder_log_parser.h"
typedef i64 Log_Tag_Kind;
enum{
    LogTagKind_Null,
    LogTagKind_Integer,
    LogTagKind_String,
};

typedef i32 Log_String_Source;
enum{
    LogParse_ExternalString,
    LogParse_PreAllocatedString,
};

struct Log_Tag_Value{
    Log_Tag_Kind kind;
    union{
        u64 value;
        i64 value_s;
    };
};

struct Log_Sort_Key{
    Log_Tag_Value value;
    i32 number;
};

struct Log_Tag_Name_Value{
    u64 name;
    Log_Tag_Value value;
};

struct Log_Tag{
    Log_Tag *next;
    u64 name;
    Log_Tag_Value value;
};

struct Log_Event{
    Log_Event *next;
    u64 src_file_name;
    u64 event_name;
    u64 line_number;

    Log_Tag *first_tag;
    Log_Tag *last_tag;
    i32 tag_count;

    i32 event_number;

    Table_u64_u64 tag_name_to_tag_ptr_table;
};

struct Log_Event_Ptr_Node{
    Log_Event_Ptr_Node *next;
    Log_Event *event;
};

struct Log_Event_List{
    Log_Event_Ptr_Node *first;
    Log_Event_Ptr_Node *last;
    i32 count;
};

struct Log_Event_Ptr_Array{
    Log_Event **events;
    i32 count;
};

struct Log_Tag_Value_Array{
    Log_Tag_Value *vals;
    i32 count;
};

struct Log_Parse{
    Arena *arena;

    Log_Event *first_event;
    Log_Event *last_event;
    i32 event_count;

    u64 string_id_counter;
    Table_Data_u64 string_to_id_table;
    Table_u64_Data id_to_string_table;

    Table_Data_u64 tag_value_to_event_list_table;
    Table_u64_u64 tag_name_to_event_list_table;
};



struct Log_Graph_Thread_Bucket{
    Log_Graph_Thread_Bucket *next;
    Range_i32 range;
    b32 had_a_tag;
    u64 thread_id_value;
};

struct Log_Graph_Box{
    Log_Graph_Box *next;
    Rect_f32 rect;
    Log_Event *event;
};

typedef i32 Log_Filter_Kind;
enum{
    LogFilter_ERROR,
    LogFilter_TagValue,
    LogFilter_Tag,
};

struct Log_Filter{
    Log_Filter *next;
    Log_Filter *prev;
    Log_Filter_Kind kind;
    u64 tag_name_code;
    Log_Tag_Value tag_value;
};

struct Log_Filter_Set{
    Log_Filter filters_memory[20];
    Log_Filter *free_filters;
    Log_Filter *first;
    Log_Filter *last;
    i32 count;
    i32 alter_counter;
};

typedef i32 Log_Graph_List_Tab;
enum{
    LogTab_ERROR,
    LogTab_Filters,
    LogTab_Previews,
    LogTab_COUNT,
};

struct Log_Graph{
    b32 holding_temp;
    Temp_Memory temp;
    Rect_f32 layout_region;
    Face_ID face_id;
    i32 filter_alter_counter;
    i32 preview_alter_counter;
    Log_Graph_List_Tab tab;
    Rect_f32 details_region;
    Log_Event_List filtered_list;
    Log_Event_Ptr_Array event_array;
    Log_Graph_Thread_Bucket *first_bucket;
    Log_Graph_Thread_Bucket *last_bucket;
    i32 bucket_count;
    Log_Graph_Box *first_box;
    Log_Graph_Box *last_box;
    i32 box_count;
    f32 y_scroll;
    f32 max_y_scroll;
    Log_Event *selected_event;
    b32 has_unused_click;
    Vec2_f32 unused_click;
};
# 56 "/home/sam/.bin/4coder/custom/4coder_default_include.cpp" 2
# 1 "/home/sam/.bin/4coder/custom/4coder_profile_inspect.h" 1
# 10 "/home/sam/.bin/4coder/custom/4coder_profile_inspect.h"
struct Profile_Node_Ptr{
    Profile_Node_Ptr *next;
    struct Profile_Node *ptr;
};

struct Profile_Slot{
    Profile_Slot *next;
    String_Const_u8 location;
    String_Const_u8 name;

    u64 total_time;
    b32 corrupted_time;

    i32 hit_count;
    Profile_Node_Ptr *first_hit;
    Profile_Node_Ptr *last_hit;
};

struct Profile_Node{
    Profile_Node *next;
    Profile_Node *parent;
    Profile_Slot *slot;
    struct Profile_Inspection_Thread *thread;
    Range_u64 time;
    Profile_ID id;
    u64 unique_counter;

    Profile_Node *first_child;
    Profile_Node *last_child;
    i32 child_count;

    b32 closed;
};

struct Profile_Inspection_Thread{
    i32 thread_id;
    String_Const_u8 name;
    Profile_Node root;
    u64 active_time;
};

struct Profile_Error{
    Profile_Error *next;
    String_Const_u8 message;
    String_Const_u8 location;
};

typedef i32 Profile_Inspection_Tab;
enum{
    ProfileInspectTab_None,
    ProfileInspectTab_Threads,
    ProfileInspectTab_Blocks,
    ProfileInspectTab_Errors,
    ProfileInspectTab_Memory,
    ProfileInspectTab_Selection,
};

struct Profile_Inspection{
    Profile_Slot *first_slot;
    Profile_Slot *last_slot;
    Profile_Error *first_error;
    Profile_Error *last_error;
    Profile_Inspection_Thread *threads;
    i32 slot_count;
    i32 thread_count;
    i32 error_count;

    Profile_Inspection_Tab tab_id;
    Profile_Inspection_Thread *selected_thread;
    Profile_Slot *selected_slot;
    Profile_Node *selected_node;

    Profile_Inspection_Tab tab_id_hovered;
    String_Const_u8 full_name_hovered;
    u64 unique_counter_hovered;
    String_Const_u8 location_jump_hovered;
    Profile_Inspection_Thread *hover_thread;
    Profile_Slot *hover_slot;
    Profile_Node *hover_node;
};

static Profile_Inspection global_profile_inspection = {};

struct Memory_Bucket{
    Memory_Bucket *next;
    Memory_Annotation annotation;
    String_Const_u8 location;
    u64 total_memory;
};
# 57 "/home/sam/.bin/4coder/custom/4coder_default_include.cpp" 2
# 1 "/home/sam/.bin/4coder/custom/4coder_tutorial.h" 1
# 10 "/home/sam/.bin/4coder/custom/4coder_tutorial.h"
typedef i32 Tutorial_Action;
enum{
    TutorialAction_None,
    TutorialAction_Minimize,
    TutorialAction_Maximize,
    TutorialAction_Prev,
    TutorialAction_Next,
    TutorialAction_Exit,
    TutorialAction_Restart,
};

struct Tutorial_Slide{
    Fancy_Block long_details;
    Fancy_Line short_details;
};

typedef Tutorial_Slide Tutorial_Slide_Function(Application_Links *app, Arena *arena);

struct Tutorial_State{
    b32 in_tutorial;
    View_ID view;
    Face_ID face;
    b32 is_active;
    Tutorial_Action hover_action;
    Tutorial_Action depressed_action;

    i32 slide_index;
    Tutorial_Slide_Function **slide_func_ptrs;
    i32 slide_count;
};
# 58 "/home/sam/.bin/4coder/custom/4coder_default_include.cpp" 2



# 1 "/home/sam/.bin/4coder/custom/4coder_base_types.cpp" 1
# 12 "/home/sam/.bin/4coder/custom/4coder_base_types.cpp"
static i32
i32_ceil32(f32 v){
    return(((v)>0)?( (v == (i32)(v))?((i32)(v)):((i32)((v)+1.f)) ):( ((i32)(v)) ));
}

static i32
i32_floor32(f32 v){
    return(((v)<0)?( (v == (i32)(v))?((i32)(v)):((i32)((v)-1.f)) ):( ((i32)(v)) ));
}

static i32
i32_round32(f32 v){
    return(i32_floor32(v + 0.5f));
}

static f32
f32_ceil32(f32 v){
    return((f32)i32_ceil32(v));
}

static f32
f32_floor32(f32 v){
    return((f32)i32_floor32(v));
}

static f32
f32_round32(f32 v){
    return((f32)i32_round32(v));
}

static i8
round_up_i8(i8 x, i8 b){
    x += b - 1;
    x -= x%b;
    return(x);
}
static u8
round_up_u8(u8 x, u8 b){
    x += b - 1;
    x -= x%b;
    return(x);
}
static i16
round_up_i16(i16 x, i16 b){
    x += b - 1;
    x -= x%b;
    return(x);
}
static u16
round_up_u16(u16 x, u16 b){
    x += b - 1;
    x -= x%b;
    return(x);
}
static i32
round_up_i32(i32 x, i32 b){
    x += b - 1;
    x -= x%b;
    return(x);
}
static u32
round_up_u32(u32 x, u32 b){
    x += b - 1;
    x -= x%b;
    return(x);
}
static i64
round_up_i64(i64 x, i64 b){
    x += b - 1;
    x -= x%b;
    return(x);
}
static u64
round_up_u64(u64 x, u64 b){
    x += b - 1;
    x -= x%b;
    return(x);
}

static i8
round_down_i8(i8 x, i8 b){
    x -= x%b;
    return(x);
}
static u8
round_down_u8(u8 x, u8 b){
    x -= x%b;
    return(x);
}
static i16
round_down_i16(i16 x, i16 b){
    x -= x%b;
    return(x);
}
static u16
round_down_u16(u16 x, u16 b){
    x -= x%b;
    return(x);
}
static i32
round_down_i32(i32 x, i32 b){
    x -= x%b;
    return(x);
}
static u32
round_down_u32(u32 x, u32 b){
    x -= x%b;
    return(x);
}
static i64
round_down_i64(i64 x, i64 b){
    x -= x%b;
    return(x);
}
static u64
round_down_u64(u64 x, u64 b){
    x -= x%b;
    return(x);
}

static f32
f32_integer(f32 x){
    return((f32)((i32)x));
}

static u32
round_up_pot_u32(u32 x){
    --x;
    x |= x >> 1;
    x |= x >> 2;
    x |= x >> 4;
    x |= x >> 8;
    x |= x >> 16;
    ++x;
    return(x);
}



static Data
make_data(void *memory, u64 size){
    Data data = {(u8*)memory, size};
    return(data);
}



static const Data zero_data = {};
# 168 "/home/sam/.bin/4coder/custom/4coder_base_types.cpp"
static void
block_zero(void *mem, u64 size){
    for (u8 *p = (u8*)mem, *e = p + size; p < e; p += 1){
        *p = 0;
    }
}
static void
block_zero(Data data){
    block_zero(data.data, data.size);
}
static void
block_fill_ones(void *mem, u64 size){
    for (u8 *p = (u8*)mem, *e = p + size; p < e; p += 1){
        *p = 0xFF;
    }
}
static void
block_fill_ones(Data data){
    block_fill_ones(data.data, data.size);
}
static void
block_copy(void *dst, const void *src, u64 size){
    u8 *d = (u8*)dst;
    u8 *s = (u8*)src;
    if (d < s){
        u8 *e = d + size;
        for (; d < e; d += 1, s += 1){
            *d = *s;
        }
    }
    else if (d > s){
        u8 *e = d;
        d += size - 1;
        s += size - 1;
        for (; d >= e; d -= 1, s -= 1){
            *d = *s;
        }
    }
}
static b32
block_match(void *a, void *b, u64 size){
    b32 result = true;
    for (u8 *pa = (u8*)a, *pb = (u8*)b, *ea = pa + size; pa < ea; pa += 1, pb += 1){
        if (*pa != *pb){
            result = false;
            break;
        }
    }
    return(result);
}
static i32
block_compare(void *a, void *b, u64 size){
    i32 result = 0;
    for (u8 *pa = (u8*)a, *pb = (u8*)b, *ea = pa + size; pa < ea; pa += 1, pb += 1){
        i32 dif = (i32)*pa - (i32)*pb;
        if (dif != 0){
            result = (dif > 0)?1:-1;
            break;
        }
    }
    return(result);
}
static void
block_fill_u8(void *a, u64 size, u8 val){
    for (u8 *ptr = (u8*)a, *e = ptr + size; ptr < e; ptr += 1){
        *ptr = val;
    }
}
static void
block_fill_u16(void *a, u64 size, u16 val){
    do{ if (!(size%sizeof(u16) == 0)) { (*((i32*)0) = 0xA11E); } }while(0);
    u64 count = size/sizeof(u16);
    for (u16 *ptr = (u16*)a, *e = ptr + count; ptr < e; ptr += 1){
        *ptr = val;
    }
}
static void
block_fill_u32(void *a, u64 size, u32 val){
    do{ if (!(size%sizeof(u32) == 0)) { (*((i32*)0) = 0xA11E); } }while(0);
    u64 count = size/sizeof(u32);
    for (u32 *ptr = (u32*)a, *e = ptr + count; ptr < e; ptr += 1){
        *ptr = val;
    }
}
static void
block_fill_u64(void *a, u64 size, u64 val){
    do{ if (!(size%sizeof(u64) == 0)) { (*((i32*)0) = 0xA11E); } }while(0);
    u64 count = size/sizeof(u64);
    for (u64 *ptr = (u64*)a, *e = ptr + count; ptr < e; ptr += 1){
        *ptr = val;
    }
}
# 272 "/home/sam/.bin/4coder/custom/4coder_base_types.cpp"
static void
block_range_copy__inner(void *dst, void *src, Range_u64 range, i64 shift){
    block_copy((u8*)dst + range.first + shift, (u8*)src + range.first, range.max - range.min);
}

static void
block_range_copy__inner(void *dst, void *src, Range_u64 range, i64 shift, u64 item_size){
    range.first *= item_size;
    range.one_past_last *= item_size;
    shift *= item_size;
    block_range_copy__inner(dst, src, range, shift);
}





static void
block_copy_array_shift__inner(void *dst, void *src, u64 it_size, Range_i64 range, i64 shift){
    u8 *dptr = (u8*)dst;
    u8 *sptr = (u8*)src;
    dptr += it_size*(range.first + shift);
    sptr += it_size*range.first;
    block_copy(dptr, sptr, (u64)(it_size*(range.one_past_last - range.first)));
}
static void
block_copy_array_shift__inner(void *dst, void *src, u64 it_size, Range_i32 range, i64 shift){
    u8 *dptr = (u8*)dst;
    u8 *sptr = (u8*)src;
    dptr += it_size*(range.first + shift);
    sptr += it_size*range.first;
    block_copy(dptr, sptr, (u64)(it_size*(range.one_past_last - range.first)));
}





static f32
abs_f32(f32 x){
    if (x < 0){
        x = -x;
    }
    return(x);
}


# 1 "/usr/include/c++/10.2.0/math.h" 1 3
# 320 "/home/sam/.bin/4coder/custom/4coder_base_types.cpp" 2

static f32
mod_f32(f32 x, i32 m){
    f32 whole;
    f32 frac = modff(x, &whole);
    f32 r = ((i32)(whole) % m) + frac;
    return(r);
}

static f32
sin_f32(f32 x){
    return(sinf(x));
}

static f32
cos_f32(f32 x){
    return(cosf(x));
}




static Vec2_i8
V2i8(i8 x, i8 y){
    Vec2_i8 v = {x, y};
    return(v);
}
static Vec3_i8
V3i8(i8 x, i8 y, i8 z){
    Vec3_i8 v = {x, y, z};
    return(v);
}
static Vec4_i8
V4i8(i8 x, i8 y, i8 z, i8 w){
    Vec4_i8 v = {x, y, z, w};
    return(v);
}
static Vec2_i16
V2i16(i16 x, i16 y){
    Vec2_i16 v = {x, y};
    return(v);
}
static Vec3_i16
V3i16(i16 x, i16 y, i16 z){
    Vec3_i16 v = {x, y, z};
    return(v);
}
static Vec4_i16
V4i16(i16 x, i16 y, i16 z, i16 w){
    Vec4_i16 v = {x, y, z, w};
    return(v);
}
static Vec2_i32
V2i32(i32 x, i32 y){
    Vec2_i32 v = {x, y};
    return(v);
}
static Vec3_i32
V3i32(i32 x, i32 y, i32 z){
    Vec3_i32 v = {x, y, z};
    return(v);
}
static Vec4_i32
V4i32(i32 x, i32 y, i32 z, i32 w){
    Vec4_i32 v = {x, y, z, w};
    return(v);
}
static Vec2_f32
V2f32(f32 x, f32 y){
    Vec2_f32 v = {x, y};
    return(v);
}
static Vec3_f32
V3f32(f32 x, f32 y, f32 z){
    Vec3_f32 v = {x, y, z};
    return(v);
}
static Vec4_f32
V4f32(f32 x, f32 y, f32 z, f32 w){
    Vec4_f32 v = {x, y, z, w};
    return(v);
}

static Vec2_i8
V2i8(Vec2_i8 o){
    return(V2i8((i8)o.x, (i8)o.y));
}
static Vec2_i8
V2i8(Vec2_i16 o){
    return(V2i8((i8)o.x, (i8)o.y));
}
static Vec2_i8
V2i8(Vec2_i32 o){
    return(V2i8((i8)o.x, (i8)o.y));
}
static Vec2_i8
V2i8(Vec2_f32 o){
    return(V2i8((i8)o.x, (i8)o.y));
}
static Vec3_i8
V3i8(Vec3_i8 o){
    return(V3i8((i8)o.x, (i8)o.y, (i8)o.z));
}
static Vec3_i8
V3i8(Vec3_i16 o){
    return(V3i8((i8)o.x, (i8)o.y, (i8)o.z));
}
static Vec3_i8
V3i8(Vec3_i32 o){
    return(V3i8((i8)o.x, (i8)o.y, (i8)o.z));
}
static Vec3_i8
V3i8(Vec3_f32 o){
    return(V3i8((i8)o.x, (i8)o.y, (i8)o.z));
}
static Vec4_i8
V4i8(Vec4_i8 o){
    return(V4i8((i8)o.x, (i8)o.y, (i8)o.z, (i8)o.w));
}
static Vec4_i8
V4i8(Vec4_i16 o){
    return(V4i8((i8)o.x, (i8)o.y, (i8)o.z, (i8)o.w));
}
static Vec4_i8
V4i8(Vec4_i32 o){
    return(V4i8((i8)o.x, (i8)o.y, (i8)o.z, (i8)o.w));
}
static Vec4_i8
V4i8(Vec4_f32 o){
    return(V4i8((i8)o.x, (i8)o.y, (i8)o.z, (i8)o.w));
}
static Vec2_i16
V2i16(Vec2_i8 o){
    return(V2i16((i16)o.x, (i16)o.y));
}
static Vec2_i16
V2i16(Vec2_i16 o){
    return(V2i16((i16)o.x, (i16)o.y));
}
static Vec2_i16
V2i16(Vec2_i32 o){
    return(V2i16((i16)o.x, (i16)o.y));
}
static Vec2_i16
V2i16(Vec2_f32 o){
    return(V2i16((i16)o.x, (i16)o.y));
}
static Vec3_i16
V3i16(Vec3_i8 o){
    return(V3i16((i16)o.x, (i16)o.y, (i16)o.z));
}
static Vec3_i16
V3i16(Vec3_i16 o){
    return(V3i16((i16)o.x, (i16)o.y, (i16)o.z));
}
static Vec3_i16
V3i16(Vec3_i32 o){
    return(V3i16((i16)o.x, (i16)o.y, (i16)o.z));
}
static Vec3_i16
V3i16(Vec3_f32 o){
    return(V3i16((i16)o.x, (i16)o.y, (i16)o.z));
}
static Vec4_i16
V4i16(Vec4_i8 o){
    return(V4i16((i16)o.x, (i16)o.y, (i16)o.z, (i16)o.w));
}
static Vec4_i16
V4i16(Vec4_i16 o){
    return(V4i16((i16)o.x, (i16)o.y, (i16)o.z, (i16)o.w));
}
static Vec4_i16
V4i16(Vec4_i32 o){
    return(V4i16((i16)o.x, (i16)o.y, (i16)o.z, (i16)o.w));
}
static Vec4_i16
V4i16(Vec4_f32 o){
    return(V4i16((i16)o.x, (i16)o.y, (i16)o.z, (i16)o.w));
}
static Vec2_i32
V2i32(Vec2_i8 o){
    return(V2i32((i32)o.x, (i32)o.y));
}
static Vec2_i32
V2i32(Vec2_i16 o){
    return(V2i32((i32)o.x, (i32)o.y));
}
static Vec2_i32
V2i32(Vec2_i32 o){
    return(V2i32((i32)o.x, (i32)o.y));
}
static Vec2_i32
V2i32(Vec2_f32 o){
    return(V2i32((i32)o.x, (i32)o.y));
}
static Vec3_i32
V3i32(Vec3_i8 o){
    return(V3i32((i32)o.x, (i32)o.y, (i32)o.z));
}
static Vec3_i32
V3i32(Vec3_i16 o){
    return(V3i32((i32)o.x, (i32)o.y, (i32)o.z));
}
static Vec3_i32
V3i32(Vec3_i32 o){
    return(V3i32((i32)o.x, (i32)o.y, (i32)o.z));
}
static Vec3_i32
V3i32(Vec3_f32 o){
    return(V3i32((i32)o.x, (i32)o.y, (i32)o.z));
}
static Vec4_i32
V4i32(Vec4_i8 o){
    return(V4i32((i32)o.x, (i32)o.y, (i32)o.z, (i32)o.w));
}
static Vec4_i32
V4i32(Vec4_i16 o){
    return(V4i32((i32)o.x, (i32)o.y, (i32)o.z, (i32)o.w));
}
static Vec4_i32
V4i32(Vec4_i32 o){
    return(V4i32((i32)o.x, (i32)o.y, (i32)o.z, (i32)o.w));
}
static Vec4_i32
V4i32(Vec4_f32 o){
    return(V4i32((i32)o.x, (i32)o.y, (i32)o.z, (i32)o.w));
}
static Vec2_f32
V2f32(Vec2_i8 o){
    return(V2f32((f32)o.x, (f32)o.y));
}
static Vec2_f32
V2f32(Vec2_i16 o){
    return(V2f32((f32)o.x, (f32)o.y));
}
static Vec2_f32
V2f32(Vec2_i32 o){
    return(V2f32((f32)o.x, (f32)o.y));
}
static Vec2_f32
V2f32(Vec2_f32 o){
    return(V2f32((f32)o.x, (f32)o.y));
}
static Vec3_f32
V3f32(Vec3_i8 o){
    return(V3f32((f32)o.x, (f32)o.y, (f32)o.z));
}
static Vec3_f32
V3f32(Vec3_i16 o){
    return(V3f32((f32)o.x, (f32)o.y, (f32)o.z));
}
static Vec3_f32
V3f32(Vec3_i32 o){
    return(V3f32((f32)o.x, (f32)o.y, (f32)o.z));
}
static Vec3_f32
V3f32(Vec3_f32 o){
    return(V3f32((f32)o.x, (f32)o.y, (f32)o.z));
}
static Vec4_f32
V4f32(Vec4_i8 o){
    return(V4f32((f32)o.x, (f32)o.y, (f32)o.z, (f32)o.w));
}
static Vec4_f32
V4f32(Vec4_i16 o){
    return(V4f32((f32)o.x, (f32)o.y, (f32)o.z, (f32)o.w));
}
static Vec4_f32
V4f32(Vec4_i32 o){
    return(V4f32((f32)o.x, (f32)o.y, (f32)o.z, (f32)o.w));
}
static Vec4_f32
V4f32(Vec4_f32 o){
    return(V4f32((f32)o.x, (f32)o.y, (f32)o.z, (f32)o.w));
}

static Vec2_i8
operator+(Vec2_i8 a, Vec2_i8 b){
    a.x += b.x;
    a.y += b.y;
    return(a);
}
static Vec3_i8
operator+(Vec3_i8 a, Vec3_i8 b){
    a.x += b.x;
    a.y += b.y;
    a.z += b.z;
    return(a);
}
static Vec4_i8
operator+(Vec4_i8 a, Vec4_i8 b){
    a.x += b.x;
    a.y += b.y;
    a.z += b.z;
    a.w += b.w;
    return(a);
}
static Vec2_i16
operator+(Vec2_i16 a, Vec2_i16 b){
    a.x += b.x;
    a.y += b.y;
    return(a);
}
static Vec3_i16
operator+(Vec3_i16 a, Vec3_i16 b){
    a.x += b.x;
    a.y += b.y;
    a.z += b.z;
    return(a);
}
static Vec4_i16
operator+(Vec4_i16 a, Vec4_i16 b){
    a.x += b.x;
    a.y += b.y;
    a.z += b.z;
    a.w += b.w;
    return(a);
}
static Vec2_i32
operator+(Vec2_i32 a, Vec2_i32 b){
    a.x += b.x;
    a.y += b.y;
    return(a);
}
static Vec3_i32
operator+(Vec3_i32 a, Vec3_i32 b){
    a.x += b.x;
    a.y += b.y;
    a.z += b.z;
    return(a);
}
static Vec4_i32
operator+(Vec4_i32 a, Vec4_i32 b){
    a.x += b.x;
    a.y += b.y;
    a.z += b.z;
    a.w += b.w;
    return(a);
}
static Vec2_f32
operator+(Vec2_f32 a, Vec2_f32 b){
    a.x += b.x;
    a.y += b.y;
    return(a);
}
static Vec3_f32
operator+(Vec3_f32 a, Vec3_f32 b){
    a.x += b.x;
    a.y += b.y;
    a.z += b.z;
    return(a);
}
static Vec4_f32
operator+(Vec4_f32 a, Vec4_f32 b){
    a.x += b.x;
    a.y += b.y;
    a.z += b.z;
    a.w += b.w;
    return(a);
}

static Vec2_i8&
operator+=(Vec2_i8 &a, Vec2_i8 b){
    a.x += b.x;
    a.y += b.y;
    return(a);
}
static Vec3_i8&
operator+=(Vec3_i8 &a, Vec3_i8 b){
    a.x += b.x;
    a.y += b.y;
    a.z += b.z;
    return(a);
}
static Vec4_i8&
operator+=(Vec4_i8 &a, Vec4_i8 b){
    a.x += b.x;
    a.y += b.y;
    a.z += b.z;
    a.w += b.w;
    return(a);
}
static Vec2_i16&
operator+=(Vec2_i16 &a, Vec2_i16 b){
    a.x += b.x;
    a.y += b.y;
    return(a);
}
static Vec3_i16&
operator+=(Vec3_i16 &a, Vec3_i16 b){
    a.x += b.x;
    a.y += b.y;
    a.z += b.z;
    return(a);
}
static Vec4_i16&
operator+=(Vec4_i16 &a, Vec4_i16 b){
    a.x += b.x;
    a.y += b.y;
    a.z += b.z;
    a.w += b.w;
    return(a);
}
static Vec2_i32&
operator+=(Vec2_i32 &a, Vec2_i32 b){
    a.x += b.x;
    a.y += b.y;
    return(a);
}
static Vec3_i32&
operator+=(Vec3_i32 &a, Vec3_i32 b){
    a.x += b.x;
    a.y += b.y;
    a.z += b.z;
    return(a);
}
static Vec4_i32&
operator+=(Vec4_i32 &a, Vec4_i32 b){
    a.x += b.x;
    a.y += b.y;
    a.z += b.z;
    a.w += b.w;
    return(a);
}
static Vec2_f32&
operator+=(Vec2_f32 &a, Vec2_f32 b){
    a.x += b.x;
    a.y += b.y;
    return(a);
}
static Vec3_f32&
operator+=(Vec3_f32 &a, Vec3_f32 b){
    a.x += b.x;
    a.y += b.y;
    a.z += b.z;
    return(a);
}
static Vec4_f32&
operator+=(Vec4_f32 &a, Vec4_f32 b){
    a.x += b.x;
    a.y += b.y;
    a.z += b.z;
    a.w += b.w;
    return(a);
}

static Vec2_i8
operator-(Vec2_i8 a, Vec2_i8 b){
    a.x -= b.x;
    a.y -= b.y;
    return(a);
}
static Vec3_i8
operator-(Vec3_i8 a, Vec3_i8 b){
    a.x -= b.x;
    a.y -= b.y;
    a.z -= b.z;
    return(a);
}
static Vec4_i8
operator-(Vec4_i8 a, Vec4_i8 b){
    a.x -= b.x;
    a.y -= b.y;
    a.z -= b.z;
    a.w -= b.w;
    return(a);
}
static Vec2_i16
operator-(Vec2_i16 a, Vec2_i16 b){
    a.x -= b.x;
    a.y -= b.y;
    return(a);
}
static Vec3_i16
operator-(Vec3_i16 a, Vec3_i16 b){
    a.x -= b.x;
    a.y -= b.y;
    a.z -= b.z;
    return(a);
}
static Vec4_i16
operator-(Vec4_i16 a, Vec4_i16 b){
    a.x -= b.x;
    a.y -= b.y;
    a.z -= b.z;
    a.w -= b.w;
    return(a);
}
static Vec2_i32
operator-(Vec2_i32 a, Vec2_i32 b){
    a.x -= b.x;
    a.y -= b.y;
    return(a);
}
static Vec3_i32
operator-(Vec3_i32 a, Vec3_i32 b){
    a.x -= b.x;
    a.y -= b.y;
    a.z -= b.z;
    return(a);
}
static Vec4_i32
operator-(Vec4_i32 a, Vec4_i32 b){
    a.x -= b.x;
    a.y -= b.y;
    a.z -= b.z;
    a.w -= b.w;
    return(a);
}
static Vec2_f32
operator-(Vec2_f32 a, Vec2_f32 b){
    a.x -= b.x;
    a.y -= b.y;
    return(a);
}
static Vec3_f32
operator-(Vec3_f32 a, Vec3_f32 b){
    a.x -= b.x;
    a.y -= b.y;
    a.z -= b.z;
    return(a);
}
static Vec4_f32
operator-(Vec4_f32 a, Vec4_f32 b){
    a.x -= b.x;
    a.y -= b.y;
    a.z -= b.z;
    a.w -= b.w;
    return(a);
}

static Vec2_i8&
operator-=(Vec2_i8 &a, Vec2_i8 b){
    a.x -= b.x;
    a.y -= b.y;
    return(a);
}
static Vec3_i8&
operator-=(Vec3_i8 &a, Vec3_i8 b){
    a.x -= b.x;
    a.y -= b.y;
    a.z -= b.z;
    return(a);
}
static Vec4_i8&
operator-=(Vec4_i8 &a, Vec4_i8 b){
    a.x -= b.x;
    a.y -= b.y;
    a.z -= b.z;
    a.w -= b.w;
    return(a);
}
static Vec2_i16&
operator-=(Vec2_i16 &a, Vec2_i16 b){
    a.x -= b.x;
    a.y -= b.y;
    return(a);
}
static Vec3_i16&
operator-=(Vec3_i16 &a, Vec3_i16 b){
    a.x -= b.x;
    a.y -= b.y;
    a.z -= b.z;
    return(a);
}
static Vec4_i16&
operator-=(Vec4_i16 &a, Vec4_i16 b){
    a.x -= b.x;
    a.y -= b.y;
    a.z -= b.z;
    a.w -= b.w;
    return(a);
}
static Vec2_i32&
operator-=(Vec2_i32 &a, Vec2_i32 b){
    a.x -= b.x;
    a.y -= b.y;
    return(a);
}
static Vec3_i32&
operator-=(Vec3_i32 &a, Vec3_i32 b){
    a.x -= b.x;
    a.y -= b.y;
    a.z -= b.z;
    return(a);
}
static Vec4_i32&
operator-=(Vec4_i32 &a, Vec4_i32 b){
    a.x -= b.x;
    a.y -= b.y;
    a.z -= b.z;
    a.w -= b.w;
    return(a);
}
static Vec2_f32&
operator-=(Vec2_f32 &a, Vec2_f32 b){
    a.x -= b.x;
    a.y -= b.y;
    return(a);
}
static Vec3_f32&
operator-=(Vec3_f32 &a, Vec3_f32 b){
    a.x -= b.x;
    a.y -= b.y;
    a.z -= b.z;
    return(a);
}
static Vec4_f32&
operator-=(Vec4_f32 &a, Vec4_f32 b){
    a.x -= b.x;
    a.y -= b.y;
    a.z -= b.z;
    a.w -= b.w;
    return(a);
}

static Vec2_i8
operator*(i8 s, Vec2_i8 v){
    v.x *= s;
    v.y *= s;
    return(v);
}
static Vec2_i8
operator*(Vec2_i8 v, i8 s){
    v.x *= s;
    v.y *= s;
    return(v);
}
static Vec3_i8
operator*(i8 s, Vec3_i8 v){
    v.x *= s;
    v.y *= s;
    v.z *= s;
    return(v);
}
static Vec3_i8
operator*(Vec3_i8 v, i8 s){
    v.x *= s;
    v.y *= s;
    v.z *= s;
    return(v);
}
static Vec4_i8
operator*(i8 s, Vec4_i8 v){
    v.x *= s;
    v.y *= s;
    v.z *= s;
    v.w *= s;
    return(v);
}
static Vec4_i8
operator*(Vec4_i8 v, i8 s){
    v.x *= s;
    v.y *= s;
    v.z *= s;
    v.w *= s;
    return(v);
}
static Vec2_i16
operator*(i16 s, Vec2_i16 v){
    v.x *= s;
    v.y *= s;
    return(v);
}
static Vec2_i16
operator*(Vec2_i16 v, i16 s){
    v.x *= s;
    v.y *= s;
    return(v);
}
static Vec3_i16
operator*(i16 s, Vec3_i16 v){
    v.x *= s;
    v.y *= s;
    v.z *= s;
    return(v);
}
static Vec3_i16
operator*(Vec3_i16 v, i16 s){
    v.x *= s;
    v.y *= s;
    v.z *= s;
    return(v);
}
static Vec4_i16
operator*(i16 s, Vec4_i16 v){
    v.x *= s;
    v.y *= s;
    v.z *= s;
    v.w *= s;
    return(v);
}
static Vec4_i16
operator*(Vec4_i16 v, i16 s){
    v.x *= s;
    v.y *= s;
    v.z *= s;
    v.w *= s;
    return(v);
}
static Vec2_i32
operator*(i32 s, Vec2_i32 v){
    v.x *= s;
    v.y *= s;
    return(v);
}
static Vec2_i32
operator*(Vec2_i32 v, i32 s){
    v.x *= s;
    v.y *= s;
    return(v);
}
static Vec3_i32
operator*(i32 s, Vec3_i32 v){
    v.x *= s;
    v.y *= s;
    v.z *= s;
    return(v);
}
static Vec3_i32
operator*(Vec3_i32 v, i32 s){
    v.x *= s;
    v.y *= s;
    v.z *= s;
    return(v);
}
static Vec4_i32
operator*(i32 s, Vec4_i32 v){
    v.x *= s;
    v.y *= s;
    v.z *= s;
    v.w *= s;
    return(v);
}
static Vec4_i32
operator*(Vec4_i32 v, i32 s){
    v.x *= s;
    v.y *= s;
    v.z *= s;
    v.w *= s;
    return(v);
}
static Vec2_f32
operator*(f32 s, Vec2_f32 v){
    v.x *= s;
    v.y *= s;
    return(v);
}
static Vec2_f32
operator*(Vec2_f32 v, f32 s){
    v.x *= s;
    v.y *= s;
    return(v);
}
static Vec3_f32
operator*(f32 s, Vec3_f32 v){
    v.x *= s;
    v.y *= s;
    v.z *= s;
    return(v);
}
static Vec3_f32
operator*(Vec3_f32 v, f32 s){
    v.x *= s;
    v.y *= s;
    v.z *= s;
    return(v);
}
static Vec4_f32
operator*(f32 s, Vec4_f32 v){
    v.x *= s;
    v.y *= s;
    v.z *= s;
    v.w *= s;
    return(v);
}
static Vec4_f32
operator*(Vec4_f32 v, f32 s){
    v.x *= s;
    v.y *= s;
    v.z *= s;
    v.w *= s;
    return(v);
}

static Vec2_i8&
operator*=(Vec2_i8 &v, i8 s){
    v.x *= s;
    v.y *= s;
    return(v);
}
static Vec3_i8&
operator*=(Vec3_i8 &v, i8 s){
    v.x *= s;
    v.y *= s;
    v.z *= s;
    return(v);
}
static Vec4_i8&
operator*=(Vec4_i8 &v, i8 s){
    v.x *= s;
    v.y *= s;
    v.z *= s;
    v.w *= s;
    return(v);
}
static Vec2_i16&
operator*=(Vec2_i16 &v, i16 s){
    v.x *= s;
    v.y *= s;
    return(v);
}
static Vec3_i16&
operator*=(Vec3_i16 &v, i16 s){
    v.x *= s;
    v.y *= s;
    v.z *= s;
    return(v);
}
static Vec4_i16&
operator*=(Vec4_i16 &v, i16 s){
    v.x *= s;
    v.y *= s;
    v.z *= s;
    v.w *= s;
    return(v);
}
static Vec2_i32&
operator*=(Vec2_i32 &v, i32 s){
    v.x *= s;
    v.y *= s;
    return(v);
}
static Vec3_i32&
operator*=(Vec3_i32 &v, i32 s){
    v.x *= s;
    v.y *= s;
    v.z *= s;
    return(v);
}
static Vec4_i32&
operator*=(Vec4_i32 &v, i32 s){
    v.x *= s;
    v.y *= s;
    v.z *= s;
    v.w *= s;
    return(v);
}
static Vec2_f32&
operator*=(Vec2_f32 &v, f32 s){
    v.x *= s;
    v.y *= s;
    return(v);
}
static Vec3_f32&
operator*=(Vec3_f32 &v, f32 s){
    v.x *= s;
    v.y *= s;
    v.z *= s;
    return(v);
}
static Vec4_f32&
operator*=(Vec4_f32 &v, f32 s){
    v.x *= s;
    v.y *= s;
    v.z *= s;
    v.w *= s;
    return(v);
}

static Vec2_i8
operator/(Vec2_i8 v, i8 s){
    v.x /= s;
    v.y /= s;
    return(v);
}
static Vec3_i8
operator/(Vec3_i8 v, i8 s){
    v.x /= s;
    v.y /= s;
    v.z /= s;
    return(v);
}
static Vec4_i8
operator/(Vec4_i8 v, i8 s){
    v.x /= s;
    v.y /= s;
    v.z /= s;
    v.w /= s;
    return(v);
}
static Vec2_i16
operator/(Vec2_i16 v, i16 s){
    v.x /= s;
    v.y /= s;
    return(v);
}
static Vec3_i16
operator/(Vec3_i16 v, i16 s){
    v.x /= s;
    v.y /= s;
    v.z /= s;
    return(v);
}
static Vec4_i16
operator/(Vec4_i16 v, i16 s){
    v.x /= s;
    v.y /= s;
    v.z /= s;
    v.w /= s;
    return(v);
}
static Vec2_i32
operator/(Vec2_i32 v, i32 s){
    v.x /= s;
    v.y /= s;
    return(v);
}
static Vec3_i32
operator/(Vec3_i32 v, i32 s){
    v.x /= s;
    v.y /= s;
    v.z /= s;
    return(v);
}
static Vec4_i32
operator/(Vec4_i32 v, i32 s){
    v.x /= s;
    v.y /= s;
    v.z /= s;
    v.w /= s;
    return(v);
}
static Vec2_f32
operator/(Vec2_f32 v, f32 s){
    v.x /= s;
    v.y /= s;
    return(v);
}
static Vec3_f32
operator/(Vec3_f32 v, f32 s){
    v.x /= s;
    v.y /= s;
    v.z /= s;
    return(v);
}
static Vec4_f32
operator/(Vec4_f32 v, f32 s){
    v.x /= s;
    v.y /= s;
    v.z /= s;
    v.w /= s;
    return(v);
}

static Vec2_i8&
operator/=(Vec2_i8 &v, i8 s){
    v.x /= s;
    v.y /= s;
    return(v);
}
static Vec3_i8&
operator/=(Vec3_i8 &v, i8 s){
    v.x /= s;
    v.y /= s;
    v.z /= s;
    return(v);
}
static Vec4_i8&
operator/=(Vec4_i8 &v, i8 s){
    v.x /= s;
    v.y /= s;
    v.z /= s;
    v.w /= s;
    return(v);
}
static Vec2_i16&
operator/=(Vec2_i16 &v, i16 s){
    v.x /= s;
    v.y /= s;
    return(v);
}
static Vec3_i16&
operator/=(Vec3_i16 &v, i16 s){
    v.x /= s;
    v.y /= s;
    v.z /= s;
    return(v);
}
static Vec4_i16&
operator/=(Vec4_i16 &v, i16 s){
    v.x /= s;
    v.y /= s;
    v.z /= s;
    v.w /= s;
    return(v);
}
static Vec2_i32&
operator/=(Vec2_i32 &v, i32 s){
    v.x /= s;
    v.y /= s;
    return(v);
}
static Vec3_i32&
operator/=(Vec3_i32 &v, i32 s){
    v.x /= s;
    v.y /= s;
    v.z /= s;
    return(v);
}
static Vec4_i32&
operator/=(Vec4_i32 &v, i32 s){
    v.x /= s;
    v.y /= s;
    v.z /= s;
    v.w /= s;
    return(v);
}
static Vec2_f32&
operator/=(Vec2_f32 &v, f32 s){
    v.x /= s;
    v.y /= s;
    return(v);
}
static Vec3_f32&
operator/=(Vec3_f32 &v, f32 s){
    v.x /= s;
    v.y /= s;
    v.z /= s;
    return(v);
}
static Vec4_f32&
operator/=(Vec4_f32 &v, f32 s){
    v.x /= s;
    v.y /= s;
    v.z /= s;
    v.w /= s;
    return(v);
}

static b32
operator==(Vec2_i8 a, Vec2_i8 b){
    return(a.x == b.x && a.y == b.y);
}
static b32
operator==(Vec3_i8 a, Vec3_i8 b){
    return(a.x == b.x && a.y == b.y && a.z == b.z);
}
static b32
operator==(Vec4_i8 a, Vec4_i8 b){
    return(a.x == b.x && a.y == b.y && a.z == b.z && a.w == b.w);
}
static b32
operator==(Vec2_i16 a, Vec2_i16 b){
    return(a.x == b.x && a.y == b.y);
}
static b32
operator==(Vec3_i16 a, Vec3_i16 b){
    return(a.x == b.x && a.y == b.y && a.z == b.z);
}
static b32
operator==(Vec4_i16 a, Vec4_i16 b){
    return(a.x == b.x && a.y == b.y && a.z == b.z && a.w == b.w);
}
static b32
operator==(Vec2_i32 a, Vec2_i32 b){
    return(a.x == b.x && a.y == b.y);
}
static b32
operator==(Vec3_i32 a, Vec3_i32 b){
    return(a.x == b.x && a.y == b.y && a.z == b.z);
}
static b32
operator==(Vec4_i32 a, Vec4_i32 b){
    return(a.x == b.x && a.y == b.y && a.z == b.z && a.w == b.w);
}
static b32
operator==(Vec2_f32 a, Vec2_f32 b){
    return(a.x == b.x && a.y == b.y);
}
static b32
operator==(Vec3_f32 a, Vec3_f32 b){
    return(a.x == b.x && a.y == b.y && a.z == b.z);
}
static b32
operator==(Vec4_f32 a, Vec4_f32 b){
    return(a.x == b.x && a.y == b.y && a.z == b.z && a.w == b.w);
}

static b32
operator!=(Vec2_i8 a, Vec2_i8 b){
    return(a.x != b.x || a.y != b.y);
}
static b32
operator!=(Vec3_i8 a, Vec3_i8 b){
    return(a.x != b.x || a.y != b.y || a.z != b.z);
}
static b32
operator!=(Vec4_i8 a, Vec4_i8 b){
    return(a.x != b.x || a.y != b.y || a.z != b.z || a.w != b.w);
}
static b32
operator!=(Vec2_i16 a, Vec2_i16 b){
    return(a.x != b.x || a.y != b.y);
}
static b32
operator!=(Vec3_i16 a, Vec3_i16 b){
    return(a.x != b.x || a.y != b.y || a.z != b.z);
}
static b32
operator!=(Vec4_i16 a, Vec4_i16 b){
    return(a.x != b.x || a.y != b.y || a.z != b.z || a.w != b.w);
}
static b32
operator!=(Vec2_i32 a, Vec2_i32 b){
    return(a.x != b.x || a.y != b.y);
}
static b32
operator!=(Vec3_i32 a, Vec3_i32 b){
    return(a.x != b.x || a.y != b.y || a.z != b.z);
}
static b32
operator!=(Vec4_i32 a, Vec4_i32 b){
    return(a.x != b.x || a.y != b.y || a.z != b.z || a.w != b.w);
}
static b32
operator!=(Vec2_f32 a, Vec2_f32 b){
    return(a.x != b.x || a.y != b.y);
}
static b32
operator!=(Vec3_f32 a, Vec3_f32 b){
    return(a.x != b.x || a.y != b.y || a.z != b.z);
}
static b32
operator!=(Vec4_f32 a, Vec4_f32 b){
    return(a.x != b.x || a.y != b.y || a.z != b.z || a.w != b.w);
}



static b32
near_zero(f32 p, f32 epsilon){
    return(-epsilon <= p && p <= epsilon);
}
static b32
near_zero(Vec2_f32 p, f32 epsilon){
    return(-epsilon <= p.x && p.x <= epsilon &&
           -epsilon <= p.y && p.y <= epsilon);
}
static b32
near_zero(Vec3_f32 p, f32 epsilon){
    return(-epsilon <= p.x && p.x <= epsilon &&
           -epsilon <= p.y && p.y <= epsilon &&
           -epsilon <= p.z && p.z <= epsilon);
}
static b32
near_zero(Vec4_f32 p, f32 epsilon){
    return(-epsilon <= p.x && p.x <= epsilon &&
           -epsilon <= p.y && p.y <= epsilon &&
           -epsilon <= p.z && p.z <= epsilon &&
           -epsilon <= p.w && p.w <= epsilon);
}

static b32
near_zero(f32 p){ return(near_zero(p, epsilon_f32)); }
static b32
near_zero(Vec2_f32 p){ return(near_zero(p, epsilon_f32)); }
static b32
near_zero(Vec3_f32 p){ return(near_zero(p, epsilon_f32)); }
static b32
near_zero(Vec4_f32 p){ return(near_zero(p, epsilon_f32)); }

static Vec2_f32
hadamard(Vec2_f32 a, Vec2_f32 b){
    return(V2f32(a.x*b.x, a.y*b.y));
}
static Vec3_f32
hadamard(Vec3_f32 a, Vec3_f32 b){
    return(V3f32(a.x*b.x, a.y*b.y, a.z*b.z));
}
static Vec4_f32
hadamard(Vec4_f32 a, Vec4_f32 b){
    return(V4f32(a.x*b.x, a.y*b.y, a.z*b.z, a.w*b.w));
}



static f32
lerp(f32 a, f32 t, f32 b){
    return(a + (b-a)*t);
}

static f32
lerp(f32 t, Range_f32 x){
    return(x.min + (x.max - x.min)*t);
}

static i32
lerp(i32 a, f32 t, i32 b){
    return((i32)(lerp((f32)a, t, (f32)b)));
}

static Vec2_f32
lerp(Vec2_f32 a, f32 t, Vec2_f32 b){
    return(a + (b-a)*t);
}

static Vec3_f32
lerp(Vec3_f32 a, f32 t, Vec3_f32 b){
    return(a + (b-a)*t);
}

static Vec4_f32
lerp(Vec4_f32 a, f32 t, Vec4_f32 b){
    return(a + (b-a)*t);
}

static f32
unlerp(f32 a, f32 x, f32 b){
    f32 r = x;
    if (b != a){
        r = (x - a)/(b - a);
    }
    return(r);
}

static f32
unlerp(u64 a, u64 x, u64 b){
    f32 r = 0.f;
    if (b <= x){
        r = 1.f;
    }
    else if (a < x){
        u64 n = x - a;
        u64 d = b - a;
        r = (f32)(((f64)n)/((f64)d));
    }
    return(r);
}

static Range_f32
unlerp(f32 a, Range_f32 x, f32 b){
    x.min = unlerp(a, x.min, b);
    x.max = unlerp(a, x.max, b);
    return(x);
}

static Range_f32
lerp(f32 a, Range_f32 x, f32 b){
    x.min = lerp(a, x.min, b);
    x.max = lerp(a, x.max, b);
    return(x);
}

static f32
lerp(Range_f32 range, f32 t){
    return(lerp(range.min, t, range.max));
}

static f32
clamp_range(Range_f32 range, f32 x){
    return((((range.min)>(x))?(range.min):(((range.max)<(x))?(range.max):(x))));
}



static b32
operator==(Rect_i32 a, Rect_i32 b){
    return(a.p0 == b.p0 && a.p1 == b.p1);
}
static b32
operator==(Rect_f32 a, Rect_f32 b){
    return(a.p0 == b.p0 && a.p1 == b.p1);
}

static b32
operator!=(Rect_i32 a, Rect_i32 b){
    return(!(a == b));
}
static b32
operator!=(Rect_f32 a, Rect_f32 b){
    return(!(a == b));
}



static Vec4_f32
unpack_color(ARGB_Color color){
    Vec4_f32 result;
    result.a = ((color >> 24) & 0xFF)/255.f;
    result.r = ((color >> 16) & 0xFF)/255.f;
    result.g = ((color >> 8) & 0xFF)/255.f;
    result.b = ((color >> 0) & 0xFF)/255.f;
    return(result);
}

static ARGB_Color
pack_color(Vec4_f32 color){
    ARGB_Color result =
        ((u8)(color.a*255) << 24) |
        ((u8)(color.r*255) << 16) |
        ((u8)(color.g*255) << 8) |
        ((u8)(color.b*255) << 0);
    return(result);
}

static ARGB_Color
color_blend(ARGB_Color a, f32 t, ARGB_Color b){
    Vec4_f32 av = unpack_color(a);
    Vec4_f32 bv = unpack_color(b);
    Vec4_f32 v = lerp(av, t, bv);
    return(pack_color(v));
}

static Vec4_f32
rgba_to_hsla(Vec4_f32 rgba){
    Vec4_f32 hsla = {};
    f32 max, min, delta;
    i32 maxc;
    hsla.a = rgba.a;
    max = rgba.r; min = rgba.r;
    maxc = 0;
    if (rgba.r < rgba.g){
        max = rgba.g;
        maxc = 1;
    }
    if (rgba.b > max){
        max = rgba.b;
        maxc = 2;
    }
    if (rgba.r > rgba.g){
        min = rgba.g;
    }
    if (rgba.b < min){
        min = rgba.b;
    }
    delta = max - min;

    hsla.z = (max + min)*.5f;
    if (delta == 0){
        hsla.x = 0.f;
        hsla.y = 0.f;
    }
    else{
        switch (maxc){
            case 0:
            {
                hsla.x = (rgba.g - rgba.b) / delta;
                hsla.x += (rgba.g < rgba.b)*6.f;
            }break;

            case 1:
            {
                hsla.x = (rgba.b - rgba.r) / delta;
                hsla.x += 2.f;
            }break;

            case 2:
            {
                hsla.x = (rgba.r - rgba.g) / delta;
                hsla.x += 4.f;
            }break;
        }
        hsla.x *= (1/6.f);
        hsla.y = delta / (1.f - abs_f32(2.f*hsla.z - 1.f));
    }

    return(hsla);
}

static Vec4_f32
hsla_to_rgba(Vec4_f32 hsla){
    if (hsla.h >= 1.f){
        hsla.h = 0.f;
    }
    f32 C = (1.f - abs_f32(2*hsla.z - 1.f))*hsla.y;
    f32 X = C*(1.f-abs_f32(mod_f32(hsla.x*6.f, 2)-1.f));
    f32 m = hsla.z - C*.5f;
    i32 H = i32_floor32(hsla.x*6.f);
    Vec4_f32 rgba = {};
    rgba.a = hsla.a;
    switch (H){
        case 0: rgba.r = C; rgba.g = X; rgba.b = 0; break;
        case 1: rgba.r = X; rgba.g = C; rgba.b = 0; break;
        case 2: rgba.r = 0; rgba.g = C; rgba.b = X; break;
        case 3: rgba.r = 0; rgba.g = X; rgba.b = C; break;
        case 4: rgba.r = X; rgba.g = 0; rgba.b = C; break;
        case 5: rgba.r = C; rgba.g = 0; rgba.b = X; break;
    }
    rgba.r += m;
    rgba.g += m;
    rgba.b += m;
    return(rgba);
}



static Range_i32
Ii32(i32 a, i32 b){
    Range_i32 interval = {a, b};
    if (b < a){
        interval.min = b;
        interval.max = a;
    }
    return(interval);
}
static Range_i64
Ii64(i64 a, i64 b){
    Range_i64 interval = {a, b};
    if (b < a){
        interval.min = b;
        interval.max = a;
    }
    return(interval);
}
static Range_u64
Iu64(u64 a, u64 b){
    Range_u64 interval = {a, b};
    if (b < a){
        interval.min = b;
        interval.max = a;
    }
    return(interval);
}
static Range_f32
If32(f32 a, f32 b){
    Range_f32 interval = {a, b};
    if (b < a){
        interval.min = b;
        interval.max = a;
    }
    return(interval);
}

static Range_i32
Ii32_size(i32 pos, i32 size){
    return(Ii32(pos, pos + size));
}
static Range_i64
Ii64_size(i64 pos, i64 size){
    return(Ii64(pos, pos + size));
}
static Range_u64
Iu64_size(u64 pos, u64 size){
    return(Iu64(pos, pos + size));
}
static Range_f32
If32_size(f32 pos, f32 size){
    return(If32(pos, pos + size));
}

static Range_i32
Ii32(i32 a){
    Range_i32 interval = {a, a};
    return(interval);
}
static Range_i64
Ii64(i64 a){
    Range_i64 interval = {a, a};
    return(interval);
}
static Range_u64
Iu64(u64 a){
    Range_u64 interval = {a, a};
    return(interval);
}
static Range_f32
If32(f32 a){
    Range_f32 interval = {a, a};
    return(interval);
}

static Range_i32
Ii32(){
    Range_i32 interval = {};
    return(interval);
}
static Range_i64
Ii64(){
    Range_i64 interval = {};
    return(interval);
}
static Range_u64
Iu64(){
    Range_u64 interval = {};
    return(interval);
}
static Range_f32
If32(){
    Range_f32 interval = {};
    return(interval);
}

static Range_u64
Iu64(Range_i32 r){
    return(Iu64(r.min, r.max));
}

static Range_i32 Ii32_neg_inf = {max_i32, min_i32};
static Range_i64 Ii64_neg_inf = {max_i64, min_i64};
static Range_u64 Iu64_neg_inf = {max_u64, 0};
static Range_f32 If32_neg_inf = {max_f32, -max_f32};

static b32
operator==(Range_i32 a, Range_i32 b){
    return(a.min == b.min && a.max == b.max);
}
static b32
operator==(Range_i64 a, Range_i64 b){
    return(a.min == b.min && a.max == b.max);
}
static b32
operator==(Range_u64 a, Range_u64 b){
    return(a.min == b.min && a.max == b.max);
}
static b32
operator==(Range_f32 a, Range_f32 b){
    return(a.min == b.min && a.max == b.max);
}

static Range_i32
operator+(Range_i32 r, i32 s){
    return(Ii32(r.min + s, r.max + s));
}
static Range_i64
operator+(Range_i64 r, i64 s){
    return(Ii64(r.min + s, r.max + s));
}
static Range_u64
operator+(Range_u64 r, u64 s){
    return(Iu64(r.min + s, r.max + s));
}
static Range_f32
operator+(Range_f32 r, f32 s){
    return(If32(r.min + s, r.max + s));
}

static Range_i32
operator-(Range_i32 r, i32 s){
    return(Ii32(r.min - s, r.max - s));
}
static Range_i64
operator-(Range_i64 r, i64 s){
    return(Ii64(r.min - s, r.max - s));
}
static Range_u64
operator-(Range_u64 r, u64 s){
    return(Iu64(r.min - s, r.max - s));
}
static Range_f32
operator-(Range_f32 r, f32 s){
    return(If32(r.min - s, r.max - s));
}

static Range_i32&
operator+=(Range_i32 &r, i32 s){
    r = r + s;
    return(r);
}
static Range_i64&
operator+=(Range_i64 &r, i64 s){
    r = r + s;
    return(r);
}
static Range_u64&
operator+=(Range_u64 &r, u64 s){
    r = r + s;
    return(r);
}
static Range_f32&
operator+=(Range_f32 &r, f32 s){
    r = r + s;
    return(r);
}

static Range_i32&
operator-=(Range_i32 &r, i32 s){
    r = r - s;
    return(r);
}
static Range_i64&
operator-=(Range_i64 &r, i64 s){
    r = r - s;
    return(r);
}
static Range_u64&
operator-=(Range_u64 &r, u64 s){
    r = r - s;
    return(r);
}
static Range_f32&
operator-=(Range_f32 &r, f32 s){
    r = r - s;
    return(r);
}

static Range_i32
range_margin(Range_i32 range, i32 margin){
    range.min += margin;
    range.max += margin;
    return(range);
}
static Range_i64
range_margin(Range_i64 range, i64 margin){
    range.min += margin;
    range.max += margin;
    return(range);
}
static Range_u64
range_margin(Range_u64 range, u64 margin){
    range.min += margin;
    range.max += margin;
    return(range);
}
static Range_f32
range_margin(Range_f32 range, f32 margin){
    range.min += margin;
    range.max += margin;
    return(range);
}

static b32
range_overlap(Range_i32 a, Range_i32 b){
    return(a.min < b.max && b.min < a.max);
}
static b32
range_overlap(Range_i64 a, Range_i64 b){
    return(a.min < b.max && b.min < a.max);
}
static b32
range_overlap(Range_u64 a, Range_u64 b){
    return(a.min < b.max && b.min < a.max);
}
static b32
range_overlap(Range_f32 a, Range_f32 b){
    return(a.min < b.max && b.min < a.max);
}

static Range_i32
range_intersect(Range_i32 a, Range_i32 b){
    Range_i32 result = {};
    if (range_overlap(a, b)){
        result = Ii32((((a.min)>(b.min))?(a.min):(b.min)), (((a.max)<(b.max))?(a.max):(b.max)));
    }
    return(result);
}
static Range_i64
range_intersect(Range_i64 a, Range_i64 b){
    Range_i64 result = {};
    if (range_overlap(a, b)){
        result = Ii64((((a.min)>(b.min))?(a.min):(b.min)), (((a.max)<(b.max))?(a.max):(b.max)));
    }
    return(result);
}
static Range_u64
range_intersect(Range_u64 a, Range_u64 b){
    Range_u64 result = {};
    if (range_overlap(a, b)){
        result = Iu64((((a.min)>(b.min))?(a.min):(b.min)), (((a.max)<(b.max))?(a.max):(b.max)));
    }
    return(result);
}
static Range_f32
range_intersect(Range_f32 a, Range_f32 b){
    Range_f32 result = {};
    if (range_overlap(a, b)){
        result = If32((((a.min)>(b.min))?(a.min):(b.min)), (((a.max)<(b.max))?(a.max):(b.max)));
    }
    return(result);
}

static Range_i32
range_union(Range_i32 a, Range_i32 b){
    return(Ii32((((a.min)<(b.min))?(a.min):(b.min)), (((a.max)>(b.max))?(a.max):(b.max))));
}
static Range_i64
range_union(Range_i64 a, Range_i64 b){
    return(Ii64((((a.min)<(b.min))?(a.min):(b.min)), (((a.max)>(b.max))?(a.max):(b.max))));
}
static Range_u64
range_union(Range_u64 a, Range_u64 b){
    return(Iu64((((a.min)<(b.min))?(a.min):(b.min)), (((a.max)>(b.max))?(a.max):(b.max))));
}
static Range_f32
range_union(Range_f32 a, Range_f32 b){
    return(If32((((a.min)<(b.min))?(a.min):(b.min)), (((a.max)>(b.max))?(a.max):(b.max))));
}

static b32
range_contains_inclusive(Range_i32 a, i32 p){
    return(a.min <= p && p <= a.max);
}
static b32
range_contains_inclusive(Range_i64 a, i64 p){
    return(a.min <= p && p <= a.max);
}
static b32
range_contains_inclusive(Range_u64 a, u64 p){
    return(a.min <= p && p <= a.max);
}
static b32
range_inclusive_contains(Range_f32 a, f32 p){
    return(a.min <= p && p <= a.max);
}

static b32
range_contains(Range_i32 a, i32 p){
    return(a.min <= p && p < a.max);
}
static b32
range_contains(Range_i64 a, i64 p){
    return(a.min <= p && p < a.max);
}
static b32
range_contains(Range_u64 a, u64 p){
    return(a.min <= p && p < a.max);
}
static b32
range_contains(Range_f32 a, f32 p){
    return(a.min <= p && p < a.max);
}

static i32
range_size(Range_i32 a){
    i32 size = a.max - a.min;
    size = (((0)>(size))?(0):(size));
    return(size);
}
static i64
range_size(Range_i64 a){
    i64 size = a.max - a.min;
    size = (((0)>(size))?(0):(size));
    return(size);
}
static u64
range_size(Range_u64 a){
    u64 size = a.max - a.min;
    size = (((0)>(size))?(0):(size));
    return(size);
}
static f32
range_size(Range_f32 a){
    f32 size = a.max - a.min;
    size = (((0)>(size))?(0):(size));
    return(size);
}

static i32
range_size_inclusive(Range_i32 a){
    i32 size = a.max - a.min + 1;
    size = (((0)>(size))?(0):(size));
    return(size);
}
static i64
range_size_inclusive(Range_i64 a){
    i64 size = a.max - a.min + 1;
    size = (((0)>(size))?(0):(size));
    return(size);
}
static u64
range_size_inclusive(Range_u64 a){
    u64 size = a.max - a.min + 1;
    size = (((0)>(size))?(0):(size));
    return(size);
}
static f32
range_size_inclusive(Range_f32 a){
    f32 size = a.max - a.min + 1;
    size = (((0)>(size))?(0):(size));
    return(size);
}

static Range_i32
rectify(Range_i32 a){
    return(Ii32(a.min, a.max));
}
static Range_i64
rectify(Range_i64 a){
    return(Ii64(a.min, a.max));
}
static Range_u64
rectify(Range_u64 a){
    return(Iu64(a.min, a.max));
}
static Range_f32
rectify(Range_f32 a){
    return(If32(a.min, a.max));
}

static Range_i32
range_clamp_size(Range_i32 a, i32 max_size){
    i32 max = a.min + max_size;
    a.max = (((a.max)<(max))?(a.max):(max));
    return(a);
}
static Range_i64
range_clamp_size(Range_i64 a, i64 max_size){
    i64 max = a.min + max_size;
    a.max = (((a.max)<(max))?(a.max):(max));
    return(a);
}
static Range_u64
range_clamp_size(Range_u64 a, u64 max_size){
    u64 max = a.min + max_size;
    a.max = (((a.max)<(max))?(a.max):(max));
    return(a);
}
static Range_f32
range_clamp_size(Range_f32 a, f32 max_size){
    f32 max = a.min + max_size;
    a.max = (((a.max)<(max))?(a.max):(max));
    return(a);
}

static b32
range_is_valid(Range_i32 a){
    return(a.min <= a.max);
}
static b32
range_is_valid(Range_i64 a){
    return(a.min <= a.max);
}
static b32
range_is_valid(Range_u64 a){
    return(a.min <= a.max);
}
static b32
range_is_valid(Range_f32 a){
    return(a.min <= a.max);
}

static i32
range_side(Range_i32 a, Side side){
    return(side == Side_Min?a.min:a.max);
}
static i64
range_side(Range_i64 a, Side side){
    return(side == Side_Min?a.min:a.max);
}
static u64
range_side(Range_u64 a, Side side){
    return(side == Side_Min?a.min:a.max);
}
static f32
range_side(Range_f32 a, Side side){
    return(side == Side_Min?a.min:a.max);
}

static i32
range_distance(Range_i32 a, Range_i32 b){
    i32 result = 0;
    if (!range_overlap(a, b)){
        if (a.max < b.min){
            result = b.min - a.max;
        }
        else{
            result = a.min - b.max;
        }
    }
    return(result);
}
static i64
range_distance(Range_i64 a, Range_i64 b){
    i64 result = 0;
    if (!range_overlap(a, b)){
        if (a.max < b.min){
            result = b.min - a.max;
        }
        else{
            result = a.min - b.max;
        }
    }
    return(result);
}
static u64
range_distance(Range_u64 a, Range_u64 b){
    u64 result = 0;
    if (!range_overlap(a, b)){
        if (a.max < b.min){
            result = b.min - a.max;
        }
        else{
            result = a.min - b.max;
        }
    }
    return(result);
}
static f32
range_distance(Range_f32 a, Range_f32 b){
    f32 result = 0;
    if (!range_overlap(a, b)){
        if (a.max < b.min){
            result = b.min - a.max;
        }
        else{
            result = a.min - b.max;
        }
    }
    return(result);
}



static i32
replace_range_shift(i32 replace_length, i32 insert_length){
    return(insert_length - replace_length);
}
static i32
replace_range_shift(i32 start, i32 end, i32 insert_length){
    return(insert_length - (end - start));
}
static i32
replace_range_shift(Range_i32 range, i32 insert_length){
    return(insert_length - (range.end - range.start));
}
static i64
replace_range_shift(i64 replace_length, i64 insert_length){
    return(insert_length - replace_length);
}
static i64
replace_range_shift(i64 start, i64 end, i64 insert_length){
    return(insert_length - (end - start));
}
static i64
replace_range_shift(Range_i64 range, i64 insert_length){
    return(insert_length - (range.end - range.start));
}
static i64
replace_range_shift(u64 replace_length, u64 insert_length){
    return((i64)insert_length - replace_length);
}
static i64
replace_range_shift(i64 start, i64 end, u64 insert_length){
    return((i64)insert_length - (end - start));
}
static i64
replace_range_shift(Range_i64 range, u64 insert_length){
    return((i64)insert_length - (range.end - range.start));
}



static Rect_i32
Ri32(i32 x0, i32 y0, i32 x1, i32 y1){
    Rect_i32 rect = {x0, y0, x1, y1};
    return(rect);
}
static Rect_f32
Rf32(f32 x0, f32 y0, f32 x1, f32 y1){
    Rect_f32 rect = {x0, y0, x1, y1};
    return(rect);
}

static Rect_i32
Ri32(Vec2_i32 p0, Vec2_i32 p1){
    Rect_i32 rect = {p0.x, p0.y, p1.x, p1.y};
    return(rect);
}
static Rect_f32
Rf32(Vec2_f32 p0, Vec2_f32 p1){
    Rect_f32 rect = {p0.x, p0.y, p1.x, p1.y};
    return(rect);
}

static Rect_i32
Ri32(Rect_f32 o){
    Rect_i32 rect = {(i32)(o.x0), (i32)(o.y0), (i32)(o.x1), (i32)(o.y1)};
    return(rect);
}
static Rect_f32
Rf32(Rect_i32 o){
    Rect_f32 rect = {(f32)(o.x0), (f32)(o.y0), (f32)(o.x1), (f32)(o.y1)};
    return(rect);
}

static Rect_i32
Ri32_xy_wh(i32 x0, i32 y0, i32 w, i32 h){
    Rect_i32 rect = {x0, y0, x0 + w, y0 + h};
    return(rect);
}
static Rect_f32
Rf32_xy_wh(f32 x0, f32 y0, f32 w, f32 h){
    Rect_f32 rect = {x0, y0, x0 + w, y0 + h};
    return(rect);
}

static Rect_i32
Ri32_xy_wh(Vec2_i32 p0, Vec2_i32 d){
    Rect_i32 rect = {p0.x, p0.y, p0.x + d.x, p0.y + d.y};
    return(rect);
}
static Rect_f32
Rf32_xy_wh(Vec2_f32 p0, Vec2_f32 d){
    Rect_f32 rect = {p0.x, p0.y, p0.x + d.x, p0.y + d.y};
    return(rect);
}

static Rect_i32
Ri32(Range_i32 x, Range_i32 y){
    return(Ri32(x.min, y.min, x.max, y.max));
}
static Rect_f32
Rf32(Range_f32 x, Range_f32 y){
    return(Rf32(x.min, y.min, x.max, y.max));
}

static const Rect_f32 Rf32_infinity = {-max_f32, -max_f32, max_f32, max_f32};
static const Rect_f32 Rf32_negative_infinity = { max_f32, max_f32, -max_f32, -max_f32};

static const Rect_i32 Ri32_infinity = {-max_i32, -max_i32, max_i32, max_i32};
static const Rect_i32 Ri32_negative_infinity = { max_i32, max_i32, -max_i32, -max_i32};

static b32
rect_equals(Rect_i32 a, Rect_i32 b){
    return(a.x0 == b.x0 && a.y0 == b.y0 && a.x1 == b.x1 && a.y1 == b.y1);
}
static b32
rect_equals(Rect_f32 a, Rect_f32 b){
    return(a.x0 == b.x0 && a.y0 == b.y0 && a.x1 == b.x1 && a.y1 == b.y1);
}

static b32
rect_contains_point(Rect_i32 a, Vec2_i32 b){
    return(a.x0 <= b.x && b.x < a.x1 && a.y0 <= b.y && b.y < a.y1);
}
static b32
rect_contains_point(Rect_f32 a, Vec2_f32 b){
    return(a.x0 <= b.x && b.x < a.x1 && a.y0 <= b.y && b.y < a.y1);
}

static Rect_i32
rect_inner(Rect_i32 r, i32 m){
    r.x0 += m;
    r.y0 += m;
    r.x1 -= m;
    r.y1 -= m;
    return(r);
}
static Rect_f32
rect_inner(Rect_f32 r, f32 m){
    r.x0 += m;
    r.y0 += m;
    r.x1 -= m;
    r.y1 -= m;
    return(r);
}

static Vec2_i32
rect_dim(Rect_i32 r){
    Vec2_i32 v = {r.x1 - r.x0, r.y1 - r.y0};
    return(v);
}
static Range_i32
rect_x(Rect_i32 r){
    return(Ii32(r.x0, r.x1));
}
static Range_i32
rect_y(Rect_i32 r){
    return(Ii32(r.y0, r.y1));
}
static i32
rect_width(Rect_i32 r){
    return(r.x1 - r.x0);
}
static i32
rect_height(Rect_i32 r){
    return(r.y1 - r.y0);
}
static Vec2_f32
rect_dim(Rect_f32 r){
    Vec2_f32 v = {r.x1 - r.x0, r.y1 - r.y0};
    return(v);
}
static Range_f32
rect_x(Rect_f32 r){
    return(If32(r.x0, r.x1));
}
static Range_f32
rect_y(Rect_f32 r){
    return(If32(r.y0, r.y1));
}
static f32
rect_width(Rect_f32 r){
    return(r.x1 - r.x0);
}
static f32
rect_height(Rect_f32 r){
    return(r.y1 - r.y0);
}

static Vec2_i32
rect_center(Rect_i32 r){
    return((r.p0 + r.p1)/2);
}
static Vec2_f32
rect_center(Rect_f32 r){
    return((r.p0 + r.p1)*0.5f);
}

static Range_i32
rect_range_x(Rect_i32 r){
    return(Ii32(r.x0, r.x1));
}
static Range_i32
rect_range_y(Rect_i32 r){
    return(Ii32(r.y0, r.y1));
}
static Range_f32
rect_range_x(Rect_f32 r){
    return(If32(r.x0, r.x1));
}
static Range_f32
rect_range_y(Rect_f32 r){
    return(If32(r.y0, r.y1));
}

static i32
rect_area(Rect_i32 r){
    return((r.x1 - r.x0)*(r.y1 - r.y0));
}
static f32
rect_area(Rect_f32 r){
    return((r.x1 - r.x0)*(r.y1 - r.y0));
}

static b32
rect_overlap(Rect_i32 a, Rect_i32 b){
    return(range_overlap(rect_range_x(a), rect_range_x(b)) &&
           range_overlap(rect_range_y(a), rect_range_y(b)));
}
static b32
rect_overlap(Rect_f32 a, Rect_f32 b){
    return(range_overlap(rect_range_x(a), rect_range_x(b)) &&
           range_overlap(rect_range_y(a), rect_range_y(b)));
}

static Vec2_i32
rect_half_dim(Rect_i32 r){
    return(rect_dim(r)/2);
}
static Vec2_f32
rect_half_dim(Rect_f32 r){
    return(rect_dim(r)*0.5f);
}

static Rect_i32
rect_intersect(Rect_i32 a, Rect_i32 b){
    a.x0 = (((a.x0)>(b.x0))?(a.x0):(b.x0));
    a.y0 = (((a.y0)>(b.y0))?(a.y0):(b.y0));
    a.x1 = (((a.x1)<(b.x1))?(a.x1):(b.x1));
    a.y1 = (((a.y1)<(b.y1))?(a.y1):(b.y1));
    a.x0 = (((a.x0)<(a.x1))?(a.x0):(a.x1));
    a.y0 = (((a.y0)<(a.y1))?(a.y0):(a.y1));
    return(a);
}
static Rect_i32
rect_union(Rect_i32 a, Rect_i32 b){
    a.x0 = (((a.x0)<(b.x0))?(a.x0):(b.x0));
    a.y0 = (((a.y0)<(b.y0))?(a.y0):(b.y0));
    a.x1 = (((a.x1)>(b.x1))?(a.x1):(b.x1));
    a.y1 = (((a.y1)>(b.y1))?(a.y1):(b.y1));
    return(a);
}
static Rect_f32
rect_intersect(Rect_f32 a, Rect_f32 b){
    a.x0 = (((a.x0)>(b.x0))?(a.x0):(b.x0));
    a.y0 = (((a.y0)>(b.y0))?(a.y0):(b.y0));
    a.x1 = (((a.x1)<(b.x1))?(a.x1):(b.x1));
    a.y1 = (((a.y1)<(b.y1))?(a.y1):(b.y1));
    a.x0 = (((a.x0)<(a.x1))?(a.x0):(a.x1));
    a.y0 = (((a.y0)<(a.y1))?(a.y0):(a.y1));
    return(a);
}
static Rect_f32
rect_union(Rect_f32 a, Rect_f32 b){
    a.x0 = (((a.x0)<(b.x0))?(a.x0):(b.x0));
    a.y0 = (((a.y0)<(b.y0))?(a.y0):(b.y0));
    a.x1 = (((a.x1)>(b.x1))?(a.x1):(b.x1));
    a.y1 = (((a.y1)>(b.y1))?(a.y1):(b.y1));
    return(a);
}



static Rect_f32_Pair
rect_split_top_bottom__inner(Rect_f32 rect, f32 y){
    y = (((rect.y0)>(y))?(rect.y0):(((rect.y1)<(y))?(rect.y1):(y)));
    Rect_f32_Pair pair = {};
    pair.a = Rf32(rect.x0, rect.y0, rect.x1, y );
    pair.b = Rf32(rect.x0, y , rect.x1, rect.y1);
    return(pair);
}

static Rect_f32_Pair
rect_split_left_right__inner(Rect_f32 rect, f32 x){
    x = (((rect.x0)>(x))?(rect.x0):(((rect.x1)<(x))?(rect.x1):(x)));
    Rect_f32_Pair pair = {};
    pair.a = Rf32(rect.x0, rect.y0, x , rect.y1);
    pair.b = Rf32(x , rect.y0, rect.x1, rect.y1);
    return(pair);
}

static Rect_f32_Pair
rect_split_top_bottom(Rect_f32 rect, f32 y){
    return(rect_split_top_bottom__inner(rect, rect.y0 + y));
}

static Rect_f32_Pair
rect_split_left_right(Rect_f32 rect, f32 x){
    return(rect_split_left_right__inner(rect, rect.x0 + x));
}

static Rect_f32_Pair
rect_split_top_bottom_neg(Rect_f32 rect, f32 y){
    return(rect_split_top_bottom__inner(rect, rect.y1 - y));
}

static Rect_f32_Pair
rect_split_left_right_neg(Rect_f32 rect, f32 x){
    return(rect_split_left_right__inner(rect, rect.x1 - x));
}

static Rect_f32_Pair
rect_split_top_bottom_lerp(Rect_f32 rect, f32 t){
    return(rect_split_top_bottom__inner(rect, lerp(rect.y0, t, rect.y1)));
}

static Rect_f32_Pair
rect_split_left_right_lerp(Rect_f32 rect, f32 t){
    return(rect_split_left_right__inner(rect, lerp(rect.x0, t, rect.x1)));
}



static Scan_Direction
flip_direction(Scan_Direction direction){
    switch (direction){
        case Scan_Forward:
        {
            direction = Scan_Backward;
        }break;
        case Scan_Backward:
        {
            direction = Scan_Forward;
        }break;
    }
    return(direction);
}

static Side
flip_side(Side side){
    switch (side){
        case Side_Min:
        {
            side = Side_Max;
        }break;
        case Side_Max:
        {
            side = Side_Min;
        }break;
    }
    return(side);
}



static u64
cstring_length(char *str){
    u64 length = 0;
    for (;str[length] != 0; length += 1);
    return(length);
}
static u64
cstring_length(u8 *str){
    u64 length = 0;
    for (;str[length] != 0; length += 1);
    return(length);
}
static u64
cstring_length(u16 *str){
    u64 length = 0;
    for (;str[length] != 0; length += 1);
    return(length);
}
static u64
cstring_length(u32 *str){
    u64 length = 0;
    for (;str[length] != 0; length += 1);
    return(length);
}

static String_char
Schar(char *str, u64 size, u64 cap){
    String_char string = {str, size, cap};
    return(string);
}
static String_u8
Su8(u8 *str, u64 size, u64 cap){
    String_u8 string = {str, size, cap};
    return(string);
}
static String_u16
Su16(u16 *str, u64 size, u64 cap){
    String_u16 string = {str, size, cap};
    return(string);
}
static String_u32
Su32(u32 *str, u64 size, u64 cap){
    String_u32 string = {str, size, cap};
    return(string);
}

static String_Any
Sany(void *str, u64 size, u64 cap, String_Encoding encoding){
    String_Any string = {encoding};
    switch (encoding){
        case StringEncoding_ASCII: string.s_char = Schar((char*)str, size, cap); break;
        case StringEncoding_UTF8: string.s_u8 = Su8((u8*)str, size, cap); break;
        case StringEncoding_UTF16: string.s_u16 = Su16((u16*)str, size, cap); break;
        case StringEncoding_UTF32: string.s_u32 = Su32((u32*)str, size, cap); break;
    }
    return(string);
}

static String_char
Schar(char *str, u64 size){
    String_char string = {str, size, size + 1};
    return(string);
}
static String_u8
Su8(u8 *str, u64 size){
    String_u8 string = {str, size, size + 1};
    return(string);
}
static String_u16
Su16(u16 *str, u64 size){
    String_u16 string = {str, size, size + 1};
    return(string);
}
static String_u32
Su32(u32 *str, u64 size){
    String_u32 string = {str, size, size + 1};
    return(string);
}

static String_Any
Sany(void *str, u64 size, String_Encoding encoding){
    String_Any string = {encoding};
    switch (encoding){
        case StringEncoding_ASCII: string.s_char = Schar((char*)str, size); break;
        case StringEncoding_UTF8: string.s_u8 = Su8((u8*)str, size); break;
        case StringEncoding_UTF16: string.s_u16 = Su16((u16*)str, size); break;
        case StringEncoding_UTF32: string.s_u32 = Su32((u32*)str, size); break;
    }
    return(string);
}

static String_char
Schar(char *str, char *one_past_last){
    return(Schar(str, (u64)(one_past_last - str)));
}
static String_u8
Su8(u8 *str, u8 *one_past_last){
    return(Su8(str, (u64)(one_past_last - str)));
}
static String_u16
Su16(u16 *str, u16 *one_past_last){
    return(Su16(str, (u64)(one_past_last - str)));
}
static String_u32
Su32(u32 *str, u32 *one_past_last){
    return(Su32(str, (u64)(one_past_last - str)));
}

static String_Any
Sany(void *str, void *one_past_last, String_Encoding encoding){
    String_Any string = {encoding};
    switch (encoding){
        case StringEncoding_ASCII: string.s_char = Schar((char*)str, (char*)one_past_last); break;
        case StringEncoding_UTF8: string.s_u8 = Su8((u8*)str, (u8*)one_past_last); break;
        case StringEncoding_UTF16: string.s_u16 = Su16((u16*)str, (u16*)one_past_last); break;
        case StringEncoding_UTF32: string.s_u32 = Su32((u32*)str, (u32*)one_past_last); break;
    }
    return(string);
}

static String_char
Schar(char *str){
    u64 size = cstring_length(str);
    String_char string = {str, size, size + 1};
    return(string);
}
static String_u8
Su8(u8 *str){
    u64 size = cstring_length(str);
    String_u8 string = {str, size, size + 1};
    return(string);
}
static String_u16
Su16(u16 *str){
    u64 size = cstring_length(str);
    String_u16 string = {str, size, size + 1};
    return(string);
}
static String_u32
Su32(u32 *str){
    u64 size = cstring_length(str);
    String_u32 string = {str, size, size + 1};
    return(string);
}

static String_Any
Sany(void *str, String_Encoding encoding){
    String_Any string = {encoding};
    switch (encoding){
        case StringEncoding_ASCII: string.s_char = Schar((char*)str); break;
        case StringEncoding_UTF8: string.s_u8 = Su8((u8*)str); break;
        case StringEncoding_UTF16: string.s_u16 = Su16((u16*)str); break;
        case StringEncoding_UTF32: string.s_u32 = Su32((u32*)str); break;
    }
    return(string);
}

static String_char
Schar(String_Const_char str, u64 cap){
    String_char string = {str.str, str.size, cap};
    return(string);
}
static String_u8
Su8(String_Const_u8 str, u64 cap){
    String_u8 string = {str.str, str.size, cap};
    return(string);
}
static String_u16
Su16(String_Const_u16 str, u64 cap){
    String_u16 string = {str.str, str.size, cap};
    return(string);
}
static String_u32
Su32(String_Const_u32 str, u64 cap){
    String_u32 string = {str.str, str.size, cap};
    return(string);
}

static String_Any
SCany(String_char str){
    String_Any string = {StringEncoding_ASCII};
    string.s_char = str;
    return(string);
}
static String_Any
SCany(String_u8 str){
    String_Any string = {StringEncoding_UTF8};
    string.s_u8 = str;
    return(string);
}
static String_Any
SCany(String_u16 str){
    String_Any string = {StringEncoding_UTF16};
    string.s_u16 = str;
    return(string);
}
static String_Any
SCany(String_u32 str){
    String_Any string = {StringEncoding_UTF32};
    string.s_u32 = str;
    return(string);
}

static String_Const_char
SCchar(char *str, u64 size){
    String_Const_char string = {str, size};
    return(string);
}
static String_Const_u8
SCu8(u8 *str, u64 size){
    String_Const_u8 string = {str, size};
    return(string);
}
static String_Const_u16
SCu16(u16 *str, u64 size){
    String_Const_u16 string = {str, size};
    return(string);
}
static String_Const_u32
SCu32(u32 *str, u64 size){
    String_Const_u32 string = {str, size};
    return(string);
}

static String_Const_Any
SCany(void *str, u64 size, String_Encoding encoding){
    String_Const_Any string = {encoding};
    switch (encoding){
        case StringEncoding_ASCII: string.s_char = SCchar((char*)str, size); break;
        case StringEncoding_UTF8: string.s_u8 = SCu8((u8*)str, size); break;
        case StringEncoding_UTF16: string.s_u16 = SCu16((u16*)str, size); break;
        case StringEncoding_UTF32: string.s_u32 = SCu32((u32*)str, size); break;
    }
    return(string);
}

static String_Const_char
SCchar(void){
    String_Const_char string = {};
    return(string);
}
static String_Const_u8
SCu8(void){
    String_Const_u8 string = {};
    return(string);
}
static String_Const_u16
SCu16(void){
    String_Const_u16 string = {};
    return(string);
}
static String_Const_u32
SCu32(void){
    String_Const_u32 string = {};
    return(string);
}

static String_Const_char
SCchar(char *str, char *one_past_last){
    return(SCchar(str, (u64)(one_past_last - str)));
}
static String_Const_u8
SCu8(u8 *str, u8 *one_past_last){
    return(SCu8(str, (u64)(one_past_last - str)));
}
static String_Const_u16
SCu16(u16 *str, u16 *one_past_last){
    return(SCu16(str, (u64)(one_past_last - str)));
}
static String_Const_u32
SCu32(u32 *str, u32 *one_past_last){
    return(SCu32(str, (u64)(one_past_last - str)));
}

static String_Const_Any
SCany(void *str, void *one_past_last, String_Encoding encoding){
    String_Const_Any string = {encoding};
    switch (encoding){
        case StringEncoding_ASCII: string.s_char = SCchar((char*)str, (char*)one_past_last); break;
        case StringEncoding_UTF8: string.s_u8 = SCu8((u8*)str, (u8*)one_past_last); break;
        case StringEncoding_UTF16: string.s_u16 = SCu16((u16*)str, (u16*)one_past_last); break;
        case StringEncoding_UTF32: string.s_u32 = SCu32((u32*)str, (u32*)one_past_last); break;
    }
    return(string);
}

static String_Const_char
SCchar(char *str){
    u64 size = cstring_length(str);
    String_Const_char string = {str, size};
    return(string);
}
static String_Const_u8
SCu8(u8 *str){
    u64 size = cstring_length(str);
    String_Const_u8 string = {str, size};
    return(string);
}
static String_Const_u16
SCu16(u16 *str){
    u64 size = cstring_length(str);
    String_Const_u16 string = {str, size};
    return(string);
}
static String_Const_u32
SCu32(u32 *str){
    u64 size = cstring_length(str);
    String_Const_u32 string = {str, size};
    return(string);
}

static String_Const_char
SCchar(String_char string){
    return(string.string);
}
static String_Const_u8
SCu8(String_u8 string){
    return(string.string);
}
static String_Const_u16
SCu16(String_u16 string){
    return(string.string);
}
static String_Const_u32
SCu32(String_u32 string){
    return(string.string);
}

static String_Const_char
SCchar(String_Const_u8 str){
    return(SCchar((char*)str.str, str.size));
}
static String_Const_u8
SCu8(String_Const_char str){
    return(SCu8((u8*)str.str, str.size));
}

static String_Const_u8
SCu8(char *str, u64 length){
    return(SCu8((u8*)str, length));
}
static String_Const_u8
SCu8(char *first, char *one_past_last){
    return(SCu8((u8*)first, (u8*)one_past_last));
}
static String_Const_u8
SCu8(char *str){
    return(SCu8((u8*)str));
}

static String_Const_u8
SCu8(Data data){
    return(SCu8((u8*)data.data, data.size));
}

static String_Const_u16
SCu16(wchar_t *str, u64 size){
    return(SCu16((u16*)str, size));
}
static String_Const_u16
SCu16(wchar_t *str){
    return(SCu16((u16*)str));
}

static String_Const_Any
SCany(void *str, String_Encoding encoding){
    String_Const_Any string = {encoding};
    switch (encoding){
        case StringEncoding_ASCII: string.s_char = SCchar((char*)str); break;
        case StringEncoding_UTF8: string.s_u8 = SCu8((u8*)str); break;
        case StringEncoding_UTF16: string.s_u16 = SCu16((u16*)str); break;
        case StringEncoding_UTF32: string.s_u32 = SCu32((u32*)str); break;
    }
    return(string);
}

static String_Const_Any
SCany(String_Const_char str){
    String_Const_Any string = {StringEncoding_ASCII};
    string.s_char = str;
    return(string);
}
static String_Const_Any
SCany(String_Const_u8 str){
    String_Const_Any string = {StringEncoding_UTF8};
    string.s_u8 = str;
    return(string);
}
static String_Const_Any
SCany(String_Const_u16 str){
    String_Const_Any string = {StringEncoding_UTF16};
    string.s_u16 = str;
    return(string);
}
static String_Const_Any
SCany(String_Const_u32 str){
    String_Const_Any string = {StringEncoding_UTF32};
    string.s_u32 = str;
    return(string);
}







static String_Const_char string_empty = {"", 0};
static String_Const_u8 string_u8_empty = {(u8*)"", 0};





static void*
base_reserve__noop(void *user_data, u64 size, u64 *size_out, String_Const_u8 location){
    *size_out = 0;
    return(0);
}
static void
base_commit__noop(void *user_data, void *ptr, u64 size){}
static void
base_uncommit__noop(void *user_data, void *ptr, u64 size){}
static void
base_free__noop(void *user_data, void *ptr){}
static void
base_set_access__noop(void *user_data, void *ptr, u64 size, Access_Flag flags){}

static Base_Allocator
make_base_allocator(Base_Allocator_Reserve_Signature *func_reserve,
                    Base_Allocator_Commit_Signature *func_commit,
                    Base_Allocator_Uncommit_Signature *func_uncommit,
                    Base_Allocator_Free_Signature *func_free,
                    Base_Allocator_Set_Access_Signature *func_set_access,
                    void *user_data){
    if (func_reserve == 0){
        func_reserve = base_reserve__noop;
    }
    if (func_commit == 0){
        func_commit = base_commit__noop;
    }
    if (func_uncommit == 0){
        func_uncommit = base_uncommit__noop;
    }
    if (func_free == 0){
        func_free = base_free__noop;
    }
    if (func_set_access == 0){
        func_set_access = base_set_access__noop;
    }
    Base_Allocator base_allocator = {
        func_reserve,
        func_commit,
        func_uncommit,
        func_free,
        func_set_access,
        user_data,
    };
    return(base_allocator);
}
static Data
base_allocate__inner(Base_Allocator *allocator, u64 size, String_Const_u8 location){
    u64 full_size = 0;
    void *memory = allocator->reserve(allocator->user_data, size, &full_size, location);
    allocator->commit(allocator->user_data, memory, full_size);
    return(make_data(memory, (u64)full_size));
}
static void
base_free(Base_Allocator *allocator, void *ptr){
    if (ptr != 0){
        allocator->free(allocator->user_data, ptr);
    }
}







static Cursor
make_cursor(void *base, u64 size){
    Cursor cursor = {(u8*)base, 0, size};
    return(cursor);
}
static Cursor
make_cursor(Data data){
    return(make_cursor(data.data, data.size));
}
static Cursor
make_cursor(Base_Allocator *allocator, u64 size){
    Data memory = base_allocate__inner((allocator), (size), SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_base_types.cpp" ":" "3077" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_base_types.cpp" ":" "3077" ":") - 1)));
    return(make_cursor(memory));
}
static Data
linalloc_push(Cursor *cursor, u64 size, String_Const_u8 location){
    Data result = {};
    if (cursor->pos + size <= cursor->cap){
        result.data = cursor->base + cursor->pos;
        result.size = size;
        cursor->pos += size;
    }
    return(result);
}
static void
linalloc_pop(Cursor *cursor, u64 size){
    if (cursor->pos > size){
        cursor->pos -= size;
    }
    else{
        cursor->pos = 0;
    }
}
static Data
linalloc_align(Cursor *cursor, u64 alignment){
    u64 pos = round_up_u64(cursor->pos, alignment);
    u64 new_size = pos - cursor->pos;
    return(linalloc_push(cursor, new_size, SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_base_types.cpp" ":" "3103" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_base_types.cpp" ":" "3103" ":") - 1))));
}
static Temp_Memory_Cursor
linalloc_begin_temp(Cursor *cursor){
    Temp_Memory_Cursor temp = {cursor, cursor->pos};
    return(temp);
}
static void
linalloc_end_temp(Temp_Memory_Cursor temp){
    temp.cursor->pos = temp.pos;
}
static void
linalloc_clear(Cursor *cursor){
    cursor->pos = 0;
}
static Arena
make_arena(Base_Allocator *allocator, u64 chunk_size, u64 alignment){
    Arena arena = {allocator, 0, chunk_size, alignment};
    return(arena);
}
static Arena
make_arena(Base_Allocator *allocator, u64 chunk_size){
    return(make_arena(allocator, chunk_size, 8));
}
static Arena
make_arena(Base_Allocator *allocator){
    return(make_arena(allocator, ((64) << 10), 8));
}
static Cursor_Node*
arena__new_node(Arena *arena, u64 min_size, String_Const_u8 location){
    min_size = (((min_size)>(arena->chunk_size))?(min_size):(arena->chunk_size));
    Data memory = base_allocate__inner(arena->base_allocator, min_size + sizeof(Cursor_Node), location);
    Cursor_Node *cursor_node = (Cursor_Node*)memory.data;
    cursor_node->cursor = make_cursor(cursor_node + 1, memory.size - sizeof(Cursor_Node));
    ((cursor_node)->next=(arena->cursor_node),(arena->cursor_node)=(cursor_node));
    return(cursor_node);
}
static Data
linalloc_push(Arena *arena, u64 size, String_Const_u8 location){
    Data result = {};
    if (size > 0){
        Cursor_Node *cursor_node = arena->cursor_node;
        if (cursor_node == 0){
            cursor_node = arena__new_node(arena, size, location);
        }
        result = linalloc_push(&cursor_node->cursor, size, location);
        if (result.data == 0){
            cursor_node = arena__new_node(arena, size, location);
            result = linalloc_push(&cursor_node->cursor, size, location);
        }
        Data alignment_data = linalloc_align(&cursor_node->cursor, arena->alignment);
        result.size += alignment_data.size;
    }
    return(result);
}
static void
linalloc_pop(Arena *arena, u64 size){
    Base_Allocator *allocator = arena->base_allocator;
    Cursor_Node *cursor_node = arena->cursor_node;
    for (Cursor_Node *prev = 0;
         cursor_node != 0 && size != 0;
         cursor_node = prev){
        prev = cursor_node->prev;
        if (size >= cursor_node->cursor.pos){
            size -= cursor_node->cursor.pos;
            base_free(allocator, cursor_node);
        }
        else{
            linalloc_pop(&cursor_node->cursor, size);
            break;
        }
    }
    arena->cursor_node = cursor_node;
}
static Data
linalloc_align(Arena *arena, u64 alignment){
    arena->alignment = alignment;
    Data data = {};
    Cursor_Node *cursor_node = arena->cursor_node;
    if (cursor_node != 0){
        data = linalloc_align(&cursor_node->cursor, arena->alignment);
    }
    return(data);
}
static Temp_Memory_Arena
linalloc_begin_temp(Arena *arena){
    Cursor_Node *cursor_node = arena->cursor_node;
    Temp_Memory_Arena temp = {arena, cursor_node,
        cursor_node == 0?0:cursor_node->cursor.pos};
    return(temp);
}
static void
linalloc_end_temp(Temp_Memory_Arena temp){
    Base_Allocator *allocator = temp.arena->base_allocator;
    Cursor_Node *cursor_node = temp.arena->cursor_node;
    for (Cursor_Node *prev = 0;
         cursor_node != temp.cursor_node && cursor_node != 0;
         cursor_node = prev){
        prev = cursor_node->prev;
        base_free(allocator, cursor_node);
    }
    temp.arena->cursor_node = cursor_node;
    if (cursor_node != 0){
        if (temp.pos > 0){
            cursor_node->cursor.pos = temp.pos;
        }
        else{
            temp.arena->cursor_node = cursor_node->prev;
            base_free(allocator, cursor_node);
        }
    }
}
static void
linalloc_clear(Arena *arena){
    Temp_Memory_Arena temp = {arena, 0, 0};
    linalloc_end_temp(temp);
}
static void*
linalloc_wrap_unintialized(Data data){
    return(data.data);
}
static void*
linalloc_wrap_zero(Data data){
    block_zero(data.data, data.size);
    return(data.data);
}
static void*
linalloc_wrap_write(Data data, u64 size, void *src){
    block_copy(data.data, src, (((data.size)<(size))?(data.size):(size)));
    return(data.data);
}






static Temp_Memory
begin_temp(Cursor *cursor){
    Temp_Memory temp = {LinearAllocatorKind_Cursor};
    temp.temp_memory_cursor = linalloc_begin_temp(cursor);
    return(temp);
}
static Temp_Memory
begin_temp(Arena *arena){
    Temp_Memory temp = {LinearAllocatorKind_Arena};
    temp.temp_memory_arena = linalloc_begin_temp(arena);
    return(temp);
}
static void
end_temp(Temp_Memory temp){
    switch (temp.kind){
        case LinearAllocatorKind_Cursor:
        {
            linalloc_end_temp(temp.temp_memory_cursor);
        }break;
        case LinearAllocatorKind_Arena:
        {
            linalloc_end_temp(temp.temp_memory_arena);
        }break;
    }
}



static void
thread_ctx_init(Thread_Context *tctx, Thread_Kind kind, Base_Allocator *allocator,
                Base_Allocator *prof_allocator){
    block_zero((tctx), sizeof(*(tctx)));
    tctx->kind = kind;
    tctx->allocator = allocator;
    tctx->node_arena = make_arena(allocator, ((4) << 10), 8);

    tctx->prof_allocator = prof_allocator;
    tctx->prof_id_counter = 1;
    tctx->prof_arena = make_arena(prof_allocator, ((16) << 10));
}

static void
thread_ctx_release(Thread_Context *tctx){
    for (Arena_Node *node = tctx->free_arenas;
         node != 0;
         node = node->next){
        linalloc_clear(&node->arena);
    }
    for (Arena_Node *node = tctx->used_first;
         node != 0;
         node = node->next){
        linalloc_clear(&node->arena);
    }
    linalloc_clear(&tctx->node_arena);
    block_zero((tctx), sizeof(*(tctx)));
}

static Arena_Node*
tctx__alloc_arena_node(Thread_Context *tctx){
    Arena_Node *result = tctx->free_arenas;
    if (result != 0){
        ((tctx->free_arenas)=(tctx->free_arenas)=(tctx->free_arenas)->next);
    }
    else{
        result = ((Arena_Node*)linalloc_wrap_zero(linalloc_push((&tctx->node_arena), sizeof(Arena_Node)*(1), SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_base_types.cpp" ":" "3304" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_base_types.cpp" ":" "3304" ":") - 1)))));
        result->arena = make_arena(tctx->allocator, ((16) << 10), 8);
    }
    return(result);
}

static void
tctx__free_arena_node(Thread_Context *tctx, Arena_Node *node){
    ((node)->next=(tctx->free_arenas),(tctx->free_arenas)=(node));
}

static Arena*
tctx_reserve(Thread_Context *tctx){
    Arena_Node *node = tctx->used_first;
    if (node == 0){
        node = tctx__alloc_arena_node(tctx);
        (((tctx->used_first)==0)?((node)->next=(node)->prev=0,(tctx->used_first)=(tctx->used_last)=(node)):((node)->prev=(tctx->used_last),(node)->next=0,(tctx->used_last)->next=(node),(tctx->used_last)=(node)));
    }
    node->ref_counter += 1;
    return(&node->arena);
}

static Arena*
tctx_reserve(Thread_Context *tctx, Arena *a1){
    Arena_Node *node = tctx->used_first;
    for (; node != 0; node = node->next){
        Arena *na = &node->arena;
        if (na != a1){
            break;
        }
    }
    if (node == 0){
        node = tctx__alloc_arena_node(tctx);
        (((tctx->used_first)==0)?((node)->next=(node)->prev=0,(tctx->used_first)=(tctx->used_last)=(node)):((node)->prev=(tctx->used_last),(node)->next=0,(tctx->used_last)->next=(node),(tctx->used_last)=(node)));
    }
    node->ref_counter += 1;
    return(&node->arena);
}

static Arena*
tctx_reserve(Thread_Context *tctx, Arena *a1, Arena *a2){
    Arena_Node *node = tctx->used_first;
    for (; node != 0; node = node->next){
        Arena *na = &node->arena;
        if (na != a1 && na != a2){
            break;
        }
    }
    if (node == 0){
        node = tctx__alloc_arena_node(tctx);
        (((tctx->used_first)==0)?((node)->next=(node)->prev=0,(tctx->used_first)=(tctx->used_last)=(node)):((node)->prev=(tctx->used_last),(node)->next=0,(tctx->used_last)->next=(node),(tctx->used_last)=(node)));
    }
    node->ref_counter += 1;
    return(&node->arena);
}

static Arena*
tctx_reserve(Thread_Context *tctx, Arena *a1, Arena *a2, Arena *a3){
    Arena_Node *node = tctx->used_first;
    for (; node != 0; node = node->next){
        Arena *na = &node->arena;
        if (na != a1 && na != a2 && na != a3){
            break;
        }
    }
    if (node == 0){
        node = tctx__alloc_arena_node(tctx);
        (((tctx->used_first)==0)?((node)->next=(node)->prev=0,(tctx->used_first)=(tctx->used_last)=(node)):((node)->prev=(tctx->used_last),(node)->next=0,(tctx->used_last)->next=(node),(tctx->used_last)=(node)));
    }
    node->ref_counter += 1;
    return(&node->arena);
}

static void
tctx_release(Thread_Context *tctx, Arena *arena){
    Arena_Node *node = (Arena_Node*)( (u8*)(arena) - ((u8*)(&(((Arena_Node*)0)->arena)) - (u8*)(0)) );
    node->ref_counter -= 1;
    if (node->ref_counter == 0){


        linalloc_clear(&node->arena);
        (((tctx->used_last)==(node))?((((tctx->used_first)==(tctx->used_last))?((tctx->used_first)=(tctx->used_last)=0):((tctx->used_last)->prev->next=0,(tctx->used_last)=(tctx->used_last)->prev))) :((tctx->used_first)==(node))?((((tctx->used_last)==(tctx->used_first))?((tctx->used_last)=(tctx->used_first)=0):((tctx->used_first)->next->prev=0,(tctx->used_first)=(tctx->used_first)->next))) : ((node)->next->prev=(node)->prev,(node)->prev->next=(node)->next,(node)->next=(node)->prev=0));
        ((node)->next=(tctx->free_arenas),(tctx->free_arenas)=(node));
    }
}



Scratch_Block::Scratch_Block(Thread_Context *t){
    this->tctx = t;
    this->arena = tctx_reserve(t);
    this->temp = begin_temp(this->arena);
}

Scratch_Block::Scratch_Block(Thread_Context *t, Arena *a1){
    this->tctx = t;
    this->arena = tctx_reserve(t, a1);
    this->temp = begin_temp(this->arena);
}

Scratch_Block::Scratch_Block(Thread_Context *t, Arena *a1, Arena *a2){
    this->tctx = t;
    this->arena = tctx_reserve(t, a1, a2);
    this->temp = begin_temp(this->arena);
}

Scratch_Block::Scratch_Block(Thread_Context *t, Arena *a1, Arena *a2, Arena *a3){
    this->tctx = t;
    this->arena = tctx_reserve(t, a1, a2, a3);
    this->temp = begin_temp(this->arena);
}

Scratch_Block::~Scratch_Block(){
    end_temp(this->temp);
    tctx_release(this->tctx, this->arena);
}

Scratch_Block::operator Arena*(){
    return(this->arena);
}

void
Scratch_Block::restore(void){
    end_temp(this->temp);
}

Temp_Memory_Block::Temp_Memory_Block(Temp_Memory t){
    this->temp = t;
}

Temp_Memory_Block::Temp_Memory_Block(Arena *arena){
    this->temp = begin_temp(arena);
}

Temp_Memory_Block::~Temp_Memory_Block(){
    end_temp(this->temp);
}

void
Temp_Memory_Block::restore(void){
    end_temp(this->temp);
}
# 3483 "/home/sam/.bin/4coder/custom/4coder_base_types.cpp"
static void
heap_init(Heap *heap, Base_Allocator *allocator){
    heap->arena_ = make_arena(allocator);
    heap->arena = &heap->arena_;
    (&heap->in_order)->next=(&heap->in_order)->prev=(&heap->in_order);
    (&heap->free_nodes)->next=(&heap->free_nodes)->prev=(&heap->free_nodes);
    heap->used_space = 0;
    heap->total_space = 0;
}

static void
heap_init(Heap *heap, Arena *arena){
    heap->arena = arena;
    (&heap->in_order)->next=(&heap->in_order)->prev=(&heap->in_order);
    (&heap->free_nodes)->next=(&heap->free_nodes)->prev=(&heap->free_nodes);
    heap->used_space = 0;
    heap->total_space = 0;
}

static Base_Allocator*
heap_get_base_allocator(Heap *heap){
    return(heap->arena->base_allocator);
}

static void
heap_free_all(Heap *heap){
    if (heap->arena == &heap->arena_){
        linalloc_clear(heap->arena);
    }
    block_zero((heap), sizeof(*(heap)));
}

static void
heap__extend(Heap *heap, void *memory, u64 size){
    ((void)(heap));
    if (size >= sizeof(Heap_Node)){
        Heap_Node *new_node = (Heap_Node*)memory;
        ((&new_node->order)->prev=(&heap->in_order)->prev,(&new_node->order)->next=(&heap->in_order),(&new_node->order)->prev->next=(&new_node->order),(&heap->in_order)->prev=(&new_node->order));
        ((&new_node->alloc)->next=(&heap->free_nodes)->next,(&new_node->alloc)->prev=(&heap->free_nodes),(&new_node->alloc)->next->prev=(&new_node->alloc),(&heap->free_nodes)->next=(&new_node->alloc));
        new_node->size = size - sizeof(*new_node);
        heap->total_space += size;
    }
    ((void)(heap));
}

static void
heap__extend_automatic(Heap *heap, u64 size){
    void *memory = ((u8*)linalloc_wrap_unintialized(linalloc_push((heap->arena), sizeof(u8)*(size), SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_base_types.cpp" ":" "3530" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_base_types.cpp" ":" "3530" ":") - 1)))));
    heap__extend(heap, memory, size);
}

static void*
heap__reserve_chunk(Heap *heap, Heap_Node *node, u64 size){
    u8 *ptr = (u8*)(node + 1);
    do{ if (!(node->size >= size)) { (*((i32*)0) = 0xA11E); } }while(0);
    u64 left_over_size = node->size - size;
    if (left_over_size > sizeof(*node)){
        u64 new_node_size = left_over_size - sizeof(*node);
        Heap_Node *new_node = (Heap_Node*)(ptr + size);
        ((&new_node->order)->next=(&node->order)->next,(&new_node->order)->prev=(&node->order),(&new_node->order)->next->prev=(&new_node->order),(&node->order)->next=(&new_node->order));
        ((&new_node->alloc)->next=(&node->alloc)->next,(&new_node->alloc)->prev=(&node->alloc),(&new_node->alloc)->next->prev=(&new_node->alloc),(&node->alloc)->next=(&new_node->alloc));
        new_node->size = new_node_size;
    }
    ((&node->alloc)->next->prev=(&node->alloc)->prev,(&node->alloc)->prev->next=(&node->alloc)->next);
    node->alloc.next = 0;
    node->alloc.prev = 0;
    node->size = size;
    heap->used_space += sizeof(*node) + size;
    return(ptr);
}

static void*
heap_allocate(Heap *heap, u64 size){
    b32 first_try = true;
    for (;;){
        if (heap->in_order.next != 0){
            ((void)(heap));
            u64 aligned_size = (size + sizeof(Heap_Node) - 1);
            aligned_size = aligned_size - (aligned_size%sizeof(Heap_Node));
            for (Heap_Basic_Node *n = heap->free_nodes.next;
                 n != &heap->free_nodes;
                 n = n->next){
                Heap_Node *node = (Heap_Node*)( (u8*)(n) - ((u8*)(&(((Heap_Node*)0)->alloc)) - (u8*)(0)) );
                if (node->size >= aligned_size){
                    void *ptr = heap__reserve_chunk(heap, node, aligned_size);
                    ((void)(heap));
                    return(ptr);
                }
            }
            ((void)(heap));
        }

        if (first_try){
            u64 extension_size = (((((64) << 10))>(size*2))?(((64) << 10)):(size*2));
            heap__extend_automatic(heap, extension_size);
            first_try = false;
        }
        else{
            break;
        }
    }
    return(0);
}

static void
heap__merge(Heap *heap, Heap_Node *l, Heap_Node *r){
    if (&l->order != &heap->in_order && &r->order != &heap->in_order &&
        l->alloc.next != 0 && l->alloc.prev != 0 &&
        r->alloc.next != 0 && r->alloc.prev != 0){
        u8 *ptr = (u8*)(l + 1) + l->size;
        if (((u8*)(ptr) - (u8*)(r)) == 0){
            ((&r->order)->next->prev=(&r->order)->prev,(&r->order)->prev->next=(&r->order)->next);
            ((&r->alloc)->next->prev=(&r->alloc)->prev,(&r->alloc)->prev->next=(&r->alloc)->next);
            ((&l->alloc)->next->prev=(&l->alloc)->prev,(&l->alloc)->prev->next=(&l->alloc)->next);
            l->size += r->size + sizeof(*r);
            ((&l->alloc)->next=(&heap->free_nodes)->next,(&l->alloc)->prev=(&heap->free_nodes),(&l->alloc)->next->prev=(&l->alloc),(&heap->free_nodes)->next=(&l->alloc));
        }
    }
}

static void
heap_free(Heap *heap, void *memory){
    if (heap->in_order.next != 0 && memory != 0){
        Heap_Node *node = ((Heap_Node*)memory) - 1;
        do{ if (!(node->alloc.next == 0)) { (*((i32*)0) = 0xA11E); } }while(0);
        do{ if (!(node->alloc.prev == 0)) { (*((i32*)0) = 0xA11E); } }while(0);
        heap->used_space -= sizeof(*node) + node->size;
        ((void)(heap));
        ((&node->alloc)->next=(&heap->free_nodes)->next,(&node->alloc)->prev=(&heap->free_nodes),(&node->alloc)->next->prev=(&node->alloc),(&heap->free_nodes)->next=(&node->alloc));
        ((void)(heap));
        heap__merge(heap, node, (Heap_Node*)( (u8*)(node->order.next) - ((u8*)(&(((Heap_Node*)0)->order)) - (u8*)(0)) ));
        ((void)(heap));
        heap__merge(heap, (Heap_Node*)( (u8*)(node->order.prev) - ((u8*)(&(((Heap_Node*)0)->order)) - (u8*)(0)) ), node);
        ((void)(heap));
    }
}





static void*
base_reserve__heap(void *user_data, u64 size, u64 *size_out, String_Const_u8 location){
    Heap *heap = (Heap*)user_data;
    void *memory = heap_allocate(heap, size);
    *size_out = size;
    return(memory);
}

static void
base_free__heap(void *user_data, void *ptr){
    Heap *heap = (Heap*)user_data;
    heap_free(heap, ptr);
}

static Base_Allocator
base_allocator_on_heap(Heap *heap){
    return(make_base_allocator(base_reserve__heap, 0, 0, base_free__heap, 0, heap));
}



static Data
push_data(Arena *arena, u64 size){
    Data result = {};
    result.data = ((u8*)linalloc_wrap_unintialized(linalloc_push((arena), sizeof(u8)*(size), SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_base_types.cpp" ":" "3648" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_base_types.cpp" ":" "3648" ":") - 1)))));
    result.size = size;
    return(result);
}

static Data
push_data_copy(Arena *arena, Data data){
    Data result = {};
    result.data = ((u8*)linalloc_wrap_write(linalloc_push((arena), sizeof(u8)*(data.size), SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_base_types.cpp" ":" "3656" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_base_types.cpp" ":" "3656" ":") - 1))), sizeof(u8)*(data.size), (data.data)));
    result.size = data.size;
    return(result);
}

static b32
data_match(Data a, Data b){
    return(a.size == b.size && block_match(a.data, b.data, a.size));
}



static b32
character_is_basic_ascii(char c){
    return(' ' <= c && c <= '~');
}
static b32
character_is_basic_ascii(u8 c){
    return(' ' <= c && c <= '~');
}
static b32
character_is_basic_ascii(u16 c){
    return(' ' <= c && c <= '~');
}
static b32
character_is_basic_ascii(u32 c){
    return(' ' <= c && c <= '~');
}

static b32
character_is_slash(char c){
    return((c == '/') || (c == '\\'));
}
static b32
character_is_slash(u8 c){
    return((c == '/') || (c == '\\'));
}
static b32
character_is_slash(u16 c){
    return((c == '/') || (c == '\\'));
}
static b32
character_is_slash(u32 c){
    return((c == '/') || (c == '\\'));
}

static b32
character_is_upper(char c){
    return(('A' <= c) && (c <= 'Z'));
}
static b32
character_is_upper(u8 c){
    return(('A' <= c) && (c <= 'Z'));
}
static b32
character_is_upper(u16 c){
    return(('A' <= c) && (c <= 'Z'));
}
static b32
character_is_upper(u32 c){
    return(('A' <= c) && (c <= 'Z'));
}

static b32
character_is_lower(char c){
    return(('a' <= c) && (c <= 'z'));
}
static b32
character_is_lower(u8 c){
    return(('a' <= c) && (c <= 'z'));
}
static b32
character_is_lower(u16 c){
    return(('a' <= c) && (c <= 'z'));
}
static b32
character_is_lower(u32 c){
    return(('a' <= c) && (c <= 'z'));
}

static b32
character_is_lower_unicode(u8 c){
    return((('a' <= c) && (c <= 'z')) || c >= 128);
}
static b32
character_is_lower_unicode(u16 c){
    return((('a' <= c) && (c <= 'z')) || c >= 128);
}
static b32
character_is_lower_unicode(u32 c){
    return((('a' <= c) && (c <= 'z')) || c >= 128);
}

static char
character_to_upper(char c){
    if (('a' <= c) && (c <= 'z')){
        c -= 'a' - 'A';
    }
    return(c);
}
static u8
character_to_upper(u8 c){
    if (('a' <= c) && (c <= 'z')){
        c -= 'a' - 'A';
    }
    return(c);
}
static u16
character_to_upper(u16 c){
    if (('a' <= c) && (c <= 'z')){
        c -= 'a' - 'A';
    }
    return(c);
}
static u32
character_to_upper(u32 c){
    if (('a' <= c) && (c <= 'z')){
        c -= 'a' - 'A';
    }
    return(c);
}
static char
character_to_lower(char c){
    if (('A' <= c) && (c <= 'Z')){
        c += 'a' - 'A';
    }
    return(c);
}
static u8
character_to_lower(u8 c){
    if (('A' <= c) && (c <= 'Z')){
        c += 'a' - 'A';
    }
    return(c);
}
static u16
character_to_lower(u16 c){
    if (('A' <= c) && (c <= 'Z')){
        c += 'a' - 'A';
    }
    return(c);
}
static u32
character_to_lower(u32 c){
    if (('A' <= c) && (c <= 'Z')){
        c += 'a' - 'A';
    }
    return(c);
}

static b32
character_is_whitespace(char c){
    return(c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == '\f' || c == '\v');
}
static b32
character_is_whitespace(u8 c){
    return(c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == '\f' || c == '\v');
}
static b32
character_is_whitespace(u16 c){
    return(c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == '\f' || c == '\v');
}
static b32
character_is_whitespace(u32 c){
    return(c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == '\f' || c == '\v');
}

static b32
character_is_base10(char c){
    return('0' <= c && c <= '9');
}
static b32
character_is_base10(u8 c){
    return('0' <= c && c <= '9');
}
static b32
character_is_base10(u16 c){
    return('0' <= c && c <= '9');
}
static b32
character_is_base10(u32 c){
    return('0' <= c && c <= '9');
}

static b32
character_is_base16(char c){
    return(('0' <= c && c <= '9') || ('A' <= c && c <= 'F'));
}
static b32
character_is_base16(u8 c){
    return(('0' <= c && c <= '9') || ('A' <= c && c <= 'F'));
}
static b32
character_is_base16(u16 c){
    return(('0' <= c && c <= '9') || ('A' <= c && c <= 'F'));
}
static b32
character_is_base16(u32 c){
    return(('0' <= c && c <= '9') || ('A' <= c && c <= 'F'));
}

static b32
character_is_base64(char c){
    return(('0' <= c && c <= '9') ||
           ('a' <= c && c <= 'z') ||
           ('A' <= c && c <= 'Z') ||
           c == '_' || c == '$' || c == '?');
}
static b32
character_is_base64(u8 c){
    return(('0' <= c && c <= '9') ||
           ('a' <= c && c <= 'z') ||
           ('A' <= c && c <= 'Z') ||
           c == '_' || c == '$' || c == '?');
}
static b32
character_is_base64(u16 c){
    return(('0' <= c && c <= '9') ||
           ('a' <= c && c <= 'z') ||
           ('A' <= c && c <= 'Z') ||
           c == '_' || c == '$' || c == '?');
}
static b32
character_is_base64(u32 c){
    return(('0' <= c && c <= '9') ||
           ('a' <= c && c <= 'z') ||
           ('A' <= c && c <= 'Z') ||
           c == '_' || c == '$' || c == '?');
}

static b32
character_is_alpha(char c){
    return( (('a' <= c) && (c <= 'z')) || (('A' <= c) && (c <= 'Z')) || c == '_');
}
static b32
character_is_alpha(u8 c){
    return( (('a' <= c) && (c <= 'z')) || (('A' <= c) && (c <= 'Z')) || c == '_');
}
static b32
character_is_alpha(u16 c){
    return( (('a' <= c) && (c <= 'z')) || (('A' <= c) && (c <= 'Z')) || c == '_');
}
static b32
character_is_alpha(u32 c){
    return( (('a' <= c) && (c <= 'z')) || (('A' <= c) && (c <= 'Z')) || c == '_');
}

static b32
character_is_alpha_numeric(char c){
    return((('a' <= c) && (c <= 'z')) || (('A' <= c) && (c <= 'Z')) || (('0' <= c) && (c <= '9')) || c == '_');
}
static b32
character_is_alpha_numeric(u8 c){
    return((('a' <= c) && (c <= 'z')) || (('A' <= c) && (c <= 'Z')) || (('0' <= c) && (c <= '9')) || c == '_');
}
static b32
character_is_alpha_numeric(u16 c){
    return((('a' <= c) && (c <= 'z')) || (('A' <= c) && (c <= 'Z')) || (('0' <= c) && (c <= '9')) || c == '_');
}
static b32
character_is_alpha_numeric(u32 c){
    return((('a' <= c) && (c <= 'z')) || (('A' <= c) && (c <= 'Z')) || (('0' <= c) && (c <= '9')) || c == '_');
}


static b32
character_is_alpha_unicode(u8 c){
    return( (('a' <= c) && (c <= 'z')) || (('A' <= c) && (c <= 'Z')) || c == '_' || c >= 128);
}
static b32
character_is_alpha_unicode(u16 c){
    return( (('a' <= c) && (c <= 'z')) || (('A' <= c) && (c <= 'Z')) || c == '_' || c >= 128);
}
static b32
character_is_alpha_unicode(u32 c){
    return( (('a' <= c) && (c <= 'z')) || (('A' <= c) && (c <= 'Z')) || c == '_' || c >= 128);
}

static b32
character_is_alpha_numeric_unicode(u8 c){
    return((('a' <= c) && (c <= 'z')) || (('A' <= c) && (c <= 'Z')) || (('0' <= c) && (c <= '9')) || c == '_' || c >= 128);
}
static b32
character_is_alpha_numeric_unicode(u16 c){
    return((('a' <= c) && (c <= 'z')) || (('A' <= c) && (c <= 'Z')) || (('0' <= c) && (c <= '9')) || c == '_' || c >= 128);
}
static b32
character_is_alpha_numeric_unicode(u32 c){
    return((('a' <= c) && (c <= 'z')) || (('A' <= c) && (c <= 'Z')) || (('0' <= c) && (c <= '9')) || c == '_' || c >= 128);
}

static char
string_get_character(String_Const_char str, u64 i){
    char r = 0;
    if (i < str.size){
        r = str.str[i];
    }
    return(r);
}
static u8
string_get_character(String_Const_u8 str, u64 i){
    u8 r = 0;
    if (i < str.size){
        r = str.str[i];
    }
    return(r);
}
static u16
string_get_character(String_Const_u16 str, u64 i){
    u16 r = 0;
    if (i < str.size){
        r = str.str[i];
    }
    return(r);
}
static u32
string_get_character(String_Const_u32 str, u64 i){
    u32 r = 0;
    if (i < str.size){
        r = str.str[i];
    }
    return(r);
}

static String_Const_char
string_prefix(String_Const_char str, u64 size){
    size = (((size)<(str.size))?(size):(str.size));
    str.size = size;
    return(str);
}
static String_Const_u8
string_prefix(String_Const_u8 str, u64 size){
    size = (((size)<(str.size))?(size):(str.size));
    str.size = size;
    return(str);
}
static String_Const_u16
string_prefix(String_Const_u16 str, u64 size){
    size = (((size)<(str.size))?(size):(str.size));
    str.size = size;
    return(str);
}
static String_Const_u32
string_prefix(String_Const_u32 str, u64 size){
    size = (((size)<(str.size))?(size):(str.size));
    str.size = size;
    return(str);
}

static String_Const_Any
string_prefix(String_Const_Any str, u64 size){
    switch (str.encoding){
        case StringEncoding_ASCII: str.s_char = string_prefix(str.s_char, size); break;
        case StringEncoding_UTF8: str.s_u8 = string_prefix(str.s_u8 , size); break;
        case StringEncoding_UTF16: str.s_u16 = string_prefix(str.s_u16 , size); break;
        case StringEncoding_UTF32: str.s_u32 = string_prefix(str.s_u32 , size); break;
    }
    return(str);
}

static String_Const_char
string_postfix(String_Const_char str, u64 size){
    size = (((size)<(str.size))?(size):(str.size));
    str.str += (str.size - size);
    str.size = size;
    return(str);
}
static String_Const_u8
string_postfix(String_Const_u8 str, u64 size){
    size = (((size)<(str.size))?(size):(str.size));
    str.str += (str.size - size);
    str.size = size;
    return(str);
}
static String_Const_u16
string_postfix(String_Const_u16 str, u64 size){
    size = (((size)<(str.size))?(size):(str.size));
    str.str += (str.size - size);
    str.size = size;
    return(str);
}
static String_Const_u32
string_postfix(String_Const_u32 str, u64 size){
    size = (((size)<(str.size))?(size):(str.size));
    str.str += (str.size - size);
    str.size = size;
    return(str);
}

static String_Const_Any
string_postfix(String_Const_Any str, u64 size){
    switch (str.encoding){
        case StringEncoding_ASCII: str.s_char = string_postfix(str.s_char, size); break;
        case StringEncoding_UTF8: str.s_u8 = string_postfix(str.s_u8 , size); break;
        case StringEncoding_UTF16: str.s_u16 = string_postfix(str.s_u16 , size); break;
        case StringEncoding_UTF32: str.s_u32 = string_postfix(str.s_u32 , size); break;
    }
    return(str);
}

static String_Const_char
string_skip(String_Const_char str, u64 n){
    n = (((n)<(str.size))?(n):(str.size));
    str.str += n;;
    str.size -= n;
    return(str);
}
static String_Const_u8
string_skip(String_Const_u8 str, u64 n){
    n = (((n)<(str.size))?(n):(str.size));
    str.str += n;;
    str.size -= n;
    return(str);
}
static String_Const_u16
string_skip(String_Const_u16 str, u64 n){
    n = (((n)<(str.size))?(n):(str.size));
    str.str += n;;
    str.size -= n;
    return(str);
}
static String_Const_u32
string_skip(String_Const_u32 str, u64 n){
    n = (((n)<(str.size))?(n):(str.size));
    str.str += n;;
    str.size -= n;
    return(str);
}

static String_Const_Any
string_skip(String_Const_Any str, u64 n){
    switch (str.encoding){
        case StringEncoding_ASCII: str.s_char = string_skip(str.s_char, n); break;
        case StringEncoding_UTF8: str.s_u8 = string_skip(str.s_u8 , n); break;
        case StringEncoding_UTF16: str.s_u16 = string_skip(str.s_u16 , n); break;
        case StringEncoding_UTF32: str.s_u32 = string_skip(str.s_u32 , n); break;
    }
    return(str);
}

static String_Const_char
string_chop(String_Const_char str, u64 n){
    n = (((n)<(str.size))?(n):(str.size));
    str.size -= n;
    return(str);
}
static String_Const_u8
string_chop(String_Const_u8 str, u64 n){
    n = (((n)<(str.size))?(n):(str.size));
    str.size -= n;
    return(str);
}
static String_Const_u16
string_chop(String_Const_u16 str, u64 n){
    n = (((n)<(str.size))?(n):(str.size));
    str.size -= n;
    return(str);
}
static String_Const_u32
string_chop(String_Const_u32 str, u64 n){
    n = (((n)<(str.size))?(n):(str.size));
    str.size -= n;
    return(str);
}

static String_Const_Any
string_chop(String_Const_Any str, u64 n){
    switch (str.encoding){
        case StringEncoding_ASCII: str.s_char = string_chop(str.s_char, n); break;
        case StringEncoding_UTF8: str.s_u8 = string_chop(str.s_u8 , n); break;
        case StringEncoding_UTF16: str.s_u16 = string_chop(str.s_u16 , n); break;
        case StringEncoding_UTF32: str.s_u32 = string_chop(str.s_u32 , n); break;
    }
    return(str);
}

static String_Const_char
string_substring(String_Const_char str, Range_i64 range){
    return(SCchar(str.str + range.min, str.str + range.max));
}
static String_Const_u8
string_substring(String_Const_u8 str, Range_i64 range){
    return(SCu8(str.str + range.min, str.str + range.max));
}
static String_Const_u16
string_substring(String_Const_u16 str, Range_i64 range){
    return(SCu16(str.str + range.min, str.str + range.max));
}
static String_Const_u32
string_substring(String_Const_u32 str, Range_i64 range){
    return(SCu32(str.str + range.min, str.str + range.max));
}

static u64
string_find_first(String_Const_char str, u64 start_pos, char c){
    u64 i = start_pos;
    for (;i < str.size && c != str.str[i]; i += 1);
    return(i);
}
static u64
string_find_first(String_Const_u8 str, u64 start_pos, u8 c){
    u64 i = start_pos;
    for (;i < str.size && c != str.str[i]; i += 1);
    return(i);
}
static u64
string_find_first(String_Const_u16 str, u64 start_pos, u16 c){
    u64 i = start_pos;
    for (;i < str.size && c != str.str[i]; i += 1);
    return(i);
}
static u64
string_find_first(String_Const_u32 str, u64 start_pos, u32 c){
    u64 i = start_pos;
    for (;i < str.size && c != str.str[i]; i += 1);
    return(i);
}

static u64
string_find_first(String_Const_char str, char c){
    return(string_find_first(str, 0, c));
}
static u64
string_find_first(String_Const_u8 str, u8 c){
    return(string_find_first(str, 0, c));
}
static u64
string_find_first(String_Const_u16 str, u16 c){
    return(string_find_first(str, 0, c));
}
static u64
string_find_first(String_Const_u32 str, u32 c){
    return(string_find_first(str, 0, c));
}

static i64
string_find_last(String_Const_char str, char c){
    i64 size = (i64)str.size;
    i64 i = size - 1;
    for (;i >= 0 && c != str.str[i]; i -= 1);
    return(i);
}
static i64
string_find_last(String_Const_u8 str, u8 c){
    i64 size = (i64)str.size;
    i64 i = size - 1;
    for (;i >= 0 && c != str.str[i]; i -= 1);
    return(i);
}
static i64
string_find_last(String_Const_u16 str, u16 c){
    i64 size = (i64)str.size;
    i64 i = size - 1;
    for (;i >= 0 && c != str.str[i]; i -= 1);
    return(i);
}
static i64
string_find_last(String_Const_u32 str, u32 c){
    i64 size = (i64)str.size;
    i64 i = size - 1;
    for (;i >= 0 && c != str.str[i]; i -= 1);
    return(i);
}

static u64
string_find_first_whitespace(String_Const_char str){
    u64 i = 0;
    for (;i < str.size && !character_is_whitespace(str.str[i]); i += 1);
    return(i);
}
static u64
string_find_first_whitespace(String_Const_u8 str){
    u64 i = 0;
    for (;i < str.size && !character_is_whitespace(str.str[i]); i += 1);
    return(i);
}
static u64
string_find_first_whitespace(String_Const_u16 str){
    u64 i = 0;
    for (;i < str.size && !character_is_whitespace(str.str[i]); i += 1);
    return(i);
}
static u64
string_find_first_whitespace(String_Const_u32 str){
    u64 i = 0;
    for (;i < str.size && !character_is_whitespace(str.str[i]); i += 1);
    return(i);
}
static i64
string_find_last_whitespace(String_Const_char str){
    i64 size = (i64)str.size;
    i64 i = size - 1;
    for (;i >= 0 && !character_is_whitespace(str.str[i]); i -= 1);
    return(i);
}
static i64
string_find_last_whitespace(String_Const_u8 str){
    i64 size = (i64)str.size;
    i64 i = size - 1;
    for (;i >= 0 && !character_is_whitespace(str.str[i]); i -= 1);
    return(i);
}
static i64
string_find_last_whitespace(String_Const_u16 str){
    i64 size = (i64)str.size;
    i64 i = size - 1;
    for (;i >= 0 && !character_is_whitespace(str.str[i]); i -= 1);
    return(i);
}
static i64
string_find_last_whitespace(String_Const_u32 str){
    i64 size = (i64)str.size;
    i64 i = size - 1;
    for (;i >= 0 && !character_is_whitespace(str.str[i]); i -= 1);
    return(i);
}

static u64
string_find_first_non_whitespace(String_Const_char str){
    u64 i = 0;
    for (;i < str.size && character_is_whitespace(str.str[i]); i += 1);
    return(i);
}
static u64
string_find_first_non_whitespace(String_Const_u8 str){
    u64 i = 0;
    for (;i < str.size && character_is_whitespace(str.str[i]); i += 1);
    return(i);
}
static u64
string_find_first_non_whitespace(String_Const_u16 str){
    u64 i = 0;
    for (;i < str.size && character_is_whitespace(str.str[i]); i += 1);
    return(i);
}
static u64
string_find_first_non_whitespace(String_Const_u32 str){
    u64 i = 0;
    for (;i < str.size && character_is_whitespace(str.str[i]); i += 1);
    return(i);
}
static i64
string_find_last_non_whitespace(String_Const_char str){
    i64 size = (i64)str.size;
    i64 i = size - 1;
    for (;i >= 0 && character_is_whitespace(str.str[i]); i -= 1);
    return(i);
}
static i64
string_find_last_non_whitespace(String_Const_u8 str){
    i64 size = (i64)str.size;
    i64 i = size - 1;
    for (;i >= 0 && character_is_whitespace(str.str[i]); i -= 1);
    return(i);
}
static i64
string_find_last_non_whitespace(String_Const_u16 str){
    i64 size = (i64)str.size;
    i64 i = size - 1;
    for (;i >= 0 && character_is_whitespace(str.str[i]); i -= 1);
    return(i);
}
static i64
string_find_last_non_whitespace(String_Const_u32 str){
    i64 size = (i64)str.size;
    i64 i = size - 1;
    for (;i >= 0 && character_is_whitespace(str.str[i]); i -= 1);
    return(i);
}

static u64
string_find_first_slash(String_Const_char str){
    u64 i = 0;
    for (;i < str.size && !character_is_slash(str.str[i]); i += 1);
    return(i);
}
static u64
string_find_first_slash(String_Const_u8 str){
    u64 i = 0;
    for (;i < str.size && !character_is_slash(str.str[i]); i += 1);
    return(i);
}
static u64
string_find_first_slash(String_Const_u16 str){
    u64 i = 0;
    for (;i < str.size && !character_is_slash(str.str[i]); i += 1);
    return(i);
}
static u64
string_find_first_slash(String_Const_u32 str){
    u64 i = 0;
    for (;i < str.size && !character_is_slash(str.str[i]); i += 1);
    return(i);
}
static i64
string_find_last_slash(String_Const_char str){
    i64 size = (i64)str.size;
    i64 i = size - 1;
    for (;i >= 0 && !character_is_slash(str.str[i]); i -= 1);
    return(i);
}
static i64
string_find_last_slash(String_Const_u8 str){
    i64 size = (i64)str.size;
    i64 i = size - 1;
    for (;i >= 0 && !character_is_slash(str.str[i]); i -= 1);
    return(i);
}
static i64
string_find_last_slash(String_Const_u16 str){
    i64 size = (i64)str.size;
    i64 i = size - 1;
    for (;i >= 0 && !character_is_slash(str.str[i]); i -= 1);
    return(i);
}
static i64
string_find_last_slash(String_Const_u32 str){
    i64 size = (i64)str.size;
    i64 i = size - 1;
    for (;i >= 0 && !character_is_slash(str.str[i]); i -= 1);
    return(i);
}

static String_Const_char
string_remove_last_folder(String_Const_char str){
    if (str.size > 0){
        str.size -= 1;
    }
    i64 slash_pos = string_find_last_slash(str);
    if (slash_pos < 0){
        str.size = 0;
    }
    else{
        str.size = slash_pos + 1;
    }
    return(str);
}
static String_Const_u8
string_remove_last_folder(String_Const_u8 str){
    if (str.size > 0){
        str.size -= 1;
    }
    i64 slash_pos = string_find_last_slash(str);
    if (slash_pos < 0){
        str.size = 0;
    }
    else{
        str.size = slash_pos + 1;
    }
    return(str);
}
static String_Const_u16
string_remove_last_folder(String_Const_u16 str){
    if (str.size > 0){
        str.size -= 1;
    }
    i64 slash_pos = string_find_last_slash(str);
    if (slash_pos < 0){
        str.size = 0;
    }
    else{
        str.size = slash_pos + 1;
    }
    return(str);
}
static String_Const_u32
string_remove_last_folder(String_Const_u32 str){
    if (str.size > 0){
        str.size -= 1;
    }
    i64 slash_pos = string_find_last_slash(str);
    if (slash_pos < 0){
        str.size = 0;
    }
    else{
        str.size = slash_pos + 1;
    }
    return(str);
}

static b32
string_looks_like_drive_letter(String_Const_u8 string){
    b32 result = false;
    if (string.size == 3 &&
        character_is_alpha(string.str[0]) &&
        string.str[1] == ':' &&
        character_is_slash(string.str[2])){
        result = true;
    }
    return(result);
}

static String_Const_char
string_remove_front_of_path(String_Const_char str){
    i64 slash_pos = string_find_last_slash(str);
    if (slash_pos < 0){
        str.size = 0;
    }
    else{
        str.size = slash_pos + 1;
    }
    return(str);
}
static String_Const_u8
string_remove_front_of_path(String_Const_u8 str){
    i64 slash_pos = string_find_last_slash(str);
    if (slash_pos < 0){
        str.size = 0;
    }
    else{
        str.size = slash_pos + 1;
    }
    return(str);
}
static String_Const_u16
string_remove_front_of_path(String_Const_u16 str){
    i64 slash_pos = string_find_last_slash(str);
    if (slash_pos < 0){
        str.size = 0;
    }
    else{
        str.size = slash_pos + 1;
    }
    return(str);
}
static String_Const_u32
string_remove_front_of_path(String_Const_u32 str){
    i64 slash_pos = string_find_last_slash(str);
    if (slash_pos < 0){
        str.size = 0;
    }
    else{
        str.size = slash_pos + 1;
    }
    return(str);
}

static String_Const_char
string_front_of_path(String_Const_char str){
    i64 slash_pos = string_find_last_slash(str);
    if (slash_pos >= 0){
        str = string_skip(str, slash_pos + 1);
    }
    return(str);
}
static String_Const_u8
string_front_of_path(String_Const_u8 str){
    i64 slash_pos = string_find_last_slash(str);
    if (slash_pos >= 0){
        str = string_skip(str, slash_pos + 1);
    }
    return(str);
}
static String_Const_u16
string_front_of_path(String_Const_u16 str){
    i64 slash_pos = string_find_last_slash(str);
    if (slash_pos >= 0){
        str = string_skip(str, slash_pos + 1);
    }
    return(str);
}
static String_Const_u32
string_front_of_path(String_Const_u32 str){
    i64 slash_pos = string_find_last_slash(str);
    if (slash_pos >= 0){
        str = string_skip(str, slash_pos + 1);
    }
    return(str);
}

static String_Const_u8
string_remove_front_folder_of_path(String_Const_u8 str){
    i64 slash_pos = string_find_last_slash(string_chop(str, 1));
    if (slash_pos < 0){
        str.size = 0;
    }
    else{
        str.size = slash_pos + 1;
    }
    return(str);
}
static String_Const_u8
string_front_folder_of_path(String_Const_u8 str){
    i64 slash_pos = string_find_last_slash(string_chop(str, 1));
    if (slash_pos >= 0){
        str = string_skip(str, slash_pos + 1);
    }
    return(str);
}

static String_Const_char
string_file_extension(String_Const_char string){
    return(string_skip(string, string_find_last(string, '.') + 1));
}
static String_Const_u8
string_file_extension(String_Const_u8 string){
    return(string_skip(string, string_find_last(string, '.') + 1));
}
static String_Const_u16
string_file_extension(String_Const_u16 string){
    return(string_skip(string, string_find_last(string, '.') + 1));
}
static String_Const_u32
string_file_extension(String_Const_u32 string){
    return(string_skip(string, string_find_last(string, '.') + 1));
}

static String_Const_char
string_file_without_extension(String_Const_char string){
    i64 pos = string_find_last(string, '.');
    if (pos > 0){
        string = string_prefix(string, pos);
    }
    return(string);
}
static String_Const_u8
string_file_without_extension(String_Const_u8 string){
    i64 pos = string_find_last(string, '.');
    if (pos > 0){
        string = string_prefix(string, pos);
    }
    return(string);
}
static String_Const_u16
string_file_without_extension(String_Const_u16 string){
    i64 pos = string_find_last(string, '.');
    if (pos > 0){
        string = string_prefix(string, pos);
    }
    return(string);
}
static String_Const_u32
string_file_without_extension(String_Const_u32 string){
    i64 pos = string_find_last(string, '.');
    if (pos > 0){
        string = string_prefix(string, pos);
    }
    return(string);
}

static String_Const_char
string_skip_whitespace(String_Const_char str){
    u64 f = string_find_first_non_whitespace(str);
    str = string_skip(str, f);
    return(str);
}
static String_Const_u8
string_skip_whitespace(String_Const_u8 str){
    u64 f = string_find_first_non_whitespace(str);
    str = string_skip(str, f);
    return(str);
}
static String_Const_u16
string_skip_whitespace(String_Const_u16 str){
    u64 f = string_find_first_non_whitespace(str);
    str = string_skip(str, f);
    return(str);
}
static String_Const_u32
string_skip_whitespace(String_Const_u32 str){
    u64 f = string_find_first_non_whitespace(str);
    str = string_skip(str, f);
    return(str);
}

static String_Const_char
string_chop_whitespace(String_Const_char str){
    i64 e = string_find_last_non_whitespace(str);
    str = string_prefix(str, (u64)(e + 1));
    return(str);
}
static String_Const_u8
string_chop_whitespace(String_Const_u8 str){
    i64 e = string_find_last_non_whitespace(str);
    str = string_prefix(str, (u64)(e + 1));
    return(str);
}
static String_Const_u16
string_chop_whitespace(String_Const_u16 str){
    i64 e = string_find_last_non_whitespace(str);
    str = string_prefix(str, (u64)(e + 1));
    return(str);
}
static String_Const_u32
string_chop_whitespace(String_Const_u32 str){
    i64 e = string_find_last_non_whitespace(str);
    str = string_prefix(str, (u64)(e + 1));
    return(str);
}

static String_Const_char
string_skip_chop_whitespace(String_Const_char str){
    u64 f = string_find_first_non_whitespace(str);
    str = string_skip(str, f);
    i64 e = string_find_last_non_whitespace(str);
    str = string_prefix(str, (u64)(e + 1));
    return(str);
}
static String_Const_u8
string_skip_chop_whitespace(String_Const_u8 str){
    u64 f = string_find_first_non_whitespace(str);
    str = string_skip(str, f);
    i64 e = string_find_last_non_whitespace(str);
    str = string_prefix(str, (u64)(e + 1));
    return(str);
}
static String_Const_u16
string_skip_chop_whitespace(String_Const_u16 str){
    u64 f = string_find_first_non_whitespace(str);
    str = string_skip(str, f);
    i64 e = string_find_last_non_whitespace(str);
    str = string_prefix(str, (u64)(e + 1));
    return(str);
}
static String_Const_u32
string_skip_chop_whitespace(String_Const_u32 str){
    u64 f = string_find_first_non_whitespace(str);
    str = string_skip(str, f);
    i64 e = string_find_last_non_whitespace(str);
    str = string_prefix(str, (u64)(e + 1));
    return(str);
}

static b32
string_match(String_Const_char a, String_Const_char b){
    b32 result = false;
    if (a.size == b.size){
        result = true;
        for (u64 i = 0; i < a.size; i += 1){
            if (a.str[i] != b.str[i]){
                result = false;
                break;
            }
        }
    }
    return(result);
}
static b32
string_match(String_Const_u8 a, String_Const_u8 b){
    b32 result = false;
    if (a.size == b.size){
        result = true;
        for (u64 i = 0; i < a.size; i += 1){
            if (a.str[i] != b.str[i]){
                result = false;
                break;
            }
        }
    }
    return(result);
}
static b32
string_match(String_Const_u16 a, String_Const_u16 b){
    b32 result = false;
    if (a.size == b.size){
        result = true;
        for (u64 i = 0; i < a.size; i += 1){
            if (a.str[i] != b.str[i]){
                result = false;
                break;
            }
        }
    }
    return(result);
}
static b32
string_match(String_Const_u32 a, String_Const_u32 b){
    b32 result = false;
    if (a.size == b.size){
        result = true;
        for (u64 i = 0; i < a.size; i += 1){
            if (a.str[i] != b.str[i]){
                result = false;
                break;
            }
        }
    }
    return(result);
}

static b32
string_match(String_Const_Any a, String_Const_Any b){
    b32 result = false;
    if (a.encoding == b.encoding){
        switch (a.encoding){
            case StringEncoding_ASCII: result = string_match(a.s_char, b.s_char); break;
            case StringEncoding_UTF8: result = string_match(a.s_u8 , b.s_u8 ); break;
            case StringEncoding_UTF16: result = string_match(a.s_u16 , b.s_u16 ); break;
            case StringEncoding_UTF32: result = string_match(a.s_u32 , b.s_u32 ); break;
        }
    }
    return(result);
}

static b32
string_match_insensitive(String_Const_char a, String_Const_char b){
    b32 result = false;
    if (a.size == b.size){
        result = true;
        for (u64 i = 0; i < a.size; i += 1){
            if (character_to_upper(a.str[i]) != character_to_upper(b.str[i])){
                result = false;
                break;
            }
        }
    }
    return(result);
}
static b32
string_match_insensitive(String_Const_u8 a, String_Const_u8 b){
    b32 result = false;
    if (a.size == b.size){
        result = true;
        for (u64 i = 0; i < a.size; i += 1){
            if (character_to_upper(a.str[i]) != character_to_upper(b.str[i])){
                result = false;
                break;
            }
        }
    }
    return(result);
}
static b32
string_match_insensitive(String_Const_u16 a, String_Const_u16 b){
    b32 result = false;
    if (a.size == b.size){
        result = true;
        for (u64 i = 0; i < a.size; i += 1){
            if (character_to_upper(a.str[i]) != character_to_upper(b.str[i])){
                result = false;
                break;
            }
        }
    }
    return(result);
}
static b32
string_match_insensitive(String_Const_u32 a, String_Const_u32 b){
    b32 result = false;
    if (a.size == b.size){
        result = true;
        for (u64 i = 0; i < a.size; i += 1){
            if (character_to_upper(a.str[i]) != character_to_upper(b.str[i])){
                result = false;
                break;
            }
        }
    }
    return(result);
}

static b32
string_match(String_Const_char a, String_Const_char b, String_Match_Rule rule){
    b32 result = false;
    switch (rule){
        case StringMatch_Exact:
        {
            result = string_match(a, b);
        }break;
        case StringMatch_CaseInsensitive:
        {
            result = string_match_insensitive(a, b);
        }break;
    }
    return(result);
}
static b32
string_match(String_Const_u8 a, String_Const_u8 b, String_Match_Rule rule){
    b32 result = false;
    switch (rule){
        case StringMatch_Exact:
        {
            result = string_match(a, b);
        }break;
        case StringMatch_CaseInsensitive:
        {
            result = string_match_insensitive(a, b);
        }break;
    }
    return(result);
}
static b32
string_match(String_Const_u16 a, String_Const_u16 b, String_Match_Rule rule){
    b32 result = false;
    switch (rule){
        case StringMatch_Exact:
        {
            result = string_match(a, b);
        }break;
        case StringMatch_CaseInsensitive:
        {
            result = string_match_insensitive(a, b);
        }break;
    }
    return(result);
}
static b32
string_match(String_Const_u32 a, String_Const_u32 b, String_Match_Rule rule){
    b32 result = false;
    switch (rule){
        case StringMatch_Exact:
        {
            result = string_match(a, b);
        }break;
        case StringMatch_CaseInsensitive:
        {
            result = string_match_insensitive(a, b);
        }break;
    }
    return(result);
}

static u64
string_find_first(String_Const_char str, String_Const_char needle, String_Match_Rule rule){
    u64 i = 0;
    if (needle.size > 0){
        i = str.size;
        if (str.size >= needle.size){
            i = 0;
            char c = character_to_upper(needle.str[0]);
            u64 one_past_last = str.size - needle.size + 1;
            for (;i < one_past_last; i += 1){
                if (character_to_upper(str.str[i]) == c){
                    String_Const_char source_part = string_prefix(string_skip(str, i), needle.size);
                    if (string_match(source_part, needle, rule)){
                        break;
                    }
                }
            }
            if (i == one_past_last){
                i = str.size;
            }
        }
    }
    return(i);
}
static u64
string_find_first(String_Const_u8 str, String_Const_u8 needle, String_Match_Rule rule){
    u64 i = 0;
    if (needle.size > 0){
        i = str.size;
        if (str.size >= needle.size){
            i = 0;
            u8 c = character_to_upper(needle.str[0]);
            u64 one_past_last = str.size - needle.size + 1;
            for (;i < one_past_last; i += 1){
                if (character_to_upper(str.str[i]) == c){
                    String_Const_u8 source_part = string_prefix(string_skip(str, i), needle.size);
                    if (string_match(source_part, needle, rule)){
                        break;
                    }
                }
            }
            if (i == one_past_last){
                i = str.size;
            }
        }
    }
    return(i);
}
static u64
string_find_first(String_Const_u16 str, String_Const_u16 needle, String_Match_Rule rule){
    u64 i = 0;
    if (needle.size > 0){
        i = str.size;
        if (str.size >= needle.size){
            i = 0;
            u16 c = character_to_upper(needle.str[0]);
            u64 one_past_last = str.size - needle.size + 1;
            for (;i < one_past_last; i += 1){
                if (character_to_upper(str.str[i]) == c){
                    String_Const_u16 source_part = string_prefix(string_skip(str, i), needle.size);
                    if (string_match(source_part, needle, rule)){
                        break;
                    }
                }
            }
            if (i == one_past_last){
                i = str.size;
            }
        }
    }
    return(i);
}
static u64
string_find_first(String_Const_u32 str, String_Const_u32 needle, String_Match_Rule rule){
    u64 i = 0;
    if (needle.size > 0){
        i = str.size;
        if (str.size >= needle.size){
            i = 0;
            u32 c = character_to_upper(needle.str[0]);
            u64 one_past_last = str.size - needle.size + 1;
            for (;i < one_past_last; i += 1){
                if (character_to_upper(str.str[i]) == c){
                    String_Const_u32 source_part = string_prefix(string_skip(str, i), needle.size);
                    if (string_match(source_part, needle, rule)){
                        break;
                    }
                }
            }
            if (i == one_past_last){
                i = str.size;
            }
        }
    }
    return(i);
}

static u64
string_find_first(String_Const_char str, String_Const_char needle){
    return(string_find_first(str, needle, StringMatch_Exact));
}
static u64
string_find_first(String_Const_u8 str, String_Const_u8 needle){
    return(string_find_first(str, needle, StringMatch_Exact));
}
static u64
string_find_first(String_Const_u16 str, String_Const_u16 needle){
    return(string_find_first(str, needle, StringMatch_Exact));
}
static u64
string_find_first(String_Const_u32 str, String_Const_u32 needle){
    return(string_find_first(str, needle, StringMatch_Exact));
}
static u64
string_find_first_insensitive(String_Const_char str, String_Const_char needle){
    return(string_find_first(str, needle, StringMatch_CaseInsensitive));
}
static u64
string_find_first_insensitive(String_Const_u8 str, String_Const_u8 needle){
    return(string_find_first(str, needle, StringMatch_CaseInsensitive));
}
static u64
string_find_first_insensitive(String_Const_u16 str, String_Const_u16 needle){
    return(string_find_first(str, needle, StringMatch_CaseInsensitive));
}
static u64
string_find_first_insensitive(String_Const_u32 str, String_Const_u32 needle){
    return(string_find_first(str, needle, StringMatch_CaseInsensitive));
}

static b32
string_has_substr(String_Const_u8 str, String_Const_u8 needle, String_Match_Rule rule){
    return(string_find_first(str, needle, rule) < str.size);
}

static b32
string_has_substr(String_Const_u8 str, String_Const_u8 needle){
    return(string_find_first(str, needle, StringMatch_Exact) < str.size);
}

static i32
string_compare(String_Const_char a, String_Const_char b){
    i32 result = 0;
    for (u64 i = 0; i < a.size || i < b.size; i += 1){
        char ca = (i < a.size)?a.str[i]:0;
        char cb = (i < b.size)?b.str[i]:0;
        i32 dif = ((ca) - (cb));
        if (dif != 0){
            result = (dif > 0)?1:-1;
            break;
        }
    }
    return(result);
}
static i32
string_compare(String_Const_u8 a, String_Const_u8 b){
    i32 result = 0;
    for (u64 i = 0; i < a.size || i < b.size; i += 1){
        u8 ca = (i < a.size)?a.str[i]:0;
        u8 cb = (i < b.size)?b.str[i]:0;
        i32 dif = ((ca) - (cb));
        if (dif != 0){
            result = (dif > 0)?1:-1;
            break;
        }
    }
    return(result);
}
static i32
string_compare(String_Const_u16 a, String_Const_u16 b){
    i32 result = 0;
    for (u64 i = 0; i < a.size || i < b.size; i += 1){
        u16 ca = (i < a.size)?a.str[i]:0;
        u16 cb = (i < b.size)?b.str[i]:0;
        i32 dif = ((ca) - (cb));
        if (dif != 0){
            result = (dif > 0)?1:-1;
            break;
        }
    }
    return(result);
}
static i32
string_compare(String_Const_u32 a, String_Const_u32 b){
    i32 result = 0;
    for (u64 i = 0; i < a.size || i < b.size; i += 1){
        u32 ca = (i < a.size)?a.str[i]:0;
        u32 cb = (i < b.size)?b.str[i]:0;
        i32 dif = ((ca) - (cb));
        if (dif != 0){
            result = (dif > 0)?1:-1;
            break;
        }
    }
    return(result);
}

static i32
string_compare_insensitive(String_Const_char a, String_Const_char b){
    i32 result = 0;
    for (u64 i = 0; i < a.size || i < b.size; i += 1){
        char ca = (i <= a.size)?0:a.str[i];
        char cb = (i <= b.size)?0:b.str[i];
        i32 dif = character_to_upper(ca) - character_to_upper(cb);
        if (dif != 0){
            result = (dif > 0)?1:-1;
            break;
        }
    }
    return(result);
}
static i32
string_compare_insensitive(String_Const_u8 a, String_Const_u8 b){
    i32 result = 0;
    for (u64 i = 0; i < a.size || i < b.size; i += 1){
        u8 ca = (i <= a.size)?0:a.str[i];
        u8 cb = (i <= b.size)?0:b.str[i];
        i32 dif = character_to_upper(ca) - character_to_upper(cb);
        if (dif != 0){
            result = (dif > 0)?1:-1;
            break;
        }
    }
    return(result);
}
static i32
string_compare_insensitive(String_Const_u16 a, String_Const_u16 b){
    i32 result = 0;
    for (u64 i = 0; i < a.size || i < b.size; i += 1){
        u16 ca = (i <= a.size)?0:a.str[i];
        u16 cb = (i <= b.size)?0:b.str[i];
        i32 dif = character_to_upper(ca) - character_to_upper(cb);
        if (dif != 0){
            result = (dif > 0)?1:-1;
            break;
        }
    }
    return(result);
}
static i32
string_compare_insensitive(String_Const_u32 a, String_Const_u32 b){
    i32 result = 0;
    for (u64 i = 0; i < a.size || i < b.size; i += 1){
        u32 ca = (i <= a.size)?0:a.str[i];
        u32 cb = (i <= b.size)?0:b.str[i];
        i32 dif = character_to_upper(ca) - character_to_upper(cb);
        if (dif != 0){
            result = (dif > 0)?1:-1;
            break;
        }
    }
    return(result);
}

static String_Const_char
string_mod_upper(String_Const_char str){
    for (u64 i = 0; i < str.size; i += 1){
        str.str[i] = character_to_upper(str.str[i]);
    }
    return(str);
}
static String_Const_u8
string_mod_upper(String_Const_u8 str){
    for (u64 i = 0; i < str.size; i += 1){
        str.str[i] = character_to_upper(str.str[i]);
    }
    return(str);
}
static String_Const_u16
string_mod_upper(String_Const_u16 str){
    for (u64 i = 0; i < str.size; i += 1){
        str.str[i] = character_to_upper(str.str[i]);
    }
    return(str);
}
static String_Const_u32
string_mod_upper(String_Const_u32 str){
    for (u64 i = 0; i < str.size; i += 1){
        str.str[i] = character_to_upper(str.str[i]);
    }
    return(str);
}
static String_Const_char
string_mod_lower(String_Const_char str){
    for (u64 i = 0; i < str.size; i += 1){
        str.str[i] = character_to_lower(str.str[i]);
    }
    return(str);
}
static String_Const_u8
string_mod_lower(String_Const_u8 str){
    for (u64 i = 0; i < str.size; i += 1){
        str.str[i] = character_to_lower(str.str[i]);
    }
    return(str);
}
static String_Const_u16
string_mod_lower(String_Const_u16 str){
    for (u64 i = 0; i < str.size; i += 1){
        str.str[i] = character_to_lower(str.str[i]);
    }
    return(str);
}
static String_Const_u32
string_mod_lower(String_Const_u32 str){
    for (u64 i = 0; i < str.size; i += 1){
        str.str[i] = character_to_lower(str.str[i]);
    }
    return(str);
}

static String_Const_char
string_mod_replace_character(String_Const_char str, char o, char n){
    for (u64 i = 0; i < str.size; i += 1){
        char c = str.str[i];
        str.str[i] = (c == o)?(n):(c);
    }
    return(str);
}
static String_Const_u8
string_mod_replace_character(String_Const_u8 str, u8 o, u8 n){
    for (u64 i = 0; i < str.size; i += 1){
        u8 c = str.str[i];
        str.str[i] = (c == o)?(n):(c);
    }
    return(str);
}
static String_Const_u16
string_mod_replace_character(String_Const_u16 str, u16 o, u16 n){
    for (u64 i = 0; i < str.size; i += 1){
        u16 c = str.str[i];
        str.str[i] = (c == o)?(n):(c);
    }
    return(str);
}
static String_Const_u32
string_mod_replace_character(String_Const_u32 str, u32 o, u32 n){
    for (u64 i = 0; i < str.size; i += 1){
        u32 c = str.str[i];
        str.str[i] = (c == o)?(n):(c);
    }
    return(str);
}

static b32
string_append(String_char *dst, String_Const_char src){
    b32 result = false;
    u64 available = dst->cap - dst->size;
    if (src.size <= available){
        result = true;
    }
    u64 copy_size = (((src.size)<(available))?(src.size):(available));
    block_copy(dst->str + dst->size, src.str, copy_size);
    dst->size += copy_size;
    return(result);
}
static b32
string_append(String_u8 *dst, String_Const_u8 src){
    b32 result = false;
    u64 available = dst->cap - dst->size;
    if (src.size <= available){
        result = true;
    }
    u64 copy_size = (((src.size)<(available))?(src.size):(available));
    block_copy(dst->str + dst->size, src.str, copy_size);
    dst->size += copy_size;
    return(result);
}
static b32
string_append(String_u16 *dst, String_Const_u16 src){
    b32 result = false;
    u64 available = dst->cap - dst->size;
    if (src.size <= available){
        result = true;
    }
    u64 copy_size = (((src.size)<(available))?(src.size):(available));
    block_copy(dst->str + dst->size, src.str, copy_size);
    dst->size += copy_size;
    return(result);
}
static b32
string_append(String_u32 *dst, String_Const_u32 src){
    b32 result = false;
    u64 available = dst->cap - dst->size;
    if (src.size <= available){
        result = true;
    }
    u64 copy_size = (((src.size)<(available))?(src.size):(available));
    block_copy(dst->str + dst->size, src.str, copy_size);
    dst->size += copy_size;
    return(result);
}

static b32
string_append_character(String_char *dst, char c){
    return(string_append(dst, SCchar(&c, 1)));
}
static b32
string_append_character(String_u8 *dst, u8 c){
    return(string_append(dst, SCu8(&c, 1)));
}
static b32
string_append_character(String_u16 *dst, u16 c){
    return(string_append(dst, SCu16(&c, 1)));
}
static b32
string_append_character(String_u32 *dst, u32 c){
    return(string_append(dst, SCu32(&c, 1)));
}

static b32
string_null_terminate(String_char *str){
    b32 result = false;
    if (str->size < str->cap){
        str->str[str->size] = 0;
    }
    return(result);
}
static b32
string_null_terminate(String_u8 *str){
    b32 result = false;
    if (str->size < str->cap){
        str->str[str->size] = 0;
    }
    return(result);
}
static b32
string_null_terminate(String_u16 *str){
    b32 result = false;
    if (str->size < str->cap){
        str->str[str->size] = 0;
    }
    return(result);
}
static b32
string_null_terminate(String_u32 *str){
    b32 result = false;
    if (str->size < str->cap){
        str->str[str->size] = 0;
    }
    return(result);
}

static String_char
string_char_push(Arena *arena, u64 size){
    String_char string = {};
    string.str = ((char*)linalloc_wrap_unintialized(linalloc_push((arena), sizeof(char)*(size), SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_base_types.cpp" ":" "5314" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_base_types.cpp" ":" "5314" ":") - 1)))));
    string.cap = size;
    return(string);
}
static String_u8
string_u8_push(Arena *arena, u64 size){
    String_u8 string = {};
    string.str = ((u8*)linalloc_wrap_unintialized(linalloc_push((arena), sizeof(u8)*(size), SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_base_types.cpp" ":" "5321" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_base_types.cpp" ":" "5321" ":") - 1)))));
    string.cap = size;
    return(string);
}
static String_u16
string_u16_push(Arena *arena, u64 size){
    String_u16 string = {};
    string.str = ((u16*)linalloc_wrap_unintialized(linalloc_push((arena), sizeof(u16)*(size), SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_base_types.cpp" ":" "5328" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_base_types.cpp" ":" "5328" ":") - 1)))));
    string.cap = size;
    return(string);
}
static String_u32
string_u32_push(Arena *arena, u64 size){
    String_u32 string = {};
    string.str = ((u32*)linalloc_wrap_unintialized(linalloc_push((arena), sizeof(u32)*(size), SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_base_types.cpp" ":" "5335" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_base_types.cpp" ":" "5335" ":") - 1)))));
    string.cap = size;
    return(string);
}

static String_Any
string_any_push(Arena *arena, u64 size, String_Encoding encoding){
    String_Any string = {};
    switch (encoding){
        case StringEncoding_ASCII: string.s_char = string_char_push(arena, size); break;
        case StringEncoding_UTF8: string.s_u8 = string_u8_push (arena, size); break;
        case StringEncoding_UTF16: string.s_u16 = string_u16_push (arena, size); break;
        case StringEncoding_UTF32: string.s_u32 = string_u32_push (arena, size); break;
    }
    return(string);
}






static String_Const_char
string_const_char_push(Arena *arena, u64 size){
    String_Const_char string = {};
    string.str = ((char*)linalloc_wrap_unintialized(linalloc_push((arena), sizeof(char)*(size), SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_base_types.cpp" ":" "5360" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_base_types.cpp" ":" "5360" ":") - 1)))));
    string.size = size;
    return(string);
}
static String_Const_u8
string_const_u8_push(Arena *arena, u64 size){
    String_Const_u8 string = {};
    string.str = ((u8*)linalloc_wrap_unintialized(linalloc_push((arena), sizeof(u8)*(size), SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_base_types.cpp" ":" "5367" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_base_types.cpp" ":" "5367" ":") - 1)))));
    string.size = size;
    return(string);
}
static String_Const_u16
string_const_u16_push(Arena *arena, u64 size){
    String_Const_u16 string = {};
    string.str = ((u16*)linalloc_wrap_unintialized(linalloc_push((arena), sizeof(u16)*(size), SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_base_types.cpp" ":" "5374" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_base_types.cpp" ":" "5374" ":") - 1)))));
    string.size = size;
    return(string);
}
static String_Const_u32
string_const_u32_push(Arena *arena, u64 size){
    String_Const_u32 string = {};
    string.str = ((u32*)linalloc_wrap_unintialized(linalloc_push((arena), sizeof(u32)*(size), SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_base_types.cpp" ":" "5381" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_base_types.cpp" ":" "5381" ":") - 1)))));
    string.size = size;
    return(string);
}

static String_Const_Any
string_const_any_push(Arena *arena, u64 size, String_Encoding encoding){
    String_Const_Any string = {};
    switch (encoding){
        case StringEncoding_ASCII: string.s_char = string_const_char_push(arena, size); break;
        case StringEncoding_UTF8: string.s_u8 = string_const_u8_push (arena, size); break;
        case StringEncoding_UTF16: string.s_u16 = string_const_u16_push (arena, size); break;
        case StringEncoding_UTF32: string.s_u32 = string_const_u32_push (arena, size); break;
    }
    return(string);
}






static String_Const_char
push_string_copy(Arena *arena, String_Const_char src){
    String_Const_char string = {};
    string.str = ((char*)linalloc_wrap_unintialized(linalloc_push((arena), sizeof(char)*(src.size + 1), SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_base_types.cpp" ":" "5406" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_base_types.cpp" ":" "5406" ":") - 1)))));
    string.size = src.size;
    block_copy((string.str), (src.str), sizeof(*(string.str))*(src.size));
    string.str[string.size] = 0;
    return(string);
}
static String_Const_u8
push_string_copy(Arena *arena, String_Const_u8 src){
    String_Const_u8 string = {};
    string.str = ((u8*)linalloc_wrap_unintialized(linalloc_push((arena), sizeof(u8)*(src.size + 1), SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_base_types.cpp" ":" "5415" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_base_types.cpp" ":" "5415" ":") - 1)))));
    string.size = src.size;
    block_copy((string.str), (src.str), sizeof(*(string.str))*(src.size));
    string.str[string.size] = 0;
    return(string);
}
static String_Const_u16
push_string_copy(Arena *arena, String_Const_u16 src){
    String_Const_u16 string = {};
    string.str = ((u16*)linalloc_wrap_unintialized(linalloc_push((arena), sizeof(u16)*(src.size + 1), SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_base_types.cpp" ":" "5424" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_base_types.cpp" ":" "5424" ":") - 1)))));
    string.size = src.size;
    block_copy((string.str), (src.str), sizeof(*(string.str))*(src.size));
    string.str[string.size] = 0;
    return(string);
}
static String_Const_u32
push_string_copy(Arena *arena, String_Const_u32 src){
    String_Const_u32 string = {};
    string.str = ((u32*)linalloc_wrap_unintialized(linalloc_push((arena), sizeof(u32)*(src.size + 1), SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_base_types.cpp" ":" "5433" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_base_types.cpp" ":" "5433" ":") - 1)))));
    string.size = src.size;
    block_copy((string.str), (src.str), sizeof(*(string.str))*(src.size));
    string.str[string.size] = 0;
    return(string);
}

static String_Const_Any
push_string_copy(Arena *arena, u64 size, String_Const_Any src){
    String_Const_Any string = {};
    switch (src.encoding){
        case StringEncoding_ASCII: string.s_char = push_string_copy(arena, src.s_char); break;
        case StringEncoding_UTF8: string.s_u8 = push_string_copy(arena, src.s_u8 ); break;
        case StringEncoding_UTF16: string.s_u16 = push_string_copy(arena, src.s_u16 ); break;
        case StringEncoding_UTF32: string.s_u32 = push_string_copy(arena, src.s_u32 ); break;
    }
    return(string);
}

static String_Const_u8_Array
push_string_array_copy(Arena *arena, String_Const_u8_Array src){
    String_Const_u8_Array result = {};
    result.vals = ((String_Const_u8*)linalloc_wrap_unintialized(linalloc_push((arena), sizeof(String_Const_u8)*(src.count), SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_base_types.cpp" ":" "5455" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_base_types.cpp" ":" "5455" ":") - 1)))));
    result.count = src.count;
    for (i32 i = 0; i < src.count; i += 1){
        result.vals[i] = push_string_copy(arena, src.vals[i]);
    }
    return(result);
}

static void
string_list_push(List_String_Const_char *list, Node_String_Const_char *node){
    do{ if((node)){if((list->first)){(list->last)->next=(node);}else{(list->first)=(node);}(list->last)=(node);(list->last)->next=0;} }while(0);
    list->node_count += 1;
    list->total_size += node->string.size;
}
static void
string_list_push(List_String_Const_u8 *list, Node_String_Const_u8 *node){
    do{ if((node)){if((list->first)){(list->last)->next=(node);}else{(list->first)=(node);}(list->last)=(node);(list->last)->next=0;} }while(0);
    list->node_count += 1;
    list->total_size += node->string.size;
}
static void
string_list_push(List_String_Const_u16 *list, Node_String_Const_u16 *node){
    do{ if((node)){if((list->first)){(list->last)->next=(node);}else{(list->first)=(node);}(list->last)=(node);(list->last)->next=0;} }while(0);
    list->node_count += 1;
    list->total_size += node->string.size;
}
static void
string_list_push(List_String_Const_u32 *list, Node_String_Const_u32 *node){
    do{ if((node)){if((list->first)){(list->last)->next=(node);}else{(list->first)=(node);}(list->last)=(node);(list->last)->next=0;} }while(0);
    list->node_count += 1;
    list->total_size += node->string.size;
}

static void
string_list_push(Arena *arena, List_String_Const_char *list, String_Const_char string){
    Node_String_Const_char *node = ((Node_String_Const_char*)linalloc_wrap_unintialized(linalloc_push((arena), sizeof(Node_String_Const_char)*(1), SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_base_types.cpp" ":" "5490" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_base_types.cpp" ":" "5490" ":") - 1)))));
    do{ if((node)){if((list->first)){(list->last)->next=(node);}else{(list->first)=(node);}(list->last)=(node);(list->last)->next=0;} }while(0);
    node->string = string;
    list->node_count += 1;
    list->total_size += string.size;
}
static void
string_list_push(Arena *arena, List_String_Const_u8 *list, String_Const_u8 string){
    Node_String_Const_u8 *node = ((Node_String_Const_u8*)linalloc_wrap_unintialized(linalloc_push((arena), sizeof(Node_String_Const_u8)*(1), SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_base_types.cpp" ":" "5498" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_base_types.cpp" ":" "5498" ":") - 1)))));
    do{ if((node)){if((list->first)){(list->last)->next=(node);}else{(list->first)=(node);}(list->last)=(node);(list->last)->next=0;} }while(0);
    node->string = string;
    list->node_count += 1;
    list->total_size += string.size;
}
static void
string_list_push(Arena *arena, List_String_Const_u16 *list, String_Const_u16 string){
    Node_String_Const_u16 *node = ((Node_String_Const_u16*)linalloc_wrap_unintialized(linalloc_push((arena), sizeof(Node_String_Const_u16)*(1), SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_base_types.cpp" ":" "5506" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_base_types.cpp" ":" "5506" ":") - 1)))));
    do{ if((node)){if((list->first)){(list->last)->next=(node);}else{(list->first)=(node);}(list->last)=(node);(list->last)->next=0;} }while(0);
    node->string = string;
    list->node_count += 1;
    list->total_size += string.size;
}
static void
string_list_push(Arena *arena, List_String_Const_u32 *list, String_Const_u32 string){
    Node_String_Const_u32 *node = ((Node_String_Const_u32*)linalloc_wrap_unintialized(linalloc_push((arena), sizeof(Node_String_Const_u32)*(1), SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_base_types.cpp" ":" "5514" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_base_types.cpp" ":" "5514" ":") - 1)))));
    do{ if((node)){if((list->first)){(list->last)->next=(node);}else{(list->first)=(node);}(list->last)=(node);(list->last)->next=0;} }while(0);
    node->string = string;
    list->node_count += 1;
    list->total_size += string.size;
}

static void
string_list_push(Arena *arena, List_String_Const_Any *list, String_Const_Any string){
    Node_String_Const_Any *node = ((Node_String_Const_Any*)linalloc_wrap_unintialized(linalloc_push((arena), sizeof(Node_String_Const_Any)*(1), SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_base_types.cpp" ":" "5523" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_base_types.cpp" ":" "5523" ":") - 1)))));
    do{ if((node)){if((list->first)){(list->last)->next=(node);}else{(list->first)=(node);}(list->last)=(node);(list->last)->next=0;} }while(0);
    node->string = string;
    list->node_count += 1;
    list->total_size += string.size;
}




static void
string_list_push(List_String_Const_char *list, List_String_Const_char *src_list){
    do{ if((src_list->last)){if((list->first)){(list->last)->next=(src_list->first);}else{(list->first)=(src_list->first);}(list->last)=(src_list->last);(list->last)->next=0;} }while(0);
    list->node_count += src_list->node_count;
    list->total_size += src_list->total_size;
    block_zero((src_list), sizeof(src_list));
}
static void
string_list_push(List_String_Const_u8 *list, List_String_Const_u8 *src_list){
    do{ if((src_list->last)){if((list->first)){(list->last)->next=(src_list->first);}else{(list->first)=(src_list->first);}(list->last)=(src_list->last);(list->last)->next=0;} }while(0);
    list->node_count += src_list->node_count;
    list->total_size += src_list->total_size;
    block_zero((src_list), sizeof(src_list));
}
static void
string_list_push(List_String_Const_u16 *list, List_String_Const_u16 *src_list){
    do{ if((src_list->last)){if((list->first)){(list->last)->next=(src_list->first);}else{(list->first)=(src_list->first);}(list->last)=(src_list->last);(list->last)->next=0;} }while(0);
    list->node_count += src_list->node_count;
    list->total_size += src_list->total_size;
    block_zero((src_list), sizeof(src_list));
}
static void
string_list_push(List_String_Const_u32 *list, List_String_Const_u32 *src_list){
    do{ if((src_list->last)){if((list->first)){(list->last)->next=(src_list->first);}else{(list->first)=(src_list->first);}(list->last)=(src_list->last);(list->last)->next=0;} }while(0);
    list->node_count += src_list->node_count;
    list->total_size += src_list->total_size;
    block_zero((src_list), sizeof(src_list));
}

static void
string_list_push(List_String_Const_Any *list, List_String_Const_Any *src_list){
    do{ if((src_list->last)){if((list->first)){(list->last)->next=(src_list->first);}else{(list->first)=(src_list->first);}(list->last)=(src_list->last);(list->last)->next=0;} }while(0);
    list->node_count += src_list->node_count;
    list->total_size += src_list->total_size;
    block_zero((src_list), sizeof(src_list));
}

static void
string_list_push_overlap(Arena *arena, List_String_Const_char *list, char overlap, String_Const_char string){
    b32 tail_has_overlap = false;
    b32 string_has_overlap = false;
    if (list->last != 0){
        String_Const_char tail = list->last->string;
        if (string_get_character(tail, tail.size - 1) == overlap){
            tail_has_overlap = true;
        }
    }
    if (string_get_character(string, 0) == overlap){
        string_has_overlap = true;
    }
    if (tail_has_overlap == string_has_overlap){
        if (!tail_has_overlap){
            string_list_push(arena, list, push_string_copy(arena, SCchar(&overlap, 1)));
        }
        else{
            string = string_skip(string, 1);
        }
    }
    if (string.size > 0){
        string_list_push(arena, list, string);
    }
}
static void
string_list_push_overlap(Arena *arena, List_String_Const_u8 *list, u8 overlap, String_Const_u8 string){
    b32 tail_has_overlap = false;
    b32 string_has_overlap = false;
    if (list->last != 0){
        String_Const_u8 tail = list->last->string;
        if (string_get_character(tail, tail.size - 1) == overlap){
            tail_has_overlap = true;
        }
    }
    if (string_get_character(string, 0) == overlap){
        string_has_overlap = true;
    }
    if (tail_has_overlap == string_has_overlap){
        if (!tail_has_overlap){
            string_list_push(arena, list, push_string_copy(arena, SCu8(&overlap, 1)));
        }
        else{
            string = string_skip(string, 1);
        }
    }
    if (string.size > 0){
        string_list_push(arena, list, string);
    }
}
static void
string_list_push_overlap(Arena *arena, List_String_Const_u16 *list, u16 overlap, String_Const_u16 string){
    b32 tail_has_overlap = false;
    b32 string_has_overlap = false;
    if (list->last != 0){
        String_Const_u16 tail = list->last->string;
        if (string_get_character(tail, tail.size - 1) == overlap){
            tail_has_overlap = true;
        }
    }
    if (string_get_character(string, 0) == overlap){
        string_has_overlap = true;
    }
    if (tail_has_overlap == string_has_overlap){
        if (!tail_has_overlap){
            string_list_push(arena, list, push_string_copy(arena, SCu16(&overlap, 1)));
        }
        else{
            string = string_skip(string, 1);
        }
    }
    if (string.size > 0){
        string_list_push(arena, list, string);
    }
}
static void
string_list_push_overlap(Arena *arena, List_String_Const_u32 *list, u32 overlap, String_Const_u32 string){
    b32 tail_has_overlap = false;
    b32 string_has_overlap = false;
    if (list->last != 0){
        String_Const_u32 tail = list->last->string;
        if (string_get_character(tail, tail.size - 1) == overlap){
            tail_has_overlap = true;
        }
    }
    if (string_get_character(string, 0) == overlap){
        string_has_overlap = true;
    }
    if (tail_has_overlap == string_has_overlap){
        if (!tail_has_overlap){
            string_list_push(arena, list, push_string_copy(arena, SCu32(&overlap, 1)));
        }
        else{
            string = string_skip(string, 1);
        }
    }
    if (string.size > 0){
        string_list_push(arena, list, string);
    }
}






typedef String_Const_char String_char_Mod_Function_Type(String_Const_char string);
typedef String_Const_u8 String_u8_Mod_Function_Type(String_Const_u8 string);
typedef String_Const_u16 String_u16_Mod_Function_Type(String_Const_u16 string);
typedef String_Const_u32 String_u32_Mod_Function_Type(String_Const_u32 string);

static String_Const_char
string_list_flatten(Arena *arena, List_String_Const_char list, String_char_Mod_Function_Type *mod, String_Const_char separator, String_Separator_Flag separator_flags, String_Fill_Terminate_Rule rule){
    u64 term_padding = (rule == StringFill_NullTerminate)?(1):(0);b32 before_first = (((separator_flags)&(StringSeparator_BeforeFirst))!=0);
    b32 after_last = (((separator_flags)&(StringSeparator_AfterLast))!=0);
    u64 separator_size = separator.size*(list.node_count + before_first + after_last - 1);
    String_char string = string_char_push(arena, list.total_size + separator_size + term_padding);
    if (before_first){
        string_append(&string, separator);
    }
    for (Node_String_Const_char *node = list.first;
         node != 0;
         node = node->next){
        block_copy((string.str + string.size), (node->string.str), sizeof(*(string.str + string.size))*(node->string.size));
        if (mod != 0){
            mod(SCchar(string.str + string.size, node->string.size));
        }
        string.size += node->string.size;
        string_append(&string, separator);
    }
    if (after_last){
        string_append(&string, separator);
    }
    if (term_padding == 1){
        string_null_terminate(&string);
    }
    return(string.string);
}
static String_Const_u8
string_list_flatten(Arena *arena, List_String_Const_u8 list, String_u8_Mod_Function_Type *mod, String_Const_u8 separator, String_Separator_Flag separator_flags, String_Fill_Terminate_Rule rule){
    u64 term_padding = (rule == StringFill_NullTerminate)?(1):(0);b32 before_first = (((separator_flags)&(StringSeparator_BeforeFirst))!=0);
    b32 after_last = (((separator_flags)&(StringSeparator_AfterLast))!=0);
    u64 separator_size = separator.size*(list.node_count + before_first + after_last - 1);
    String_u8 string = string_u8_push(arena, list.total_size + separator_size + term_padding);
    if (before_first){
        string_append(&string, separator);
    }
    for (Node_String_Const_u8 *node = list.first;
         node != 0;
         node = node->next){
        block_copy((string.str + string.size), (node->string.str), sizeof(*(string.str + string.size))*(node->string.size));
        if (mod != 0){
            mod(SCu8(string.str + string.size, node->string.size));
        }
        string.size += node->string.size;
        string_append(&string, separator);
    }
    if (after_last){
        string_append(&string, separator);
    }
    if (term_padding == 1){
        string_null_terminate(&string);
    }
    return(string.string);
}
static String_Const_u16
string_list_flatten(Arena *arena, List_String_Const_u16 list, String_u16_Mod_Function_Type *mod, String_Const_u16 separator, String_Separator_Flag separator_flags, String_Fill_Terminate_Rule rule){
    u64 term_padding = (rule == StringFill_NullTerminate)?(1):(0);b32 before_first = (((separator_flags)&(StringSeparator_BeforeFirst))!=0);
    b32 after_last = (((separator_flags)&(StringSeparator_AfterLast))!=0);
    u64 separator_size = separator.size*(list.node_count + before_first + after_last - 1);
    String_u16 string = string_u16_push(arena, list.total_size + separator_size + term_padding);
    if (before_first){
        string_append(&string, separator);
    }
    for (Node_String_Const_u16 *node = list.first;
         node != 0;
         node = node->next){
        block_copy((string.str + string.size), (node->string.str), sizeof(*(string.str + string.size))*(node->string.size));
        if (mod != 0){
            mod(SCu16(string.str + string.size, node->string.size));
        }
        string.size += node->string.size;
        string_append(&string, separator);
    }
    if (after_last){
        string_append(&string, separator);
    }
    if (term_padding == 1){
        string_null_terminate(&string);
    }
    return(string.string);
}
static String_Const_u32
string_list_flatten(Arena *arena, List_String_Const_u32 list, String_u32_Mod_Function_Type *mod, String_Const_u32 separator, String_Separator_Flag separator_flags, String_Fill_Terminate_Rule rule){
    u64 term_padding = (rule == StringFill_NullTerminate)?(1):(0);b32 before_first = (((separator_flags)&(StringSeparator_BeforeFirst))!=0);
    b32 after_last = (((separator_flags)&(StringSeparator_AfterLast))!=0);
    u64 separator_size = separator.size*(list.node_count + before_first + after_last - 1);
    String_u32 string = string_u32_push(arena, list.total_size + separator_size + term_padding);
    if (before_first){
        string_append(&string, separator);
    }
    for (Node_String_Const_u32 *node = list.first;
         node != 0;
         node = node->next){
        block_copy((string.str + string.size), (node->string.str), sizeof(*(string.str + string.size))*(node->string.size));
        if (mod != 0){
            mod(SCu32(string.str + string.size, node->string.size));
        }
        string.size += node->string.size;
        string_append(&string, separator);
    }
    if (after_last){
        string_append(&string, separator);
    }
    if (term_padding == 1){
        string_null_terminate(&string);
    }
    return(string.string);
}
static String_Const_char
string_list_flatten(Arena *arena, List_String_Const_char list, String_Const_char separator, String_Separator_Flag separator_flags, String_Fill_Terminate_Rule rule){
    return(string_list_flatten(arena, list, 0, separator, separator_flags, rule));
}
static String_Const_u8
string_list_flatten(Arena *arena, List_String_Const_u8 list, String_Const_u8 separator, String_Separator_Flag separator_flags, String_Fill_Terminate_Rule rule){
    return(string_list_flatten(arena, list, 0, separator, separator_flags, rule));
}
static String_Const_u16
string_list_flatten(Arena *arena, List_String_Const_u16 list, String_Const_u16 separator, String_Separator_Flag separator_flags, String_Fill_Terminate_Rule rule){
    return(string_list_flatten(arena, list, 0, separator, separator_flags, rule));
}
static String_Const_u32
string_list_flatten(Arena *arena, List_String_Const_u32 list, String_Const_u32 separator, String_Separator_Flag separator_flags, String_Fill_Terminate_Rule rule){
    return(string_list_flatten(arena, list, 0, separator, separator_flags, rule));
}
static String_Const_char
string_list_flatten(Arena *arena, List_String_Const_char list, String_char_Mod_Function_Type *mod, String_Fill_Terminate_Rule rule){
    return(string_list_flatten(arena, list, mod, SCchar(), 0, rule));
}
static String_Const_u8
string_list_flatten(Arena *arena, List_String_Const_u8 list, String_u8_Mod_Function_Type *mod, String_Fill_Terminate_Rule rule){
    return(string_list_flatten(arena, list, mod, SCu8(), 0, rule));
}
static String_Const_u16
string_list_flatten(Arena *arena, List_String_Const_u16 list, String_u16_Mod_Function_Type *mod, String_Fill_Terminate_Rule rule){
    return(string_list_flatten(arena, list, mod, SCu16(), 0, rule));
}
static String_Const_u32
string_list_flatten(Arena *arena, List_String_Const_u32 list, String_u32_Mod_Function_Type *mod, String_Fill_Terminate_Rule rule){
    return(string_list_flatten(arena, list, mod, SCu32(), 0, rule));
}
static String_Const_char
string_list_flatten(Arena *arena, List_String_Const_char string, String_Fill_Terminate_Rule rule){
    return(string_list_flatten(arena, string, 0, SCchar(), 0, rule));
}
static String_Const_u8
string_list_flatten(Arena *arena, List_String_Const_u8 string, String_Fill_Terminate_Rule rule){
    return(string_list_flatten(arena, string, 0, SCu8(), 0, rule));
}
static String_Const_u16
string_list_flatten(Arena *arena, List_String_Const_u16 string, String_Fill_Terminate_Rule rule){
    return(string_list_flatten(arena, string, 0, SCu16(), 0, rule));
}
static String_Const_u32
string_list_flatten(Arena *arena, List_String_Const_u32 string, String_Fill_Terminate_Rule rule){
    return(string_list_flatten(arena, string, 0, SCu32(), 0, rule));
}
static String_Const_char
string_list_flatten(Arena *arena, List_String_Const_char string){
    return(string_list_flatten(arena, string, 0, SCchar(), 0, StringFill_NoTerminate));
}
static String_Const_u8
string_list_flatten(Arena *arena, List_String_Const_u8 string){
    return(string_list_flatten(arena, string, 0, SCu8(), 0, StringFill_NoTerminate));
}
static String_Const_u16
string_list_flatten(Arena *arena, List_String_Const_u16 string){
    return(string_list_flatten(arena, string, 0, SCu16(), 0, StringFill_NoTerminate));
}
static String_Const_u32
string_list_flatten(Arena *arena, List_String_Const_u32 string){
    return(string_list_flatten(arena, string, 0, SCu32(), 0, StringFill_NoTerminate));
}

static List_String_Const_char
string_split(Arena *arena, String_Const_char string, char *split_characters, i32 split_character_count){
    List_String_Const_char list = {};
    for (;;){
        u64 i = string.size;
        String_Const_char prefix = string;
        for (i32 j = 0; j < split_character_count; j += 1){
            u64 pos = string_find_first(prefix, split_characters[j]);
            prefix = string_prefix(prefix, pos);
            i = (((i)<(pos))?(i):(pos));
        }
        if (prefix.size > 0){
            string_list_push(arena, &list, prefix);
        }
        string = string_skip(string, i + 1);
        if (string.size == 0){
            break;
        }
    }
    return(list);
}
static List_String_Const_u8
string_split(Arena *arena, String_Const_u8 string, u8 *split_characters, i32 split_character_count){
    List_String_Const_u8 list = {};
    for (;;){
        u64 i = string.size;
        String_Const_u8 prefix = string;
        for (i32 j = 0; j < split_character_count; j += 1){
            u64 pos = string_find_first(prefix, split_characters[j]);
            prefix = string_prefix(prefix, pos);
            i = (((i)<(pos))?(i):(pos));
        }
        if (prefix.size > 0){
            string_list_push(arena, &list, prefix);
        }
        string = string_skip(string, i + 1);
        if (string.size == 0){
            break;
        }
    }
    return(list);
}
static List_String_Const_u16
string_split(Arena *arena, String_Const_u16 string, u16 *split_characters, i32 split_character_count){
    List_String_Const_u16 list = {};
    for (;;){
        u64 i = string.size;
        String_Const_u16 prefix = string;
        for (i32 j = 0; j < split_character_count; j += 1){
            u64 pos = string_find_first(prefix, split_characters[j]);
            prefix = string_prefix(prefix, pos);
            i = (((i)<(pos))?(i):(pos));
        }
        if (prefix.size > 0){
            string_list_push(arena, &list, prefix);
        }
        string = string_skip(string, i + 1);
        if (string.size == 0){
            break;
        }
    }
    return(list);
}
static List_String_Const_u32
string_split(Arena *arena, String_Const_u32 string, u32 *split_characters, i32 split_character_count){
    List_String_Const_u32 list = {};
    for (;;){
        u64 i = string.size;
        String_Const_u32 prefix = string;
        for (i32 j = 0; j < split_character_count; j += 1){
            u64 pos = string_find_first(prefix, split_characters[j]);
            prefix = string_prefix(prefix, pos);
            i = (((i)<(pos))?(i):(pos));
        }
        if (prefix.size > 0){
            string_list_push(arena, &list, prefix);
        }
        string = string_skip(string, i + 1);
        if (string.size == 0){
            break;
        }
    }
    return(list);
}

static List_String_Const_char
string_split_needle(Arena *arena, String_Const_char string, String_Const_char needle){
    List_String_Const_char list = {};
    for (;string.size > 0;){
        u64 pos = string_find_first(string, needle);
        String_Const_char prefix = string_prefix(string, pos);
        if (pos < string.size){
            string_list_push(arena, &list, needle);
        }
        if (prefix.size > 0){
            string_list_push(arena, &list, prefix);
        }
        string = string_skip(string, prefix.size + needle.size);
    }
    return(list);
}
static List_String_Const_u8
string_split_needle(Arena *arena, String_Const_u8 string, String_Const_u8 needle){
    List_String_Const_u8 list = {};
    for (;string.size > 0;){
        u64 pos = string_find_first(string, needle);
        String_Const_u8 prefix = string_prefix(string, pos);
        if (pos < string.size){
            string_list_push(arena, &list, needle);
        }
        if (prefix.size > 0){
            string_list_push(arena, &list, prefix);
        }
        string = string_skip(string, prefix.size + needle.size);
    }
    return(list);
}
static List_String_Const_u16
string_split_needle(Arena *arena, String_Const_u16 string, String_Const_u16 needle){
    List_String_Const_u16 list = {};
    for (;string.size > 0;){
        u64 pos = string_find_first(string, needle);
        String_Const_u16 prefix = string_prefix(string, pos);
        if (pos < string.size){
            string_list_push(arena, &list, needle);
        }
        if (prefix.size > 0){
            string_list_push(arena, &list, prefix);
        }
        string = string_skip(string, prefix.size + needle.size);
    }
    return(list);
}
static List_String_Const_u32
string_split_needle(Arena *arena, String_Const_u32 string, String_Const_u32 needle){
    List_String_Const_u32 list = {};
    for (;string.size > 0;){
        u64 pos = string_find_first(string, needle);
        String_Const_u32 prefix = string_prefix(string, pos);
        if (pos < string.size){
            string_list_push(arena, &list, needle);
        }
        if (prefix.size > 0){
            string_list_push(arena, &list, prefix);
        }
        string = string_skip(string, prefix.size + needle.size);
    }
    return(list);
}

static void
string_list_insert_separators(Arena *arena, List_String_Const_char *list, String_Const_char separator, String_Separator_Flag flags){
    Node_String_Const_char *last = list->last;
    for (Node_String_Const_char *node = list->first, *next = 0;
         node != last;
         node = next){
        next = node->next;
        Node_String_Const_char *new_node = ((Node_String_Const_char*)linalloc_wrap_unintialized(linalloc_push((arena), sizeof(Node_String_Const_char)*(1), SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_base_types.cpp" ":" "6011" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_base_types.cpp" ":" "6011" ":") - 1)))));
        node->next = new_node;
        new_node->next = next;
        new_node->string = separator;
        list->node_count += 1;
        list->total_size += separator.size;
    }
    if ((((flags)&(StringSeparator_BeforeFirst))!=0)){
        Node_String_Const_char *new_node = ((Node_String_Const_char*)linalloc_wrap_unintialized(linalloc_push((arena), sizeof(Node_String_Const_char)*(1), SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_base_types.cpp" ":" "6019" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_base_types.cpp" ":" "6019" ":") - 1)))));
        new_node->next = list->first;
        list->first = new_node;
        new_node->string = separator;
        list->node_count += 1;
        list->total_size += separator.size;
    }
    if ((((flags)&(StringSeparator_AfterLast))!=0)){
        Node_String_Const_char *new_node = ((Node_String_Const_char*)linalloc_wrap_unintialized(linalloc_push((arena), sizeof(Node_String_Const_char)*(1), SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_base_types.cpp" ":" "6027" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_base_types.cpp" ":" "6027" ":") - 1)))));
        list->last->next = new_node;
        list->last = new_node;
        new_node->next = 0;
        new_node->string = separator;
        list->node_count += 1;
        list->total_size += separator.size;
    }
}
static void
string_list_insert_separators(Arena *arena, List_String_Const_u8 *list, String_Const_u8 separator, String_Separator_Flag flags){
    Node_String_Const_u8 *last = list->last;
    for (Node_String_Const_u8 *node = list->first, *next = 0;
         node != last;
         node = next){
        next = node->next;
        Node_String_Const_u8 *new_node = ((Node_String_Const_u8*)linalloc_wrap_unintialized(linalloc_push((arena), sizeof(Node_String_Const_u8)*(1), SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_base_types.cpp" ":" "6043" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_base_types.cpp" ":" "6043" ":") - 1)))));
        node->next = new_node;
        new_node->next = next;
        new_node->string = separator;
        list->node_count += 1;
        list->total_size += separator.size;
    }
    if ((((flags)&(StringSeparator_BeforeFirst))!=0)){
        Node_String_Const_u8 *new_node = ((Node_String_Const_u8*)linalloc_wrap_unintialized(linalloc_push((arena), sizeof(Node_String_Const_u8)*(1), SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_base_types.cpp" ":" "6051" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_base_types.cpp" ":" "6051" ":") - 1)))));
        new_node->next = list->first;
        list->first = new_node;
        new_node->string = separator;
        list->node_count += 1;
        list->total_size += separator.size;
    }
    if ((((flags)&(StringSeparator_AfterLast))!=0)){
        Node_String_Const_u8 *new_node = ((Node_String_Const_u8*)linalloc_wrap_unintialized(linalloc_push((arena), sizeof(Node_String_Const_u8)*(1), SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_base_types.cpp" ":" "6059" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_base_types.cpp" ":" "6059" ":") - 1)))));
        list->last->next = new_node;
        list->last = new_node;
        new_node->next = 0;
        new_node->string = separator;
        list->node_count += 1;
        list->total_size += separator.size;
    }
}
static void
string_list_insert_separators(Arena *arena, List_String_Const_u16 *list, String_Const_u16 separator, String_Separator_Flag flags){
    Node_String_Const_u16 *last = list->last;
    for (Node_String_Const_u16 *node = list->first, *next = 0;
         node != last;
         node = next){
        next = node->next;
        Node_String_Const_u16 *new_node = ((Node_String_Const_u16*)linalloc_wrap_unintialized(linalloc_push((arena), sizeof(Node_String_Const_u16)*(1), SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_base_types.cpp" ":" "6075" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_base_types.cpp" ":" "6075" ":") - 1)))));
        node->next = new_node;
        new_node->next = next;
        new_node->string = separator;
        list->node_count += 1;
        list->total_size += separator.size;
    }
    if ((((flags)&(StringSeparator_BeforeFirst))!=0)){
        Node_String_Const_u16 *new_node = ((Node_String_Const_u16*)linalloc_wrap_unintialized(linalloc_push((arena), sizeof(Node_String_Const_u16)*(1), SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_base_types.cpp" ":" "6083" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_base_types.cpp" ":" "6083" ":") - 1)))));
        new_node->next = list->first;
        list->first = new_node;
        new_node->string = separator;
        list->node_count += 1;
        list->total_size += separator.size;
    }
    if ((((flags)&(StringSeparator_AfterLast))!=0)){
        Node_String_Const_u16 *new_node = ((Node_String_Const_u16*)linalloc_wrap_unintialized(linalloc_push((arena), sizeof(Node_String_Const_u16)*(1), SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_base_types.cpp" ":" "6091" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_base_types.cpp" ":" "6091" ":") - 1)))));
        list->last->next = new_node;
        list->last = new_node;
        new_node->next = 0;
        new_node->string = separator;
        list->node_count += 1;
        list->total_size += separator.size;
    }
}
static void
string_list_insert_separators(Arena *arena, List_String_Const_u32 *list, String_Const_u32 separator, String_Separator_Flag flags){
    Node_String_Const_u32 *last = list->last;
    for (Node_String_Const_u32 *node = list->first, *next = 0;
         node != last;
         node = next){
        next = node->next;
        Node_String_Const_u32 *new_node = ((Node_String_Const_u32*)linalloc_wrap_unintialized(linalloc_push((arena), sizeof(Node_String_Const_u32)*(1), SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_base_types.cpp" ":" "6107" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_base_types.cpp" ":" "6107" ":") - 1)))));
        node->next = new_node;
        new_node->next = next;
        new_node->string = separator;
        list->node_count += 1;
        list->total_size += separator.size;
    }
    if ((((flags)&(StringSeparator_BeforeFirst))!=0)){
        Node_String_Const_u32 *new_node = ((Node_String_Const_u32*)linalloc_wrap_unintialized(linalloc_push((arena), sizeof(Node_String_Const_u32)*(1), SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_base_types.cpp" ":" "6115" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_base_types.cpp" ":" "6115" ":") - 1)))));
        new_node->next = list->first;
        list->first = new_node;
        new_node->string = separator;
        list->node_count += 1;
        list->total_size += separator.size;
    }
    if ((((flags)&(StringSeparator_AfterLast))!=0)){
        Node_String_Const_u32 *new_node = ((Node_String_Const_u32*)linalloc_wrap_unintialized(linalloc_push((arena), sizeof(Node_String_Const_u32)*(1), SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_base_types.cpp" ":" "6123" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_base_types.cpp" ":" "6123" ":") - 1)))));
        list->last->next = new_node;
        list->last = new_node;
        new_node->next = 0;
        new_node->string = separator;
        list->node_count += 1;
        list->total_size += separator.size;
    }
}

static void
string_list_rewrite_nodes(Arena *arena, List_String_Const_char *list, String_Const_char needle, String_Const_char new_value){
    for (Node_String_Const_char *node = list->first;
         node != 0;
         node = node->next){
        if (string_match(node->string, needle)){
            node->string = new_value;
            list->total_size += new_value.size;
            list->total_size -= needle.size;
        }
    }
}
static void
string_list_rewrite_nodes(Arena *arena, List_String_Const_u8 *list, String_Const_u8 needle, String_Const_u8 new_value){
    for (Node_String_Const_u8 *node = list->first;
         node != 0;
         node = node->next){
        if (string_match(node->string, needle)){
            node->string = new_value;
            list->total_size += new_value.size;
            list->total_size -= needle.size;
        }
    }
}
static void
string_list_rewrite_nodes(Arena *arena, List_String_Const_u16 *list, String_Const_u16 needle, String_Const_u16 new_value){
    for (Node_String_Const_u16 *node = list->first;
         node != 0;
         node = node->next){
        if (string_match(node->string, needle)){
            node->string = new_value;
            list->total_size += new_value.size;
            list->total_size -= needle.size;
        }
    }
}
static void
string_list_rewrite_nodes(Arena *arena, List_String_Const_u32 *list, String_Const_u32 needle, String_Const_u32 new_value){
    for (Node_String_Const_u32 *node = list->first;
         node != 0;
         node = node->next){
        if (string_match(node->string, needle)){
            node->string = new_value;
            list->total_size += new_value.size;
            list->total_size -= needle.size;
        }
    }
}

static String_Const_char
string_condense_whitespace(Arena *arena, String_Const_char string){
    char split_characters[] = { ' ', '\t', '\n', '\r', '\f', '\v', };
    List_String_Const_char list = string_split(arena, string, split_characters, ((sizeof(split_characters))/(sizeof(*split_characters))));
    string_list_insert_separators(arena, &list, SCchar(split_characters, 1), StringSeparator_NoFlags);
    return(string_list_flatten(arena, list, StringFill_NullTerminate));
}
static String_Const_u8
string_condense_whitespace(Arena *arena, String_Const_u8 string){
    u8 split_characters[] = { ' ', '\t', '\n', '\r', '\f', '\v', };
    List_String_Const_u8 list = string_split(arena, string, split_characters, ((sizeof(split_characters))/(sizeof(*split_characters))));
    string_list_insert_separators(arena, &list, SCu8(split_characters, 1), StringSeparator_NoFlags);
    return(string_list_flatten(arena, list, StringFill_NullTerminate));
}
static String_Const_u16
string_condense_whitespace(Arena *arena, String_Const_u16 string){
    u16 split_characters[] = { ' ', '\t', '\n', '\r', '\f', '\v', };
    List_String_Const_u16 list = string_split(arena, string, split_characters, ((sizeof(split_characters))/(sizeof(*split_characters))));
    string_list_insert_separators(arena, &list, SCu16(split_characters, 1), StringSeparator_NoFlags);
    return(string_list_flatten(arena, list, StringFill_NullTerminate));
}
static String_Const_u32
string_condense_whitespace(Arena *arena, String_Const_u32 string){
    u32 split_characters[] = { ' ', '\t', '\n', '\r', '\f', '\v', };
    List_String_Const_u32 list = string_split(arena, string, split_characters, ((sizeof(split_characters))/(sizeof(*split_characters))));
    string_list_insert_separators(arena, &list, SCu32(split_characters, 1), StringSeparator_NoFlags);
    return(string_list_flatten(arena, list, StringFill_NullTerminate));
}

static List_String_Const_u8
string_split_wildcards(Arena *arena, String_Const_u8 string){
    List_String_Const_u8 list = {};
    if (string_get_character(string, 0) == '*'){
        string_list_push(arena, &list, SCu8());
    }
    {
        List_String_Const_u8 splits = string_split(arena, string, (u8*)"*", 1);
        string_list_push(&list, &splits);
    }
    if (string.size > 1 && string_get_character(string, string.size - 1) == '*'){
        string_list_push(arena, &list, SCu8());
    }
    return(list);
}

static b32
string_wildcard_match(List_String_Const_u8 list, String_Const_u8 string, String_Match_Rule rule){
    b32 success = true;
    if (list.node_count > 0){
        String_Const_u8 head = list.first->string;
        if (!string_match(head, string_prefix(string, head.size), rule)){
            success = false;
        }
        else if (list.node_count > 1){
            string = string_skip(string, head.size);
            String_Const_u8 tail = list.last->string;
            if (!string_match(tail, string_postfix(string, tail.size), rule)){
                success = false;
            }
            else if (list.node_count > 2){
                string = string_chop(string, tail.size);
                Node_String_Const_u8 *one_past_last = list.last;
                for (Node_String_Const_u8 *node = list.first->next;
                     node != one_past_last;
                     node = node->next){
                    u64 position = string_find_first(string, node->string, rule);
                    if (position < string.size){
                        string = string_skip(string, position + node->string.size);
                    }
                    else{
                        success = false;
                        break;
                    }
                }
            }
        }
    }
    return(success);
}

static b32
string_wildcard_match(List_String_Const_u8 list, String_Const_u8 string){
    return(string_wildcard_match(list, string, StringMatch_Exact));
}
static b32
string_wildcard_match_insensitive(List_String_Const_u8 list, String_Const_u8 string){
    return(string_wildcard_match(list, string, StringMatch_CaseInsensitive));
}

static void
string_list_reverse(List_String_Const_char *list){
    Node_String_Const_char *first = 0;
    Node_String_Const_char *last = list->first;
    for (Node_String_Const_char *node = list->first, *next = 0;
         node != 0;
         node = next){
        next = node->next;
        ((node)->next=(first),(first)=(node));
    }
    list->first = first;
    list->last = last;
}
static void
string_list_reverse(List_String_Const_u8 *list){
    Node_String_Const_u8 *first = 0;
    Node_String_Const_u8 *last = list->first;
    for (Node_String_Const_u8 *node = list->first, *next = 0;
         node != 0;
         node = next){
        next = node->next;
        ((node)->next=(first),(first)=(node));
    }
    list->first = first;
    list->last = last;
}
static void
string_list_reverse(List_String_Const_u16 *list){
    Node_String_Const_u16 *first = 0;
    Node_String_Const_u16 *last = list->first;
    for (Node_String_Const_u16 *node = list->first, *next = 0;
         node != 0;
         node = next){
        next = node->next;
        ((node)->next=(first),(first)=(node));
    }
    list->first = first;
    list->last = last;
}
static void
string_list_reverse(List_String_Const_u32 *list){
    Node_String_Const_u32 *first = 0;
    Node_String_Const_u32 *last = list->first;
    for (Node_String_Const_u32 *node = list->first, *next = 0;
         node != 0;
         node = next){
        next = node->next;
        ((node)->next=(first),(first)=(node));
    }
    list->first = first;
    list->last = last;
}

static b32
string_list_match(List_String_Const_u8 a, List_String_Const_u8 b){
    b32 result = true;
    for (Node_String_Const_u8 *a_node = a.first, *b_node = b.first;
         a_node != 0 && b_node != 0;
         a_node = a_node->next, b_node = b_node->next){
        if (!string_match(a_node->string, b_node->string)){
            result = false;
            break;
        }
    }
    return(result);
}



static const u8 utf8_class[32] = {
    1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,2,2,2,2,3,3,4,5,
};

static Character_Consume_Result
utf8_consume(u8 *str, u64 max){
    Character_Consume_Result result = {1, max_u32};
    u8 byte = str[0];
    u8 byte_class = utf8_class[byte >> 3];
    switch (byte_class){
        case 1:
        {
            result.codepoint = byte;
        }break;
        case 2:
        {
            if (1 < max){
                u8 cont_byte = str[1];
                if (utf8_class[cont_byte >> 3] == 0){
                    result.codepoint = (byte & bitmask_5) << 6;
                    result.codepoint |= (cont_byte & bitmask_6);
                    result.inc = 2;
                }
            }
        }break;
        case 3:
        {
            if (2 < max){
                u8 cont_byte[2] = {str[1], str[2]};
                if (utf8_class[cont_byte[0] >> 3] == 0 &&
                    utf8_class[cont_byte[1] >> 3] == 0){
                    result.codepoint = (byte & bitmask_4) << 12;
                    result.codepoint |= ((cont_byte[0] & bitmask_6) << 6);
                    result.codepoint |= (cont_byte[1] & bitmask_6);
                    result.inc = 3;
                }
            }
        }break;
        case 4:
        {
            if (3 < max){
                u8 cont_byte[3] = {str[1], str[2], str[3]};
                if (utf8_class[cont_byte[0] >> 3] == 0 &&
                    utf8_class[cont_byte[1] >> 3] == 0 &&
                    utf8_class[cont_byte[2] >> 3] == 0){
                    result.codepoint = (byte & bitmask_3) << 18;
                    result.codepoint |= ((cont_byte[0] & bitmask_6) << 12);
                    result.codepoint |= ((cont_byte[1] & bitmask_6) << 6);
                    result.codepoint |= (cont_byte[2] & bitmask_6);
                    result.inc = 4;
                }
            }
        }break;
    }
    return(result);
}

static Character_Consume_Result
utf16_consume(u16 *str, u64 max){
    Character_Consume_Result result = {1, max_u32};
    result.codepoint = str[0];
    result.inc = 1;
    if (0xD800 <= str[0] && str[0] < 0xDC00 && max > 1 && 0xDC00 <= str[1] && str[1] < 0xE000){
        result.codepoint = ((str[0] - 0xD800) << 10) | (str[1] - 0xDC00);
        result.inc = 2;
    }
    return(result);
}

static u32
utf8_write(u8 *str, u32 codepoint){
    u32 inc = 0;
    if (codepoint <= 0x7F){
        str[0] = (u8)codepoint;
        inc = 1;
    }
    else if (codepoint <= 0x7FF){
        str[0] = (bitmask_2 << 6) | ((codepoint >> 6) & bitmask_5);
        str[1] = bit_8 | (codepoint & bitmask_6);
        inc = 2;
    }
    else if (codepoint <= 0xFFFF){
        str[0] = (bitmask_3 << 5) | ((codepoint >> 12) & bitmask_4);
        str[1] = bit_8 | ((codepoint >> 6) & bitmask_6);
        str[2] = bit_8 | ( codepoint & bitmask_6);
        inc = 3;
    }
    else if (codepoint <= 0x10FFFF){
        str[0] = (bitmask_4 << 3) | ((codepoint >> 18) & bitmask_3);
        str[1] = bit_8 | ((codepoint >> 12) & bitmask_6);
        str[2] = bit_8 | ((codepoint >> 6) & bitmask_6);
        str[3] = bit_8 | ( codepoint & bitmask_6);
        inc = 4;
    }
    else{
        str[0] = '?';
        inc = 1;
    }
    return(inc);
}

static u32
utf16_write(u16 *str, u32 codepoint){
    u32 inc = 1;
    if (codepoint == max_u32){
        str[0] = (u16)'?';
    }
    else if (codepoint < 0x10000){
        str[0] = (u16)codepoint;
    }
    else{
        u32 v = codepoint - 0x10000;
        str[0] = 0xD800 + (u16)(v >> 10);
        str[1] = 0xDC00 + (v & bitmask_10);
        inc = 2;
    }
    return(inc);
}



static String_u8
string_u8_from_string_char(Arena *arena, String_Const_char string, String_Fill_Terminate_Rule rule){
    String_u8 out = {};
    out.cap = string.size;
    if (rule == StringFill_NullTerminate){
        out.cap += 1;
    }
    out.str = ((u8*)linalloc_wrap_unintialized(linalloc_push((arena), sizeof(u8)*(out.cap), SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_base_types.cpp" ":" "6468" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_base_types.cpp" ":" "6468" ":") - 1)))));
    for (u64 i = 0; i < string.size; i += 1){
        out.str[i] = ((u8)string.str[i])&bitmask_7;
    }
    out.size = string.size;
    if (rule == StringFill_NullTerminate){
        string_null_terminate(&out);
    }
    return(out);
}

static String_u16
string_u16_from_string_char(Arena *arena, String_Const_char string, String_Fill_Terminate_Rule rule){
    String_u16 out = {};
    out.cap = string.size;
    if (rule == StringFill_NullTerminate){
        out.cap += 1;
    }
    out.str = ((u16*)linalloc_wrap_unintialized(linalloc_push((arena), sizeof(u16)*(out.cap), SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_base_types.cpp" ":" "6486" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_base_types.cpp" ":" "6486" ":") - 1)))));
    for (u64 i = 0; i < string.size; i += 1){
        out.str[i] = ((u16)string.str[i])&bitmask_7;
    }
    out.size = string.size;
    if (rule == StringFill_NullTerminate){
        string_null_terminate(&out);
    }
    return(out);
}

static String_u32
string_u32_from_string_char(Arena *arena, String_Const_char string, String_Fill_Terminate_Rule rule){
    String_u32 out = {};
    out.cap = string.size;
    if (rule == StringFill_NullTerminate){
        out.cap += 1;
    }
    out.str = ((u32*)linalloc_wrap_unintialized(linalloc_push((arena), sizeof(u32)*(string.size), SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_base_types.cpp" ":" "6504" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_base_types.cpp" ":" "6504" ":") - 1)))));
    for (u64 i = 0; i < string.size; i += 1){
        out.str[i] = ((u32)string.str[i])&bitmask_7;
    }
    out.size = string.size;
    if (rule == StringFill_NullTerminate){
        string_null_terminate(&out);
    }
    return(out);
}

static String_char
string_char_from_string_u8(Arena *arena, String_Const_u8 string, String_Fill_Terminate_Rule rule){
    String_char out = {};
    out.cap = string.size;
    if (rule == StringFill_NullTerminate){
        out.cap += 1;
    }
    out.str = ((char*)linalloc_wrap_unintialized(linalloc_push((arena), sizeof(char)*(out.cap), SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_base_types.cpp" ":" "6522" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_base_types.cpp" ":" "6522" ":") - 1)))));
    u8 *ptr = string.str;
    u8 *one_past_last = ptr + string.size;
    u64 cap = string.size;
    Character_Consume_Result consume;
    for (;ptr < one_past_last; ptr += consume.inc, cap -= consume.inc){
        consume = utf8_consume(ptr, cap);
        out.str[out.size++] = (consume.codepoint <= 127)?((char)consume.codepoint):('?');
    }
    if (rule == StringFill_NullTerminate){
        string_null_terminate(&out);
    }
    return(out);
}

static String_u16
string_u16_from_string_u8(Arena *arena, String_Const_u8 string, String_Fill_Terminate_Rule rule){
    String_u16 out = {};
    out.cap = string.size;
    if (rule == StringFill_NullTerminate){
        out.cap += 1;
    }
    out.str = ((u16*)linalloc_wrap_unintialized(linalloc_push((arena), sizeof(u16)*(out.cap), SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_base_types.cpp" ":" "6544" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_base_types.cpp" ":" "6544" ":") - 1)))));
    u8 *ptr = string.str;
    u8 *one_past_last = ptr + string.size;
    u64 cap = string.size;
    Character_Consume_Result consume;
    for (;ptr < one_past_last; ptr += consume.inc, cap -= consume.inc){
        consume = utf8_consume(ptr, cap);
        out.size += utf16_write(out.str + out.size, consume.codepoint);
    }
    if (rule == StringFill_NullTerminate){
        string_null_terminate(&out);
    }
    return(out);
}

static String_u32
string_u32_from_string_u8(Arena *arena, String_Const_u8 string, String_Fill_Terminate_Rule rule){
    String_u32 out = {};
    out.cap = string.size;
    if (rule == StringFill_NullTerminate){
        out.cap += 1;
    }
    out.str = ((u32*)linalloc_wrap_unintialized(linalloc_push((arena), sizeof(u32)*(out.cap), SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_base_types.cpp" ":" "6566" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_base_types.cpp" ":" "6566" ":") - 1)))));
    u8 *ptr = string.str;
    u8 *one_past_last = ptr + string.size;
    u64 cap = string.size;
    Character_Consume_Result consume;
    for (;ptr < one_past_last; ptr += consume.inc, cap -= consume.inc){
        consume = utf8_consume(ptr, cap);
        out.str[out.size++] = (consume.codepoint == max_u32)?(u64)'?':(consume.codepoint);
    }
    if (rule == StringFill_NullTerminate){
        string_null_terminate(&out);
    }
    return(out);
}

static String_char
string_char_from_string_u16(Arena *arena, String_Const_u16 string, String_Fill_Terminate_Rule rule){
    String_char out = {};
    out.cap = string.size;
    if (rule == StringFill_NullTerminate){
        out.cap += 1;
    }
    out.str = ((char*)linalloc_wrap_unintialized(linalloc_push((arena), sizeof(char)*(out.cap), SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_base_types.cpp" ":" "6588" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_base_types.cpp" ":" "6588" ":") - 1)))));
    u16 *ptr = string.str;
    u16 *one_past_last = ptr + string.size;
    u64 cap = string.size;
    Character_Consume_Result consume;
    for (;ptr < one_past_last; ptr += consume.inc, cap -= consume.inc){
        consume = utf16_consume(ptr, cap);
        out.str[out.size++] = (consume.codepoint <= 127)?((char)consume.codepoint):('?');
    }
    if (rule == StringFill_NullTerminate){
        string_null_terminate(&out);
    }
    return(out);
}

static String_u8
string_u8_from_string_u16(Arena *arena, String_Const_u16 string, String_Fill_Terminate_Rule rule){
    String_u8 out = {};
    out.cap = string.size*3;
    if (rule == StringFill_NullTerminate){
        out.cap += 1;
    }
    out.str = ((u8*)linalloc_wrap_unintialized(linalloc_push((arena), sizeof(u8)*(out.cap), SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_base_types.cpp" ":" "6610" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_base_types.cpp" ":" "6610" ":") - 1)))));
    u16 *ptr = string.str;
    u16 *one_past_last = ptr + string.size;
    u64 cap = string.size;
    Character_Consume_Result consume;
    for (;ptr < one_past_last; ptr += consume.inc, cap -= consume.inc){
        consume = utf16_consume(ptr, cap);
        out.size += utf8_write(out.str + out.size, consume.codepoint);
    }
    if (rule == StringFill_NullTerminate){
        string_null_terminate(&out);
    }
    return(out);
}

static String_u32
string_u32_from_string_u16(Arena *arena, String_Const_u16 string, String_Fill_Terminate_Rule rule){
    String_u32 out = {};
    out.cap = string.size;
    if (rule == StringFill_NullTerminate){
        out.cap += 1;
    }
    out.str = ((u32*)linalloc_wrap_unintialized(linalloc_push((arena), sizeof(u32)*(out.cap), SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_base_types.cpp" ":" "6632" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_base_types.cpp" ":" "6632" ":") - 1)))));
    u16 *ptr = string.str;
    u16 *one_past_last = ptr + string.size;
    u64 cap = string.size;
    Character_Consume_Result consume;
    for (;ptr < one_past_last; ptr += consume.inc, cap -= consume.inc){
        consume = utf16_consume(ptr, cap);
        out.str[out.size++] = consume.codepoint;
    }
    if (rule == StringFill_NullTerminate){
        string_null_terminate(&out);
    }
    return(out);
}

static String_char
string_char_from_string_u32(Arena *arena, String_Const_u32 string, String_Fill_Terminate_Rule rule){
    String_char out = {};
    out.cap = string.size;
    if (rule == StringFill_NullTerminate){
        out.cap += 1;
    }
    out.str = ((char*)linalloc_wrap_unintialized(linalloc_push((arena), sizeof(char)*(string.size), SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_base_types.cpp" ":" "6654" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_base_types.cpp" ":" "6654" ":") - 1)))));
    u32 *ptr = string.str;
    u32 *one_past_last = ptr + string.size;
    for (;ptr < one_past_last; ptr += 1){
        u32 codepoint = *ptr;
        out.str[out.size++] = (codepoint <= 127)?((char)codepoint):('?');
    }
    if (rule == StringFill_NullTerminate){
        string_null_terminate(&out);
    }
    return(out);
}

static String_u8
string_u8_from_string_u32(Arena *arena, String_Const_u32 string, String_Fill_Terminate_Rule rule){
    String_u8 out = {};
    out.cap = string.size*4;
    if (rule == StringFill_NullTerminate){
        out.cap += 1;
    }
    out.str = ((u8*)linalloc_wrap_unintialized(linalloc_push((arena), sizeof(u8)*(out.cap), SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_base_types.cpp" ":" "6674" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_base_types.cpp" ":" "6674" ":") - 1)))));
    u32 *ptr = string.str;
    u32 *one_past_last = ptr + string.size;
    for (;ptr < one_past_last; ptr += 1){
        out.size += utf8_write(out.str + out.size, *ptr);
    }
    if (rule == StringFill_NullTerminate){
        string_null_terminate(&out);
    }
    return(out);
}

static String_u16
string_u16_from_string_u32(Arena *arena, String_Const_u32 string, String_Fill_Terminate_Rule rule){
    String_u16 out = {};
    out.cap = string.size*2;
    if (rule == StringFill_NullTerminate){
        out.cap += 1;
    }
    out.str = ((u16*)linalloc_wrap_unintialized(linalloc_push((arena), sizeof(u16)*(out.cap), SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_base_types.cpp" ":" "6693" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_base_types.cpp" ":" "6693" ":") - 1)))));
    u32 *ptr = string.str;
    u32 *one_past_last = ptr + string.size;
    for (;ptr < one_past_last; ptr += 1){
        out.size += utf16_write(out.str + out.size, *ptr);
    }
    if (rule == StringFill_NullTerminate){
        string_null_terminate(&out);
    }
    return(out);
}



static String_char
string_char_from_string_u8(Arena *arena, String_Const_u8 string){
    return(string_char_from_string_u8(arena, string, StringFill_NullTerminate));
}
static String_char
string_char_from_string_u16(Arena *arena, String_Const_u16 string){
    return(string_char_from_string_u16(arena, string, StringFill_NullTerminate));
}
static String_char
string_char_from_string_u32(Arena *arena, String_Const_u32 string){
    return(string_char_from_string_u32(arena, string, StringFill_NullTerminate));
}
static String_u8
string_u8_from_string_char(Arena *arena, String_Const_char string){
    return(string_u8_from_string_char(arena, string, StringFill_NullTerminate));
}
static String_u8
string_u8_from_string_u16(Arena *arena, String_Const_u16 string){
    return(string_u8_from_string_u16(arena, string, StringFill_NullTerminate));
}
static String_u8
string_u8_from_string_u32(Arena *arena, String_Const_u32 string){
    return(string_u8_from_string_u32(arena, string, StringFill_NullTerminate));
}
static String_u16
string_u16_from_string_char(Arena *arena, String_Const_char string){
    return(string_u16_from_string_char(arena, string, StringFill_NullTerminate));
}
static String_u16
string_u16_from_string_u8(Arena *arena, String_Const_u8 string){
    return(string_u16_from_string_u8(arena, string, StringFill_NullTerminate));
}
static String_u16
string_u16_from_string_u32(Arena *arena, String_Const_u32 string){
    return(string_u16_from_string_u32(arena, string, StringFill_NullTerminate));
}
static String_u32
string_u32_from_string_char(Arena *arena, String_Const_char string){
    return(string_u32_from_string_char(arena, string, StringFill_NullTerminate));
}
static String_u32
string_u32_from_string_u8(Arena *arena, String_Const_u8 string){
    return(string_u32_from_string_u8(arena, string, StringFill_NullTerminate));
}
static String_u32
string_u32_from_string_u16(Arena *arena, String_Const_u16 string){
    return(string_u32_from_string_u16(arena, string, StringFill_NullTerminate));
}



static String_Const_char
string_char_from_any(Arena *arena, String_Const_Any string){
    String_Const_char result = {};
    switch (string.encoding){
        case StringEncoding_ASCII: result = string.s_char; break;
        case StringEncoding_UTF8: result = string_char_from_string_u8 (arena, string.s_u8 ).string; break;
        case StringEncoding_UTF16: result = string_char_from_string_u16(arena, string.s_u16).string; break;
        case StringEncoding_UTF32: result = string_char_from_string_u32(arena, string.s_u32).string; break;
    }
    return(result);
}
static String_Const_u8
string_u8_from_any(Arena *arena, String_Const_Any string){
    String_Const_u8 result = {};
    switch (string.encoding){
        case StringEncoding_ASCII: result = string_u8_from_string_char(arena, string.s_char).string; break;
        case StringEncoding_UTF8: result = string.s_u8; break;
        case StringEncoding_UTF16: result = string_u8_from_string_u16(arena, string.s_u16).string; break;
        case StringEncoding_UTF32: result = string_u8_from_string_u32(arena, string.s_u32).string; break;
    }
    return(result);
}
static String_Const_u16
string_u16_from_any(Arena *arena, String_Const_Any string){
    String_Const_u16 result = {};
    switch (string.encoding){
        case StringEncoding_ASCII: result = string_u16_from_string_char(arena, string.s_char).string; break;
        case StringEncoding_UTF8: result = string_u16_from_string_u8 (arena, string.s_u8 ).string; break;
        case StringEncoding_UTF16: result = string.s_u16; break;
        case StringEncoding_UTF32: result = string_u16_from_string_u32(arena, string.s_u32).string; break;
    }
    return(result);
}
static String_Const_u32
string_u32_from_any(Arena *arena, String_Const_Any string){
    String_Const_u32 result = {};
    switch (string.encoding){
        case StringEncoding_ASCII: result = string_u32_from_string_char(arena, string.s_char).string; break;
        case StringEncoding_UTF8: result = string_u32_from_string_u8 (arena, string.s_u8 ).string; break;
        case StringEncoding_UTF16: result = string_u32_from_string_u16 (arena, string.s_u16 ).string; break;
        case StringEncoding_UTF32: result = string.s_u32; break;
    }
    return(result);
}

static String_Const_Any
string_any_from_any(Arena *arena, String_Encoding encoding, String_Const_Any string){
    String_Const_Any result = {encoding};
    switch (encoding){
        case StringEncoding_ASCII: result.s_char = string_char_from_any(arena, string); break;
        case StringEncoding_UTF8: result.s_u8 = string_u8_from_any (arena, string); break;
        case StringEncoding_UTF16: result.s_u16 = string_u16_from_any (arena, string); break;
        case StringEncoding_UTF32: result.s_u32 = string_u32_from_any (arena, string); break;
    }
    return(result);
}

static List_String_Const_char
string_list_char_from_any(Arena *arena, List_String_Const_Any list){
    List_String_Const_char result = {};
    for (Node_String_Const_Any *node = list.first;
         node != 0;
         node = node->next){
        string_list_push(arena, &result, string_char_from_any(arena, node->string));
    }
    return(result);
}
static List_String_Const_u8
string_list_u8_from_any(Arena *arena, List_String_Const_Any list){
    List_String_Const_u8 result = {};
    for (Node_String_Const_Any *node = list.first;
         node != 0;
         node = node->next){
        string_list_push(arena, &result, string_u8_from_any(arena, node->string));
    }
    return(result);
}
static List_String_Const_u16
string_list_u16_from_any(Arena *arena, List_String_Const_Any list){
    List_String_Const_u16 result = {};
    for (Node_String_Const_Any *node = list.first;
         node != 0;
         node = node->next){
        string_list_push(arena, &result, string_u16_from_any(arena, node->string));
    }
    return(result);
}
static List_String_Const_u32
string_list_u32_from_any(Arena *arena, List_String_Const_Any list){
    List_String_Const_u32 result = {};
    for (Node_String_Const_Any *node = list.first;
         node != 0;
         node = node->next){
        string_list_push(arena, &result, string_u32_from_any(arena, node->string));
    }
    return(result);
}



static Line_Ending_Kind
string_guess_line_ending_kind(String_Const_u8 string){
    b32 looks_like_binary = false;
    u64 crlf_count = 0;
    u64 lf_count = 0;
    for (u64 i = 0; i < string.size; i += 1){
        if (string.str[i] == 0){
            looks_like_binary = true;
            break;
        }
        if (string.str[i] == '\r' &&
            (i + 1 == string.size || string.str[i + 1] != '\n')){
            looks_like_binary = true;
            break;
        }
        if (string.str[i] == '\n'){
            if (i > 0 && string.str[i - 1] == '\r'){
                crlf_count += 1;
            }
            else{
                lf_count += 1;
            }
        }
    }
    Line_Ending_Kind kind = LineEndingKind_Binary;
    if (!looks_like_binary){
        if (crlf_count > lf_count){
            kind = LineEndingKind_CRLF;
        }
        else{
            kind = LineEndingKind_LF;
        }
    }
    return(kind);
}



static List_String_Const_char
string_replace_list(Arena *arena, String_Const_char source, String_Const_char needle, String_Const_char replacement){
    List_String_Const_char list = {};
    for (;;){
        u64 i = string_find_first(source, needle);
        string_list_push(arena, &list, string_prefix(source, i));
        if (i < source.size){
            string_list_push(arena, &list, replacement);
            source = string_skip(source, i + needle.size);
        }
        else{
            break;
        }
    }
    return(list);
}
static List_String_Const_u8
string_replace_list(Arena *arena, String_Const_u8 source, String_Const_u8 needle, String_Const_u8 replacement){
    List_String_Const_u8 list = {};
    for (;;){
        u64 i = string_find_first(source, needle);
        string_list_push(arena, &list, string_prefix(source, i));
        if (i < source.size){
            string_list_push(arena, &list, replacement);
            source = string_skip(source, i + needle.size);
        }
        else{
            break;
        }
    }
    return(list);
}
static List_String_Const_u16
string_replace_list(Arena *arena, String_Const_u16 source, String_Const_u16 needle, String_Const_u16 replacement){
    List_String_Const_u16 list = {};
    for (;;){
        u64 i = string_find_first(source, needle);
        string_list_push(arena, &list, string_prefix(source, i));
        if (i < source.size){
            string_list_push(arena, &list, replacement);
            source = string_skip(source, i + needle.size);
        }
        else{
            break;
        }
    }
    return(list);
}
static List_String_Const_u32
string_replace_list(Arena *arena, String_Const_u32 source, String_Const_u32 needle, String_Const_u32 replacement){
    List_String_Const_u32 list = {};
    for (;;){
        u64 i = string_find_first(source, needle);
        string_list_push(arena, &list, string_prefix(source, i));
        if (i < source.size){
            string_list_push(arena, &list, replacement);
            source = string_skip(source, i + needle.size);
        }
        else{
            break;
        }
    }
    return(list);
}

static String_Const_char
string_replace(Arena *arena, String_Const_char source, String_Const_char needle, String_Const_char replacement, String_Fill_Terminate_Rule rule){
    List_String_Const_char list = string_replace_list(arena, source, needle, replacement);
    return(string_list_flatten(arena, list, rule));
}
static String_Const_u8
string_replace(Arena *arena, String_Const_u8 source, String_Const_u8 needle, String_Const_u8 replacement, String_Fill_Terminate_Rule rule){
    List_String_Const_u8 list = string_replace_list(arena, source, needle, replacement);
    return(string_list_flatten(arena, list, rule));
}
static String_Const_u16
string_replace(Arena *arena, String_Const_u16 source, String_Const_u16 needle, String_Const_u16 replacement, String_Fill_Terminate_Rule rule){
    List_String_Const_u16 list = string_replace_list(arena, source, needle, replacement);
    return(string_list_flatten(arena, list, rule));
}
static String_Const_u32
string_replace(Arena *arena, String_Const_u32 source, String_Const_u32 needle, String_Const_u32 replacement, String_Fill_Terminate_Rule rule){
    List_String_Const_u32 list = string_replace_list(arena, source, needle, replacement);
    return(string_list_flatten(arena, list, rule));
}

static String_Const_char
string_replace(Arena *arena, String_Const_char source, String_Const_char needle, String_Const_char replacement){
    return(string_replace(arena, source, needle, replacement, StringFill_NullTerminate));
}
static String_Const_u8
string_replace(Arena *arena, String_Const_u8 source, String_Const_u8 needle, String_Const_u8 replacement){
    return(string_replace(arena, source, needle, replacement, StringFill_NullTerminate));
}
static String_Const_u16
string_replace(Arena *arena, String_Const_u16 source, String_Const_u16 needle, String_Const_u16 replacement){
    return(string_replace(arena, source, needle, replacement, StringFill_NullTerminate));
}
static String_Const_u32
string_replace(Arena *arena, String_Const_u32 source, String_Const_u32 needle, String_Const_u32 replacement){
    return(string_replace(arena, source, needle, replacement, StringFill_NullTerminate));
}



static b32
byte_is_ascii(u8 byte){
    return(byte == '\r' || byte == '\n' || byte == '\t' || (' ' <= byte && byte <= '~'));
}

static b32
data_is_ascii(Data data){
    u8 *ptr = (u8*)data.data;
    u8 *one_past_last = ptr + data.size;
    b32 result = true;
    for (;ptr < one_past_last; ptr += 1){
        if (!byte_is_ascii(*ptr) && !(*ptr == 0 && ptr + 1 == one_past_last)){
            result = false;
            break;
        }
    }
    return(result);
}



static String_Const_u8
string_escape(Arena *arena, String_Const_u8 string){
    List_String_Const_u8 list = string_replace_list(arena, string, SCu8((u8*)("\\"), (u64)(sizeof("\\") - 1)),
                                                    SCu8((u8*)("\\\\"), (u64)(sizeof("\\\\") - 1)));
    Node_String_Const_u8 **fixup_ptr = &list.first;
    for (Node_String_Const_u8 *node = list.first, *next = 0;
         node != 0;
         node = next){
        next = node->next;
        List_String_Const_u8 relist = string_replace_list(arena, node->string, SCu8((u8*)("\""), (u64)(sizeof("\"") - 1)),
                                                          SCu8((u8*)("\\\""), (u64)(sizeof("\\\"") - 1)));
        if (relist.first != 0){
            *fixup_ptr = relist.first;
            relist.last->next = next;
            fixup_ptr = &relist.last->next;
            list.last = relist.last;
        }
        else{
            *fixup_ptr = next;
        }
    }
    return(string_list_flatten(arena, list, StringFill_NullTerminate));
}

static String_Const_char
string_interpret_escapes(Arena *arena, String_Const_char string){
    char *space = ((char*)linalloc_wrap_unintialized(linalloc_push((arena), sizeof(char)*(string.size + 1), SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_base_types.cpp" ":" "7048" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_base_types.cpp" ":" "7048" ":") - 1)))));
    String_char result = Schar(space, 0, string.size);
    for (;;){
        u64 back_slash_pos = string_find_first(string, '\\');
        string_append(&result, string_prefix(string, back_slash_pos));
        string = string_skip(string, back_slash_pos + 1);
        if (string.size == 0){
            break;
        }
        switch (string.str[0]){
            case '\\':
            {
                string_append_character(&result, '\\');
            }break;

            case 'n':
            {
                string_append_character(&result, '\n');
            }break;

            case 't':
            {
                string_append_character(&result, '\t');
            }break;

            case '"':
            {
                string_append_character(&result, '\"');
            }break;

            case '0':
            {
                string_append_character(&result, '\0');
            }break;

            default:
            {
                char c[2] = {'\\'};
                c[1] = string.str[0];
                string_append(&result, SCchar(c, 2));
            }break;
        }
        string = string_skip(string, 1);
    }
    result.str[result.size] = 0;
    (linalloc_pop((arena), sizeof(char)*(result.cap - result.size)));
    return(result.string);
}

static String_Const_u8
string_interpret_escapes(Arena *arena, String_Const_u8 string){
    return(SCu8(string_interpret_escapes(arena, SCchar(string))));
}

static const u8 integer_symbols[] = {
    '0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F',
};

static const u8 integer_symbol_reverse[128] = {
    0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
    0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
    0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
    0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
    0xFF,0x0A,0x0B,0x0C,0x0D,0x0E,0x0F,0x10,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
    0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
    0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
    0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
};

static const u8 base64[64] = {
    '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',
    'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm',
    'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z',
    'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',
    'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',
    '_', '$',
};

static const u8 base64_reverse[128] = {
    0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
    0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
    0xFF,0xFF,0xFF,0xFF,0x3F,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
    0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,
    0xFF,0x24,0x25,0x26,0x27,0x28,0x29,0x2A,0x2B,0x2C,0x2D,0x2E,0x2F,0x30,0x31,0x32,
    0x33,0x34,0x35,0x36,0x37,0x38,0x39,0x3A,0x3B,0x3C,0x3D,0xFF,0xFF,0xFF,0xFF,0x3E,
    0xFF,0x0A,0x0B,0x0C,0x0D,0x0E,0x0F,0x10,0x11,0x12,0x13,0x14,0x15,0x16,0x17,0x18,
    0x19,0x1A,0x1B,0x1C,0x1D,0x1E,0x1F,0x20,0x21,0x22,0x23,0xFF,0xFF,0xFF,0xFF,0xFF,
};

static u64
digit_count_from_integer(u64 x, u32 radix){
    u64 result = 0;
    if (radix >= 2 && radix <= 16){
        if (x == 0){
            result = 1;
        }
        else{
            do{
                x /= radix;
                result += 1;
            } while(x > 0);
        }
    }
    return(result);
}

static String_Const_u8
string_from_integer(Arena *arena, u64 x, u32 radix){
    String_Const_u8 result = {};
    if (radix >= 2 && radix <= 16){
        if (x == 0){
            result = push_string_copy(arena, SCu8((u8*)("0"), (u64)(sizeof("0") - 1)));
        }
        else{
            u8 string_space[64];
            u64 length = 0;
            for (u64 X = x;
                 X > 0;
                 X /= radix, length += 1){
                string_space[length] = integer_symbols[X%radix];
            }
            for (u64 j = 0, i = length - 1;
                 j < i;
                 j += 1, i -= 1){
                do { u8 hidden_temp_7172 = string_space[i]; string_space[i] = string_space[j]; string_space[j] = hidden_temp_7172; } while(0);
            }
            result = push_string_copy(arena, SCu8(string_space, length));
        }
    }
    return(result);
}

static b32
string_is_integer(String_Const_u8 string, u32 radix){
    b32 is_integer = false;
    if (string.size > 0 && radix <= 16){
        is_integer = true;
        for (u64 i = 0; i < string.size; i += 1){
            if (string.str[i] < 128){
                u8 x = integer_symbol_reverse[character_to_upper(string.str[i])];
                if (x >= radix){
                    is_integer = false;
                    break;
                }
            }
            else{
                is_integer = false;
                break;
            }
        }
    }
    return(is_integer);
}

static u64
string_to_integer(String_Const_u8 string, u32 radix){
    u64 x = 0;
    if (radix <= 16){
        for (u64 i = 0; i < string.size; i += 1){
            x *= radix;
            if (string.str[i] < 128){
                x += integer_symbol_reverse[character_to_upper(string.str[i])];
            }
            else{
                x += 0xFF;
            }
        }
    }
    return(x);
}

static u64
string_to_integer(String_Const_char string, u32 radix){
    return(string_to_integer(SCu8((u8*)string.str, string.size), radix));
}

static String_Const_u8
string_base64_encode_from_binary(Arena *arena, void *data, u64 size){
    u64 char_count = (((size*8) + (6) - 1)/(6));
    char_count = round_up_u64(char_count, 4);
    String_Const_u8 string = string_const_u8_push(arena, char_count);
    u8 *s = string.str;
    u8 *d = (u8*)data;
    u8 *de = d + size;
    for (;d < de; d += 3, s += 4){
        i32 in_byte_count = (i32)(de - d);
        u8 *D = d;
        b32 partial_fill = (in_byte_count < 3);
        u8 D_space[3] = {};
        if (partial_fill){
            block_copy(D_space, d, (((sizeof(D_space))<(in_byte_count))?(sizeof(D_space)):(in_byte_count)));
            D = D_space;
        }
        s[0] = D[0] &bitmask_6;
        s[1] = ((D[0] >> 6)&bitmask_2) | ((D[1]&bitmask_4) << 2);
        s[2] = ((D[1] >> 4)&bitmask_4) | ((D[2]&bitmask_2) << 4);
        s[3] = (D[2] >> 2)&bitmask_6;
        for (i32 j = 0; j < 4; j += 1){
            s[j] = base64[s[j]];
        }
        switch (in_byte_count){
            case 1:
            {
                s[2] = '?';
                s[3] = '?';
            }break;
            case 2:
            {
                s[3] = '?';
            }break;
        }
    }
    return(string);
}

static Data
data_decode_from_base64(Arena *arena, u8 *str, u64 size){
    Data data = {};
    if (size%4 == 0){
        u64 data_size = size*6/8;
        if (str[size - 2] == '?'){
            data_size -= 2;
        }
        else if (str[size - 1] == '?'){
            data_size -= 1;
        }
        data = push_data(arena, data_size);
        u8 *s = str;
        u8 *se = s + size;
        u8 *d = (u8*)data.data;
        u8 *de = d + data_size;
        for (;s < se; d += 3, s += 4){
            u8 *D = d;
            i32 out_byte_count = (i32)(de - d);
            b32 partial_fill = (out_byte_count < 3);
            u8 D_space[2];
            if (partial_fill){
                D = D_space;
            }
            u8 S[4];
            for (i32 j = 0; j < 4; j += 1){
                if (s[j] < 128){
                    S[j] = base64_reverse[s[j]];
                }
                else{
                    S[j] = 0xFF;
                }
            }
            D[0] = ( S[0] &bitmask_6) | ((S[1]&bitmask_2) << 6);
            D[1] = ((S[1] >> 2)&bitmask_4) | ((S[2]&bitmask_4) << 4);
            D[2] = ((S[2] >> 4)&bitmask_2) | ((S[3]&bitmask_6) << 2);
            if (partial_fill){
                do{ if (!(out_byte_count <= sizeof(D_space))) { (*((i32*)0) = 0xA11E); } }while(0);
                block_copy(D, D_space, out_byte_count);
            }
        }
    }
    return(data);
}



static u64
time_stamp_from_date_time(Date_Time *date_time){
    u64 result = 0;
    result += date_time->year;
    result *= 12;
    result += date_time->mon;
    result *= 30;
    result += date_time->day;
    result *= 24;
    result += date_time->hour;
    result *= 60;
    result += date_time->min;
    result *= 61;
    result += date_time->sec;
    result *= 1000;
    result += date_time->msec;
    return(result);
}

static Date_Time
date_time_from_time_stamp(u64 time_stamp){
    Date_Time result = {};
    result.msec = time_stamp%1000;
    time_stamp /= 1000;
    result.sec = time_stamp%61;
    time_stamp /= 61;
    result.min = time_stamp%60;
    time_stamp /= 60;
    result.hour = time_stamp%24;
    time_stamp /= 24;
    result.day = time_stamp%30;
    time_stamp /= 30;
    result.mon = time_stamp%12;
    time_stamp /= 12;
    result.year = (u32)time_stamp;
    return(result);
}
# 62 "/home/sam/.bin/4coder/custom/4coder_default_include.cpp" 2
# 1 "/home/sam/.bin/4coder/custom/4coder_stringf.cpp" 1
# 10 "/home/sam/.bin/4coder/custom/4coder_stringf.cpp"
# 1 "/usr/lib/gcc/x86_64-pc-linux-gnu/10.2.0/include/stdarg.h" 1 3 4
# 11 "/home/sam/.bin/4coder/custom/4coder_stringf.cpp" 2


static String_Const_u8
push_stringfv(Arena *arena, char *format, va_list args){
    va_list args2;
    
# 16 "/home/sam/.bin/4coder/custom/4coder_stringf.cpp" 3 4
   __builtin_va_copy(
# 16 "/home/sam/.bin/4coder/custom/4coder_stringf.cpp"
   args2
# 16 "/home/sam/.bin/4coder/custom/4coder_stringf.cpp" 3 4
   ,
# 16 "/home/sam/.bin/4coder/custom/4coder_stringf.cpp"
   args
# 16 "/home/sam/.bin/4coder/custom/4coder_stringf.cpp" 3 4
   )
# 16 "/home/sam/.bin/4coder/custom/4coder_stringf.cpp"
                       ;
    i32 size = vsnprintf(0, 0, format, args);
    String_Const_u8 result = string_const_u8_push(arena, size + 1);
    vsnprintf((char*)result.str, (size_t)result.size, format, args2);
    result.size -= 1;
    result.str[result.size] = 0;
    return(result);
}
static String_Const_u8
push_stringf(Arena *arena, char *format, ...){
    va_list args;
    
# 27 "/home/sam/.bin/4coder/custom/4coder_stringf.cpp" 3 4
   __builtin_va_start(
# 27 "/home/sam/.bin/4coder/custom/4coder_stringf.cpp"
   args
# 27 "/home/sam/.bin/4coder/custom/4coder_stringf.cpp" 3 4
   ,
# 27 "/home/sam/.bin/4coder/custom/4coder_stringf.cpp"
   format
# 27 "/home/sam/.bin/4coder/custom/4coder_stringf.cpp" 3 4
   )
# 27 "/home/sam/.bin/4coder/custom/4coder_stringf.cpp"
                         ;
    String_Const_u8 result = push_stringfv(arena, format, args);
    
# 29 "/home/sam/.bin/4coder/custom/4coder_stringf.cpp" 3 4
   __builtin_va_end(
# 29 "/home/sam/.bin/4coder/custom/4coder_stringf.cpp"
   args
# 29 "/home/sam/.bin/4coder/custom/4coder_stringf.cpp" 3 4
   )
# 29 "/home/sam/.bin/4coder/custom/4coder_stringf.cpp"
               ;
    return(result);
}
static String_Const_u8
push_u8_stringfv(Arena *arena, char *format, va_list args){
    return(push_stringfv(arena, format, args));
}
static String_Const_u8
push_u8_stringf(Arena *arena, char *format, ...){
    va_list args;
    
# 39 "/home/sam/.bin/4coder/custom/4coder_stringf.cpp" 3 4
   __builtin_va_start(
# 39 "/home/sam/.bin/4coder/custom/4coder_stringf.cpp"
   args
# 39 "/home/sam/.bin/4coder/custom/4coder_stringf.cpp" 3 4
   ,
# 39 "/home/sam/.bin/4coder/custom/4coder_stringf.cpp"
   format
# 39 "/home/sam/.bin/4coder/custom/4coder_stringf.cpp" 3 4
   )
# 39 "/home/sam/.bin/4coder/custom/4coder_stringf.cpp"
                         ;
    String_Const_u8 result = push_stringfv(arena, format, args);
    
# 41 "/home/sam/.bin/4coder/custom/4coder_stringf.cpp" 3 4
   __builtin_va_end(
# 41 "/home/sam/.bin/4coder/custom/4coder_stringf.cpp"
   args
# 41 "/home/sam/.bin/4coder/custom/4coder_stringf.cpp" 3 4
   )
# 41 "/home/sam/.bin/4coder/custom/4coder_stringf.cpp"
               ;
    return(result);
}

static void
string_list_pushfv(Arena *arena, List_String_Const_char *list, char *format, va_list args){
    String_Const_u8 string = push_stringfv(arena, format, args);
    if (arena->alignment < sizeof(u64)){
        (linalloc_align((arena), (sizeof(u64))));
    }
    string_list_push(arena, list, SCchar(string));
}
static void
string_list_pushf(Arena *arena, List_String_Const_char *list, char *format, ...){
    va_list args;
    
# 56 "/home/sam/.bin/4coder/custom/4coder_stringf.cpp" 3 4
   __builtin_va_start(
# 56 "/home/sam/.bin/4coder/custom/4coder_stringf.cpp"
   args
# 56 "/home/sam/.bin/4coder/custom/4coder_stringf.cpp" 3 4
   ,
# 56 "/home/sam/.bin/4coder/custom/4coder_stringf.cpp"
   format
# 56 "/home/sam/.bin/4coder/custom/4coder_stringf.cpp" 3 4
   )
# 56 "/home/sam/.bin/4coder/custom/4coder_stringf.cpp"
                         ;
    string_list_pushfv(arena, list, format, args);
    
# 58 "/home/sam/.bin/4coder/custom/4coder_stringf.cpp" 3 4
   __builtin_va_end(
# 58 "/home/sam/.bin/4coder/custom/4coder_stringf.cpp"
   args
# 58 "/home/sam/.bin/4coder/custom/4coder_stringf.cpp" 3 4
   )
# 58 "/home/sam/.bin/4coder/custom/4coder_stringf.cpp"
               ;
}
static void
string_list_pushfv(Arena *arena, List_String_Const_u8 *list, char *format, va_list args){
    String_Const_u8 string = push_u8_stringfv(arena, format, args);
    if (arena->alignment < sizeof(u64)){
        (linalloc_align((arena), (sizeof(u64))));
    }
    string_list_push(arena, list, string);
}
static void
string_list_pushf(Arena *arena, List_String_Const_u8 *list, char *format, ...){
    va_list args;
    
# 71 "/home/sam/.bin/4coder/custom/4coder_stringf.cpp" 3 4
   __builtin_va_start(
# 71 "/home/sam/.bin/4coder/custom/4coder_stringf.cpp"
   args
# 71 "/home/sam/.bin/4coder/custom/4coder_stringf.cpp" 3 4
   ,
# 71 "/home/sam/.bin/4coder/custom/4coder_stringf.cpp"
   format
# 71 "/home/sam/.bin/4coder/custom/4coder_stringf.cpp" 3 4
   )
# 71 "/home/sam/.bin/4coder/custom/4coder_stringf.cpp"
                         ;
    string_list_pushfv(arena, list, format, args);
    
# 73 "/home/sam/.bin/4coder/custom/4coder_stringf.cpp" 3 4
   __builtin_va_end(
# 73 "/home/sam/.bin/4coder/custom/4coder_stringf.cpp"
   args
# 73 "/home/sam/.bin/4coder/custom/4coder_stringf.cpp" 3 4
   )
# 73 "/home/sam/.bin/4coder/custom/4coder_stringf.cpp"
               ;
}




static void
push_year_full(Arena *arena, List_String_Const_u8 *list, u32 year){
    string_list_pushf(arena, list, "%u", year);
}

static void
push_year_abrev(Arena *arena, List_String_Const_u8 *list, u32 year){
    string_list_pushf(arena, list, "%u", year % 100);
}


static void
push_month_num(Arena *arena, List_String_Const_u8 *list, u8 mon){
    string_list_pushf(arena, list, "%u", mon + 1);
}

static void
push_month_num_zeros(Arena *arena, List_String_Const_u8 *list, u8 mon){
    string_list_pushf(arena, list, "%02u", mon + 1);
}

static void
push_month_name(Arena *arena, List_String_Const_u8 *list, u8 mon){
    string_list_push(arena, list, month_full_name[mon%12]);
}

static void
push_month_abrev(Arena *arena, List_String_Const_u8 *list, u8 mon){
    string_list_push(arena, list, month_abrev_name[mon%12]);
}


static void
push_day_num(Arena *arena, List_String_Const_u8 *list, u8 day){
    string_list_pushf(arena, list, "%u", day + 1);
}

static void
push_day_num_zeroes(Arena *arena, List_String_Const_u8 *list, u8 day){
    string_list_pushf(arena, list, "%02u", day + 1);
}

static void
push_day_ord(Arena *arena, List_String_Const_u8 *list, u8 day){
    string_list_push(arena, list, ordinal_numeric_name[day%100]);
}


static void
push_hour_24(Arena *arena, List_String_Const_u8 *list, u8 hour){
    string_list_pushf(arena, list, "%u", hour);
}

static void
push_hour_24_zeroes(Arena *arena, List_String_Const_u8 *list, u8 hour){
    string_list_pushf(arena, list, "%02u", hour);
}

static void
push_hour_12(Arena *arena, List_String_Const_u8 *list, u8 hour){
    string_list_pushf(arena, list, "%u", hour%12);
}

static void
push_hour_12_zeroes(Arena *arena, List_String_Const_u8 *list, u8 hour){
    string_list_pushf(arena, list, "%02u", hour%12);
}

static void
push_hour_am_pm(Arena *arena, List_String_Const_u8 *list, u8 hour){
    if (hour >= 12){
        string_list_push(arena, list, SCu8((u8*)("pm"), (u64)(sizeof("pm") - 1)));
    }
    else{
        string_list_push(arena, list, SCu8((u8*)("am"), (u64)(sizeof("am") - 1)));
    }
}


static void
push_minute(Arena *arena, List_String_Const_u8 *list, u8 min){
    string_list_pushf(arena, list, "%u", min);
}

static void
push_minute_zeroes(Arena *arena, List_String_Const_u8 *list, u8 min){
    string_list_pushf(arena, list, "%02u", min);
}


static void
push_second(Arena *arena, List_String_Const_u8 *list, u8 sec){
    string_list_pushf(arena, list, "%u", sec);
}

static void
push_second_zeroes(Arena *arena, List_String_Const_u8 *list, u8 sec){
    string_list_pushf(arena, list, "%02u", sec);
}


static void
push_millisecond_zeroes(Arena *arena, List_String_Const_u8 *list, u16 msec){
    string_list_pushf(arena, list, "%03u", msec);
}

static void
date_time_format(Arena *arena, List_String_Const_u8 *list, String_Const_u8 format, Date_Time *date_time){
    u8 *ptr = format.str;
    u8 *end = format.str + format.size;
    for (;ptr < end;){
        if (character_is_alpha_numeric(*ptr)){
            u8 *start = ptr;
            for (;ptr < end; ptr += 1){
                if (!character_is_alpha_numeric(*ptr)){
                    break;
                }
            }

            String_Const_u8 field = SCu8(start, ptr);
            for (; field.size > 0;){
                if (string_match(string_prefix(field, 5), SCu8((u8*)("month"), (u64)(sizeof("month") - 1)))){
                    field = string_skip(field, 5);
                    push_month_name(arena, list, date_time->mon);
                }

                else if (string_match(string_prefix(field, 4), SCu8((u8*)("yyyy"), (u64)(sizeof("yyyy") - 1)))){
                    field = string_skip(field, 4);
                    push_year_full(arena, list, date_time->year);
                }
                else if (string_match(string_prefix(field, 4), SCu8((u8*)("hh24"), (u64)(sizeof("hh24") - 1)))){
                    field = string_skip(field, 4);
                    push_hour_24_zeroes(arena, list, date_time->hour);
                }
                else if (string_match(string_prefix(field, 4), SCu8((u8*)("ampm"), (u64)(sizeof("ampm") - 1)))){
                    field = string_skip(field, 4);
                    push_hour_am_pm(arena, list, date_time->hour);
                }
                else if (string_match(string_prefix(field, 4), SCu8((u8*)("mimi"), (u64)(sizeof("mimi") - 1)))){
                    field = string_skip(field, 4);
                    push_minute_zeroes(arena, list, date_time->min);
                }

                else if (string_match(string_prefix(field, 3), SCu8((u8*)("mon"), (u64)(sizeof("mon") - 1)))){
                    field = string_skip(field, 3);
                    push_month_abrev(arena, list, date_time->mon);
                }
                else if (string_match(string_prefix(field, 3), SCu8((u8*)("day"), (u64)(sizeof("day") - 1)))){
                    field = string_skip(field, 3);
                    push_day_ord(arena, list, date_time->day);
                }
                else if (string_match(string_prefix(field, 3), SCu8((u8*)("h24"), (u64)(sizeof("h24") - 1)))){
                    field = string_skip(field, 3);
                    push_hour_24(arena, list, date_time->hour);
                }

                else if (string_match(string_prefix(field, 2), SCu8((u8*)("yy"), (u64)(sizeof("yy") - 1)))){
                    field = string_skip(field, 2);
                    push_year_abrev(arena, list, date_time->year);
                }
                else if (string_match(string_prefix(field, 2), SCu8((u8*)("mm"), (u64)(sizeof("mm") - 1)))){
                    field = string_skip(field, 2);
                    push_month_num_zeros(arena, list, date_time->mon);
                }
                else if (string_match(string_prefix(field, 2), SCu8((u8*)("dd"), (u64)(sizeof("dd") - 1)))){
                    field = string_skip(field, 2);
                    push_day_num_zeroes(arena, list, date_time->day);
                }
                else if (string_match(string_prefix(field, 2), SCu8((u8*)("hh"), (u64)(sizeof("hh") - 1)))){
                    field = string_skip(field, 2);
                    push_hour_12_zeroes(arena, list, date_time->hour);
                }
                else if (string_match(string_prefix(field, 2), SCu8((u8*)("mi"), (u64)(sizeof("mi") - 1)))){
                    field = string_skip(field, 2);
                    push_minute(arena, list, date_time->min);
                }
                else if (string_match(string_prefix(field, 2), SCu8((u8*)("ss"), (u64)(sizeof("ss") - 1)))){
                    field = string_skip(field, 2);
                    push_second_zeroes(arena, list, date_time->sec);
                }
                else if (string_match(string_prefix(field, 2), SCu8((u8*)("ms"), (u64)(sizeof("ms") - 1)))){
                    field = string_skip(field, 2);
                    push_millisecond_zeroes(arena, list, date_time->msec);
                }

                else if (string_match(string_prefix(field, 1), SCu8((u8*)("m"), (u64)(sizeof("m") - 1)))){
                    field = string_skip(field, 1);
                    push_month_num(arena, list, date_time->mon);
                }
                else if (string_match(string_prefix(field, 1), SCu8((u8*)("d"), (u64)(sizeof("d") - 1)))){
                    field = string_skip(field, 1);
                    push_day_num(arena, list, date_time->day);
                }
                else if (string_match(string_prefix(field, 1), SCu8((u8*)("h"), (u64)(sizeof("h") - 1)))){
                    field = string_skip(field, 1);
                    push_hour_12(arena, list, date_time->hour);
                }
                else if (string_match(string_prefix(field, 1), SCu8((u8*)("s"), (u64)(sizeof("s") - 1)))){
                    field = string_skip(field, 1);
                    push_second(arena, list, date_time->sec);
                }

                else{
                    string_list_push(arena, list, SCu8(start, ptr));
                    break;
                }
            }
        }
        else{
            u8 *start = ptr;
            for (;ptr < end; ptr += 1){
                if (character_is_alpha_numeric(*ptr)){
                    break;
                }
            }
            string_list_push(arena, list, SCu8(start, ptr));
        }
    }
}
static void
date_time_format(Arena *arena, List_String_Const_u8 *list, char *format, Date_Time *date_time){
    date_time_format(arena, list, SCu8(format), date_time);
}

static String_Const_u8
date_time_format(Arena *arena, String_Const_u8 format, Date_Time *date_time){
    List_String_Const_u8 list = {};
    date_time_format(arena, &list, format, date_time);
    return(string_list_flatten(arena, list));
}
static String_Const_u8
date_time_format(Arena *arena, char *format, Date_Time *date_time){
    return(date_time_format(arena, SCu8(format), date_time));
}
# 63 "/home/sam/.bin/4coder/custom/4coder_default_include.cpp" 2
# 1 "/home/sam/.bin/4coder/custom/4coder_app_links_allocator.cpp" 1






Scratch_Block::Scratch_Block(Application_Links *app){
    Thread_Context *t = this->tctx = get_thread_context(app);
    this->arena = tctx_reserve(t);
    this->temp = begin_temp(this->arena);
}

Scratch_Block::Scratch_Block(Application_Links *app, Arena *a1){
    Thread_Context *t = this->tctx = get_thread_context(app);
    this->arena = tctx_reserve(t, a1);
    this->temp = begin_temp(this->arena);
}

Scratch_Block::Scratch_Block(Application_Links *app, Arena *a1, Arena *a2){
    Thread_Context *t = this->tctx = get_thread_context(app);
    this->arena = tctx_reserve(t, a1, a2);
    this->temp = begin_temp(this->arena);
}

Scratch_Block::Scratch_Block(Application_Links *app, Arena *a1, Arena *a2, Arena *a3){
    Thread_Context *t = this->tctx = get_thread_context(app);
    this->arena = tctx_reserve(t, a1, a2, a3);
    this->temp = begin_temp(this->arena);
}
# 64 "/home/sam/.bin/4coder/custom/4coder_default_include.cpp" 2
# 1 "/home/sam/.bin/4coder/custom/4coder_system_allocator.cpp" 1






static void*
base_reserve__system(void *user_data, u64 size, u64 *size_out, String_Const_u8 location){
    u64 extra_size = 128;
    u64 increased_size = size + extra_size;
    size = round_up_u64(increased_size, ((4) << 10));
    *size_out = size - extra_size;
    void *ptr = system_memory_allocate(size, location);
    *(u64*)ptr = size;
    ptr = (u8*)ptr + extra_size;
    return(ptr);
}

static void
base_free__system(void *user_data, void *ptr){
    u64 extra_size = 128;
    ptr = (u8*)ptr - extra_size;
    u64 size = *(u64*)ptr;
    system_memory_free(ptr, size);
}

static Base_Allocator
make_base_allocator_system(void){
    return(make_base_allocator(base_reserve__system, 0, 0, base_free__system, 0, 0));
}

static Base_Allocator base_allocator_system = {};

static Base_Allocator*
get_base_allocator_system(void){
    if (base_allocator_system.reserve == 0){
        base_allocator_system = make_base_allocator_system();
    }
    return(&base_allocator_system);
}

static Arena
make_arena_system(u64 chunk_size, u64 align){
    return(make_arena(get_base_allocator_system(), chunk_size, align));
}

static Arena
make_arena_system(u64 chunk_size){
    return(make_arena_system(chunk_size, 8));
}

static Arena
make_arena_system(void){
    return(make_arena_system(((16) << 10), 8));
}
# 65 "/home/sam/.bin/4coder/custom/4coder_default_include.cpp" 2
# 1 "/home/sam/.bin/4coder/custom/generated/lexer_cpp.h" 1



struct Lexeme_Table_Value{
    Token_Base_Kind base_kind;
    u16 sub_kind;
};

struct Lexeme_Table_Lookup{
    b32 found_match;
    Token_Base_Kind base_kind;
    u16 sub_kind;
};


typedef u16 Token_Cpp_Kind;
enum{
TokenCppKind_EOF = 0,
TokenCppKind_Whitespace = 1,
TokenCppKind_LexError = 2,
TokenCppKind_BlockComment = 3,
TokenCppKind_LineComment = 4,
TokenCppKind_Backslash = 5,
TokenCppKind_LiteralInteger = 6,
TokenCppKind_LiteralIntegerU = 7,
TokenCppKind_LiteralIntegerL = 8,
TokenCppKind_LiteralIntegerUL = 9,
TokenCppKind_LiteralIntegerLL = 10,
TokenCppKind_LiteralIntegerULL = 11,
TokenCppKind_LiteralIntegerHex = 12,
TokenCppKind_LiteralIntegerHexU = 13,
TokenCppKind_LiteralIntegerHexL = 14,
TokenCppKind_LiteralIntegerHexUL = 15,
TokenCppKind_LiteralIntegerHexLL = 16,
TokenCppKind_LiteralIntegerHexULL = 17,
TokenCppKind_LiteralIntegerOct = 18,
TokenCppKind_LiteralIntegerOctU = 19,
TokenCppKind_LiteralIntegerOctL = 20,
TokenCppKind_LiteralIntegerOctUL = 21,
TokenCppKind_LiteralIntegerOctLL = 22,
TokenCppKind_LiteralIntegerOctULL = 23,
TokenCppKind_LiteralFloat32 = 24,
TokenCppKind_LiteralFloat64 = 25,
TokenCppKind_LiteralString = 26,
TokenCppKind_LiteralStringWide = 27,
TokenCppKind_LiteralStringUTF8 = 28,
TokenCppKind_LiteralStringUTF16 = 29,
TokenCppKind_LiteralStringUTF32 = 30,
TokenCppKind_LiteralStringRaw = 31,
TokenCppKind_LiteralStringWideRaw = 32,
TokenCppKind_LiteralStringUTF8Raw = 33,
TokenCppKind_LiteralStringUTF16Raw = 34,
TokenCppKind_LiteralStringUTF32Raw = 35,
TokenCppKind_LiteralCharacter = 36,
TokenCppKind_LiteralCharacterWide = 37,
TokenCppKind_LiteralCharacterUTF8 = 38,
TokenCppKind_LiteralCharacterUTF16 = 39,
TokenCppKind_LiteralCharacterUTF32 = 40,
TokenCppKind_PPIncludeFile = 41,
TokenCppKind_PPErrorMessage = 42,
TokenCppKind_KeywordGeneric = 43,
TokenCppKind_BraceOp = 44,
TokenCppKind_BraceCl = 45,
TokenCppKind_ParenOp = 46,
TokenCppKind_BrackOp = 47,
TokenCppKind_ParenCl = 48,
TokenCppKind_BrackCl = 49,
TokenCppKind_Semicolon = 50,
TokenCppKind_Colon = 51,
TokenCppKind_DotDotDot = 52,
TokenCppKind_ColonColon = 53,
TokenCppKind_PlusPlus = 54,
TokenCppKind_MinusMinus = 55,
TokenCppKind_Dot = 56,
TokenCppKind_Arrow = 57,
TokenCppKind_Plus = 58,
TokenCppKind_Minus = 59,
TokenCppKind_Not = 60,
TokenCppKind_Tilde = 61,
TokenCppKind_Star = 62,
TokenCppKind_And = 63,
TokenCppKind_DotStar = 64,
TokenCppKind_ArrowStar = 65,
TokenCppKind_Div = 66,
TokenCppKind_Mod = 67,
TokenCppKind_LeftLeft = 68,
TokenCppKind_RightRight = 69,
TokenCppKind_Compare = 70,
TokenCppKind_Less = 71,
TokenCppKind_LessEq = 72,
TokenCppKind_Grtr = 73,
TokenCppKind_GrtrEq = 74,
TokenCppKind_EqEq = 75,
TokenCppKind_NotEq = 76,
TokenCppKind_Xor = 77,
TokenCppKind_Or = 78,
TokenCppKind_AndAnd = 79,
TokenCppKind_OrOr = 80,
TokenCppKind_Ternary = 81,
TokenCppKind_Eq = 82,
TokenCppKind_PlusEq = 83,
TokenCppKind_MinusEq = 84,
TokenCppKind_StarEq = 85,
TokenCppKind_DivEq = 86,
TokenCppKind_ModEq = 87,
TokenCppKind_LeftLeftEq = 88,
TokenCppKind_RightRightEq = 89,
TokenCppKind_Comma = 90,
TokenCppKind_PPStringify = 91,
TokenCppKind_PPConcat = 92,
TokenCppKind_Void = 93,
TokenCppKind_Bool = 94,
TokenCppKind_Char = 95,
TokenCppKind_Int = 96,
TokenCppKind_Float = 97,
TokenCppKind_Double = 98,
TokenCppKind_Long = 99,
TokenCppKind_Short = 100,
TokenCppKind_Unsigned = 101,
TokenCppKind_Signed = 102,
TokenCppKind_Const = 103,
TokenCppKind_Volatile = 104,
TokenCppKind_Asm = 105,
TokenCppKind_Break = 106,
TokenCppKind_Case = 107,
TokenCppKind_Catch = 108,
TokenCppKind_Continue = 109,
TokenCppKind_Default = 110,
TokenCppKind_Do = 111,
TokenCppKind_Else = 112,
TokenCppKind_For = 113,
TokenCppKind_Goto = 114,
TokenCppKind_If = 115,
TokenCppKind_Return = 116,
TokenCppKind_Switch = 117,
TokenCppKind_Try = 118,
TokenCppKind_While = 119,
TokenCppKind_StaticAssert = 120,
TokenCppKind_ConstCast = 121,
TokenCppKind_DynamicCast = 122,
TokenCppKind_ReinterpretCast = 123,
TokenCppKind_StaticCast = 124,
TokenCppKind_Class = 125,
TokenCppKind_Enum = 126,
TokenCppKind_Struct = 127,
TokenCppKind_Typedef = 128,
TokenCppKind_Union = 129,
TokenCppKind_Template = 130,
TokenCppKind_Typename = 131,
TokenCppKind_Friend = 132,
TokenCppKind_Namespace = 133,
TokenCppKind_Private = 134,
TokenCppKind_Protected = 135,
TokenCppKind_Public = 136,
TokenCppKind_Using = 137,
TokenCppKind_Extern = 138,
TokenCppKind_Export = 139,
TokenCppKind_Inline = 140,
TokenCppKind_Static = 141,
TokenCppKind_Virtual = 142,
TokenCppKind_AlignAs = 143,
TokenCppKind_Explicit = 144,
TokenCppKind_NoExcept = 145,
TokenCppKind_NullPtr = 146,
TokenCppKind_Operator = 147,
TokenCppKind_Register = 148,
TokenCppKind_This = 149,
TokenCppKind_ThreadLocal = 150,
TokenCppKind_SizeOf = 151,
TokenCppKind_AlignOf = 152,
TokenCppKind_DeclType = 153,
TokenCppKind_TypeID = 154,
TokenCppKind_New = 155,
TokenCppKind_Delete = 156,
TokenCppKind_LiteralTrue = 157,
TokenCppKind_LiteralFalse = 158,
TokenCppKind_Identifier = 159,
TokenCppKind_PPInclude = 160,
TokenCppKind_PPVersion = 161,
TokenCppKind_PPDefine = 162,
TokenCppKind_PPUndef = 163,
TokenCppKind_PPIf = 164,
TokenCppKind_PPIfDef = 165,
TokenCppKind_PPIfNDef = 166,
TokenCppKind_PPElse = 167,
TokenCppKind_PPElIf = 168,
TokenCppKind_PPEndIf = 169,
TokenCppKind_PPError = 170,
TokenCppKind_PPImport = 171,
TokenCppKind_PPUsing = 172,
TokenCppKind_PPLine = 173,
TokenCppKind_PPPragma = 174,
TokenCppKind_PPUnknown = 175,
TokenCppKind_PPDefined = 176,
TokenCppKind_COUNT = 177,
};
char *token_cpp_kind_names[] = {
"EOF",
"Whitespace",
"LexError",
"BlockComment",
"LineComment",
"Backslash",
"LiteralInteger",
"LiteralIntegerU",
"LiteralIntegerL",
"LiteralIntegerUL",
"LiteralIntegerLL",
"LiteralIntegerULL",
"LiteralIntegerHex",
"LiteralIntegerHexU",
"LiteralIntegerHexL",
"LiteralIntegerHexUL",
"LiteralIntegerHexLL",
"LiteralIntegerHexULL",
"LiteralIntegerOct",
"LiteralIntegerOctU",
"LiteralIntegerOctL",
"LiteralIntegerOctUL",
"LiteralIntegerOctLL",
"LiteralIntegerOctULL",
"LiteralFloat32",
"LiteralFloat64",
"LiteralString",
"LiteralStringWide",
"LiteralStringUTF8",
"LiteralStringUTF16",
"LiteralStringUTF32",
"LiteralStringRaw",
"LiteralStringWideRaw",
"LiteralStringUTF8Raw",
"LiteralStringUTF16Raw",
"LiteralStringUTF32Raw",
"LiteralCharacter",
"LiteralCharacterWide",
"LiteralCharacterUTF8",
"LiteralCharacterUTF16",
"LiteralCharacterUTF32",
"PPIncludeFile",
"PPErrorMessage",
"KeywordGeneric",
"BraceOp",
"BraceCl",
"ParenOp",
"BrackOp",
"ParenCl",
"BrackCl",
"Semicolon",
"Colon",
"DotDotDot",
"ColonColon",
"PlusPlus",
"MinusMinus",
"Dot",
"Arrow",
"Plus",
"Minus",
"Not",
"Tilde",
"Star",
"And",
"DotStar",
"ArrowStar",
"Div",
"Mod",
"LeftLeft",
"RightRight",
"Compare",
"Less",
"LessEq",
"Grtr",
"GrtrEq",
"EqEq",
"NotEq",
"Xor",
"Or",
"AndAnd",
"OrOr",
"Ternary",
"Eq",
"PlusEq",
"MinusEq",
"StarEq",
"DivEq",
"ModEq",
"LeftLeftEq",
"RightRightEq",
"Comma",
"PPStringify",
"PPConcat",
"Void",
"Bool",
"Char",
"Int",
"Float",
"Double",
"Long",
"Short",
"Unsigned",
"Signed",
"Const",
"Volatile",
"Asm",
"Break",
"Case",
"Catch",
"Continue",
"Default",
"Do",
"Else",
"For",
"Goto",
"If",
"Return",
"Switch",
"Try",
"While",
"StaticAssert",
"ConstCast",
"DynamicCast",
"ReinterpretCast",
"StaticCast",
"Class",
"Enum",
"Struct",
"Typedef",
"Union",
"Template",
"Typename",
"Friend",
"Namespace",
"Private",
"Protected",
"Public",
"Using",
"Extern",
"Export",
"Inline",
"Static",
"Virtual",
"AlignAs",
"Explicit",
"NoExcept",
"NullPtr",
"Operator",
"Register",
"This",
"ThreadLocal",
"SizeOf",
"AlignOf",
"DeclType",
"TypeID",
"New",
"Delete",
"LiteralTrue",
"LiteralFalse",
"Identifier",
"PPInclude",
"PPVersion",
"PPDefine",
"PPUndef",
"PPIf",
"PPIfDef",
"PPIfNDef",
"PPElse",
"PPElIf",
"PPEndIf",
"PPError",
"PPImport",
"PPUsing",
"PPLine",
"PPPragma",
"PPUnknown",
"PPDefined",
};
# 66 "/home/sam/.bin/4coder/custom/4coder_default_include.cpp" 2


# 1 "/home/sam/.bin/4coder/custom/generated/custom_api.cpp" 1
static void
custom_api_fill_vtable(API_VTable_custom *vtable){
vtable->global_set_setting = global_set_setting;
vtable->global_get_screen_rectangle = global_get_screen_rectangle;
vtable->get_thread_context = get_thread_context;
vtable->create_child_process = create_child_process;
vtable->child_process_set_target_buffer = child_process_set_target_buffer;
vtable->buffer_get_attached_child_process = buffer_get_attached_child_process;
vtable->child_process_get_attached_buffer = child_process_get_attached_buffer;
vtable->child_process_get_state = child_process_get_state;
vtable->enqueue_virtual_event = enqueue_virtual_event;
vtable->get_buffer_count = get_buffer_count;
vtable->get_buffer_next = get_buffer_next;
vtable->get_buffer_by_name = get_buffer_by_name;
vtable->get_buffer_by_file_name = get_buffer_by_file_name;
vtable->buffer_read_range = buffer_read_range;
vtable->buffer_replace_range = buffer_replace_range;
vtable->buffer_batch_edit = buffer_batch_edit;
vtable->buffer_seek_string = buffer_seek_string;
vtable->buffer_seek_character_class = buffer_seek_character_class;
vtable->buffer_line_y_difference = buffer_line_y_difference;
vtable->buffer_line_shift_y = buffer_line_shift_y;
vtable->buffer_pos_at_relative_xy = buffer_pos_at_relative_xy;
vtable->buffer_relative_box_of_pos = buffer_relative_box_of_pos;
vtable->buffer_padded_box_of_pos = buffer_padded_box_of_pos;
vtable->buffer_relative_character_from_pos = buffer_relative_character_from_pos;
vtable->buffer_pos_from_relative_character = buffer_pos_from_relative_character;
vtable->view_line_y_difference = view_line_y_difference;
vtable->view_line_shift_y = view_line_shift_y;
vtable->view_pos_at_relative_xy = view_pos_at_relative_xy;
vtable->view_relative_box_of_pos = view_relative_box_of_pos;
vtable->view_padded_box_of_pos = view_padded_box_of_pos;
vtable->view_relative_character_from_pos = view_relative_character_from_pos;
vtable->view_pos_from_relative_character = view_pos_from_relative_character;
vtable->buffer_exists = buffer_exists;
vtable->buffer_get_access_flags = buffer_get_access_flags;
vtable->buffer_get_size = buffer_get_size;
vtable->buffer_get_line_count = buffer_get_line_count;
vtable->push_buffer_base_name = push_buffer_base_name;
vtable->push_buffer_unique_name = push_buffer_unique_name;
vtable->push_buffer_file_name = push_buffer_file_name;
vtable->buffer_get_dirty_state = buffer_get_dirty_state;
vtable->buffer_set_dirty_state = buffer_set_dirty_state;
vtable->buffer_set_layout = buffer_set_layout;
vtable->buffer_clear_layout_cache = buffer_clear_layout_cache;
vtable->buffer_get_layout = buffer_get_layout;
vtable->buffer_get_setting = buffer_get_setting;
vtable->buffer_set_setting = buffer_set_setting;
vtable->buffer_get_managed_scope = buffer_get_managed_scope;
vtable->buffer_send_end_signal = buffer_send_end_signal;
vtable->create_buffer = create_buffer;
vtable->buffer_save = buffer_save;
vtable->buffer_kill = buffer_kill;
vtable->buffer_reopen = buffer_reopen;
vtable->buffer_get_file_attributes = buffer_get_file_attributes;
vtable->get_view_next = get_view_next;
vtable->get_view_prev = get_view_prev;
vtable->get_this_ctx_view = get_this_ctx_view;
vtable->get_active_view = get_active_view;
vtable->view_exists = view_exists;
vtable->view_get_buffer = view_get_buffer;
vtable->view_get_cursor_pos = view_get_cursor_pos;
vtable->view_get_mark_pos = view_get_mark_pos;
vtable->view_get_preferred_x = view_get_preferred_x;
vtable->view_set_preferred_x = view_set_preferred_x;
vtable->view_get_screen_rect = view_get_screen_rect;
vtable->view_get_panel = view_get_panel;
vtable->panel_get_view = panel_get_view;
vtable->panel_is_split = panel_is_split;
vtable->panel_is_leaf = panel_is_leaf;
vtable->panel_split = panel_split;
vtable->panel_set_split = panel_set_split;
vtable->panel_swap_children = panel_swap_children;
vtable->panel_get_root = panel_get_root;
vtable->panel_get_parent = panel_get_parent;
vtable->panel_get_child = panel_get_child;
vtable->view_close = view_close;
vtable->view_get_buffer_region = view_get_buffer_region;
vtable->view_get_buffer_scroll = view_get_buffer_scroll;
vtable->view_set_active = view_set_active;
vtable->view_enqueue_command_function = view_enqueue_command_function;
vtable->view_get_setting = view_get_setting;
vtable->view_set_setting = view_set_setting;
vtable->view_get_managed_scope = view_get_managed_scope;
vtable->buffer_compute_cursor = buffer_compute_cursor;
vtable->view_compute_cursor = view_compute_cursor;
vtable->view_set_camera_bounds = view_set_camera_bounds;
vtable->view_get_camera_bounds = view_get_camera_bounds;
vtable->view_set_cursor = view_set_cursor;
vtable->view_set_buffer_scroll = view_set_buffer_scroll;
vtable->view_set_mark = view_set_mark;
vtable->view_quit_ui = view_quit_ui;
vtable->view_set_buffer = view_set_buffer;
vtable->view_push_context = view_push_context;
vtable->view_pop_context = view_pop_context;
vtable->view_alter_context = view_alter_context;
vtable->view_current_context = view_current_context;
vtable->view_current_context_hook_memory = view_current_context_hook_memory;
vtable->create_user_managed_scope = create_user_managed_scope;
vtable->destroy_user_managed_scope = destroy_user_managed_scope;
vtable->get_global_managed_scope = get_global_managed_scope;
vtable->get_managed_scope_with_multiple_dependencies = get_managed_scope_with_multiple_dependencies;
vtable->managed_scope_clear_contents = managed_scope_clear_contents;
vtable->managed_scope_clear_self_all_dependent_scopes = managed_scope_clear_self_all_dependent_scopes;
vtable->managed_scope_allocator = managed_scope_allocator;
vtable->managed_id_group_highest_id = managed_id_group_highest_id;
vtable->managed_id_declare = managed_id_declare;
vtable->managed_id_get = managed_id_get;
vtable->managed_scope_get_attachment = managed_scope_get_attachment;
vtable->managed_scope_attachment_erase = managed_scope_attachment_erase;
vtable->alloc_managed_memory_in_scope = alloc_managed_memory_in_scope;
vtable->alloc_buffer_markers_on_buffer = alloc_buffer_markers_on_buffer;
vtable->managed_object_get_item_size = managed_object_get_item_size;
vtable->managed_object_get_item_count = managed_object_get_item_count;
vtable->managed_object_get_pointer = managed_object_get_pointer;
vtable->managed_object_get_type = managed_object_get_type;
vtable->managed_object_get_containing_scope = managed_object_get_containing_scope;
vtable->managed_object_free = managed_object_free;
vtable->managed_object_store_data = managed_object_store_data;
vtable->managed_object_load_data = managed_object_load_data;
vtable->get_next_input_raw = get_next_input_raw;
vtable->get_current_input_sequence_number = get_current_input_sequence_number;
vtable->get_current_input = get_current_input;
vtable->set_current_input = set_current_input;
vtable->leave_current_input_unhandled = leave_current_input_unhandled;
vtable->set_custom_hook = set_custom_hook;
vtable->get_custom_hook = get_custom_hook;
vtable->set_custom_hook_memory_size = set_custom_hook_memory_size;
vtable->get_mouse_state = get_mouse_state;
vtable->get_active_query_bars = get_active_query_bars;
vtable->start_query_bar = start_query_bar;
vtable->end_query_bar = end_query_bar;
vtable->clear_all_query_bars = clear_all_query_bars;
vtable->print_message = print_message;
vtable->log_string = log_string;
vtable->get_largest_face_id = get_largest_face_id;
vtable->set_global_face = set_global_face;
vtable->buffer_history_get_max_record_index = buffer_history_get_max_record_index;
vtable->buffer_history_get_record_info = buffer_history_get_record_info;
vtable->buffer_history_get_group_sub_record = buffer_history_get_group_sub_record;
vtable->buffer_history_get_current_state_index = buffer_history_get_current_state_index;
vtable->buffer_history_set_current_state_index = buffer_history_set_current_state_index;
vtable->buffer_history_merge_record_range = buffer_history_merge_record_range;
vtable->buffer_history_clear_after_current_state = buffer_history_clear_after_current_state;
vtable->global_history_edit_group_begin = global_history_edit_group_begin;
vtable->global_history_edit_group_end = global_history_edit_group_end;
vtable->buffer_set_face = buffer_set_face;
vtable->get_face_description = get_face_description;
vtable->get_face_metrics = get_face_metrics;
vtable->get_face_advance_map = get_face_advance_map;
vtable->get_face_id = get_face_id;
vtable->try_create_new_face = try_create_new_face;
vtable->try_modify_face = try_modify_face;
vtable->try_release_face = try_release_face;
vtable->push_hot_directory = push_hot_directory;
vtable->set_hot_directory = set_hot_directory;
vtable->send_exit_signal = send_exit_signal;
vtable->hard_exit = hard_exit;
vtable->set_window_title = set_window_title;
vtable->acquire_global_frame_mutex = acquire_global_frame_mutex;
vtable->release_global_frame_mutex = release_global_frame_mutex;
vtable->draw_string_oriented = draw_string_oriented;
vtable->get_string_advance = get_string_advance;
vtable->draw_rectangle = draw_rectangle;
vtable->draw_rectangle_outline = draw_rectangle_outline;
vtable->draw_set_clip = draw_set_clip;
vtable->text_layout_create = text_layout_create;
vtable->text_layout_region = text_layout_region;
vtable->text_layout_get_buffer = text_layout_get_buffer;
vtable->text_layout_get_visible_range = text_layout_get_visible_range;
vtable->text_layout_line_on_screen = text_layout_line_on_screen;
vtable->text_layout_character_on_screen = text_layout_character_on_screen;
vtable->paint_text_color = paint_text_color;
vtable->paint_text_color_blend = paint_text_color_blend;
vtable->text_layout_free = text_layout_free;
vtable->draw_text_layout = draw_text_layout;
vtable->open_color_picker = open_color_picker;
vtable->animate_in_n_milliseconds = animate_in_n_milliseconds;
vtable->buffer_find_all_matches = buffer_find_all_matches;
vtable->get_core_profile_list = get_core_profile_list;
vtable->get_custom_layer_boundary_docs = get_custom_layer_boundary_docs;
}

static void
custom_api_read_vtable(API_VTable_custom *vtable){
global_set_setting = vtable->global_set_setting;
global_get_screen_rectangle = vtable->global_get_screen_rectangle;
get_thread_context = vtable->get_thread_context;
create_child_process = vtable->create_child_process;
child_process_set_target_buffer = vtable->child_process_set_target_buffer;
buffer_get_attached_child_process = vtable->buffer_get_attached_child_process;
child_process_get_attached_buffer = vtable->child_process_get_attached_buffer;
child_process_get_state = vtable->child_process_get_state;
enqueue_virtual_event = vtable->enqueue_virtual_event;
get_buffer_count = vtable->get_buffer_count;
get_buffer_next = vtable->get_buffer_next;
get_buffer_by_name = vtable->get_buffer_by_name;
get_buffer_by_file_name = vtable->get_buffer_by_file_name;
buffer_read_range = vtable->buffer_read_range;
buffer_replace_range = vtable->buffer_replace_range;
buffer_batch_edit = vtable->buffer_batch_edit;
buffer_seek_string = vtable->buffer_seek_string;
buffer_seek_character_class = vtable->buffer_seek_character_class;
buffer_line_y_difference = vtable->buffer_line_y_difference;
buffer_line_shift_y = vtable->buffer_line_shift_y;
buffer_pos_at_relative_xy = vtable->buffer_pos_at_relative_xy;
buffer_relative_box_of_pos = vtable->buffer_relative_box_of_pos;
buffer_padded_box_of_pos = vtable->buffer_padded_box_of_pos;
buffer_relative_character_from_pos = vtable->buffer_relative_character_from_pos;
buffer_pos_from_relative_character = vtable->buffer_pos_from_relative_character;
view_line_y_difference = vtable->view_line_y_difference;
view_line_shift_y = vtable->view_line_shift_y;
view_pos_at_relative_xy = vtable->view_pos_at_relative_xy;
view_relative_box_of_pos = vtable->view_relative_box_of_pos;
view_padded_box_of_pos = vtable->view_padded_box_of_pos;
view_relative_character_from_pos = vtable->view_relative_character_from_pos;
view_pos_from_relative_character = vtable->view_pos_from_relative_character;
buffer_exists = vtable->buffer_exists;
buffer_get_access_flags = vtable->buffer_get_access_flags;
buffer_get_size = vtable->buffer_get_size;
buffer_get_line_count = vtable->buffer_get_line_count;
push_buffer_base_name = vtable->push_buffer_base_name;
push_buffer_unique_name = vtable->push_buffer_unique_name;
push_buffer_file_name = vtable->push_buffer_file_name;
buffer_get_dirty_state = vtable->buffer_get_dirty_state;
buffer_set_dirty_state = vtable->buffer_set_dirty_state;
buffer_set_layout = vtable->buffer_set_layout;
buffer_clear_layout_cache = vtable->buffer_clear_layout_cache;
buffer_get_layout = vtable->buffer_get_layout;
buffer_get_setting = vtable->buffer_get_setting;
buffer_set_setting = vtable->buffer_set_setting;
buffer_get_managed_scope = vtable->buffer_get_managed_scope;
buffer_send_end_signal = vtable->buffer_send_end_signal;
create_buffer = vtable->create_buffer;
buffer_save = vtable->buffer_save;
buffer_kill = vtable->buffer_kill;
buffer_reopen = vtable->buffer_reopen;
buffer_get_file_attributes = vtable->buffer_get_file_attributes;
get_view_next = vtable->get_view_next;
get_view_prev = vtable->get_view_prev;
get_this_ctx_view = vtable->get_this_ctx_view;
get_active_view = vtable->get_active_view;
view_exists = vtable->view_exists;
view_get_buffer = vtable->view_get_buffer;
view_get_cursor_pos = vtable->view_get_cursor_pos;
view_get_mark_pos = vtable->view_get_mark_pos;
view_get_preferred_x = vtable->view_get_preferred_x;
view_set_preferred_x = vtable->view_set_preferred_x;
view_get_screen_rect = vtable->view_get_screen_rect;
view_get_panel = vtable->view_get_panel;
panel_get_view = vtable->panel_get_view;
panel_is_split = vtable->panel_is_split;
panel_is_leaf = vtable->panel_is_leaf;
panel_split = vtable->panel_split;
panel_set_split = vtable->panel_set_split;
panel_swap_children = vtable->panel_swap_children;
panel_get_root = vtable->panel_get_root;
panel_get_parent = vtable->panel_get_parent;
panel_get_child = vtable->panel_get_child;
view_close = vtable->view_close;
view_get_buffer_region = vtable->view_get_buffer_region;
view_get_buffer_scroll = vtable->view_get_buffer_scroll;
view_set_active = vtable->view_set_active;
view_enqueue_command_function = vtable->view_enqueue_command_function;
view_get_setting = vtable->view_get_setting;
view_set_setting = vtable->view_set_setting;
view_get_managed_scope = vtable->view_get_managed_scope;
buffer_compute_cursor = vtable->buffer_compute_cursor;
view_compute_cursor = vtable->view_compute_cursor;
view_set_camera_bounds = vtable->view_set_camera_bounds;
view_get_camera_bounds = vtable->view_get_camera_bounds;
view_set_cursor = vtable->view_set_cursor;
view_set_buffer_scroll = vtable->view_set_buffer_scroll;
view_set_mark = vtable->view_set_mark;
view_quit_ui = vtable->view_quit_ui;
view_set_buffer = vtable->view_set_buffer;
view_push_context = vtable->view_push_context;
view_pop_context = vtable->view_pop_context;
view_alter_context = vtable->view_alter_context;
view_current_context = vtable->view_current_context;
view_current_context_hook_memory = vtable->view_current_context_hook_memory;
create_user_managed_scope = vtable->create_user_managed_scope;
destroy_user_managed_scope = vtable->destroy_user_managed_scope;
get_global_managed_scope = vtable->get_global_managed_scope;
get_managed_scope_with_multiple_dependencies = vtable->get_managed_scope_with_multiple_dependencies;
managed_scope_clear_contents = vtable->managed_scope_clear_contents;
managed_scope_clear_self_all_dependent_scopes = vtable->managed_scope_clear_self_all_dependent_scopes;
managed_scope_allocator = vtable->managed_scope_allocator;
managed_id_group_highest_id = vtable->managed_id_group_highest_id;
managed_id_declare = vtable->managed_id_declare;
managed_id_get = vtable->managed_id_get;
managed_scope_get_attachment = vtable->managed_scope_get_attachment;
managed_scope_attachment_erase = vtable->managed_scope_attachment_erase;
alloc_managed_memory_in_scope = vtable->alloc_managed_memory_in_scope;
alloc_buffer_markers_on_buffer = vtable->alloc_buffer_markers_on_buffer;
managed_object_get_item_size = vtable->managed_object_get_item_size;
managed_object_get_item_count = vtable->managed_object_get_item_count;
managed_object_get_pointer = vtable->managed_object_get_pointer;
managed_object_get_type = vtable->managed_object_get_type;
managed_object_get_containing_scope = vtable->managed_object_get_containing_scope;
managed_object_free = vtable->managed_object_free;
managed_object_store_data = vtable->managed_object_store_data;
managed_object_load_data = vtable->managed_object_load_data;
get_next_input_raw = vtable->get_next_input_raw;
get_current_input_sequence_number = vtable->get_current_input_sequence_number;
get_current_input = vtable->get_current_input;
set_current_input = vtable->set_current_input;
leave_current_input_unhandled = vtable->leave_current_input_unhandled;
set_custom_hook = vtable->set_custom_hook;
get_custom_hook = vtable->get_custom_hook;
set_custom_hook_memory_size = vtable->set_custom_hook_memory_size;
get_mouse_state = vtable->get_mouse_state;
get_active_query_bars = vtable->get_active_query_bars;
start_query_bar = vtable->start_query_bar;
end_query_bar = vtable->end_query_bar;
clear_all_query_bars = vtable->clear_all_query_bars;
print_message = vtable->print_message;
log_string = vtable->log_string;
get_largest_face_id = vtable->get_largest_face_id;
set_global_face = vtable->set_global_face;
buffer_history_get_max_record_index = vtable->buffer_history_get_max_record_index;
buffer_history_get_record_info = vtable->buffer_history_get_record_info;
buffer_history_get_group_sub_record = vtable->buffer_history_get_group_sub_record;
buffer_history_get_current_state_index = vtable->buffer_history_get_current_state_index;
buffer_history_set_current_state_index = vtable->buffer_history_set_current_state_index;
buffer_history_merge_record_range = vtable->buffer_history_merge_record_range;
buffer_history_clear_after_current_state = vtable->buffer_history_clear_after_current_state;
global_history_edit_group_begin = vtable->global_history_edit_group_begin;
global_history_edit_group_end = vtable->global_history_edit_group_end;
buffer_set_face = vtable->buffer_set_face;
get_face_description = vtable->get_face_description;
get_face_metrics = vtable->get_face_metrics;
get_face_advance_map = vtable->get_face_advance_map;
get_face_id = vtable->get_face_id;
try_create_new_face = vtable->try_create_new_face;
try_modify_face = vtable->try_modify_face;
try_release_face = vtable->try_release_face;
push_hot_directory = vtable->push_hot_directory;
set_hot_directory = vtable->set_hot_directory;
send_exit_signal = vtable->send_exit_signal;
hard_exit = vtable->hard_exit;
set_window_title = vtable->set_window_title;
acquire_global_frame_mutex = vtable->acquire_global_frame_mutex;
release_global_frame_mutex = vtable->release_global_frame_mutex;
draw_string_oriented = vtable->draw_string_oriented;
get_string_advance = vtable->get_string_advance;
draw_rectangle = vtable->draw_rectangle;
draw_rectangle_outline = vtable->draw_rectangle_outline;
draw_set_clip = vtable->draw_set_clip;
text_layout_create = vtable->text_layout_create;
text_layout_region = vtable->text_layout_region;
text_layout_get_buffer = vtable->text_layout_get_buffer;
text_layout_get_visible_range = vtable->text_layout_get_visible_range;
text_layout_line_on_screen = vtable->text_layout_line_on_screen;
text_layout_character_on_screen = vtable->text_layout_character_on_screen;
paint_text_color = vtable->paint_text_color;
paint_text_color_blend = vtable->paint_text_color_blend;
text_layout_free = vtable->text_layout_free;
draw_text_layout = vtable->draw_text_layout;
open_color_picker = vtable->open_color_picker;
animate_in_n_milliseconds = vtable->animate_in_n_milliseconds;
buffer_find_all_matches = vtable->buffer_find_all_matches;
get_core_profile_list = vtable->get_core_profile_list;
get_custom_layer_boundary_docs = vtable->get_custom_layer_boundary_docs;
}
# 69 "/home/sam/.bin/4coder/custom/4coder_default_include.cpp" 2

# 1 "/home/sam/.bin/4coder/custom/generated/system_api.cpp" 1
static void
system_api_fill_vtable(API_VTable_system *vtable){
vtable->get_path = system_get_path;
vtable->get_canonical = system_get_canonical;
vtable->get_file_list = system_get_file_list;
vtable->quick_file_attributes = system_quick_file_attributes;
vtable->load_handle = system_load_handle;
vtable->load_attributes = system_load_attributes;
vtable->load_file = system_load_file;
vtable->load_close = system_load_close;
vtable->save_file = system_save_file;
vtable->load_library = system_load_library;
vtable->release_library = system_release_library;
vtable->get_proc = system_get_proc;
vtable->now_time = system_now_time;
vtable->now_date_time_universal = system_now_date_time_universal;
vtable->local_date_time_from_universal = system_local_date_time_from_universal;
vtable->universal_date_time_from_local = system_universal_date_time_from_local;
vtable->wake_up_timer_create = system_wake_up_timer_create;
vtable->wake_up_timer_release = system_wake_up_timer_release;
vtable->wake_up_timer_set = system_wake_up_timer_set;
vtable->signal_step = system_signal_step;
vtable->sleep = system_sleep;
vtable->get_clipboard = system_get_clipboard;
vtable->post_clipboard = system_post_clipboard;
vtable->set_clipboard_catch_all = system_set_clipboard_catch_all;
vtable->get_clipboard_catch_all = system_get_clipboard_catch_all;
vtable->cli_call = system_cli_call;
vtable->cli_begin_update = system_cli_begin_update;
vtable->cli_update_step = system_cli_update_step;
vtable->cli_end_update = system_cli_end_update;
vtable->open_color_picker = system_open_color_picker;
vtable->get_screen_scale_factor = system_get_screen_scale_factor;
vtable->thread_launch = system_thread_launch;
vtable->thread_join = system_thread_join;
vtable->thread_free = system_thread_free;
vtable->thread_get_id = system_thread_get_id;
vtable->acquire_global_frame_mutex = system_acquire_global_frame_mutex;
vtable->release_global_frame_mutex = system_release_global_frame_mutex;
vtable->mutex_make = system_mutex_make;
vtable->mutex_acquire = system_mutex_acquire;
vtable->mutex_release = system_mutex_release;
vtable->mutex_free = system_mutex_free;
vtable->condition_variable_make = system_condition_variable_make;
vtable->condition_variable_wait = system_condition_variable_wait;
vtable->condition_variable_signal = system_condition_variable_signal;
vtable->condition_variable_free = system_condition_variable_free;
vtable->memory_allocate = system_memory_allocate;
vtable->memory_set_protection = system_memory_set_protection;
vtable->memory_free = system_memory_free;
vtable->memory_annotation = system_memory_annotation;
vtable->show_mouse_cursor = system_show_mouse_cursor;
vtable->set_fullscreen = system_set_fullscreen;
vtable->is_fullscreen = system_is_fullscreen;
vtable->get_keyboard_modifiers = system_get_keyboard_modifiers;
vtable->set_key_mode = system_set_key_mode;
}

static void
system_api_read_vtable(API_VTable_system *vtable){
system_get_path = vtable->get_path;
system_get_canonical = vtable->get_canonical;
system_get_file_list = vtable->get_file_list;
system_quick_file_attributes = vtable->quick_file_attributes;
system_load_handle = vtable->load_handle;
system_load_attributes = vtable->load_attributes;
system_load_file = vtable->load_file;
system_load_close = vtable->load_close;
system_save_file = vtable->save_file;
system_load_library = vtable->load_library;
system_release_library = vtable->release_library;
system_get_proc = vtable->get_proc;
system_now_time = vtable->now_time;
system_now_date_time_universal = vtable->now_date_time_universal;
system_local_date_time_from_universal = vtable->local_date_time_from_universal;
system_universal_date_time_from_local = vtable->universal_date_time_from_local;
system_wake_up_timer_create = vtable->wake_up_timer_create;
system_wake_up_timer_release = vtable->wake_up_timer_release;
system_wake_up_timer_set = vtable->wake_up_timer_set;
system_signal_step = vtable->signal_step;
system_sleep = vtable->sleep;
system_get_clipboard = vtable->get_clipboard;
system_post_clipboard = vtable->post_clipboard;
system_set_clipboard_catch_all = vtable->set_clipboard_catch_all;
system_get_clipboard_catch_all = vtable->get_clipboard_catch_all;
system_cli_call = vtable->cli_call;
system_cli_begin_update = vtable->cli_begin_update;
system_cli_update_step = vtable->cli_update_step;
system_cli_end_update = vtable->cli_end_update;
system_open_color_picker = vtable->open_color_picker;
system_get_screen_scale_factor = vtable->get_screen_scale_factor;
system_thread_launch = vtable->thread_launch;
system_thread_join = vtable->thread_join;
system_thread_free = vtable->thread_free;
system_thread_get_id = vtable->thread_get_id;
system_acquire_global_frame_mutex = vtable->acquire_global_frame_mutex;
system_release_global_frame_mutex = vtable->release_global_frame_mutex;
system_mutex_make = vtable->mutex_make;
system_mutex_acquire = vtable->mutex_acquire;
system_mutex_release = vtable->mutex_release;
system_mutex_free = vtable->mutex_free;
system_condition_variable_make = vtable->condition_variable_make;
system_condition_variable_wait = vtable->condition_variable_wait;
system_condition_variable_signal = vtable->condition_variable_signal;
system_condition_variable_free = vtable->condition_variable_free;
system_memory_allocate = vtable->memory_allocate;
system_memory_set_protection = vtable->memory_set_protection;
system_memory_free = vtable->memory_free;
system_memory_annotation = vtable->memory_annotation;
system_show_mouse_cursor = vtable->show_mouse_cursor;
system_set_fullscreen = vtable->set_fullscreen;
system_is_fullscreen = vtable->is_fullscreen;
system_get_keyboard_modifiers = vtable->get_keyboard_modifiers;
system_set_key_mode = vtable->set_key_mode;
}
# 71 "/home/sam/.bin/4coder/custom/4coder_default_include.cpp" 2
# 1 "/home/sam/.bin/4coder/custom/4coder_system_helpers.cpp" 1






static String_Const_u8
get_file_path_in_fonts_folder(Arena *arena, String_Const_u8 base_name){
    String_Const_u8 binary = system_get_path(arena, SystemPath_Binary);
    return(push_u8_stringf(arena, "%.*sfonts/%.*s", (i32)(binary).size, (char*)(binary).str, (i32)(base_name).size, (char*)(base_name).str));
}



Mutex_Lock::Mutex_Lock(System_Mutex m){
    system_mutex_acquire(m);
    this->mutex = m;
}

Mutex_Lock::~Mutex_Lock(){
    system_mutex_release(this->mutex);
}

Mutex_Lock::operator System_Mutex(){
    return(this->mutex);
}
# 72 "/home/sam/.bin/4coder/custom/4coder_default_include.cpp" 2
# 1 "/home/sam/.bin/4coder/custom/4coder_layout.cpp" 1






static i64
layout_nearest_pos_to_xy(Layout_Item_List list, Vec2_f32 p){
    i64 closest_match = 0;
    if (p.y < 0.f){
        closest_match = list.manifested_index_range.min;
    }
    else if (p.y >= list.height){
        closest_match = list.manifested_index_range.max;
    }
    else{
        if (0.f < p.x && p.x < max_f32){
            f32 closest_x = -max_f32;
            for (Layout_Item_Block *block = list.first;
                 block != 0;
                 block = block->next){
                i64 count = block->item_count;
                Layout_Item *item = block->items;
                for (i32 i = 0; i < count; i += 1, item += 1){
                    if ((((item->flags)&(LayoutItemFlag_Ghost_Character))!=0)){
                        continue;
                    }

                    if (p.y < item->rect.y0){
                        goto double_break;
                    }
                    if (item->padded_y1 <= p.y){
                        continue;
                    }
                    f32 dist0 = p.x - item->rect.x0;
                    f32 dist1 = item->rect.x1 - p.x;
                    if (dist0 >= 0.f && dist1 > 0.f){
                        closest_match = item->index;
                        goto double_break;
                    }



                    f32 neg_dist = (((dist0)<(dist1))?(dist0):(dist1));
                    if (closest_x < neg_dist){
                        closest_x = neg_dist;
                        closest_match = item->index;
                    }
                }
            }
            double_break:;
        }
        else{

            if (p.x == max_f32){
                Layout_Item *prev_item = 0;
                for (Layout_Item_Block *block = list.first;
                     block != 0;
                     block = block->next){
                    i64 count = block->item_count;
                    Layout_Item *item = block->items;
                    for (i32 i = 0; i < count; i += 1, item += 1){
                        if ((((item->flags)&(LayoutItemFlag_Ghost_Character))!=0)){
                            continue;
                        }
                        if (p.y < item->rect.y0){
                            goto double_break_2;
                        }
                        prev_item = item;
                        if (item->padded_y1 <= p.y){
                            continue;
                        }
                    }
                }

                double_break_2:;
                if (prev_item != 0){
                    closest_match = prev_item->index;
                }
                else{
                    closest_match = list.manifested_index_range.max;
                }
            }
            else{
                Layout_Item *closest_item = 0;
                for (Layout_Item_Block *block = list.first;
                     block != 0;
                     block = block->next){
                    i64 count = block->item_count;
                    Layout_Item *item = block->items;
                    for (i32 i = 0; i < count; i += 1, item += 1){
                        if ((((item->flags)&(LayoutItemFlag_Ghost_Character))!=0)){
                            continue;
                        }

                        if (p.y < item->rect.y0){
                            goto double_break_3;
                        }
                        if (item->padded_y1 <= p.y){
                            continue;
                        }
                        closest_item = item;
                        goto double_break_3;
                    }
                }

                double_break_3:;
                if (closest_item != 0){
                    closest_match = closest_item->index;
                }
                else{
                    closest_match = list.manifested_index_range.min;
                }
            }

        }
    }
    return(closest_match);
}

static Layout_Item*
layout_get_first_with_index(Layout_Item_List list, i64 index){
    Layout_Item *result = 0;
    Layout_Item *prev = 0;
    for (Layout_Item_Block *block = list.first;
         block != 0;
         block = block->next){
        i64 count = block->item_count;
        Layout_Item *item = block->items;
        for (i32 i = 0; i < count; i += 1, item += 1){
            if ((((item->flags)&(LayoutItemFlag_Ghost_Character))!=0)){
                continue;
            }
            if (item->index > index){
                result = prev;
                goto done;
            }
            if (item->index == index){
                result = item;
                goto done;
            }
            prev = item;
        }
    }
    if (result == 0){
        result = prev;
    }
    done:;
    return(result);
}

static Rect_f32
layout_box_of_pos(Layout_Item_List list, i64 index){
    Rect_f32 result = {};
    Layout_Item *item = layout_get_first_with_index(list, index);
    if (item != 0){
        result = item->rect;
    }
    return(result);
}

static Rect_f32
layout_padded_box_of_pos(Layout_Item_List list, i64 index){
    Rect_f32 result = {};
    Layout_Item *item = layout_get_first_with_index(list, index);
    if (item != 0){
        result.x0 = item->rect.x0;
        result.y0 = item->rect.y0;
        result.x1 = item->rect.x1;
        result.y1 = item->padded_y1;
    }
    return(result);
}

static i64
layout_get_pos_at_character(Layout_Item_List list, i64 character){
    i64 result = 0;
    if (character <= 0){
        result = list.manifested_index_range.min;
    }
    else if (character >= list.character_count){
        result = list.manifested_index_range.max;
    }
    else{
        i64 counter = 0;
        i64 next_counter = 0;
        for (Layout_Item_Block *node = list.first;
             node != 0;
             node = node->next, counter = next_counter){
            next_counter = counter + node->character_count;
            if (character >= next_counter){
                continue;
            }

            i64 count = node->item_count;
            i64 relative_character = character - counter;
            i64 relative_character_counter = 0;

            Layout_Item *item = node->items;
            for (i64 i = 0; i < count; i += 1, item += 1){
                if ((((item->flags)&(LayoutItemFlag_Ghost_Character))!=0)){
                    continue;
                }
                if (relative_character_counter == relative_character){
                    result = item->index;
                    break;
                }
                relative_character_counter += 1;
            }

            break;
        }
    }
    return(result);
}

static i64
layout_character_from_pos(Layout_Item_List list, i64 index){
    i64 result = 0;
    i64 prev_index = -1;
    if (index <= list.manifested_index_range.first){
        result = 0;
    }
    else if (index > list.manifested_index_range.one_past_last){
        result = list.character_count - 1;
    }
    else{
        for (Layout_Item_Block *node = list.first;
             node != 0;
             node = node->next){
            Layout_Item *item = node->items;
            i64 count = node->item_count;
            for (i64 i = 0; i < count; i += 1, item += 1){
                if (item->index >= index){
                    goto double_break;
                }
                if (item->index > prev_index){
                    prev_index = item->index;
                    result += 1;
                }
            }
        }
    }
    double_break:;
    return(result);
}
# 73 "/home/sam/.bin/4coder/custom/4coder_default_include.cpp" 2
# 1 "/home/sam/.bin/4coder/custom/4coder_profile.cpp" 1






static void
profile_init(Profile_Global_List *list){
    list->mutex = system_mutex_make();
    list->node_arena = make_arena_system(((4) << 10));
    list->disable_bits = ProfileEnable_UserBit;
}

static Profile_Thread*
prof__get_thread(Profile_Global_List *list, i32 thread_id){
    Profile_Thread *result = 0;
    for (Profile_Thread *node = list->first_thread;
         node != 0;
         node = node->next){
        if (thread_id == node->thread_id){
            result = node;
            break;
        }
    }
    if (result == 0){
        result = ((Profile_Thread*)linalloc_wrap_zero(linalloc_push((&list->node_arena), sizeof(Profile_Thread)*(1), SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_profile.cpp" ":" "26" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_profile.cpp" ":" "26" ":") - 1)))));
        do{ if((result)){if((list->first_thread)){(list->last_thread)->next=(result);}else{(list->first_thread)=(result);}(list->last_thread)=(result);(list->last_thread)->next=0;} }while(0);
        list->thread_count += 1;
        result->thread_id = thread_id;
    }
    return(result);
}

static void
profile_clear(Profile_Global_List *list){
    Mutex_Lock lock(list->mutex);
    for (Arena_Node *node = list->first_arena;
         node != 0;
         node = node->next){
        linalloc_clear(&node->arena);
    }
    list->first_arena = 0;
    list->last_arena = 0;

    linalloc_clear(&list->node_arena);
    list->first_thread = 0;
    list->last_thread = 0;
    list->thread_count = 0;
}

static void
profile_thread_flush(Thread_Context *tctx, Profile_Global_List *list){
    if (tctx->prof_record_count > 0){
        Mutex_Lock lock(list->mutex);
        if (list->disable_bits == 0){
            Profile_Thread* thread = prof__get_thread(list, system_thread_get_id());

            Arena_Node* node = ((Arena_Node*)linalloc_wrap_unintialized(linalloc_push((&list->node_arena), sizeof(Arena_Node)*(1), SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_profile.cpp" ":" "58" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_profile.cpp" ":" "58" ":") - 1)))));
            do{ if((node)){if((list->first_arena)){(list->last_arena)->next=(node);}else{(list->first_arena)=(node);}(list->last_arena)=(node);(list->last_arena)->next=0;} }while(0);
            node->arena = tctx->prof_arena;
            tctx->prof_arena = make_arena_system(((16) << 10));

            if (tctx->prof_first != 0){
            if (thread->first_record == 0){
                thread->first_record = tctx->prof_first;
                thread->last_record = tctx->prof_last;
            }
            else{
                thread->last_record->next = tctx->prof_first;
                thread->last_record = tctx->prof_last;
            }
            thread->record_count += tctx->prof_record_count;
            }
        }
        else{
            linalloc_clear(&tctx->prof_arena);
        }
        tctx->prof_record_count = 0;
        tctx->prof_first = 0;
        tctx->prof_last = 0;
    }
}

static void
profile_thread_set_name(Thread_Context *tctx, Profile_Global_List *list, String_Const_u8 name){
    Mutex_Lock lock(list->mutex);
    Profile_Thread* thread = prof__get_thread(list, system_thread_get_id());
    thread->name = name;
}



static void
profile_set_enabled(Profile_Global_List *list, b32 value, Profile_Enable_Flag flag){
    Mutex_Lock lock(list->mutex);
    if (value){
        ((list->disable_bits)&=(~(flag)));
    }
    else{
        ((list->disable_bits)|=(flag));
    }
}

static void
thread_profile_record__inner(Thread_Context *tctx, Profile_ID id, u64 time,
                             String_Const_u8 name, String_Const_u8 location){
    Profile_Record *record = ((Profile_Record*)linalloc_wrap_zero(linalloc_push((&tctx->prof_arena), sizeof(Profile_Record)*(1), SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_profile.cpp" ":" "107" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_profile.cpp" ":" "107" ":") - 1)))));
    do{ if((record)){if((tctx->prof_first)){(tctx->prof_last)->next=(record);}else{(tctx->prof_first)=(record);}(tctx->prof_last)=(record);(tctx->prof_last)->next=0;} }while(0);
    tctx->prof_record_count += 1;
    record->id = id;
    record->time = time;
    record->location = location;
    record->name = name;
}

static Profile_ID
thread_profile_record_push(Thread_Context *tctx, u64 time,
                           String_Const_u8 name, String_Const_u8 location){
    Profile_ID id = tctx->prof_id_counter;
    tctx->prof_id_counter += 1;
    thread_profile_record__inner(tctx, id, time, name, location);
    return(id);
}
static void
thread_profile_record_pop(Thread_Context *tctx, u64 time, Profile_ID id){
    do{ if (!(tctx->prof_id_counter > 1)) { (*((i32*)0) = 0xA11E); } }while(0);
    tctx->prof_id_counter = id;
    thread_profile_record__inner(tctx, id, time, SCu8(""), SCu8(""));
}

static Profile_ID
thread_profile_record_push(Application_Links *app, u64 time,
                           String_Const_u8 name, String_Const_u8 location){
    Thread_Context *tctx = get_thread_context(app);
    return(thread_profile_record_push(tctx, time, name, location));
}
static void
thread_profile_record_pop(Application_Links *app, u64 time, Profile_ID id){
    Thread_Context *tctx = get_thread_context(app);
    thread_profile_record_pop(tctx, time, id);
}



static void
profile_block__init(Thread_Context *tctx, Profile_Global_List *list,
                    String_Const_u8 name, String_Const_u8 location, Profile_Block *block){
    block->tctx = tctx;
    block->list = list;
    block->is_closed = false;
    block->id = thread_profile_record_push(tctx, system_now_time(), name, location);
}
static void
profile_block__init(Thread_Context *tctx, Profile_Global_List *list,
                    String_Const_u8 name, String_Const_u8 location,
                    Profile_Scope_Block *block){
    block->tctx = tctx;
    block->list = list;
    block->is_closed = false;
    block->id = thread_profile_record_push(tctx, system_now_time(), name, location);
}



Profile_Block::Profile_Block(Thread_Context *tctx, Profile_Global_List *list,
                             String_Const_u8 name, String_Const_u8 location){
    profile_block__init(tctx, list, name, location, this);
}
Profile_Block::Profile_Block(Application_Links *app, String_Const_u8 name,
                             String_Const_u8 location){
    Thread_Context *v_tctx = get_thread_context(app);
    Profile_Global_List *v_list = get_core_profile_list(app);
    profile_block__init(v_tctx, v_list, name, location, this);
}
Profile_Block::~Profile_Block(){
    this->close_now();
}
void
Profile_Block::close_now(){
    if (!this->is_closed){
        thread_profile_record_pop(this->tctx, system_now_time(), this->id);
        this->is_closed = true;
    }
}



Profile_Scope_Block::Profile_Scope_Block(Thread_Context *tctx, Profile_Global_List *list,
                                         String_Const_u8 name, String_Const_u8 location){
    profile_block__init(tctx, list, name, location, this);
}
Profile_Scope_Block::Profile_Scope_Block(Application_Links *app, String_Const_u8 name,
                                         String_Const_u8 location){
    Thread_Context *v_tctx = get_thread_context(app);
    Profile_Global_List *v_list = get_core_profile_list(app);
    profile_block__init(v_tctx, v_list, name, location, this);
}
Profile_Scope_Block::~Profile_Scope_Block(){
    this->close_now();
    profile_thread_flush(this->tctx, this->list);
}
void
Profile_Scope_Block::close_now(){
    if (!this->is_closed){
        thread_profile_record_pop(this->tctx, system_now_time(), this->id);
        this->is_closed = true;
    }
}



CUSTOM_COMMAND(profile_enable, "/home/sam/.bin/4coder/custom/4coder_profile.cpp", 212, Normal)
CUSTOM_DOC("Allow 4coder's self profiler to gather new profiling information.")
{
    Profile_Global_List *list = get_core_profile_list(app);
    profile_set_enabled(list, true, ProfileEnable_UserBit);
}

CUSTOM_COMMAND(profile_disable, "/home/sam/.bin/4coder/custom/4coder_profile.cpp", 219, Normal)
CUSTOM_DOC("Prevent 4coder's self profiler from gathering new profiling information.")
{
    Profile_Global_List *list = get_core_profile_list(app);
    profile_set_enabled(list, false, ProfileEnable_UserBit);
}

CUSTOM_COMMAND(profile_clear, "/home/sam/.bin/4coder/custom/4coder_profile.cpp", 226, Normal)
CUSTOM_DOC("Clear all profiling information from 4coder's self profiler.")
{
    Profile_Global_List *list = get_core_profile_list(app);
    profile_clear(list);
}
# 74 "/home/sam/.bin/4coder/custom/4coder_default_include.cpp" 2
# 1 "/home/sam/.bin/4coder/custom/4coder_profile_static_enable.cpp" 1
# 75 "/home/sam/.bin/4coder/custom/4coder_default_include.cpp" 2
# 1 "/home/sam/.bin/4coder/custom/4coder_events.cpp" 1






static b32
has_modifier(Key_Code *mods, i32 count, Key_Code modifier){
    b32 result = false;
    for (i32 i = 0; i < count; i += 1){
        if (mods[i] == modifier){
            result = true;
            break;
        }
    }
    return(result);
}

static b32
has_modifier(Input_Modifier_Set_Fixed *set, Key_Code modifier){
    return(has_modifier(set->mods, set->count, modifier));
}

static b32
has_modifier(Input_Modifier_Set *set, Key_Code modifier){
    return(has_modifier(set->mods, set->count, modifier));
}

static Input_Modifier_Set
copy_modifier_set(Arena *arena, Input_Modifier_Set_Fixed *set){
    Input_Modifier_Set result = {};
    result.count = set->count;
    if (result.count > 0){
        result.mods = ((Key_Code*)linalloc_wrap_write(linalloc_push((arena), sizeof(Key_Code)*(result.count), SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_events.cpp" ":" "34" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_events.cpp" ":" "34" ":") - 1))), sizeof(Key_Code)*(result.count), (set->mods)));
    }
    return(result);
}

static void
copy_modifier_set(Input_Modifier_Set_Fixed *dst, Input_Modifier_Set *set){
    i32 count = (((set->count)<(((sizeof(dst->mods))/(sizeof(*dst->mods)))))?(set->count):(((sizeof(dst->mods))/(sizeof(*dst->mods)))));
    dst->count = count;
    block_copy(dst->mods, set->mods, count*sizeof(*set->mods));
}

static void
add_modifier(Input_Modifier_Set_Fixed *set, Key_Code mod){
    if (!has_modifier(set, mod)){
        if (set->count < ((sizeof(set->mods))/(sizeof(*set->mods)))){
            set->mods[set->count] = mod;
            set->count += 1;
        }
    }
}

static void
remove_modifier(Input_Modifier_Set_Fixed *set, Key_Code mod){
    i32 count = set->count;
    Key_Code *mods = set->mods;
    for (i32 i = 0; i < count; i += 1){
        if (mods[i] == mod){
            i32 new_count = count - 1;
            mods[i] = mods[new_count];
            set->count = new_count;
            break;
        }
    }
}

static void
set_modifier(Input_Modifier_Set_Fixed *set, Key_Code mod, b32 val){
    if (val){
        add_modifier(set, mod);
    }
    else{
        remove_modifier(set, mod);
    }
}

static Input_Modifier_Set
copy_modifier_set(Arena *arena, Input_Modifier_Set *set){
    Input_Modifier_Set result = {};
    result.count = set->count;
    if (result.count > 0){
        result.mods = ((Key_Code*)linalloc_wrap_write(linalloc_push((arena), sizeof(Key_Code)*(result.count), SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_events.cpp" ":" "85" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_events.cpp" ":" "85" ":") - 1))), sizeof(Key_Code)*(result.count), (set->mods)));
    }
    return(result);
}

static Input_Modifier_Set*
get_modifiers(Input_Event *event){
    Input_Modifier_Set *result = 0;
    switch (event->kind){
        case InputEventKind_KeyStroke:
        {
            result = &event->key.modifiers;
        }break;
        case InputEventKind_MouseButton:
        {
            result = &event->mouse.modifiers;
        }break;
        case InputEventKind_MouseWheel:
        {
            result = &event->mouse_wheel.modifiers;
        }break;
        case InputEventKind_MouseMove:
        {
            result = &event->mouse_move.modifiers;
        }break;
    }
    return(result);
}

static b32
has_modifier(Input_Event *event, Key_Code modifier){
    Input_Modifier_Set *set = get_modifiers(event);
    return(has_modifier(set, modifier));
}

static b32
is_unmodified_key(Input_Event *event){
    b32 result = false;
    if (event->kind == InputEventKind_KeyStroke){
        Input_Modifier_Set *set = get_modifiers(event);
        result = (!has_modifier(set, KeyCode_Control) &&
                  !has_modifier(set, KeyCode_Alt) &&
                  !has_modifier(set, KeyCode_Shift) &&
                  !has_modifier(set, KeyCode_Command));
    }
    return(result);
}

static b32
is_modified(Input_Event *event){
    Input_Modifier_Set *mods = get_modifiers(event);
    b32 result = false;
    if (mods != 0){
        result = (mods->count > 0);
    }
    return(result);
}

static b32
event_is_dead_key(Input_Event *event){
    return(event->kind == InputEventKind_KeyStroke && (((event->key.flags)&(KeyFlag_IsDeadKey))!=0));
}

static Input_Event
event_next_text_event(Input_Event *event){
    Input_Event result = {};
    if (event != 0){
        if (event->kind == InputEventKind_KeyStroke &&
            event->key.first_dependent_text != 0){
            block_copy((&result), (event->key.first_dependent_text), sizeof(*(&result)));
        }
        else if (event->kind == InputEventKind_TextInsert &&
                 event->text.next_text != 0){
            block_copy((&result), (event->text.next_text), sizeof(*(&result)));
        }
    }
    return(result);
}

static String_Const_u8
to_writable(Input_Event *event){
    String_Const_u8 result = {};
    if (event->kind == InputEventKind_TextInsert){
        result = event->text.string;
    }
    return(result);
}

static b32
match_key_code(Input_Event *event, Key_Code code){
    return(event->kind == InputEventKind_KeyStroke && event->key.code == code);
}

static b32
match_mouse_code(Input_Event *event, Mouse_Code code){
    return(event->kind == InputEventKind_MouseButton && event->mouse.code == code);
}

static b32
match_mouse_code_release(Input_Event *event, Mouse_Code code){
    return(event->kind == InputEventKind_MouseButtonRelease && event->mouse.code == code);
}

static b32
match_core_code(Input_Event *event, Core_Code code){
    return(event->kind == InputEventKind_Core && event->core.code == code);
}

static Event_Property
get_event_properties(Input_Event *event){
    Event_Property flags = 0;

    switch (event->kind){
        case InputEventKind_TextInsert:
        {
            flags |= EventProperty_TextInsert;
        }break;

        case InputEventKind_KeyStroke:
        {
            if (event->key.code == KeyCode_Escape){
                flags |= EventProperty_Escape;
            }
            flags |= EventProperty_AnyKey;
        }break;

        case InputEventKind_KeyRelease:
        {
            flags |= EventProperty_AnyKeyRelease;
        }break;

        case InputEventKind_MouseButton:
        {
            flags |= EventProperty_MouseButton;
        }break;

        case InputEventKind_MouseButtonRelease:
        {
            flags |= EventProperty_MouseRelease;
        }break;

        case InputEventKind_MouseWheel:
        {
            flags |= EventProperty_MouseWheel;
        }break;

        case InputEventKind_MouseMove:
        {
            flags |= EventProperty_MouseMove;
        }break;

        case InputEventKind_Core:
        {
            switch (event->core.code){
                case CoreCode_Animate:
                {
                    flags |= EventProperty_Animate;
                }break;

                case CoreCode_ClickActivateView:
                case CoreCode_ClickDeactivateView:
                {
                    flags |= EventProperty_ViewActivation;
                }break;

                case CoreCode_FileExternallyModified:
                {
                    flags |= EventProperty_AnyFile;
                }break;

                case CoreCode_Startup:
                {
                    flags |= EventProperty_Startup;
                }break;

                case CoreCode_TryExit:
                {
                    flags |= EventProperty_Exit;
                }break;

                case CoreCode_NewClipboardContents:
                {
                    flags |= EventProperty_Clipboard;
                }break;
            }
        }break;

        case InputEventKind_CustomFunction:
        {
            flags |= EventProperty_CustomFunction;
        }break;
    }

    return(flags);
}

static Input_Event*
push_input_event(Arena *arena, Input_List *list){
    Input_Event_Node *node = ((Input_Event_Node*)linalloc_wrap_zero(linalloc_push((arena), sizeof(Input_Event_Node)*(1), SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_events.cpp" ":" "283" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_events.cpp" ":" "283" ":") - 1)))));
    do{ if((node)){if((list->first)){(list->last)->next=(node);}else{(list->first)=(node);}(list->last)=(node);(list->last)->next=0;} }while(0);
    list->count += 1;
    return(&node->event);
}

static Input_Event*
push_input_event(Arena *arena, Input_List *list, Input_Event *event){
    Input_Event_Node *node = ((Input_Event_Node*)linalloc_wrap_unintialized(linalloc_push((arena), sizeof(Input_Event_Node)*(1), SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_events.cpp" ":" "291" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_events.cpp" ":" "291" ":") - 1)))));
    block_copy((&node->event), (event), sizeof(*(&node->event)));
    do{ if((node)){if((list->first)){(list->last)->next=(node);}else{(list->first)=(node);}(list->last)=(node);(list->last)->next=0;} }while(0);
    list->count += 1;
    return(&node->event);
}

static Input_Event
copy_input_event(Arena *arena, Input_Event *event){
    Input_Event result = *event;
    switch (result.kind){
        case InputEventKind_TextInsert:
        {
            result.text.string = push_string_copy(arena, event->text.string);
        }break;

        case InputEventKind_KeyStroke:
        case InputEventKind_KeyRelease:
        {
            result.key.modifiers = copy_modifier_set(arena, &event->key.modifiers);
        }break;

        case InputEventKind_MouseButton:
        case InputEventKind_MouseButtonRelease:
        {
            result.mouse.modifiers = copy_modifier_set(arena, &event->mouse.modifiers);
        }break;

        case InputEventKind_MouseWheel:
        {
            result.mouse_wheel.modifiers = copy_modifier_set(arena, &event->mouse_wheel.modifiers);
        }break;

        case InputEventKind_MouseMove:
        {
            result.mouse_move.modifiers = copy_modifier_set(arena, &event->mouse_move.modifiers);
        }break;

        case InputEventKind_Core:
        {
            switch (result.core.code){
                case CoreCode_Startup:
                {
                    result.core.flag_strings = push_string_array_copy(arena, event->core.flag_strings);
                    result.core.file_names = push_string_array_copy(arena, event->core.file_names);
                }break;

                case CoreCode_FileExternallyModified:
                case CoreCode_NewClipboardContents:
                {
                    result.core.string = push_string_copy(arena, event->core.string);
                }break;
            }
        }break;
    }
    return(result);
}



static String_Const_u8
stringize_keyboard_event(Arena *arena, Input_Event *event){
    List_String_Const_u8 list = {};

    switch (event->kind){
        case InputEventKind_TextInsert:
        {
            string_list_push(arena, &list, SCu8((u8*)("t"), (u64)(sizeof("t") - 1)));
            u64 size = event->text.string.size;
            u8 *ptr = event->text.string.str;
            for (u64 i = 0; i < size; i += 1, ptr += 1){
                string_list_pushf(arena, &list, "%02X", (i32)(*ptr));
            }
            string_list_push(arena, &list, SCu8((u8*)("\n"), (u64)(sizeof("\n") - 1)));
        }break;

        case InputEventKind_KeyStroke:
        case InputEventKind_KeyRelease:
        {
            string_list_pushf(arena, &list, "k%X ", event->key.code);
            if (event->kind == InputEventKind_KeyRelease){
                string_list_push(arena, &list, SCu8((u8*)("^"), (u64)(sizeof("^") - 1)));
            }
            i32 count = event->key.modifiers.count;
            if (count > 0){
                Key_Code *m = event->key.modifiers.mods;
                string_list_push(arena, &list, SCu8((u8*)("m{"), (u64)(sizeof("m{") - 1)));
                for (i32 i = 0; i < count; i += 1, m += 1){
                    string_list_pushf(arena, &list, "%X ", *m);
                }
                string_list_push(arena, &list, SCu8((u8*)("}"), (u64)(sizeof("}") - 1)));
            }
            string_list_push(arena, &list, SCu8((u8*)("\n"), (u64)(sizeof("\n") - 1)));
        }break;
    }

    return(string_list_flatten(arena, list));
}

static Input_Event
parse_keyboard_event(Arena *arena, String_Const_u8 text){
    Input_Event result = {};
    u64 pos = 0;
    Range_i64 range = {};

    if (pos < text.size && text.str[pos] == 't'){
        pos += 1;
        result.kind = InputEventKind_TextInsert;

        u64 max_size = text.size/2;
        result.text.string.str = ((u8*)linalloc_wrap_unintialized(linalloc_push((arena), sizeof(u8)*(max_size), SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_events.cpp" ":" "401" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_events.cpp" ":" "401" ":") - 1)))));
        for (; pos + 1 < text.size; pos += 2){
            if (character_is_base16(text.str[pos]) &&
                character_is_base16(text.str[pos + 1])){
                String_Const_u8 byte_str = {text.str + pos, 2};
                result.text.string.str[result.text.string.size] = (u8)string_to_integer(byte_str, 16);
                result.text.string.size += 1;
            }
        }
    }
    else if (pos < text.size && text.str[pos] == 'k'){
        pos += 1;
        result.kind = InputEventKind_KeyStroke;

        range.first = pos;
        for (;pos < text.size && character_is_base16(text.str[pos]); pos += 1);
        range.one_past_last = pos;

        if (range.first == range.one_past_last){
            result.kind = InputEventKind_None;
        }
        else{
            String_Const_u8 code_str = string_substring(text, range);
            result.key.code = (u32)string_to_integer(code_str, 16);

            for (;pos < text.size && character_is_whitespace(text.str[pos]); pos += 1);

            if (pos < text.size && text.str[pos] == '^'){
                result.kind = InputEventKind_KeyRelease;
                pos += 1;
                for (;pos < text.size && character_is_whitespace(text.str[pos]); pos += 1);
            }

            if (pos < text.size && text.str[pos] == 'm'){
                pos += 1;
                if (pos < text.size && text.str[pos] == '{'){
                    pos += 1;

                    Input_Modifier_Set_Fixed mods = {};
                    for (;mods.count < ((sizeof(mods.mods))/(sizeof(*mods.mods)));){
                        for (;pos < text.size && character_is_whitespace(text.str[pos]); pos += 1);
                        range.first = pos;
                        for (;pos < text.size && character_is_base16(text.str[pos]); pos += 1);
                        range.one_past_last = pos;

                        if (range.first == range.one_past_last){
                            break;
                        }

                        code_str = string_substring(text, range);
                        mods.mods[mods.count] = (u32)string_to_integer(code_str, 16);
                        mods.count += 1;
                    }

                    result.key.modifiers = copy_modifier_set(arena, &mods);
                }
            }
        }
    }

    return(result);
}
# 76 "/home/sam/.bin/4coder/custom/4coder_default_include.cpp" 2
# 1 "/home/sam/.bin/4coder/custom/4coder_custom.cpp" 1






extern "C" b32
get_version(i32 maj, i32 min, i32 patch){
    return(maj == 4 && min == 1 && patch == 6);
}

extern "C" Custom_Layer_Init_Type*
init_apis(API_VTable_custom *custom_vtable, API_VTable_system *system_vtable){
    custom_api_read_vtable(custom_vtable);
    system_api_read_vtable(system_vtable);
    return(custom_layer_init);
}
# 77 "/home/sam/.bin/4coder/custom/4coder_default_include.cpp" 2
# 1 "/home/sam/.bin/4coder/custom/4coder_log.cpp" 1
# 15 "/home/sam/.bin/4coder/custom/4coder_log.cpp"
static String_Const_u8
log_event(Arena *arena, String_Const_u8 event_name, String_Const_u8 src_name, i32 line_number, i32 buffer, i32 view, i32 thread_id){
    List_String_Const_u8 list = {};
    string_list_pushf(arena, &list, "%.*s:%d: %.*s",
                      (i32)(src_name).size, (char*)(src_name).str, line_number, (i32)(event_name).size, (char*)(event_name).str);
    if (thread_id != 0){
        string_list_pushf(arena, &list, " [thread=%d]", thread_id);
    }
    if (buffer != 0){
        string_list_pushf(arena, &list, " [buffer=%d]", buffer);
    }
    if (view != 0){
        string_list_pushf(arena, &list, " [view=%d]", view);
    }
    string_list_push(arena, &list, SCu8((u8*)("\n"), (u64)(sizeof("\n") - 1)));
    return(string_list_flatten(arena, list));
}
# 78 "/home/sam/.bin/4coder/custom/4coder_default_include.cpp" 2
# 1 "/home/sam/.bin/4coder/custom/4coder_hash_functions.cpp" 1
# 15 "/home/sam/.bin/4coder/custom/4coder_hash_functions.cpp"
static u64
table_hash_u8(u8 *v, u64 size){
    u64 hash = 0;
    for (u8 *p = v, *e = v + size; p < e; p += 1){
        u8 k = *p;
        k *= 81;
        k = ((u8)(k << 4)) | ((u8)(k >> 4));
        hash ^= k;
        hash *= 11;
        hash += 237;
    }
    return(hash);
}
static u64
table_hash_u16(u16 *v, u64 size){
    u64 hash = 0;
    for (u16 *p = v, *e = v + size; p < e; p += 1){
        u16 k = *p;
        k *= 11601;
        k = ((u16)(k << 8)) | ((u16)(k >> 8));
        hash ^= k;
        hash *= 11;
        hash += 12525;
    }
    return(hash);
}
static u64
table_hash_u32(u32 *v, u64 size){
    u64 hash = 0;
    for (u32 *p = v, *e = v + size; p < e; p += 1){
        u32 k = *p;
        k *= 3432918353U;
        k = ((u32)(k << 16)) | ((u32)(k >> 16));
        hash ^= k;
        hash *= 11;
        hash += 2041000173U;
    }
    return(hash);
}
static u64
table_hash_u64(u64 *v, u64 size){
    u64 hash = 0;
    for (u64 *p = v, *e = v + size; p < e; p += 1){
        u64 k = *p;
        k *= 14744272059406101841ULL;
        k = ((u64)(k << 32)) | ((u64)(k >> 32));
        hash ^= k;
        hash *= 11;
        hash += 8766028991911375085ULL;
    }
    return(hash);
}
static u64
table_hash(void *v, i32 it_size, u64 size){
    u64 hash = 0;
    switch (it_size){
        case 1:
        {
            hash = table_hash_u8((u8*)v, size);
        }break;
        case 2:
        {
            hash = table_hash_u16((u16*)v, size);
        }break;
        case 4:
        {
            hash = table_hash_u32((u32*)v, size);
        }break;
        case 8:
        {
            hash = table_hash_u64((u64*)v, size);
        }break;
        default:
        {
            hash = table_hash_u8((u8*)v, it_size*size);
        }break;
    }
    return(hash);
}
# 79 "/home/sam/.bin/4coder/custom/4coder_default_include.cpp" 2
# 1 "/home/sam/.bin/4coder/custom/4coder_table.cpp" 1






static u64
table_hash(Data key){
    return(table_hash_u8((u8*)key.data, key.size) | bit_64);
}

static const u64 table_empty_slot = 0;
static const u64 table_erased_slot = 1;

static const u64 table_empty_key = 0;
static const u64 table_erased_key = max_u64;

static const u32 table_empty_u32_key = 0;
static const u32 table_erased_u32_key = max_u32;



static Table_u64_u64
make_table_u64_u64__inner(Base_Allocator *allocator, u32 slot_count, String_Const_u8 location){
    Table_u64_u64 table = {};
    table.allocator = allocator;
    slot_count = (((8)>(slot_count))?(8):(slot_count));
    Data mem = base_allocate__inner(allocator, slot_count*(sizeof(*table.keys) + sizeof(*table.vals)), location);
    block_zero(mem.data, mem.size);
    table.memory = mem.data;
    table.keys = (u64*)table.memory;
    table.vals = (u64*)(table.keys + slot_count);
    table.slot_count = slot_count;
    table.used_count = 0;
    table.dirty_count = 0;
    return(table);
}



static void
table_free(Table_u64_u64 *table){
    base_free(table->allocator, table->memory);
    block_zero((table), sizeof(*(table)));
}

static Table_Lookup
table_lookup(Table_u64_u64 *table, u64 key){
    Table_Lookup result = {};

    if (key != table_empty_key && key != table_erased_key &&
        table->slot_count > 0){
        u64 *keys = table->keys;
        u32 slot_count = table->slot_count;

        u32 first_index = key % slot_count;
        u32 index = first_index;
        result.hash = key;
        for (;;){
            if (key == keys[index]){
                result.index = index;
                result.found_match = true;
                result.found_empty_slot = false;
                result.found_erased_slot = false;
                break;
            }
            if (table_empty_key == keys[index]){
                if (!result.found_erased_slot){
                    result.index = index;
                    result.found_empty_slot = true;
                }
                break;
            }
            if (table_erased_key == keys[index]){
                if (!result.found_erased_slot){
                    result.index = index;
                    result.found_erased_slot = true;
                }
            }
            index += 1;
            if (index >= slot_count){
                index = 0;
            }
            if (index == first_index){
                break;
            }
        }
    }

    return(result);
}

static b32
table_read(Table_u64_u64 *table, Table_Lookup lookup, u64 *val_out){
    b32 result = false;
    if (lookup.found_match){
        *val_out = table->vals[lookup.index];
        result = true;
    }
    return(result);
}

static b32
table_read(Table_u64_u64 *table, u64 key, u64 *val_out){
    Table_Lookup lookup = table_lookup(table, key);
    return(table_read(table, lookup, val_out));
}

static void
table_insert__inner(Table_u64_u64 *table, Table_Lookup lookup, u64 val){
    do{ if (!(lookup.found_empty_slot || lookup.found_erased_slot)) { (*((i32*)0) = 0xA11E); } }while(0);
    table->keys[lookup.index] = lookup.hash;
    table->vals[lookup.index] = val;
    table->used_count += 1;
    if (lookup.found_empty_slot){
        table->dirty_count += 1;
    }
}

static b32
table_rehash(Table_u64_u64 *dst, Table_u64_u64 *src){
    b32 result = false;
    u32 src_slot_count = src->slot_count;
    if ((dst->dirty_count + src->used_count)*8 < dst->slot_count*7){
        u64 *src_keys = src->keys;
        for (u32 i = 0; i < src_slot_count; i += 1){
            u64 key = src_keys[i];
            if (key != table_empty_key &&
                key != table_erased_key){
                Table_Lookup lookup = table_lookup(dst, key);
                table_insert__inner(dst, lookup, src->vals[i]);
            }
        }
        result = true;
    }
    return(result);
}

static b32
table_insert(Table_u64_u64 *table, u64 key, u64 val){
    b32 result = false;
    if (key != table_empty_key && key != table_erased_key){
        Table_Lookup lookup = table_lookup(table, key);
        if (!lookup.found_match){
            if ((table->dirty_count + 1)*8 >= table->slot_count*7){
                i32 new_slot_count = table->slot_count;
                if (table->used_count*2 >= table->slot_count){
                    new_slot_count = table->slot_count*4;
                }
                Table_u64_u64 new_table = make_table_u64_u64__inner((table->allocator),(new_slot_count),SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_table.cpp" ":" "150" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_table.cpp" ":" "150" ":") - 1)));
                table_rehash(&new_table, table);
                table_free(table);
                *table = new_table;
                lookup = table_lookup(table, key);
                do{ if (!(lookup.found_empty_slot)) { (*((i32*)0) = 0xA11E); } }while(0);
            }
            table_insert__inner(table, lookup, val);
            result = true;
        }
    }
    return(result);
}

static b32
table_erase(Table_u64_u64 *table, Table_Lookup lookup){
    b32 result = false;
    if (lookup.found_match){
        table->keys[lookup.index] = table_erased_key;
        table->vals[lookup.index] = 0;
        table->used_count -= 1;
        result = true;
    }
    return(result);
}

static b32
table_erase(Table_u64_u64 *table, u64 key){
    Table_Lookup lookup = table_lookup(table, key);
    return(table_erase(table, lookup));
}

static void
table_clear(Table_u64_u64 *table){
    block_zero((table->keys), sizeof(*(table->keys))*(table->slot_count));
    block_zero((table->vals), sizeof(*(table->vals))*(table->slot_count));
}



static Table_u32_u16
make_table_u32_u16__inner(Base_Allocator *allocator, u32 slot_count, String_Const_u8 location){
    Table_u32_u16 table = {};
    table.allocator = allocator;
    slot_count = (((8)>(slot_count))?(8):(slot_count));
    Data mem = base_allocate__inner(allocator, slot_count*(sizeof(*table.keys) + sizeof(*table.vals)), location);
    block_zero(mem.data, mem.size);
    table.memory = mem.data;
    table.keys = (u32*)table.memory;
    table.vals = (u16*)(table.keys + slot_count);
    table.slot_count = slot_count;
    table.used_count = 0;
    table.dirty_count = 0;
    return(table);
}



static void
table_free(Table_u32_u16 *table){
    base_free(table->allocator, table->memory);
    block_zero((table), sizeof(*(table)));
}

static Table_Lookup
table_lookup(Table_u32_u16 *table, u32 key){
    Table_Lookup result = {};

    if (key != table_empty_u32_key && key != table_erased_u32_key &&
        table->slot_count > 0){
        u32 *keys = table->keys;
        u32 slot_count = table->slot_count;

        u32 first_index = key % slot_count;
        u32 index = first_index;
        result.hash = key;
        for (;;){
            if (key == keys[index]){
                result.index = index;
                result.found_match = true;
                result.found_empty_slot = false;
                result.found_erased_slot = false;
                break;
            }
            if (table_empty_u32_key == keys[index]){
                if (!result.found_erased_slot){
                    result.index = index;
                    result.found_empty_slot = true;
                }
                break;
            }
            if (table_erased_u32_key == keys[index]){
                if (!result.found_erased_slot){
                    result.index = index;
                    result.found_erased_slot = true;
                }
            }
            index += 1;
            if (index >= slot_count){
                index = 0;
            }
            if (index == first_index){
                break;
            }
        }
    }

    return(result);
}

static b32
table_read(Table_u32_u16 *table, u32 key, u16 *val_out){
    b32 result = false;
    Table_Lookup lookup = table_lookup(table, key);
    if (lookup.found_match){
        *val_out = table->vals[lookup.index];
        result = true;
    }
    return(result);
}

static void
table_insert__inner(Table_u32_u16 *table, Table_Lookup lookup, u32 key, u16 val){
    do{ if (!(lookup.found_empty_slot || lookup.found_erased_slot)) { (*((i32*)0) = 0xA11E); } }while(0);
    table->keys[lookup.index] = key;
    table->vals[lookup.index] = val;
    table->used_count += 1;
    if (lookup.found_empty_slot){
        table->dirty_count += 1;
    }
}

static b32
table_rehash(Table_u32_u16 *dst, Table_u32_u16 *src){
    b32 result = false;
    u32 src_slot_count = src->slot_count;
    if ((dst->dirty_count + src->used_count)*8 < dst->slot_count*7){
        u32 *src_keys = src->keys;
        for (u32 i = 0; i < src_slot_count; i += 1){
            u32 key = src_keys[i];
            if (key != table_empty_u32_key && key != table_erased_u32_key){
                Table_Lookup lookup = table_lookup(dst, key);
                table_insert__inner(dst, lookup, key, src->vals[i]);
            }
        }
        result = true;
    }
    return(result);
}

static b32
table_insert(Table_u32_u16 *table, u32 key, u16 val){
    b32 result = false;
    if (key != table_empty_u32_key && key != table_erased_u32_key){
        Table_Lookup lookup = table_lookup(table, key);
        if (!lookup.found_match){
            if ((table->dirty_count + 1)*8 >= table->slot_count*7){
                i32 new_slot_count = table->slot_count;
                if (table->used_count*2 >= table->slot_count){
                    new_slot_count = table->slot_count*4;
                }
                Table_u32_u16 new_table = make_table_u32_u16__inner((table->allocator),(new_slot_count),SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_table.cpp" ":" "311" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_table.cpp" ":" "311" ":") - 1)));
                table_rehash(&new_table, table);
                table_free(table);
                *table = new_table;
                lookup = table_lookup(table, key);
                do{ if (!(lookup.found_empty_slot)) { (*((i32*)0) = 0xA11E); } }while(0);
            }
            table_insert__inner(table, lookup, key, val);
            result = true;
        }
    }
    return(result);
}

static b32
table_erase(Table_u32_u16 *table, Table_Lookup lookup){
    b32 result = false;
    if (lookup.found_match){
        table->keys[lookup.index] = table_erased_u32_key;
        table->vals[lookup.index] = 0;
        table->used_count -= 1;
        result = true;
    }
    return(result);
}

static b32
table_erase(Table_u32_u16 *table, u32 key){
    Table_Lookup lookup = table_lookup(table, key);
    return(table_erase(table, lookup));
}

static void
table_clear(Table_u32_u16 *table){
    block_zero((table->keys), sizeof(*(table->keys))*(table->slot_count));
    block_zero((table->vals), sizeof(*(table->vals))*(table->slot_count));
    table->used_count = 0;
    table->dirty_count = 0;
}



static Table_Data_u64
make_table_Data_u64__inner(Base_Allocator *allocator, u32 slot_count, String_Const_u8 location){
    Table_Data_u64 table = {};
    table.allocator = allocator;
    slot_count = (((8)>(slot_count))?(8):(slot_count));
    Data mem = base_allocate__inner(allocator, slot_count*(sizeof(*table.hashes) + sizeof(*table.keys) + sizeof(*table.vals)), location);
    block_zero(mem.data, mem.size);
    table.memory = mem.data;
    table.hashes = (u64*)table.memory;
    table.keys = (Data*)(table.hashes + slot_count);
    table.vals = (u64*)(table.keys + slot_count);
    table.slot_count = slot_count;
    table.used_count = 0;
    table.dirty_count = 0;
    return(table);
}



static void
table_free(Table_Data_u64 *table){
    base_free(table->allocator, table->memory);
    block_zero((table), sizeof(*(table)));
}

static Table_Lookup
table_lookup(Table_Data_u64 *table, Data key){
    Table_Lookup result = {};

    if (table->slot_count > 0){
        u64 *hashes = table->hashes;
        u32 slot_count = table->slot_count;

        u64 hash = table_hash(key);
        u32 first_index = hash % slot_count;
        u32 index = first_index;
        result.hash = hash;
        for (;;){
            if (hash == hashes[index]){
                if (data_match(key, table->keys[index])){
                    result.index = index;
                    result.found_match = true;
                    result.found_empty_slot = false;
                    result.found_erased_slot = false;
                    break;
                }
            }
            if (table_empty_slot == hashes[index]){
                if (!result.found_erased_slot){
                    result.index = index;
                    result.found_empty_slot = true;
                }
                break;
            }
            if (table_erased_slot == hashes[index]){
                if (!result.found_erased_slot){
                    result.index = index;
                    result.found_erased_slot = true;
                }
            }
            index += 1;
            if (index >= slot_count){
                index = 0;
            }
            if (index == first_index){
                break;
            }
        }
    }

    return(result);
}

static b32
table_read(Table_Data_u64 *table, Table_Lookup lookup, u64 *val_out){
    b32 result = false;
    if (lookup.found_match){
        *val_out = table->vals[lookup.index];
        result = true;
    }
    return(result);
}

static b32
table_read_key(Table_Data_u64 *table, Table_Lookup lookup, Data *key_out){
    b32 result = false;
    if (lookup.found_match){
        *key_out = table->keys[lookup.index];
        result = true;
    }
    return(result);
}

static b32
table_read(Table_Data_u64 *table, Data key, u64 *val_out){
    Table_Lookup lookup = table_lookup(table, key);
    return(table_read(table, lookup, val_out));
}

static void
table_insert__inner(Table_Data_u64 *table, Table_Lookup lookup, Data key, u64 val){
    do{ if (!(lookup.found_empty_slot || lookup.found_erased_slot)) { (*((i32*)0) = 0xA11E); } }while(0);
    table->hashes[lookup.index] = lookup.hash;
    table->keys[lookup.index] = key;
    table->vals[lookup.index] = val;
    table->used_count += 1;
    if (lookup.found_empty_slot){
        table->dirty_count += 1;
    }
}

static b32
table_rehash(Table_Data_u64 *dst, Table_Data_u64 *src){
    b32 result = false;
    u32 src_slot_count = src->slot_count;
    if ((dst->dirty_count + src->used_count)*8 < dst->slot_count*7){
        u64 *src_hashes = src->hashes;
        for (u32 i = 0; i < src_slot_count; i += 1){
            if ((((src_hashes[i])&(bit_64))!=0)){
                Data key = src->keys[i];
                Table_Lookup lookup = table_lookup(dst, key);
                table_insert__inner(dst, lookup, key, src->vals[i]);
            }
        }
        result = true;
    }
    return(result);
}

static b32
table_insert(Table_Data_u64 *table, Data key, u64 val){
    b32 result = false;
    if (key.data != 0){
        Table_Lookup lookup = table_lookup(table, key);
        if (!lookup.found_match){
            if ((table->dirty_count + 1)*8 >= table->slot_count*7){
                i32 new_slot_count = table->slot_count;
                if (table->used_count*2 >= table->slot_count){
                    new_slot_count = table->slot_count*4;
                }
                Table_Data_u64 new_table = make_table_Data_u64__inner((table->allocator),(new_slot_count),SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_table.cpp" ":" "493" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_table.cpp" ":" "493" ":") - 1)));
                table_rehash(&new_table, table);
                table_free(table);
                *table = new_table;
                lookup = table_lookup(table, key);
                do{ if (!(lookup.found_empty_slot)) { (*((i32*)0) = 0xA11E); } }while(0);
            }
            table_insert__inner(table, lookup, key, val);
            result = true;
        }
    }
    return(result);
}

static b32
table_erase(Table_Data_u64 *table, Data key){
    b32 result = false;
    Table_Lookup lookup = table_lookup(table, key);
    if (lookup.found_match){
        table->hashes[lookup.index] = table_erased_slot;
        block_zero((&table->keys[lookup.index]), sizeof(*(&table->keys[lookup.index])));
        table->vals[lookup.index] = 0;
        table->used_count -= 1;
        result = true;
    }
    return(result);
}

static void
table_clear(Table_Data_u64 *table){
    block_zero((table->hashes), sizeof(*(table->hashes))*(table->slot_count));
    block_zero((table->keys), sizeof(*(table->keys))*(table->slot_count));
    block_zero((table->vals), sizeof(*(table->vals))*(table->slot_count));
    table->used_count = 0;
    table->dirty_count = 0;
}



static Table_u64_Data
make_table_u64_Data__inner(Base_Allocator *allocator, u32 slot_count, String_Const_u8 location){
    Table_u64_Data table = {};
    table.allocator = allocator;
    slot_count = (((8)>(slot_count))?(8):(slot_count));
    Data mem = base_allocate__inner(allocator, slot_count*(sizeof(*table.keys) + sizeof(*table.vals)), location);
    block_zero(mem.data, mem.size);
    table.memory = mem.data;
    table.keys = (u64*)table.memory;
    table.vals = (Data*)(table.keys + slot_count);
    table.slot_count = slot_count;
    table.used_count = 0;
    table.dirty_count = 0;
    return(table);
}



static void
table_free(Table_u64_Data *table){
    base_free(table->allocator, table->memory);
    block_zero((table), sizeof(*(table)));
}

static Table_Lookup
table_lookup(Table_u64_Data *table, u64 key){
    Table_Lookup result = {};

    if (key != table_empty_key && key != table_erased_key &&
        table->slot_count > 0){
        u64 *keys = table->keys;
        u32 slot_count = table->slot_count;

        u32 first_index = key % slot_count;
        u32 index = first_index;
        result.hash = key;
        for (;;){
            if (key == keys[index]){
                result.index = index;
                result.found_match = true;
                result.found_empty_slot = false;
                result.found_erased_slot = false;
                break;
            }
            if (table_empty_key == keys[index]){
                if (!result.found_erased_slot){
                    result.index = index;
                    result.found_empty_slot = true;
                }
                break;
            }
            if (table_erased_key == keys[index]){
                if (!result.found_erased_slot){
                    result.index = index;
                    result.found_erased_slot = true;
                }
            }
            index += 1;
            if (index >= slot_count){
                index = 0;
            }
            if (index == first_index){
                break;
            }
        }
    }

    return(result);
}

static b32
table_read(Table_u64_Data *table, Table_Lookup lookup, Data *val_out){
    b32 result = false;
    if (lookup.found_match){
        *val_out = table->vals[lookup.index];
        result = true;
    }
    return(result);
}

static b32
table_read(Table_u64_Data *table, u64 key, Data *val_out){
    Table_Lookup lookup = table_lookup(table, key);
    return(table_read(table, lookup, val_out));
}

static void
table_insert__inner(Table_u64_Data *table, Table_Lookup lookup, Data val){
    do{ if (!(lookup.found_empty_slot || lookup.found_erased_slot)) { (*((i32*)0) = 0xA11E); } }while(0);
    table->keys[lookup.index] = lookup.hash;
    table->vals[lookup.index] = val;
    table->used_count += 1;
    if (lookup.found_empty_slot){
        table->dirty_count += 1;
    }
}

static b32
table_rehash(Table_u64_Data *dst, Table_u64_Data *src){
    b32 result = false;
    u32 src_slot_count = src->slot_count;
    if ((dst->dirty_count + src->used_count)*8 < dst->slot_count*7){
        u64 *src_keys = src->keys;
        for (u32 i = 0; i < src_slot_count; i += 1){
            u64 key = src_keys[i];
            if (key != table_empty_key &&
                key != table_erased_key){
                Table_Lookup lookup = table_lookup(dst, key);
                table_insert__inner(dst, lookup, src->vals[i]);
            }
        }
        result = true;
    }
    return(result);
}

static b32
table_insert(Table_u64_Data *table, u64 key, Data val){
    b32 result = false;
    if (key != table_empty_key && table_erased_key){
        Table_Lookup lookup = table_lookup(table, key);
        if (!lookup.found_match){
            if ((table->dirty_count + 1)*8 >= table->slot_count*7){
                i32 new_slot_count = table->slot_count;
                if (table->used_count*2 >= table->slot_count){
                    new_slot_count = table->slot_count*4;
                }
                Table_u64_Data new_table = make_table_u64_Data__inner((table->allocator),(new_slot_count),SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_table.cpp" ":" "659" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_table.cpp" ":" "659" ":") - 1)));
                table_rehash(&new_table, table);
                table_free(table);
                *table = new_table;
                lookup = table_lookup(table, key);
                do{ if (!(lookup.found_empty_slot)) { (*((i32*)0) = 0xA11E); } }while(0);
            }
            table_insert__inner(table, lookup, val);
            result = true;
        }
    }
    return(result);
}

static b32
table_erase(Table_u64_Data *table, Table_Lookup lookup){
    b32 result = false;
    if (lookup.found_match){
        table->keys[lookup.index] = 0;
        block_zero((&table->vals[lookup.index]), sizeof(*(&table->vals[lookup.index])));
        table->used_count -= 1;
        result = true;
    }
    return(result);
}

static b32
table_erase(Table_u64_Data *table, u64 key){
    Table_Lookup lookup = table_lookup(table, key);
    return(table_erase(table, lookup));
}

static void
table_clear(Table_u64_Data *table){
    block_zero((table->keys), sizeof(*(table->keys))*(table->slot_count));
    block_zero((table->vals), sizeof(*(table->vals))*(table->slot_count));
    table->used_count = 0;
    table->dirty_count = 0;
}



static Table_Data_Data
make_table_Data_Data__inner(Base_Allocator *allocator, u32 slot_count, String_Const_u8 location){
    Table_Data_Data table = {};
    table.allocator = allocator;
    slot_count = (((8)>(slot_count))?(8):(slot_count));
    Data mem = base_allocate__inner(allocator, slot_count*(sizeof(*table.hashes) + sizeof(*table.keys) + sizeof(*table.vals)), location);
    block_zero(mem.data, mem.size);
    table.memory = mem.data;
    table.hashes = (u64*)table.memory;
    table.keys = (Data*)(table.hashes + slot_count);
    table.vals = (Data*)(table.keys + slot_count);
    table.slot_count = slot_count;
    table.used_count = 0;
    table.dirty_count = 0;
    return(table);
}



static void
table_free(Table_Data_Data *table){
    base_free(table->allocator, table->memory);
    block_zero((table), sizeof(*(table)));
}

static Table_Lookup
table_lookup(Table_Data_Data *table, Data key){
    Table_Lookup result = {};

    if (table->slot_count > 0){
        u64 *hashes = table->hashes;
        u32 slot_count = table->slot_count;

        u64 hash = table_hash(key);
        u32 first_index = hash % slot_count;
        u32 index = first_index;
        result.hash = hash;
        for (;;){
            if (hash == hashes[index]){
                if (data_match(key, table->keys[index])){
                    result.index = index;
                    result.found_match = true;
                    result.found_empty_slot = false;
                    result.found_erased_slot = false;
                    break;
                }
            }
            if (table_empty_slot == hashes[index]){
                if (!result.found_erased_slot){
                    result.index = index;
                    result.found_empty_slot = true;
                }
                break;
            }
            if (table_erased_slot == hashes[index] && !result.found_erased_slot){
                result.index = index;
                result.found_erased_slot = true;
            }
            index += 1;
            if (index >= slot_count){
                index = 0;
            }
            if (index == first_index){
                break;
            }
        }
    }

    return(result);
}

static b32
table_read(Table_Data_Data *table, Table_Lookup lookup, Data *val_out){
    b32 result = false;
    if (lookup.found_match){
        *val_out = table->vals[lookup.index];
        result = true;
    }
    return(result);
}

static b32
table_read_key(Table_Data_Data *table, Table_Lookup lookup, Data *key_out){
    b32 result = false;
    if (lookup.found_match){
        *key_out = table->keys[lookup.index];
        result = true;
    }
    return(result);
}

static b32
table_read(Table_Data_Data *table, Data key, Data *val_out){
    Table_Lookup lookup = table_lookup(table, key);
    return(table_read(table, lookup, val_out));
}

static void
table_insert__inner(Table_Data_Data *table, Table_Lookup lookup, Data key, Data val){
    do{ if (!(lookup.found_empty_slot || lookup.found_erased_slot)) { (*((i32*)0) = 0xA11E); } }while(0);
    table->hashes[lookup.index] = lookup.hash;
    table->keys[lookup.index] = key;
    table->vals[lookup.index] = val;
    table->used_count += 1;
    if (lookup.found_empty_slot){
        table->dirty_count += 1;
    }
}

static b32
table_rehash(Table_Data_Data *dst, Table_Data_Data *src){
    b32 result = false;
    u32 src_slot_count = src->slot_count;
    if ((dst->dirty_count + src->used_count)*8 < dst->slot_count*7){
        u64 *src_hashes = src->hashes;
        for (u32 i = 0; i < src_slot_count; i += 1){
            if ((((src_hashes[i])&(bit_64))!=0)){
                Data key = src->keys[i];
                Table_Lookup lookup = table_lookup(dst, key);
                table_insert__inner(dst, lookup, key, src->vals[i]);
            }
        }
        result = true;
    }
    return(result);
}

static b32
table_insert(Table_Data_Data *table, Data key, Data val){
    b32 result = false;
    if (key.data != 0){
        Table_Lookup lookup = table_lookup(table, key);
        if (!lookup.found_match){
            if ((table->dirty_count + 1)*8 >= table->slot_count*7){
                i32 new_slot_count = table->slot_count;
                if (table->used_count*2 >= table->slot_count){
                    new_slot_count = table->slot_count*4;
                }
                Table_Data_Data new_table = make_table_Data_Data__inner((table->allocator),(new_slot_count),SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_table.cpp" ":" "839" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_table.cpp" ":" "839" ":") - 1)));
                table_rehash(&new_table, table);
                table_free(table);
                *table = new_table;
                lookup = table_lookup(table, key);
                do{ if (!(lookup.found_empty_slot)) { (*((i32*)0) = 0xA11E); } }while(0);
            }
            table_insert__inner(table, lookup, key, val);
            result = true;
        }
    }
    return(result);
}

static b32
table_erase(Table_Data_Data *table, Data key){
    b32 result = false;
    Table_Lookup lookup = table_lookup(table, key);
    if (lookup.found_match){
        table->hashes[lookup.index] = table_erased_slot;
        block_zero((&table->keys[lookup.index]), sizeof(*(&table->keys[lookup.index])));
        block_zero((&table->vals[lookup.index]), sizeof(*(&table->vals[lookup.index])));
        table->used_count -= 1;
        result = true;
    }
    return(result);
}

static void
table_clear(Table_Data_Data *table){
    block_zero((table->hashes), sizeof(*(table->hashes))*(table->slot_count));
    block_zero((table->keys), sizeof(*(table->keys))*(table->slot_count));
    block_zero((table->vals), sizeof(*(table->vals))*(table->slot_count));
    table->used_count = 0;
    table->dirty_count = 0;
}
# 80 "/home/sam/.bin/4coder/custom/4coder_default_include.cpp" 2
# 1 "/home/sam/.bin/4coder/custom/4coder_codepoint_map.cpp" 1






static b32
codepoint_index_map_read(Codepoint_Index_Map *map, u32 codepoint, u16 *index_out){
    b32 success = true;
    if (codepoint == 0 && map->has_zero_index){
        *index_out = map->zero_index;
    }
    else if (table_read(&map->table, codepoint, index_out)){

    }
    else{
        success = false;
    }
    return(success);
}

static u16
codepoint_index_map_count(Codepoint_Index_Map *map){
    return(map->max_index + 1);
}

static f32
font_get_glyph_advance(Face_Advance_Map *map, Face_Metrics *metrics, u32 codepoint, f32 tab_multiplier){
    f32 result = 0.f;
    if (codepoint == '\t'){
        result = metrics->space_advance*tab_multiplier;
    }
    else{
        if (character_is_whitespace(codepoint)){
            codepoint = ' ';
        }
        u16 index = 0;
        if (codepoint_index_map_read(&map->codepoint_to_index, codepoint, &index)){
            if (index < map->index_count){
                result = map->advance[index];
            }
        }
    }
    return(result);
}

static f32
font_get_max_glyph_advance_range(Face_Advance_Map *map, Face_Metrics *metrics,
                                 u32 codepoint_first, u32 codepoint_last,
                                 f32 tab_multiplier){
    f32 result = font_get_glyph_advance(map, metrics, codepoint_first, tab_multiplier);
    for (u32 i = codepoint_first + 1; i <= codepoint_last; i += 1){
        f32 a = font_get_glyph_advance(map, metrics, i, tab_multiplier);
        result = (((a)>(result))?(a):(result));
    }
    return(result);
}

static f32
font_get_average_glyph_advance_range(Face_Advance_Map *map, Face_Metrics *metrics,
                                     u32 codepoint_first, u32 codepoint_last,
                                     f32 tab_multiplier){
    f32 result = 0.f;
    for (u32 i = codepoint_first; i <= codepoint_last; i += 1){
        result += font_get_glyph_advance(map, metrics, i, tab_multiplier);
    }
    result /= (f32)(codepoint_last - codepoint_first + 1);
    return(result);
}
# 81 "/home/sam/.bin/4coder/custom/4coder_default_include.cpp" 2
# 1 "/home/sam/.bin/4coder/custom/4coder_async_tasks.cpp" 1
# 11 "/home/sam/.bin/4coder/custom/4coder_async_tasks.cpp"
static Async_System global_async_system = {};

static Async_Node*
async_pop_node(Async_System *async_system){
    for (;async_system->task_count == 0;){
        system_condition_variable_wait(async_system->cv, async_system->mutex);
    }
    Node *node = async_system->task_sent.next;
    do{ if (!(node != &async_system->task_sent)) { (*((i32*)0) = 0xA11E); } }while(0);
    ((node)->next->prev=(node)->prev,(node)->prev->next=(node)->next,(node)->next=(node)->prev=0);
    async_system->task_count -= 1;
    Async_Node *a_node = (Async_Node*)( (u8*)(node) - ((u8*)(&(((Async_Node*)0)->node)) - (u8*)(0)) );
    a_node->next = 0;
    return(a_node);
}

static Async_Node*
async_push_node__inner(Async_System *async_system, Async_Task_Function_Type *func,
                       Data data){
    Async_Task result = async_system->task_id_counter;
    async_system->task_id_counter += 1;

    Async_Node *node = async_system->free_nodes;
    if (node == 0){
        node = ((Async_Node*)linalloc_wrap_unintialized(linalloc_push((&async_system->node_arena), sizeof(Async_Node)*(1), SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_async_tasks.cpp" ":" "35" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_async_tasks.cpp" ":" "35" ":") - 1)))));
    }
    else{
        ((async_system->free_nodes)=(async_system->free_nodes)=(async_system->free_nodes)->next);
    }
    node->task = result;
    node->thread = 0;
    node->func = func;
    node->data.data = (u8*)heap_allocate(&async_system->node_heap, data.size);
    block_copy(node->data.data, data.data, data.size);
    node->data.size = data.size;
    ((&node->node)->prev=(&async_system->task_sent)->prev,(&node->node)->next=(&async_system->task_sent),(&async_system->task_sent)->prev->next=(&node->node),(&async_system->task_sent)->prev=(&node->node));
    async_system->task_count += 1;
    system_condition_variable_signal(async_system->cv);

    return(node);
}

static Async_Task
async_push_node(Async_System *async_system, Async_Task_Function_Type *func, Data data){
    Async_Node *node = async_push_node__inner(async_system, func, data);
    return(node->task);
}

static void
async_free_node(Async_System *async_system, Async_Node *node){
    heap_free(&async_system->node_heap, node->data.data);
    ((node)->next=(async_system->free_nodes),(async_system->free_nodes)=(node));
}

static void
async_task_thread(void *thread_ptr){
    Base_Allocator *allocator = get_base_allocator_system();

    Thread_Context_Extra_Info tctx_info = {};
    tctx_info.async_thread = thread_ptr;

    Thread_Context tctx_ = {};
    Thread_Context *tctx = &tctx_;
    thread_ctx_init(tctx, ThreadKind_AsyncTasks, allocator, allocator);

    Async_Thread *thread = (Async_Thread*)thread_ptr;
    Async_System *async_system = thread->async_system;

    Application_Links app = {};
    app.tctx = tctx;
    app.cmd_context = async_system->cmd_context;

    Profile_Global_List *list = get_core_profile_list(&app);
    profile_thread_set_name((tctx), (list), (SCu8((u8*)("async"), (u64)(sizeof("async") - 1))));

    Async_Context ctx = {&app, thread};

    for (;;){
        system_mutex_acquire(async_system->mutex);
        Async_Node *node = async_pop_node(async_system);
        node->thread = thread;
        thread->node = node;
        thread->task = node->task;
        thread->cancel_signal = false;
        system_mutex_release(async_system->mutex);

        node->func(&ctx, node->data);

        system_mutex_acquire(async_system->mutex);
        node->thread = 0;
        thread->node = 0;
        thread->task = 0;
        thread->cancel_signal = false;
        async_free_node(async_system, node);
        system_condition_variable_signal(async_system->join_cv);
        system_mutex_release(async_system->mutex);
    }
}

static Async_Node*
async_get_pending_node(Async_System *async_system, Async_Task task){
    Async_Node *result = 0;
    if (task != 0){
        for (Node *node = async_system->task_sent.next;
             node != &async_system->task_sent;
             node = node->next){
            Async_Node *a_node = (Async_Node*)( (u8*)(node) - ((u8*)(&(((Async_Node*)0)->node)) - (u8*)(0)) );
            if (a_node->task == task){
                result = a_node;
                break;
            }
        }
    }
    return(result);
}

static Async_Node*
async_get_running_node(Async_System *async_system, Async_Task task){
    Async_Node *result = 0;
    if (task != 0 && async_system->thread.task == task){
        result = async_system->thread.node;
    }
    return(result);
}



static void
async_task_handler_init(Application_Links *app, Async_System *async_system){
    block_zero((async_system), sizeof(*(async_system)));
    async_system->cmd_context = app->cmd_context;
    async_system->node_arena = make_arena_system(((4) << 10));
    heap_init(&async_system->node_heap, &async_system->node_arena);
    async_system->mutex = system_mutex_make();
    async_system->cv = system_condition_variable_make();
    async_system->join_cv = system_condition_variable_make();
    ((&async_system->task_sent)->next=(&async_system->task_sent),(&async_system->task_sent)->prev=(&async_system->task_sent));
    async_system->thread.async_system = async_system;
    async_system->thread.thread = system_thread_launch(async_task_thread, &async_system->thread);
}

static Async_Task
async_task_no_dep(Async_System *async_system, Async_Task_Function_Type *func,
                  Data data){
    system_mutex_acquire(async_system->mutex);
    Async_Task result = async_push_node(async_system, func, data);
    system_mutex_release(async_system->mutex);
    return(result);
}

static b32
async_task_is_pending(Async_System *async_system, Async_Task task){
    system_mutex_acquire(async_system->mutex);
    Async_Node *node = async_get_pending_node(async_system, task);
    system_mutex_release(async_system->mutex);
    return(node != 0);
}

static b32
async_task_is_running(Async_System *async_system, Async_Task task){
    system_mutex_acquire(async_system->mutex);
    Async_Node *node = async_get_running_node(async_system, task);
    system_mutex_release(async_system->mutex);
    return(node != 0);
}

static b32
async_task_is_running_or_pending__inner(Async_System *async_system, Async_Task task){
    Async_Node *node = async_get_pending_node(async_system, task);
    if (node == 0){
        node = async_get_running_node(async_system, task);
    }
    return(node != 0);
}

static b32
async_task_is_running_or_pending(Async_System *async_system, Async_Task task){
    system_mutex_acquire(async_system->mutex);
    b32 result = async_task_is_running_or_pending__inner(async_system, task);
    system_mutex_release(async_system->mutex);
    return(result);
}

static void
async_task_wait__inner(Application_Links *app, Async_System *async_system, Async_Task task){
    release_global_frame_mutex(app);
    for (;async_task_is_running_or_pending__inner(async_system, task);){
        system_condition_variable_wait(async_system->join_cv, async_system->mutex);
    }
    acquire_global_frame_mutex(app);
}

static void
async_task_wait(Application_Links *app, Async_System *async_system, Async_Task task){
    system_mutex_acquire(async_system->mutex);
    if (async_task_is_running_or_pending__inner(async_system, task)){
        async_task_wait__inner(app, async_system, task);
    }
    system_mutex_release(async_system->mutex);
}

static void
async_task_cancel(Application_Links *app, Async_System *async_system, Async_Task task){
    system_mutex_acquire(async_system->mutex);
    Async_Node *node = async_get_pending_node(async_system, task);
    if (node != 0){
        ((&node->node)->next->prev=(&node->node)->prev,(&node->node)->prev->next=(&node->node)->next,(&node->node)->next=(&node->node)->prev=0);
        async_system->task_count -= 1;
        async_free_node(async_system, node);
    }
    else{
        node = async_get_running_node(async_system, task);
        if (node != 0){
            b32 *cancel_signal = &node->thread->cancel_signal;
            (*(cancel_signal)=(true));
            async_task_wait__inner(app, async_system, task);
        }
    }
    system_mutex_release(async_system->mutex);
}

static b32
async_check_canceled(Async_Context *actx){
    b32 *cancel_signal = &actx->thread->cancel_signal;
    b32 result = (*(cancel_signal));
    return(result);
}
# 82 "/home/sam/.bin/4coder/custom/4coder_default_include.cpp" 2
# 1 "/home/sam/.bin/4coder/custom/4coder_string_match.cpp" 1
# 12 "/home/sam/.bin/4coder/custom/4coder_string_match.cpp"
static void
string_match_list_push(Arena *arena, String_Match_List *list,
                       Buffer_ID buffer, i32 string_id, String_Match_Flag flags, Range_i64 range){
    String_Match *match = ((String_Match*)linalloc_wrap_unintialized(linalloc_push((arena), sizeof(String_Match)*(1), SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_string_match.cpp" ":" "15" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_string_match.cpp" ":" "15" ":") - 1)))));
    do{ if((match)){if((list->first)){(list->last)->next=(match);}else{(list->first)=(match);}(list->last)=(match);(list->last)->next=0;} }while(0);
    list->count += 1;
    match->buffer = buffer;
    match->string_id = string_id;
    match->flags = flags;
    match->range = range;
}

static void
string_match_list_push(Arena *arena, String_Match_List *list,
                       Buffer_ID buffer, i32 string_id, String_Match_Flag flags, i64 start, i64 length){
    string_match_list_push(arena, list, buffer, string_id, flags,
                           Ii64(start, start + length));
}

static String_Match_List
string_match_list_join(String_Match_List *a, String_Match_List *b){
    String_Match_List list = *a;
    block_zero((a), sizeof(*(a)));
    if (list.last != 0){
        list.last->next = b->first;
        if (b->last != 0){
            list.last = b->last;
        }
    }
    else{
        list.first = b->first;
        list.last = b->last;
    }
    list.count += b->count;
    block_zero((b), sizeof(*(b)));
    return(list);
}

static void
string_match_list_filter_flags(String_Match_List *list, String_Match_Flag must_have_flags, String_Match_Flag must_not_have_flags){
    String_Match_List new_list = {};
    if ((must_have_flags & must_not_have_flags) == 0){
        for (String_Match *node = list->first, *next = 0;
             node != 0;
             node = next){
            next = node->next;
            if ((node->flags & must_have_flags) == must_have_flags && (node->flags & must_not_have_flags) == 0){
                do{ if((node)){if((new_list.first)){(new_list.last)->next=(node);}else{(new_list.first)=(node);}(new_list.last)=(node);(new_list.last)->next=0;} }while(0);
                new_list.count += 1;
            }
        }
    }
    *list = new_list;
}

static void
string_match_list_filter_remove_buffer(String_Match_List *list, Buffer_ID buffer){
    String_Match_List new_list = {};
    for (String_Match *node = list->first, *next = 0;
         node != 0;
         node = next){
        next = node->next;
        if (node->buffer != buffer){
            do{ if((node)){if((new_list.first)){(new_list.last)->next=(node);}else{(new_list.first)=(node);}(new_list.last)=(node);(new_list.last)->next=0;} }while(0);
            new_list.count += 1;
        }
    }
    *list = new_list;
}

static void
string_match_list_filter_remove_buffer_predicate(Application_Links *app, String_Match_List *list, Buffer_Predicate *predicate){
    String_Match_List new_list = {};
    for (String_Match *node = list->first, *next = 0;
         node != 0;
         node = next){
        next = node->next;
        if (!predicate(app, node->buffer)){
            do{ if((node)){if((new_list.first)){(new_list.last)->next=(node);}else{(new_list.first)=(node);}(new_list.last)=(node);(new_list.last)->next=0;} }while(0);
            new_list.count += 1;
        }
    }
    *list = new_list;
}

static String_Match_List
string_match_list_merge_nearest(String_Match_List *a, String_Match_List *b, Range_i64 range){
    String_Match_List list = {};
    String_Match *node_a = a->first;
    String_Match *node_b = b->first;
    for (String_Match *next_a = node_a, *next_b = node_b;
         node_a != 0 && node_b != 0;
         node_a = next_a, node_b = next_b){
        i64 dist_a = range_distance(node_a->range, range);
        i64 dist_b = range_distance(node_b->range, range);
        if (dist_a <= dist_b){
            next_a = next_a->next;
            do{ if((node_a)){if((list.first)){(list.last)->next=(node_a);}else{(list.first)=(node_a);}(list.last)=(node_a);(list.last)->next=0;} }while(0);
            list.count += 1;
        }
        else{
            next_b = next_b->next;
            do{ if((node_b)){if((list.first)){(list.last)->next=(node_b);}else{(list.first)=(node_b);}(list.last)=(node_b);(list.last)->next=0;} }while(0);
            list.count += 1;
        }
    }
    do{ if (!(node_a == 0 || node_b == 0)) { (*((i32*)0) = 0xA11E); } }while(0);

    String_Match *node = 0;
    if (node_a != 0){
        node = node_a;
    }
    else if (node_b != 0){
        node = node_b;
    }
    for (String_Match *next = 0;
         node != 0;
         node = next){
        next = node->next;
        do{ if((node)){if((list.first)){(list.last)->next=(node);}else{(list.first)=(node);}(list.last)=(node);(list.last)->next=0;} }while(0);
        list.count += 1;
    }
    block_zero((a), sizeof(*(a)));
    block_zero((b), sizeof(*(b)));
    return(list);
}

static String_Match_List
string_match_list_merge_front_to_back(String_Match_List *a, String_Match_List *b){
    return(string_match_list_merge_nearest(a, b, Ii64((i64)0)));
}
# 83 "/home/sam/.bin/4coder/custom/4coder_default_include.cpp" 2
# 1 "/home/sam/.bin/4coder/custom/4coder_buffer_seek_constructors.cpp" 1






static Buffer_Seek
seek_pos(i64 pos){
    Buffer_Seek result;
    result.type = buffer_seek_pos;
    result.pos = pos;
    return(result);
}

static Buffer_Seek
seek_line_col(i64 line, i64 col){
    Buffer_Seek result;
    result.type = buffer_seek_line_col;
    result.line = line;
    result.col = col;
    return(result);
}
# 84 "/home/sam/.bin/4coder/custom/4coder_default_include.cpp" 2
# 1 "/home/sam/.bin/4coder/custom/4coder_token.cpp" 1






static Range_i64
Ii64(Token *token){
    return(Ii64_size(token->pos, token->size));
}

static void
token_list_push(Arena *arena, Token_List *list, Token *token){
    Token_Block *block = list->last;
    if (block == 0 || block->count + 1 > block->max){
        block = ((Token_Block*)linalloc_wrap_unintialized(linalloc_push((arena), sizeof(Token_Block)*(1), SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_token.cpp" ":" "16" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_token.cpp" ":" "16" ":") - 1)))));
        block->next = 0;
        block->prev = 0;
        u32 new_max = round_up_u32(1, ((4) << 10));
        block->tokens = ((Token*)linalloc_wrap_unintialized(linalloc_push((arena), sizeof(Token)*(new_max), SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_token.cpp" ":" "20" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_token.cpp" ":" "20" ":") - 1)))));
        block->count = 0;
        block->max = new_max;
        (((list->first)==0)?((block)->next=(block)->prev=0,(list->first)=(list->last)=(block)):((block)->prev=(list->last),(block)->next=0,(list->last)->next=(block),(list->last)=(block)));
        list->node_count += 1;
    }
    block_copy((&block->tokens[block->count]), (token), sizeof(*(&block->tokens[block->count])));
    block->count += 1;
    list->total_count += 1;
}

static void
token_fill_memory_from_list(Token *dst, Token_List *list, i64 count){
    Token *ptr = dst;
    for (Token_Block *node = list->first;
         node != 0 && count > 0;
         node = node->next){
        i64 write_count = (((node->count)<(count))?(node->count):(count));
        block_copy((ptr), (node->tokens), sizeof(*(ptr))*(write_count));
        ptr += write_count;
        count -= write_count;
    }
}

static void
token_fill_memory_from_list(Token *dst, Token_List *list){
    token_fill_memory_from_list(dst, list, list->total_count);
}

static Token_Array
token_array_from_list_always_copy(Arena *arena, Token_List *list){
    Token_Array array = {};
    if (list->node_count >= 1){
        array.tokens = ((Token*)linalloc_wrap_unintialized(linalloc_push((arena), sizeof(Token)*(list->total_count), SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_token.cpp" ":" "53" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_token.cpp" ":" "53" ":") - 1)))));
        token_fill_memory_from_list(array.tokens, list);
        array.count = list->total_count;
        array.max = array.count;
    }
    return(array);
}

static Token_Array
token_array_from_list(Arena *arena, Token_List *list){
    Token_Array array = {};
    if (list->node_count > 1){
        array.tokens = ((Token*)linalloc_wrap_unintialized(linalloc_push((arena), sizeof(Token)*(list->total_count), SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_token.cpp" ":" "65" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_token.cpp" ":" "65" ":") - 1)))));
        token_fill_memory_from_list(array.tokens, list);
        array.count = list->total_count;
        array.max = array.count;
    }
    else if (list->node_count == 1){
        array.tokens = list->first->tokens;
        array.count = list->first->count;
        array.max = list->first->max;
    }
    return(array);
}

static i64
token_index_from_pos(Token *tokens, i64 count, i64 pos){
    i64 result = 0;
    if (count > 0){
        if (pos >= tokens[count - 1].pos){
            result = count - 1;
        }
        else if (pos <= tokens[0].pos){
            result = 0;
        }
        else{
            i64 first = 0;
            i64 one_past_last = count;
            for (;;){
                i64 index = (first + one_past_last) >> 1;
                i64 index_pos = tokens[index].pos;
                if (index_pos > pos){
                    one_past_last = index;
                }
                else if (index_pos + tokens[index].size <= pos){
                    first = index + 1;
                }
                else{
                    result = index;
                    break;
                }
            }
        }
    }
    return(result);
}

static i64
token_index_from_pos(Token_Array *tokens, u64 pos){
    return(token_index_from_pos(tokens->tokens, tokens->count, pos));
}

static Token*
token_from_pos(Token *tokens, i64 count, i64 pos){
    i64 index = token_index_from_pos(tokens, count, pos);
    return(tokens + index);
}

static Token*
token_from_pos(Token_Array *tokens, u64 pos){
    i64 index = token_index_from_pos(tokens, pos);
    return(tokens->tokens + index);
}



static Token_Iterator_Array
token_iterator_index(u64 user_id, Token *tokens, i64 count, i64 token_index){
    Token_Iterator_Array it = {};
    if (tokens != 0){
        it.user_id = user_id;
        it.ptr = tokens + token_index;
        it.tokens = tokens;
        it.count = count;
    }
    return(it);
}

static Token_Iterator_Array
token_iterator_index(u64 user_id, Token_Array *tokens, i64 token_index){
    return(token_iterator_index(user_id, tokens->tokens, tokens->count, token_index));
}

static Token_Iterator_Array
token_iterator(u64 user_id, Token *tokens, i64 count, Token *token){
    return(token_iterator_index(user_id, tokens, count, (i64)(token - tokens)));
}

static Token_Iterator_Array
token_iterator(u64 user_id, Token_Array *tokens, Token *token){
    return(token_iterator_index(user_id, tokens->tokens, tokens->count, (i64)(token - tokens->tokens)));
}

static Token_Iterator_Array
token_iterator(u64 user_id, Token *tokens, i64 count){
    return(token_iterator_index(user_id, tokens, count, 0));
}

static Token_Iterator_Array
token_iterator(u64 user_id, Token_Array *tokens){
    return(token_iterator_index(user_id, tokens->tokens, tokens->count, 0));
}

static Token_Iterator_Array
token_iterator_pos(u64 user_id, Token *tokens, i64 count, i64 pos){
    i64 index = token_index_from_pos(tokens, count, pos);
    return(token_iterator_index(user_id, tokens, count, index));
}

static Token_Iterator_Array
token_iterator_pos(u64 user_id, Token_Array *tokens, i64 pos){
    i64 index = token_index_from_pos(tokens->tokens, tokens->count, pos);
    return(token_iterator_index(user_id, tokens->tokens, tokens->count, index));
}

static Token*
token_it_read(Token_Iterator_Array *it){
    Token *result = 0;
    if (it->tokens != 0){
        result = it->ptr;
    }
    return(result);
}

static i64
token_it_index(Token_Iterator_Array *it){
    return((i64)(it->ptr - it->tokens));
}

static b32
token_it_inc_all(Token_Iterator_Array *it){
    b32 result = false;
    if (it->tokens != 0){
        if (it->ptr < it->tokens + it->count - 1){
            it->ptr += 1;
            result = true;
        }
    }
    return(result);
}

static b32
token_it_dec_all(Token_Iterator_Array *it){
    b32 result = false;
    if (it->tokens != 0){
        if (it->ptr > it->tokens){
            it->ptr -= 1;
            result = true;
        }
    }
    return(result);
}

static b32
token_it_inc_non_whitespace(Token_Iterator_Array *it){
    b32 result = false;
    repeat:
    if (token_it_inc_all(it)){
        Token *token = token_it_read(it);
        if (token != 0 && token->kind == TokenBaseKind_Whitespace){
            goto repeat;
        }
        result = true;
    }
    return(result);
}

static b32
token_it_dec_non_whitespace(Token_Iterator_Array *it){
    b32 result = false;
    repeat:
    if (token_it_dec_all(it)){
        Token *token = token_it_read(it);
        if (token != 0 && token->kind == TokenBaseKind_Whitespace){
            goto repeat;
        }
        result = true;
    }
    return(result);
}

static b32
token_it_inc(Token_Iterator_Array *it){
    b32 result = false;
    repeat:
    if (token_it_inc_all(it)){
        Token *token = token_it_read(it);
        if (token != 0 && (token->kind == TokenBaseKind_Whitespace ||
                           token->kind == TokenBaseKind_Comment)){
            goto repeat;
        }
        result = true;
    }
    return(result);
}

static b32
token_it_dec(Token_Iterator_Array *it){
    b32 result = false;
    repeat:
    if (token_it_dec_all(it)){
        Token *token = token_it_read(it);
        if (token != 0 && (token->kind == TokenBaseKind_Whitespace ||
                           token->kind == TokenBaseKind_Comment)){
            goto repeat;
        }
        result = true;
    }
    return(result);
}

static Token_Iterator_List
token_iterator_index(u64 user_id, Token_List *list, i64 index){
    Token_Iterator_List it = {};
    if (list->first != 0){
        index = (((0)>(index))?(0):(((list->total_count - 1)<(index))?(list->total_count - 1):(index)));
        i64 base_index = 0;
        Token_Block *block = 0;
        for (Token_Block *node = list->first;
             node != 0;
             node = node->next){
            if (index < base_index + node->count){
                block = node;
                break;
            }
            base_index += node->count;
        }
        do{ if (!(block != 0)) { (*((i32*)0) = 0xA11E); } }while(0);
        it.user_id = user_id;
        it.index = index;
        it.ptr = block->tokens + (index - base_index);
        it.block = block;
        it.first = list->first;
        it.last = list->last;
        it.node_count = list->node_count;
        it.total_count = list->total_count;
    }
    return(it);
}

static Token_Iterator_List
token_iterator(u64 user_id, Token_List *list){
    return(token_iterator_index(user_id, list, 0));
}

static Token_Iterator_List
token_iterator_pos(u64 user_id, Token_List *list, i64 pos){
    Token_Iterator_List it = {};
    if (list->first != 0){
        Token_Block *block = list->last;
        Token *token = &block->tokens[block->count - 1];
        i64 size = token->pos + token->size;
        pos = (((0)>(pos))?(0):(((size)<(pos))?(size):(pos)));
        i64 base_index = 0;
        block = 0;
        for (Token_Block *node = list->first;
             node != 0;
             node = node->next){
            Token *last_token = &node->tokens[node->count - 1];
            i64 one_past_last = last_token->pos + last_token->size;
            if (pos < one_past_last ||
                (node->next == 0 && pos == one_past_last)){
                block = node;
                break;
            }
            base_index += node->count;
        }
        do{ if (!(block != 0)) { (*((i32*)0) = 0xA11E); } }while(0);
        i64 sub_index = token_index_from_pos(block->tokens, block->count, pos);
        it.user_id = user_id;
        it.index = base_index + sub_index;
        it.ptr = block->tokens + sub_index;
        it.block = block;
        it.first = list->first;
        it.last = list->last;
        it.node_count = list->node_count;
        it.total_count = list->total_count;
    }
    return(it);
}

static Token*
token_it_read(Token_Iterator_List *it){
    Token *result = 0;
    if (it->block != 0){
        result = it->ptr;
    }
    return(result);
}

static i64
token_it_index(Token_Iterator_List *it){
    return(it->index);
}

static b32
token_it_inc_all(Token_Iterator_List *it){
    b32 result = false;
    if (it->block != 0){
        i64 sub_index = (i64)(it->ptr - it->block->tokens);
        if (sub_index + 1 < it->block->count){
            it->index += 1;
            it->ptr += 1;
            result = true;
        }
        else{
            if (it->block->next != 0){
                it->block = it->block->next;
                it->index += 1;
                it->ptr = it->block->tokens;
                result = true;
            }
        }
    }
    return(result);
}

static b32
token_it_dec_all(Token_Iterator_List *it){
    b32 result = false;
    if (it->block != 0){
        i64 sub_index = (i64)(it->ptr - it->block->tokens);
        if (sub_index > 0){
            it->index -= 1;
            it->ptr -= 1;
            result = true;
        }
        else{
            if (it->block->prev != 0){
                it->block = it->block->prev;
                it->index -= 1;
                it->ptr = it->block->tokens + it->block->count - 1;
                result = true;
            }
        }
    }
    return(result);
}

static b32
token_it_inc_non_whitespace(Token_Iterator_List *it){
    b32 result = false;
    repeat:
    if (token_it_inc_all(it)){
        Token *token = token_it_read(it);
        if (token != 0 && token->kind == TokenBaseKind_Whitespace){
            goto repeat;
        }
        result = true;
    }
    return(result);
}

static b32
token_it_dec_non_whitespace(Token_Iterator_List *it){
    b32 result = false;
    repeat:
    if (token_it_dec_all(it)){
        Token *token = token_it_read(it);
        if (token != 0 && token->kind == TokenBaseKind_Whitespace){
            goto repeat;
        }
        result = true;
    }
    return(result);
}

static b32
token_it_inc(Token_Iterator_List *it){
    b32 result = false;
    repeat:
    if (token_it_inc_all(it)){
        Token *token = token_it_read(it);
        if (token != 0 && (token->kind == TokenBaseKind_Whitespace ||
                           token->kind == TokenBaseKind_Comment)){
            goto repeat;
        }
        result = true;
    }
    return(result);
}

static b32
token_it_dec(Token_Iterator_List *it){
    b32 result = false;
    repeat:
    if (token_it_dec_all(it)){
        Token *token = token_it_read(it);
        if (token != 0 && (token->kind == TokenBaseKind_Whitespace ||
                           token->kind == TokenBaseKind_Comment)){
            goto repeat;
        }
        result = true;
    }
    return(result);
}

static Token_Iterator
token_iterator(Token_Iterator_Array it){
    Token_Iterator result = {};
    result.kind = TokenIterator_Array;
    result.array = it;
    return(result);
}

static Token_Iterator
token_iterator(Token_Iterator_List it){
    Token_Iterator result = {};
    result.kind = TokenIterator_List;
    result.list = it;
    return(result);
}

static Token*
token_it_read(Token_Iterator *it){
    switch (it->kind){
        case TokenIterator_Array:
        {
            return(token_it_read(&it->array));
        }break;
        case TokenIterator_List:
        {
            return(token_it_read(&it->list));
        }break;
    }
    return(0);
}

static i64
token_it_index(Token_Iterator *it){
    switch (it->kind){
        case TokenIterator_Array:
        {
            return(token_it_index(&it->array));
        }break;
        case TokenIterator_List:
        {
            return(token_it_index(&it->list));
        }break;
    }
    return(0);
}

static b32
token_it_inc_all(Token_Iterator *it){
    switch (it->kind){
        case TokenIterator_Array:
        {
            return(token_it_inc_all(&it->array));
        }break;
        case TokenIterator_List:
        {
            return(token_it_inc_all(&it->list));
        }break;
    }
    return(0);
}

static b32
token_it_dec_all(Token_Iterator *it){
    switch (it->kind){
        case TokenIterator_Array:
        {
            return(token_it_dec_all(&it->array));
        }break;
        case TokenIterator_List:
        {
            return(token_it_dec_all(&it->list));
        }break;
    }
    return(0);
}

static b32
token_it_inc_non_whitespace(Token_Iterator *it){
    switch (it->kind){
        case TokenIterator_Array:
        {
            return(token_it_inc_non_whitespace(&it->array));
        }break;
        case TokenIterator_List:
        {
            return(token_it_inc_non_whitespace(&it->list));
        }break;
    }
    return(0);
}

static b32
token_it_dec_non_whitespace(Token_Iterator *it){
    switch (it->kind){
        case TokenIterator_Array:
        {
            return(token_it_dec_non_whitespace(&it->array));
        }break;
        case TokenIterator_List:
        {
            return(token_it_dec_non_whitespace(&it->list));
        }break;
    }
    return(0);
}

static b32
token_it_inc(Token_Iterator *it){
    switch (it->kind){
        case TokenIterator_Array:
        {
            return(token_it_inc(&it->array));
        }break;
        case TokenIterator_List:
        {
            return(token_it_inc(&it->list));
        }break;
    }
    return(0);
}

static b32
token_it_dec(Token_Iterator *it){
    switch (it->kind){
        case TokenIterator_Array:
        {
            return(token_it_dec(&it->array));
        }break;
        case TokenIterator_List:
        {
            return(token_it_dec(&it->list));
        }break;
    }
    return(0);
}



static void
token_drop_eof(Token_List *list){
    if (list->last != 0){
        Token_Block *block = list->last;
        if (block->tokens[block->count - 1].kind == TokenBaseKind_EOF){
            list->total_count -= 1;
            block->count -= 1;
            if (block->count == 0){
                (((list->last)==(block))?((((list->first)==(list->last))?((list->first)=(list->last)=0):((list->last)->prev->next=0,(list->last)=(list->last)->prev))) :((list->first)==(block))?((((list->last)==(list->first))?((list->last)=(list->first)=0):((list->first)->next->prev=0,(list->first)=(list->first)->next))) : ((block)->next->prev=(block)->prev,(block)->prev->next=(block)->next,(block)->next=(block)->prev=0));
                list->node_count -= 1;
            }
        }
    }
}



static i64
token_relex_first(Token_Array *tokens, i64 edit_range_first, i64 backup_repeats){
    Token_Iterator_Array it = token_iterator_pos(0, tokens, edit_range_first);
    b32 good_status = true;
    for (i64 i = 0; i < backup_repeats && good_status; i += 1){
        good_status = token_it_dec(&it);
    }
    if (good_status){
        for (;;){
            Token *token = token_it_read(&it);
            if (!(((token->flags)&(TokenBaseFlag_PreprocessorBody))!=0)){
                break;
            }
            if (!token_it_dec(&it)){
                break;
            }
        }
    }
    return(token_it_index(&it));
}

static i64
token_relex_resync(Token_Array *tokens, i64 edit_range_first, i64 look_ahead_repeats){
    Token_Iterator_Array it = token_iterator_pos(0, tokens, edit_range_first);
    b32 good_status = true;
    for (i64 i = 0; (i < look_ahead_repeats) && good_status; i += 1){
        good_status = token_it_inc(&it);
    }
    if (good_status){
        for (;;){
            Token *token = token_it_read(&it);
            if (!(((token->flags)&(TokenBaseFlag_PreprocessorBody))!=0)){
                break;
            }
            if (!token_it_inc(&it)){
                break;
            }
        }
    }
    return(token_it_index(&it));
}

static Token_Relex
token_relex(Token_List relex_list, i64 new_pos_to_old_pos_shift, Token *tokens, i64 relex_first, i64 relex_last){
    Token_Relex relex = {};
    if (relex_list.total_count > 0){
        Token_Array relexed_tokens = {tokens + relex_first, relex_last - relex_first + 1};
        Token_Iterator_List it = token_iterator_index(0, &relex_list, relex_list.total_count - 1);
        for (;;){
            Token *token = token_it_read(&it);
            i64 new_pos_rebased = token->pos + new_pos_to_old_pos_shift;
            i64 old_token_index = token_index_from_pos(&relexed_tokens, new_pos_rebased);
            Token *old_token = relexed_tokens.tokens + old_token_index;
            if (new_pos_rebased == old_token->pos &&
                token->size == old_token->size &&
                token->kind == old_token->kind &&
                token->sub_kind == old_token->sub_kind &&
                token->flags == old_token->flags &&
                token->sub_flags == old_token->sub_flags){
                relex.successful_resync = true;
                relex.first_resync_index = relex_first + old_token_index;
            }
            else{
                break;
            }
            if (!token_it_dec_all(&it)){
                break;
            }
        }
    }
    return(relex);
}
# 85 "/home/sam/.bin/4coder/custom/4coder_default_include.cpp" 2
# 1 "/home/sam/.bin/4coder/custom/4coder_command_map.cpp" 1
# 17 "/home/sam/.bin/4coder/custom/4coder_command_map.cpp"
Command_Binding::Command_Binding(){
    block_zero((this), sizeof(*(this)));
}
Command_Binding::Command_Binding(Custom_Command_Function *c){
    this->custom = c;
}
Command_Binding::Command_Binding(char *n){
    this->name = n;
}
Command_Binding::operator Custom_Command_Function*(){
    return(this->custom);
}
Command_Binding::operator char*(){
    return(this->name);
}

static u64
mapping__key(Input_Event_Kind kind, u32 sub_code){
    return((((u64)kind) << 32) | sub_code);
}

static Command_Map*
mapping__alloc_map(Mapping *mapping){
    Command_Map *result = mapping->free_maps;
    if (result != 0){
        ((mapping->free_maps)=(mapping->free_maps)=(mapping->free_maps)->next);
    }
    else{
        result = ((Command_Map*)linalloc_wrap_unintialized(linalloc_push((&mapping->node_arena), sizeof(Command_Map)*(1), SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_command_map.cpp" ":" "45" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_command_map.cpp" ":" "45" ":") - 1)))));
    }
    (((mapping->first_map)==0)?((result)->next=(result)->prev=0,(mapping->first_map)=(mapping->last_map)=(result)):((result)->prev=(mapping->last_map),(result)->next=0,(mapping->last_map)->next=(result),(mapping->last_map)=(result)));
    return(result);
}

static void
mapping__free_map(Mapping *mapping, Command_Map *map){
    (((mapping->last_map)==(map))?((((mapping->first_map)==(mapping->last_map))?((mapping->first_map)=(mapping->last_map)=0):((mapping->last_map)->prev->next=0,(mapping->last_map)=(mapping->last_map)->prev))) :((mapping->first_map)==(map))?((((mapping->last_map)==(mapping->first_map))?((mapping->last_map)=(mapping->first_map)=0):((mapping->first_map)->next->prev=0,(mapping->first_map)=(mapping->first_map)->next))) : ((map)->next->prev=(map)->prev,(map)->prev->next=(map)->next,(map)->next=(map)->prev=0));
    ((map)->next=(mapping->free_maps),(mapping->free_maps)=(map));
}

static Command_Modified_Binding*
mapping__alloc_modified_binding(Mapping *mapping){
    Command_Modified_Binding *result = mapping->free_bindings;
    if (result != 0){
        ((mapping->free_bindings)=(mapping->free_bindings)=(mapping->free_bindings)->next);
    }
    else{
        result = ((Command_Modified_Binding*)linalloc_wrap_unintialized(linalloc_push((&mapping->node_arena), sizeof(Command_Modified_Binding)*(1), SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_command_map.cpp" ":" "64" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_command_map.cpp" ":" "64" ":") - 1)))));
    }
    return(result);
}

static void
mapping__free_modified_binding(Mapping *mapping, Command_Modified_Binding *binding){
    ((binding)->next=(mapping->free_bindings),(mapping->free_bindings)=(binding));
}

static Command_Binding_List*
mapping__alloc_binding_list(Mapping *mapping){
    Command_Binding_List *result = mapping->free_lists;
    if (result != 0){
        ((mapping->free_lists)=(mapping->free_lists)=(mapping->free_lists)->next);
    }
    else{
        result = ((Command_Binding_List*)linalloc_wrap_unintialized(linalloc_push((&mapping->node_arena), sizeof(Command_Binding_List)*(1), SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_command_map.cpp" ":" "81" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_command_map.cpp" ":" "81" ":") - 1)))));
    }
    return(result);
}

static void
mapping__free_binding_list(Mapping *mapping, Command_Binding_List *binding_list){
    ((binding_list)->next=(mapping->free_lists),(mapping->free_lists)=(binding_list));
}

static Command_Binding_List*
map__get_list(Command_Map *map, u64 key){
    Command_Binding_List *result = 0;
    Table_Lookup lookup = table_lookup(&map->event_code_to_binding_list, key);
    if (lookup.found_match){
        u64 val = 0;
        table_read(&map->event_code_to_binding_list, lookup, &val);
        result = (Command_Binding_List*)(void*)(((u8*)0) + val);
    }
    return(result);
}

static Command_Binding_List*
map__get_or_make_list(Mapping *mapping, Command_Map *map, u64 key){
    Command_Binding_List *result = map__get_list(map, key);
    if (result == 0){
        result = mapping__alloc_binding_list(mapping);
        block_zero((result), sizeof(*(result)));
        do{ if((result)){if((map->list_first)){(map->list_last)->next=(result);}else{(map->list_first)=(result);}(map->list_last)=(result);(map->list_last)->next=0;} }while(0);
        table_insert(&map->event_code_to_binding_list, key, (u64)((u8*)(result) - (u8*)(0)));
    }
    return(result);
}



static void
mapping_init(Thread_Context *tctx, Mapping *mapping){
    block_zero((mapping), sizeof(*(mapping)));
    mapping->node_arena = make_arena_system();
    heap_init(&mapping->heap, &mapping->node_arena);
    mapping->heap_wrapper = base_allocator_on_heap(&mapping->heap);
    mapping->id_to_map = make_table_u64_u64__inner((tctx->allocator),(10),SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_command_map.cpp" ":" "123" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_command_map.cpp" ":" "123" ":") - 1)));
    mapping->id_counter = 1;
}

static void
mapping_release(Thread_Context *tctx, Mapping *mapping){
    linalloc_clear(&mapping->node_arena);
    table_free(&mapping->id_to_map);
}

static void
map__init(Mapping *mapping, Command_Map *map, Command_Map_ID id){
    block_zero((map), sizeof(*(map)));
    map->id = id;
    map->node_arena = make_arena(&mapping->heap_wrapper, ((2) << 10));
    map->event_code_to_binding_list = make_table_u64_u64__inner((&mapping->heap_wrapper),(100),SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_command_map.cpp" ":" "138" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_command_map.cpp" ":" "138" ":") - 1)));
    map->cmd_to_binding_trigger = make_table_u64_u64__inner((&mapping->heap_wrapper),(100),SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_command_map.cpp" ":" "139" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_command_map.cpp" ":" "139" ":") - 1)));
}

static Command_Map*
mapping_begin_new_map(Mapping *mapping){
    Command_Map *map = mapping__alloc_map(mapping);
    map__init(mapping, map, mapping->id_counter);
    mapping->id_counter += 1;
    table_insert(&mapping->id_to_map, map->id, (u64)((u8*)(map) - (u8*)(0)));
    return(map);
}

static Command_Map*
mapping_get_map(Mapping *mapping, Command_Map_ID id){
    Command_Map *result = 0;
    Table_Lookup lookup = table_lookup(&mapping->id_to_map, id);
    if (lookup.found_match){
        u64 val = 0;
        table_read(&mapping->id_to_map, lookup, &val);
        result = (Command_Map*)(void*)(((u8*)0) + val);
    }
    return(result);
}

static Command_Map_ID
mapping_validate_id(Mapping *mapping, Command_Map_ID id){
    Table_Lookup lookup = table_lookup(&mapping->id_to_map, id);
    if (!lookup.found_match){
        id = 0;
    }
    return(id);
}

static Command_Map*
mapping_get_or_make_map(Mapping *mapping, Command_Map_ID id){
    Command_Map *result = mapping_get_map(mapping, id);
    if (result == 0){
        result = mapping__alloc_map(mapping);
        map__init(mapping, result, id);
        table_insert(&mapping->id_to_map, result->id, (u64)((u8*)(result) - (u8*)(0)));
    }
    return(result);
}

static void
mapping_release_map(Mapping *mapping, Command_Map *map){
    table_erase(&mapping->id_to_map, map->id);
    if (map->binding_last != 0){
        map->binding_last->next = mapping->free_bindings;
        mapping->free_bindings = map->binding_first;
    }
    if (map->list_last != 0){
        map->list_last->next = mapping->free_lists;
        mapping->free_lists = map->list_first;
    }
    table_free(&map->event_code_to_binding_list);
    linalloc_clear(&map->node_arena);
}



static b32
map_strict_match(Input_Modifier_Set *binding_mod_set, Input_Modifier_Set *event_mod_set, Key_Code skip_self_mod){
    b32 result = true;
    i32 binding_mod_count = binding_mod_set->count;
    Key_Code *binding_mods = binding_mod_set->mods;
    for (i32 i = 0; i < binding_mod_count; i += 1){
        if (!has_modifier(event_mod_set, binding_mods[i])){
            result = false;
            break;
        }
    }
    i32 mod_count = event_mod_set->count;
    Key_Code *mods = event_mod_set->mods;
    for (i32 i = 0; i < mod_count; i += 1){
        if (mods[i] != skip_self_mod && !has_modifier(binding_mod_set, mods[i])){
            result = false;
            break;
        }
    }
    return(result);
}

static b32
map_loose_match(Input_Modifier_Set *binding_mod_set, Input_Modifier_Set *event_mod_set){
    b32 result = true;
    i32 binding_mod_count = binding_mod_set->count;
    Key_Code *binding_mods = binding_mod_set->mods;
    for (i32 i = 0; i < binding_mod_count; i += 1){
        if (!has_modifier(event_mod_set, binding_mods[i])){
            result = false;
            break;
        }
    }
    return(result);
}

static Map_Event_Breakdown
map_get_event_breakdown(Input_Event *event){
    Map_Event_Breakdown result = {};

    switch (event->kind){
        case InputEventKind_KeyStroke:
        {
            result.key = mapping__key(InputEventKind_KeyStroke, event->key.code);
            result.mod_set = &event->key.modifiers;
            result.skip_self_mod = event->key.code;
        }break;

        case InputEventKind_MouseButton:
        {
            result.key = mapping__key(InputEventKind_MouseButton, event->mouse.code);
            result.mod_set = &event->mouse.modifiers;
        }break;

        case InputEventKind_MouseWheel:
        {
            result.key = mapping__key(InputEventKind_MouseWheel, 0);
            result.mod_set = &event->mouse_wheel.modifiers;
        }break;

        case InputEventKind_MouseMove:
        {
            result.key = mapping__key(InputEventKind_MouseMove, 0);
            result.mod_set = &event->mouse_move.modifiers;
        }break;

        case InputEventKind_Core:
        {
            result.key = mapping__key(InputEventKind_Core, event->core.code);
        }break;
    }

    return(result);
}

static Command_Binding
map_get_binding_non_recursive(Command_Map *map, Input_Event *event, Binding_Match_Rule rule){
    Command_Binding result = {};

    if (event->kind == InputEventKind_CustomFunction){
        result.custom = event->custom_func;
    }
    else if (map != 0){
        if (event->kind == InputEventKind_TextInsert){
            result = map->text_input_command;
        }
        else{
            Map_Event_Breakdown breakdown = map_get_event_breakdown(event);
            Table_Lookup lookup = table_lookup(&map->event_code_to_binding_list, breakdown.key);
            if (lookup.found_match){
                u64 val = 0;
                table_read(&map->event_code_to_binding_list, lookup, &val);
                Command_Binding_List *list = (Command_Binding_List*)(void*)(((u8*)0) + val);
                if (breakdown.mod_set != 0){
                    switch (rule){
                        case BindingMatchRule_Strict:
                        {
                            for (SNode *node = list->first;
                                 node != 0;
                                 node = node->next){
                                Command_Modified_Binding *mod_binding = (Command_Modified_Binding*)( (u8*)(node) - ((u8*)(&(((Command_Modified_Binding*)0)->order_node)) - (u8*)(0)) );
                                Input_Modifier_Set *binding_mod_set = &mod_binding->mods;
                                if (map_strict_match(binding_mod_set, breakdown.mod_set, breakdown.skip_self_mod)){
                                    result = mod_binding->binding;
                                    goto done;
                                }
                            }
                        }break;

                        case BindingMatchRule_Loose:
                        {
                            for (SNode *node = list->first;
                                 node != 0;
                                 node = node->next){
                                Command_Modified_Binding *mod_binding = (Command_Modified_Binding*)( (u8*)(node) - ((u8*)(&(((Command_Modified_Binding*)0)->order_node)) - (u8*)(0)) );
                                Input_Modifier_Set *binding_mod_set = &mod_binding->mods;
                                if (map_loose_match(binding_mod_set, breakdown.mod_set)){
                                    result = mod_binding->binding;
                                    goto done;
                                }
                            }
                        }break;
                    }
                    done:;
                }
                else{
                    Command_Modified_Binding *mod_binding = (Command_Modified_Binding*)( (u8*)(list->first) - ((u8*)(&(((Command_Modified_Binding*)0)->order_node)) - (u8*)(0)) );
                    result = mod_binding->binding;
                }
            }
        }
    }

    return(result);
}

static Command_Binding
map_get_binding_non_recursive(Command_Map *map, Input_Event *event){
    Command_Binding result = map_get_binding_non_recursive(map, event, BindingMatchRule_Strict);
    if (result.custom == 0){
        result = map_get_binding_non_recursive(map, event, BindingMatchRule_Loose);
    }
    return(result);
}

static Command_Binding
map_get_binding_recursive(Mapping *mapping, Command_Map *map, Input_Event *event, Binding_Match_Rule rule){
    Command_Binding result = {};
    for (i32 safety_counter = 0;
         map != 0 && safety_counter < 40;
         safety_counter += 1){
        result = map_get_binding_non_recursive(map, event, rule);
        if (result.custom != 0){
            break;
        }
        map = mapping_get_map(mapping, map->parent);
    }
    return(result);
}

static Command_Binding
map_get_binding_recursive(Mapping *mapping, Command_Map *map, Input_Event *event){
    Command_Binding result = map_get_binding_recursive(mapping, map, event, BindingMatchRule_Strict);
    if (result.custom == 0){
        result = map_get_binding_recursive(mapping, map, event, BindingMatchRule_Loose);
    }
    return(result);
}

static void
map_set_parent(Command_Map *map, Command_Map *parent){
    if (map != 0 && parent != 0){
        map->parent = parent->id;
    }
}

static void
map_null_parent(Command_Map *map){
    map->parent = 0;
}

static void
map__command_add_trigger(Command_Map *map, Command_Binding binding, Command_Trigger *trigger){
    if (map != 0){
        u64 key = (u64)(((u8*)(((binding).custom)) - (u8*)(0)));
        Table_Lookup lookup = table_lookup(&map->cmd_to_binding_trigger, key);
        Command_Trigger_List *list = 0;
        if (!lookup.found_match){
            list = ((Command_Trigger_List*)linalloc_wrap_zero(linalloc_push((&map->node_arena), sizeof(Command_Trigger_List)*(1), SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_command_map.cpp" ":" "388" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_command_map.cpp" ":" "388" ":") - 1)))));
            table_insert(&map->cmd_to_binding_trigger, key, (u64)(((u8*)(list) - (u8*)(0))));
        }
        else{
            u64 val = 0;
            table_read(&map->cmd_to_binding_trigger, lookup, &val);
            list = (Command_Trigger_List*)(void*)(((u8*)0) + val);
        }
        Command_Trigger *trigger_ptr = ((Command_Trigger*)linalloc_wrap_unintialized(linalloc_push((&map->node_arena), sizeof(Command_Trigger)*(1), SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_command_map.cpp" ":" "396" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_command_map.cpp" ":" "396" ":") - 1)))));
        block_copy((trigger_ptr), (trigger), sizeof(*(trigger_ptr)));
        do{ if((trigger_ptr)){if((list->first)){(list->last)->next=(trigger_ptr);}else{(list->first)=(trigger_ptr);}(list->last)=(trigger_ptr);(list->last)->next=0;} }while(0);
    }
}

static Input_Event
map_trigger_as_event(Command_Trigger *trigger){
    Input_Event result = {};
    result.kind = trigger->kind;
    switch (result.kind){
        case InputEventKind_TextInsert:
        {}break;

        case InputEventKind_KeyStroke:
        case InputEventKind_KeyRelease:
        {
            result.key.code = trigger->sub_code;
            result.key.modifiers = trigger->mods;
        }break;

        case InputEventKind_MouseButton:
        case InputEventKind_MouseButtonRelease:
        {
            result.mouse.code = trigger->sub_code;
            result.mouse.modifiers = trigger->mods;
        }break;

        case InputEventKind_MouseWheel:
        {
            result.mouse_wheel.modifiers = trigger->mods;
        }break;

        case InputEventKind_MouseMove:
        {
            result.mouse_move.modifiers = trigger->mods;
        }break;

        case InputEventKind_Core:
        {
            result.core.code = trigger->sub_code;
        }break;
    }
    return(result);
}

static Command_Trigger_List
map_get_triggers_non_recursive(Mapping *mapping, Command_Map *map, Command_Binding binding){
    Command_Trigger_List *result_ptr = 0;
    if (map != 0){
        u64 key = (u64)(((u8*)(((binding).custom)) - (u8*)(0)));
        Table_Lookup lookup = table_lookup(&map->cmd_to_binding_trigger, key);
        if (lookup.found_match){
            u64 val = 0;
            table_read(&map->cmd_to_binding_trigger, lookup, &val);
            result_ptr = (Command_Trigger_List*)(void*)(((u8*)0) + val);

            Command_Trigger_List list = {};
            for (Command_Trigger *node = result_ptr->first, *next = 0;
                 node != 0;
                 node = next){
                next = node->next;
                Input_Event event = map_trigger_as_event(node);
                Command_Binding this_binding = {};
                if (mapping != 0){
                    this_binding = map_get_binding_recursive(mapping, map, &event);
                }
                else{
                    this_binding = map_get_binding_non_recursive(map, &event);
                }
                if (((this_binding).custom) == ((binding).custom)){
                    do{ if((node)){if((list.first)){(list.last)->next=(node);}else{(list.first)=(node);}(list.last)=(node);(list.last)->next=0;} }while(0);
                }
            }
            *result_ptr = list;
        }
    }
    Command_Trigger_List result = {};
    if (result_ptr != 0){
        result = *result_ptr;
    }
    return(result);
}

static Command_Trigger_List
map_get_triggers_non_recursive(Command_Map *map, Command_Binding binding){
    return(map_get_triggers_non_recursive(0, map, binding));
}

static Command_Trigger_List
map_get_triggers_recursive(Arena *arena, Mapping *mapping, Command_Map *map, Command_Binding binding){
    Command_Trigger_List result = {};
    if (mapping != 0){
        for (i32 safety_counter = 0;
             map != 0 && safety_counter < 40;
             safety_counter += 1){
            Command_Trigger_List list = map_get_triggers_non_recursive(mapping, map, binding);

            for (Command_Trigger *node = list.first, *next = 0;
                 node != 0;
                 node = next){
                next = node->next;
                Command_Trigger *nnode = ((Command_Trigger*)linalloc_wrap_write(linalloc_push((arena), sizeof(Command_Trigger)*(1), SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_command_map.cpp" ":" "498" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_command_map.cpp" ":" "498" ":") - 1))), sizeof(Command_Trigger)*(1), (node)));
                do{ if((nnode)){if((result.first)){(result.last)->next=(nnode);}else{(result.first)=(nnode);}(result.last)=(nnode);(result.last)->next=0;} }while(0);
            }

            map = mapping_get_map(mapping, map->parent);
        }
    }
    return(result);
}

static Command_Binding_List*
map_get_binding_list_on_key(Command_Map *map, Key_Code code){
    Command_Binding_List *result = 0;
    if (map != 0){
        u64 key = mapping__key(InputEventKind_KeyStroke, code);
        result = map__get_list(map, key);
    }
    return(result);
}

static Command_Binding_List*
map_get_binding_list_on_mouse_button(Command_Map *map, Mouse_Code code){
    Command_Binding_List *result = 0;
    if (map != 0){
        u64 key = mapping__key(InputEventKind_MouseButton, code);
        result = map__get_list(map, key);
    }
    return(result);
}

static Command_Binding_List*
map_get_binding_list_on_core(Command_Map *map, Core_Code code){
    Command_Binding_List *result = 0;
    if (map != 0){
        u64 key = mapping__key(InputEventKind_Core, code);
        result = map__get_list(map, key);
    }
    return(result);
}



static void
map_set_binding(Mapping *mapping, Command_Map *map, Command_Binding binding, u32 code1, u32 code2, Input_Modifier_Set *mods){
    if (map != 0){
        u64 key = mapping__key(code1, code2);
        Command_Binding_List *list = map__get_or_make_list(mapping, map, key);
        Command_Modified_Binding *mod_binding = mapping__alloc_modified_binding(mapping);
        ((mod_binding)->next=(map->binding_first),(map->binding_first)=(mod_binding));
        if (map->binding_last == 0){
            map->binding_last = map->binding_first;
        }
        ((&mod_binding->order_node)->next=(list->first),(list->first)=(&mod_binding->order_node));
        if (list->last == 0){
            list->last= list->first;
        }
        list->count += 1;
        mod_binding->mods = copy_modifier_set(&map->node_arena, mods);
        mod_binding->binding = binding;

        Command_Trigger trigger = {};
        trigger.kind = code1;
        trigger.sub_code = code2;
        trigger.mods = mod_binding->mods;
        map__command_add_trigger(map, binding, &trigger);
    }
}

static void
map_set_binding_key(Mapping *mapping, Command_Map *map, Command_Binding binding, Key_Code code, Input_Modifier_Set *modifiers){
    map_set_binding(mapping, map, binding, InputEventKind_KeyStroke, code, modifiers);
}

static void
map_set_binding_mouse(Mapping *mapping, Command_Map *map, Command_Binding binding, Mouse_Code code, Input_Modifier_Set *modifiers){
    map_set_binding(mapping, map, binding, InputEventKind_MouseButton, code, modifiers);
}

static void
map_set_binding_core(Mapping *mapping, Command_Map *map, Command_Binding binding, Core_Code code, Input_Modifier_Set *modifiers){
    map_set_binding(mapping, map, binding, InputEventKind_Core, code, modifiers);
}

static void
map_set_binding_text_input(Command_Map *map, Command_Binding binding){
    if (map != 0){
        map->text_input_command = binding;
        Command_Trigger trigger = {};
        trigger.kind = InputEventKind_TextInsert;
        map__command_add_trigger(map, binding, &trigger);
    }
}



static Command_Binding_List*
map_get_binding_list_on_key(Mapping *mapping, Command_Map_ID map_id, Key_Code code){
    Command_Map *map = mapping_get_map(mapping, map_id);
    return(map_get_binding_list_on_key(map, code));
}

static Command_Binding
map_get_binding_non_recursive(Mapping *mapping, Command_Map_ID map_id, Input_Event *event){
    Command_Map *map = mapping_get_map(mapping, map_id);
    return(map_get_binding_non_recursive(map, event));
}

static Command_Binding
map_get_binding_recursive(Mapping *mapping, Command_Map_ID map_id, Input_Event *event){
    Command_Map *map = mapping_get_map(mapping, map_id);
    return(map_get_binding_recursive(mapping, map, event));
}

static Command_Trigger_List
map_get_triggers_non_recursive(Mapping *mapping, Command_Map_ID map_id, Command_Binding binding){
    Command_Map *map = mapping_get_map(mapping, map_id);
    return(map_get_triggers_non_recursive(map, binding));
}

static Command_Trigger_List
map_get_triggers_recursive(Arena *arena, Mapping *mapping, Command_Map_ID map_id, Command_Binding binding){
    Command_Map *map = mapping_get_map(mapping, map_id);
    return(map_get_triggers_recursive(arena, mapping, map, binding));
}

static void
map_set_parent(Mapping *mapping, Command_Map_ID map_id, Command_Map_ID parent_id){
    Command_Map *map = mapping_get_map(mapping, map_id);
    Command_Map *parent = mapping_get_map(mapping, parent_id);
    map_set_parent(map, parent);
}

static void
map_set_parent(Mapping *mapping, Command_Map *map, Command_Map_ID parent_id){
    Command_Map *parent = mapping_get_map(mapping, parent_id);
    map_set_parent(map, parent);
}

static void
map_null_parent(Mapping *mapping, Command_Map_ID map_id){
    Command_Map *map = mapping_get_map(mapping, map_id);
    map_null_parent(map);
}

static void
map_set_binding(Mapping *mapping, Command_Map_ID map_id, Command_Binding binding,
                u32 code1, u32 code2, Input_Modifier_Set *modifiers){
    Command_Map *map = mapping_get_map(mapping, map_id);
    map_set_binding(mapping, map, binding, code1, code2, modifiers);
}

static void
map_set_binding_key(Mapping *mapping, Command_Map_ID map_id, Command_Binding binding,
                    Key_Code code, Input_Modifier_Set *modifiers){
    Command_Map *map = mapping_get_map(mapping, map_id);
    map_set_binding_key(mapping, map, binding, code, modifiers);
}

static void
map_set_binding_mouse(Mapping *mapping, Command_Map_ID map_id, Command_Binding binding,
                      Mouse_Code code, Input_Modifier_Set *modifiers){
    Command_Map *map = mapping_get_map(mapping, map_id);
    map_set_binding_mouse(mapping, map, binding, code, modifiers);
}

static void
map_set_binding_core(Mapping *mapping, Command_Map_ID map_id, Command_Binding binding,
                     Core_Code code, Input_Modifier_Set *modifiers){
    Command_Map *map = mapping_get_map(mapping, map_id);
    map_set_binding_core(mapping, map, binding, code, modifiers);
}

static void
map_set_binding_text_input(Mapping *mapping, Command_Map_ID map_id, Command_Binding binding){
    Command_Map *map = mapping_get_map(mapping, map_id);
    map_set_binding_text_input(map, binding);
}



static void
command_trigger_stringize_mods(Arena *arena, List_String_Const_u8 *list, Input_Modifier_Set *modifiers){
    if (modifiers->count > 0){
        string_list_push(arena, list, SCu8((u8*)(" holding:"), (u64)(sizeof(" holding:") - 1)));
        i32 count = modifiers->count;
        Key_Code *mods = modifiers->mods;
        for (i32 i = 0; i < count; i += 1){
            string_list_pushf(arena, list, " %s", ((key_code_name)[(mods[i])%((sizeof(key_code_name))/(sizeof(*key_code_name)))]));
        }
    }
}

static void
command_trigger_stringize(Arena *arena, List_String_Const_u8 *list, Command_Trigger *trigger){
    string_list_push(arena, list, SCu8((u8*)("<"), (u64)(sizeof("<") - 1)));
    switch (trigger->kind){
        case InputEventKind_TextInsert:
        {
            string_list_push(arena, list, SCu8((u8*)("TextInsert"), (u64)(sizeof("TextInsert") - 1)));
        }break;

        case InputEventKind_KeyStroke:
        {
            String_Const_u8 key_name = SCu8(((key_code_name)[(trigger->sub_code)%((sizeof(key_code_name))/(sizeof(*key_code_name)))]));
            string_list_push(arena, list, key_name);
            command_trigger_stringize_mods(arena, list, &trigger->mods);
        }break;

        case InputEventKind_KeyRelease:
        {
            string_list_pushf(arena, list, "Release %s", ((key_code_name)[(trigger->sub_code)%((sizeof(key_code_name))/(sizeof(*key_code_name)))]));
            command_trigger_stringize_mods(arena, list, &trigger->mods);
        }break;

        case InputEventKind_MouseButton:
        {
            string_list_pushf(arena, list, "Mouse %s", ((mouse_code_name)[(trigger->sub_code)%((sizeof(mouse_code_name))/(sizeof(*mouse_code_name)))]));
            command_trigger_stringize_mods(arena, list, &trigger->mods);
        }break;

        case InputEventKind_MouseButtonRelease:
        {
            string_list_pushf(arena, list, "Release Mouse %s", ((mouse_code_name)[(trigger->sub_code)%((sizeof(mouse_code_name))/(sizeof(*mouse_code_name)))]));
            command_trigger_stringize_mods(arena, list, &trigger->mods);
        }break;

        case InputEventKind_MouseWheel:
        {
            string_list_push(arena, list, SCu8((u8*)("MouseWheel"), (u64)(sizeof("MouseWheel") - 1)));
            command_trigger_stringize_mods(arena, list, &trigger->mods);
        }break;

        case InputEventKind_MouseMove:
        {
            string_list_push(arena, list, SCu8((u8*)("MouseMove"), (u64)(sizeof("MouseMove") - 1)));
            command_trigger_stringize_mods(arena, list, &trigger->mods);
        }break;

        case InputEventKind_Core:
        {
            string_list_pushf(arena, list, "Core %s", ((core_code_name)[(trigger->sub_code)%((sizeof(core_code_name))/(sizeof(*core_code_name)))]));
        }break;

        default:
        {
            string_list_push(arena, list, SCu8((u8*)("ERROR unexpected trigger kind"), (u64)(sizeof("ERROR unexpected trigger kind") - 1)));
        }break;
    }
    string_list_push(arena, list, SCu8((u8*)(">"), (u64)(sizeof(">") - 1)));
}



static void
map_set_binding_lv(Mapping *mapping, Command_Map *map,
                   Command_Binding binding, u32 code1, u32 code2, va_list args){
    Input_Modifier_Set mods = {};
    Key_Code mods_array[Input_MaxModifierCount];
    mods.mods = mods_array;
    for (;mods.count < ((sizeof(mods_array))/(sizeof(*mods_array)));){
        i32 v = 
# 758 "/home/sam/.bin/4coder/custom/4coder_command_map.cpp" 3 4
               __builtin_va_arg(
# 758 "/home/sam/.bin/4coder/custom/4coder_command_map.cpp"
               args
# 758 "/home/sam/.bin/4coder/custom/4coder_command_map.cpp" 3 4
               ,
# 758 "/home/sam/.bin/4coder/custom/4coder_command_map.cpp"
               i32
# 758 "/home/sam/.bin/4coder/custom/4coder_command_map.cpp" 3 4
               )
# 758 "/home/sam/.bin/4coder/custom/4coder_command_map.cpp"
                                ;
        if (v <= 0){
            break;
        }
        mods.mods[mods.count] = v;
        mods.count += 1;
    }
    return(map_set_binding(mapping, map, binding, code1, code2, &mods));
}
# 779 "/home/sam/.bin/4coder/custom/4coder_command_map.cpp"
static void
map_set_binding_l(Mapping *mapping, Command_Map *map, Custom_Command_Function *custom, u32 code1, u32 code2, ...){
    va_list args;
    
# 782 "/home/sam/.bin/4coder/custom/4coder_command_map.cpp" 3 4
   __builtin_va_start(
# 782 "/home/sam/.bin/4coder/custom/4coder_command_map.cpp"
   args
# 782 "/home/sam/.bin/4coder/custom/4coder_command_map.cpp" 3 4
   ,
# 782 "/home/sam/.bin/4coder/custom/4coder_command_map.cpp"
   code2
# 782 "/home/sam/.bin/4coder/custom/4coder_command_map.cpp" 3 4
   )
# 782 "/home/sam/.bin/4coder/custom/4coder_command_map.cpp"
                        ;
    Command_Binding binding = {};
    binding.custom = custom;
    map_set_binding_lv(mapping, map, binding, code1, code2, args);
    
# 786 "/home/sam/.bin/4coder/custom/4coder_command_map.cpp" 3 4
   __builtin_va_end(
# 786 "/home/sam/.bin/4coder/custom/4coder_command_map.cpp"
   args
# 786 "/home/sam/.bin/4coder/custom/4coder_command_map.cpp" 3 4
   )
# 786 "/home/sam/.bin/4coder/custom/4coder_command_map.cpp"
               ;
}
# 86 "/home/sam/.bin/4coder/custom/4coder_default_include.cpp" 2

# 1 "/home/sam/.bin/4coder/custom/generated/lexer_cpp.cpp" 1



static u64
lexeme_hash(u64 seed, u8 *ptr, u64 size){
    u64 result = 0;
    for (u64 i = 0; i < size; i += 1, ptr += 1){
        result ^= ((*ptr) ^ result*59) + seed;
    }
    return(result);
}

static Lexeme_Table_Lookup
lexeme_table_lookup(u64 *hash_array, String_Const_u8 *key_array,
                    Lexeme_Table_Value *value_array, i32 slot_count, u64 seed,
                    u8 *ptr, u64 size){
    Lexeme_Table_Lookup result = {};
    u64 hash = lexeme_hash(seed, ptr, size);
    u64 comparison_hash = hash | 1;
    i32 first_index = (hash % slot_count);
    i32 index = first_index;
    for (;;){
        if (hash_array[index] == comparison_hash){
            if (string_match(SCu8(ptr, size), key_array[index])){
                result.found_match = true;
                result.base_kind = value_array[index].base_kind;
                result.sub_kind = value_array[index].sub_kind;
                break;
            }
        }
        else if (hash_array[index] == 0){
            break;
        }
        index += 1;
        if (index == slot_count){
            index = 0;
        }
        if (index == first_index){
            break;
        }
    }
    return(result);
}


u64 cpp_main_keys_hash_array[122] = {
0x0000000000000000,0x0000000000000000,0x0000000000000000,0xd888b941bb2b6159,
0xccde0af67297b1c3,0x0000000000000000,0xe93c453339435f15,0x40f1a6e6d86b10af,
0x0000000000000000,0x77327f669815c887,0xccde0af639a14193,0xccde0af6fa38dd15,
0x0000000000000000,0xccde0ad211ca1afb,0x0000000000000000,0x0000000000000000,
0x77327f6697fd1da1,0x0000000000000000,0x0000000000000000,0x0000000000000000,
0xccde0af60f50b791,0xccde0af6727367b9,0x0000000000000000,0x22ffdb4ae1749afb,
0x1c27cc5e4ba3b635,0xd888c4b2d86ccd67,0x77327f6698027b99,0x0000000000000000,
0xccde0a834c69e907,0xccde0ad22f9b8f97,0x0000000000000000,0x08a9f4496e202343,
0x0000000000000000,0x1c2444c003847197,0x0000000000000000,0x0000000000000000,
0x0000000000000000,0x22ffdb4aa9e424d7,0x22ffdb4aaafced3f,0x0000000000000000,
0x0000000000000000,0x0000000000000000,0x77327f6698747faf,0x1c27562bbbb39725,
0x22ffdb4ae194dfcd,0x0000000000000000,0x1c27da5fe3ac9f6d,0x77327f6697f8dae5,
0x77327f66987ccda7,0xd888c487106b77fb,0x22ffdb4ae384998f,0x0000000000000000,
0xccde0af6f3ad114d,0x0000000000000000,0x467e1883189478bd,0xe93c4533397cc243,
0x77327f669702637d,0xccde0a8319ed4039,0x0000000000000000,0x565424cb24dd928f,
0xe93c4533397c9765,0x1c27d51feed4d17b,0x0000000000000000,0x0000000000000000,
0x0000000000000000,0xacfa9837bc316a8f,0xccde0ad21dce0c8f,0x0000000000000000,
0x0000000000000000,0x1c24419ebc92c865,0xd888c4b2d86ccb31,0x0000000000000000,
0x0000000000000000,0x0000000000000000,0x77327f6697ff35fd,0x0000000000000000,
0x0000000000000000,0x0000000000000000,0x0000000000000000,0xacdfec8540e4aa8f,
0x08c2843a9d1cd943,0x467e45ffb063895f,0x0000000000000000,0x22ffdb4aef8301c3,
0x0000000000000000,0x0000000000000000,0x0000000000000000,0xccde0a832bf7e4df,
0x0000000000000000,0xccde0a8670b9b441,0x22ffdb4ae2a54483,0xe93c4533397cedc5,
0x08c2843a9d1cd859,0x0000000000000000,0x0000000000000000,0x0000000000000000,
0x0000000000000000,0x77327f669708e447,0x22ffdb4ae22ad229,0x1c275d11db796377,
0x77327f6697fe85c3,0x0000000000000000,0x1c24407a5a35d76d,0x0000000000000000,
0x22ffdb4ae2b3a67d,0xccde0a8670bbc997,0x1c2440ec2aab7c19,0x0000000000000000,
0x0000000000000000,0x0000000000000000,0x1c2442ee09b1cf99,0xd888c26d56cf3125,
0xd888cf25f8181bcd,0xd888b93e19d14ef7,0x0000000000000000,0x22ffdb4ae2a47d67,
0x989635cca281928f,0xe93c4533394342eb,0x0000000000000000,0x0000000000000000,
0x0000000000000000,0x0000000000000000,
};
u8 cpp_main_keys_key_array_3[] = {0x74,0x79,0x70,0x65,0x64,0x65,0x66,};
u8 cpp_main_keys_key_array_4[] = {0x65,0x78,0x70,0x6f,0x72,0x74,};
u8 cpp_main_keys_key_array_6[] = {0x74,0x72,0x79,};
u8 cpp_main_keys_key_array_7[] = {0x74,0x68,0x72,0x65,0x61,0x64,0x5f,0x6c,0x6f,0x63,0x61,0x6c,};
u8 cpp_main_keys_key_array_9[] = {0x76,0x6f,0x69,0x64,};
u8 cpp_main_keys_key_array_10[] = {0x66,0x72,0x69,0x65,0x6e,0x64,};
u8 cpp_main_keys_key_array_11[] = {0x64,0x6f,0x75,0x62,0x6c,0x65,};
u8 cpp_main_keys_key_array_13[] = {0x73,0x77,0x69,0x74,0x63,0x68,};
u8 cpp_main_keys_key_array_16[] = {0x65,0x6e,0x75,0x6d,};
u8 cpp_main_keys_key_array_20[] = {0x69,0x6e,0x6c,0x69,0x6e,0x65,};
u8 cpp_main_keys_key_array_21[] = {0x65,0x78,0x74,0x65,0x72,0x6e,};
u8 cpp_main_keys_key_array_23[] = {0x63,0x61,0x74,0x63,0x68,};
u8 cpp_main_keys_key_array_24[] = {0x6f,0x70,0x65,0x72,0x61,0x74,0x6f,0x72,};
u8 cpp_main_keys_key_array_25[] = {0x61,0x6c,0x69,0x67,0x6e,0x61,0x73,};
u8 cpp_main_keys_key_array_26[] = {0x74,0x72,0x75,0x65,};
u8 cpp_main_keys_key_array_28[] = {0x70,0x75,0x62,0x6c,0x69,0x63,};
u8 cpp_main_keys_key_array_29[] = {0x73,0x74,0x61,0x74,0x69,0x63,};
u8 cpp_main_keys_key_array_31[] = {0x73,0x74,0x61,0x74,0x69,0x63,0x5f,0x61,0x73,0x73,0x65,0x72,0x74,};
u8 cpp_main_keys_key_array_33[] = {0x75,0x6e,0x73,0x69,0x67,0x6e,0x65,0x64,};
u8 cpp_main_keys_key_array_37[] = {0x66,0x6c,0x6f,0x61,0x74,};
u8 cpp_main_keys_key_array_38[] = {0x62,0x72,0x65,0x61,0x6b,};
u8 cpp_main_keys_key_array_42[] = {0x6c,0x6f,0x6e,0x67,};
u8 cpp_main_keys_key_array_43[] = {0x64,0x65,0x63,0x6c,0x74,0x79,0x70,0x65,};
u8 cpp_main_keys_key_array_44[] = {0x77,0x68,0x69,0x6c,0x65,};
u8 cpp_main_keys_key_array_46[] = {0x74,0x65,0x6d,0x70,0x6c,0x61,0x74,0x65,};
u8 cpp_main_keys_key_array_47[] = {0x63,0x68,0x61,0x72,};
u8 cpp_main_keys_key_array_48[] = {0x74,0x68,0x69,0x73,};
u8 cpp_main_keys_key_array_49[] = {0x64,0x65,0x66,0x61,0x75,0x6c,0x74,};
u8 cpp_main_keys_key_array_50[] = {0x75,0x73,0x69,0x6e,0x67,};
u8 cpp_main_keys_key_array_52[] = {0x64,0x65,0x6c,0x65,0x74,0x65,};
u8 cpp_main_keys_key_array_54[] = {0x6e,0x61,0x6d,0x65,0x73,0x70,0x61,0x63,0x65,};
u8 cpp_main_keys_key_array_55[] = {0x69,0x6e,0x74,};
u8 cpp_main_keys_key_array_56[] = {0x65,0x6c,0x73,0x65,};
u8 cpp_main_keys_key_array_57[] = {0x72,0x65,0x74,0x75,0x72,0x6e,};
u8 cpp_main_keys_key_array_59[] = {0x64,0x79,0x6e,0x61,0x6d,0x69,0x63,0x5f,0x63,0x61,0x73,0x74,};
u8 cpp_main_keys_key_array_60[] = {0x61,0x73,0x6d,};
u8 cpp_main_keys_key_array_61[] = {0x6e,0x6f,0x65,0x78,0x63,0x65,0x70,0x74,};
u8 cpp_main_keys_key_array_65[] = {0x72,0x65,0x69,0x6e,0x74,0x65,0x72,0x70,0x72,0x65,0x74,0x5f,0x63,0x61,0x73,0x74,};
u8 cpp_main_keys_key_array_66[] = {0x73,0x74,0x72,0x75,0x63,0x74,};
u8 cpp_main_keys_key_array_69[] = {0x72,0x65,0x67,0x69,0x73,0x74,0x65,0x72,};
u8 cpp_main_keys_key_array_70[] = {0x61,0x6c,0x69,0x67,0x6e,0x6f,0x66,};
u8 cpp_main_keys_key_array_74[] = {0x63,0x61,0x73,0x65,};
u8 cpp_main_keys_key_array_79[] = {0x63,0x6f,0x6e,0x73,0x74,0x5f,0x63,0x61,0x73,0x74,};
u8 cpp_main_keys_key_array_80[] = {0x64,0x6f,};
u8 cpp_main_keys_key_array_81[] = {0x70,0x72,0x6f,0x74,0x65,0x63,0x74,0x65,0x64,};
u8 cpp_main_keys_key_array_83[] = {0x73,0x68,0x6f,0x72,0x74,};
u8 cpp_main_keys_key_array_87[] = {0x74,0x79,0x70,0x65,0x69,0x64,};
u8 cpp_main_keys_key_array_89[] = {0x73,0x69,0x7a,0x65,0x6f,0x66,};
u8 cpp_main_keys_key_array_90[] = {0x63,0x6c,0x61,0x73,0x73,};
u8 cpp_main_keys_key_array_91[] = {0x66,0x6f,0x72,};
u8 cpp_main_keys_key_array_92[] = {0x69,0x66,};
u8 cpp_main_keys_key_array_97[] = {0x62,0x6f,0x6f,0x6c,};
u8 cpp_main_keys_key_array_98[] = {0x75,0x6e,0x69,0x6f,0x6e,};
u8 cpp_main_keys_key_array_99[] = {0x65,0x78,0x70,0x6c,0x69,0x63,0x69,0x74,};
u8 cpp_main_keys_key_array_100[] = {0x67,0x6f,0x74,0x6f,};
u8 cpp_main_keys_key_array_102[] = {0x76,0x6f,0x6c,0x61,0x74,0x69,0x6c,0x65,};
u8 cpp_main_keys_key_array_104[] = {0x66,0x61,0x6c,0x73,0x65,};
u8 cpp_main_keys_key_array_105[] = {0x73,0x69,0x67,0x6e,0x65,0x64,};
u8 cpp_main_keys_key_array_106[] = {0x74,0x79,0x70,0x65,0x6e,0x61,0x6d,0x65,};
u8 cpp_main_keys_key_array_110[] = {0x63,0x6f,0x6e,0x74,0x69,0x6e,0x75,0x65,};
u8 cpp_main_keys_key_array_111[] = {0x6e,0x75,0x6c,0x6c,0x70,0x74,0x72,};
u8 cpp_main_keys_key_array_112[] = {0x70,0x72,0x69,0x76,0x61,0x74,0x65,};
u8 cpp_main_keys_key_array_113[] = {0x76,0x69,0x72,0x74,0x75,0x61,0x6c,};
u8 cpp_main_keys_key_array_115[] = {0x63,0x6f,0x6e,0x73,0x74,};
u8 cpp_main_keys_key_array_116[] = {0x73,0x74,0x61,0x74,0x69,0x63,0x5f,0x63,0x61,0x73,0x74,};
u8 cpp_main_keys_key_array_117[] = {0x6e,0x65,0x77,};
String_Const_u8 cpp_main_keys_key_array[122] = {
{0, 0},
{0, 0},
{0, 0},
{cpp_main_keys_key_array_3, 7},
{cpp_main_keys_key_array_4, 6},
{0, 0},
{cpp_main_keys_key_array_6, 3},
{cpp_main_keys_key_array_7, 12},
{0, 0},
{cpp_main_keys_key_array_9, 4},
{cpp_main_keys_key_array_10, 6},
{cpp_main_keys_key_array_11, 6},
{0, 0},
{cpp_main_keys_key_array_13, 6},
{0, 0},
{0, 0},
{cpp_main_keys_key_array_16, 4},
{0, 0},
{0, 0},
{0, 0},
{cpp_main_keys_key_array_20, 6},
{cpp_main_keys_key_array_21, 6},
{0, 0},
{cpp_main_keys_key_array_23, 5},
{cpp_main_keys_key_array_24, 8},
{cpp_main_keys_key_array_25, 7},
{cpp_main_keys_key_array_26, 4},
{0, 0},
{cpp_main_keys_key_array_28, 6},
{cpp_main_keys_key_array_29, 6},
{0, 0},
{cpp_main_keys_key_array_31, 13},
{0, 0},
{cpp_main_keys_key_array_33, 8},
{0, 0},
{0, 0},
{0, 0},
{cpp_main_keys_key_array_37, 5},
{cpp_main_keys_key_array_38, 5},
{0, 0},
{0, 0},
{0, 0},
{cpp_main_keys_key_array_42, 4},
{cpp_main_keys_key_array_43, 8},
{cpp_main_keys_key_array_44, 5},
{0, 0},
{cpp_main_keys_key_array_46, 8},
{cpp_main_keys_key_array_47, 4},
{cpp_main_keys_key_array_48, 4},
{cpp_main_keys_key_array_49, 7},
{cpp_main_keys_key_array_50, 5},
{0, 0},
{cpp_main_keys_key_array_52, 6},
{0, 0},
{cpp_main_keys_key_array_54, 9},
{cpp_main_keys_key_array_55, 3},
{cpp_main_keys_key_array_56, 4},
{cpp_main_keys_key_array_57, 6},
{0, 0},
{cpp_main_keys_key_array_59, 12},
{cpp_main_keys_key_array_60, 3},
{cpp_main_keys_key_array_61, 8},
{0, 0},
{0, 0},
{0, 0},
{cpp_main_keys_key_array_65, 16},
{cpp_main_keys_key_array_66, 6},
{0, 0},
{0, 0},
{cpp_main_keys_key_array_69, 8},
{cpp_main_keys_key_array_70, 7},
{0, 0},
{0, 0},
{0, 0},
{cpp_main_keys_key_array_74, 4},
{0, 0},
{0, 0},
{0, 0},
{0, 0},
{cpp_main_keys_key_array_79, 10},
{cpp_main_keys_key_array_80, 2},
{cpp_main_keys_key_array_81, 9},
{0, 0},
{cpp_main_keys_key_array_83, 5},
{0, 0},
{0, 0},
{0, 0},
{cpp_main_keys_key_array_87, 6},
{0, 0},
{cpp_main_keys_key_array_89, 6},
{cpp_main_keys_key_array_90, 5},
{cpp_main_keys_key_array_91, 3},
{cpp_main_keys_key_array_92, 2},
{0, 0},
{0, 0},
{0, 0},
{0, 0},
{cpp_main_keys_key_array_97, 4},
{cpp_main_keys_key_array_98, 5},
{cpp_main_keys_key_array_99, 8},
{cpp_main_keys_key_array_100, 4},
{0, 0},
{cpp_main_keys_key_array_102, 8},
{0, 0},
{cpp_main_keys_key_array_104, 5},
{cpp_main_keys_key_array_105, 6},
{cpp_main_keys_key_array_106, 8},
{0, 0},
{0, 0},
{0, 0},
{cpp_main_keys_key_array_110, 8},
{cpp_main_keys_key_array_111, 7},
{cpp_main_keys_key_array_112, 7},
{cpp_main_keys_key_array_113, 7},
{0, 0},
{cpp_main_keys_key_array_115, 5},
{cpp_main_keys_key_array_116, 11},
{cpp_main_keys_key_array_117, 3},
{0, 0},
{0, 0},
{0, 0},
{0, 0},
};
Lexeme_Table_Value cpp_main_keys_value_array[122] = {
{0, 0},
{0, 0},
{0, 0},
{4, TokenCppKind_Typedef},
{4, TokenCppKind_Export},
{0, 0},
{4, TokenCppKind_Try},
{4, TokenCppKind_ThreadLocal},
{0, 0},
{4, TokenCppKind_Void},
{4, TokenCppKind_Friend},
{4, TokenCppKind_Double},
{0, 0},
{4, TokenCppKind_Switch},
{0, 0},
{0, 0},
{4, TokenCppKind_Enum},
{0, 0},
{0, 0},
{0, 0},
{4, TokenCppKind_Inline},
{4, TokenCppKind_Extern},
{0, 0},
{4, TokenCppKind_Catch},
{4, TokenCppKind_Operator},
{4, TokenCppKind_AlignAs},
{8, TokenCppKind_LiteralTrue},
{0, 0},
{4, TokenCppKind_Public},
{4, TokenCppKind_Static},
{0, 0},
{4, TokenCppKind_StaticAssert},
{0, 0},
{4, TokenCppKind_Unsigned},
{0, 0},
{0, 0},
{0, 0},
{4, TokenCppKind_Float},
{4, TokenCppKind_Break},
{0, 0},
{0, 0},
{0, 0},
{4, TokenCppKind_Long},
{4, TokenCppKind_DeclType},
{4, TokenCppKind_While},
{0, 0},
{4, TokenCppKind_Template},
{4, TokenCppKind_Char},
{4, TokenCppKind_This},
{4, TokenCppKind_Default},
{4, TokenCppKind_Using},
{0, 0},
{4, TokenCppKind_Delete},
{0, 0},
{4, TokenCppKind_Namespace},
{4, TokenCppKind_Int},
{4, TokenCppKind_Else},
{4, TokenCppKind_Return},
{0, 0},
{4, TokenCppKind_DynamicCast},
{4, TokenCppKind_Asm},
{4, TokenCppKind_NoExcept},
{0, 0},
{0, 0},
{0, 0},
{4, TokenCppKind_ReinterpretCast},
{4, TokenCppKind_Struct},
{0, 0},
{0, 0},
{4, TokenCppKind_Register},
{4, TokenCppKind_AlignOf},
{0, 0},
{0, 0},
{0, 0},
{4, TokenCppKind_Case},
{0, 0},
{0, 0},
{0, 0},
{0, 0},
{4, TokenCppKind_ConstCast},
{4, TokenCppKind_Do},
{4, TokenCppKind_Protected},
{0, 0},
{4, TokenCppKind_Short},
{0, 0},
{0, 0},
{0, 0},
{4, TokenCppKind_TypeID},
{0, 0},
{4, TokenCppKind_SizeOf},
{4, TokenCppKind_Class},
{4, TokenCppKind_For},
{4, TokenCppKind_If},
{0, 0},
{0, 0},
{0, 0},
{0, 0},
{4, TokenCppKind_Bool},
{4, TokenCppKind_Union},
{4, TokenCppKind_Explicit},
{4, TokenCppKind_Goto},
{0, 0},
{4, TokenCppKind_Volatile},
{0, 0},
{8, TokenCppKind_LiteralFalse},
{4, TokenCppKind_Signed},
{4, TokenCppKind_Typename},
{0, 0},
{0, 0},
{0, 0},
{4, TokenCppKind_Continue},
{4, TokenCppKind_NullPtr},
{4, TokenCppKind_Private},
{4, TokenCppKind_Virtual},
{0, 0},
{4, TokenCppKind_Const},
{4, TokenCppKind_StaticCast},
{4, TokenCppKind_New},
{0, 0},
{0, 0},
{0, 0},
{0, 0},
};
i32 cpp_main_keys_slot_count = 122;
u64 cpp_main_keys_seed = 0xdd2a47876eba3f33;
u64 cpp_pp_directives_hash_array[25] = {
0xfee65092b0823a9f,0xb244fc5ad06cd73d,0x0000000000000000,0x1130bf0269562241,
0xa0c05d1a6ef6578d,0x0000000000000000,0xb244fc08f1dd2e6b,0xb244fc591ebd9625,
0x0000000000000000,0xfee6509374202a6d,0x0000000000000000,0x0000000000000000,
0xfee650937bf653e1,0x0000000000000000,0x81ec68a24186cd05,0x0000000000000000,
0x0000000000000000,0x1130cd567e684fad,0xfee65092acadd5a5,0x0000000000000000,
0x81ec68a24186c80f,0x81ec68a241be5e3d,0x0000000000000000,0xfee650937f4ed5a5,
0xb244fc590de874b5,
};
u8 cpp_pp_directives_key_array_0[] = {0x75,0x73,0x69,0x6e,0x67,};
u8 cpp_pp_directives_key_array_1[] = {0x64,0x65,0x66,0x69,0x6e,0x65,};
u8 cpp_pp_directives_key_array_3[] = {0x69,0x6e,0x63,0x6c,0x75,0x64,0x65,};
u8 cpp_pp_directives_key_array_4[] = {0x69,0x66,};
u8 cpp_pp_directives_key_array_6[] = {0x70,0x72,0x61,0x67,0x6d,0x61,};
u8 cpp_pp_directives_key_array_7[] = {0x69,0x6d,0x70,0x6f,0x72,0x74,};
u8 cpp_pp_directives_key_array_9[] = {0x65,0x6e,0x64,0x69,0x66,};
u8 cpp_pp_directives_key_array_12[] = {0x65,0x72,0x72,0x6f,0x72,};
u8 cpp_pp_directives_key_array_14[] = {0x65,0x6c,0x69,0x66,};
u8 cpp_pp_directives_key_array_17[] = {0x76,0x65,0x72,0x73,0x69,0x6f,0x6e,};
u8 cpp_pp_directives_key_array_18[] = {0x75,0x6e,0x64,0x65,0x66,};
u8 cpp_pp_directives_key_array_20[] = {0x65,0x6c,0x73,0x65,};
u8 cpp_pp_directives_key_array_21[] = {0x6c,0x69,0x6e,0x65,};
u8 cpp_pp_directives_key_array_23[] = {0x69,0x66,0x64,0x65,0x66,};
u8 cpp_pp_directives_key_array_24[] = {0x69,0x66,0x6e,0x64,0x65,0x66,};
String_Const_u8 cpp_pp_directives_key_array[25] = {
{cpp_pp_directives_key_array_0, 5},
{cpp_pp_directives_key_array_1, 6},
{0, 0},
{cpp_pp_directives_key_array_3, 7},
{cpp_pp_directives_key_array_4, 2},
{0, 0},
{cpp_pp_directives_key_array_6, 6},
{cpp_pp_directives_key_array_7, 6},
{0, 0},
{cpp_pp_directives_key_array_9, 5},
{0, 0},
{0, 0},
{cpp_pp_directives_key_array_12, 5},
{0, 0},
{cpp_pp_directives_key_array_14, 4},
{0, 0},
{0, 0},
{cpp_pp_directives_key_array_17, 7},
{cpp_pp_directives_key_array_18, 5},
{0, 0},
{cpp_pp_directives_key_array_20, 4},
{cpp_pp_directives_key_array_21, 4},
{0, 0},
{cpp_pp_directives_key_array_23, 5},
{cpp_pp_directives_key_array_24, 6},
};
Lexeme_Table_Value cpp_pp_directives_value_array[25] = {
{5, TokenCppKind_PPUsing},
{5, TokenCppKind_PPDefine},
{0, 0},
{5, TokenCppKind_PPInclude},
{5, TokenCppKind_PPIf},
{0, 0},
{5, TokenCppKind_PPPragma},
{5, TokenCppKind_PPImport},
{0, 0},
{5, TokenCppKind_PPEndIf},
{0, 0},
{0, 0},
{5, TokenCppKind_PPError},
{0, 0},
{5, TokenCppKind_PPElIf},
{0, 0},
{0, 0},
{5, TokenCppKind_PPVersion},
{5, TokenCppKind_PPUndef},
{0, 0},
{5, TokenCppKind_PPElse},
{5, TokenCppKind_PPLine},
{0, 0},
{5, TokenCppKind_PPIfDef},
{5, TokenCppKind_PPIfNDef},
};
i32 cpp_pp_directives_slot_count = 25;
u64 cpp_pp_directives_seed = 0x8d8e1acc1b8ecef0;
u64 cpp_pp_keys_hash_array[2] = {
0x70877a022d73e363,0x0000000000000000,
};
u8 cpp_pp_keys_key_array_0[] = {0x64,0x65,0x66,0x69,0x6e,0x65,0x64,};
String_Const_u8 cpp_pp_keys_key_array[2] = {
{cpp_pp_keys_key_array_0, 7},
{0, 0},
};
Lexeme_Table_Value cpp_pp_keys_value_array[2] = {
{4, TokenCppKind_PPDefined},
{0, 0},
};
i32 cpp_pp_keys_slot_count = 2;
u64 cpp_pp_keys_seed = 0xb572e8914e05b8d4;
struct Lex_State_Cpp{
u32 flags_ZF0;
u32 flags_KF0;
u16 flags_KB0;
u8 *base;
u8 *delim_first;
u8 *delim_one_past_last;
u8 *emit_ptr;
u8 *ptr;
u8 *opl_ptr;
};
static void
lex_full_input_cpp_init(Lex_State_Cpp *state_ptr, String_Const_u8 input){
state_ptr->flags_ZF0 = 0;
state_ptr->flags_KF0 = 0;
state_ptr->flags_KB0 = 0;
state_ptr->base = input.str;
state_ptr->delim_first = input.str;
state_ptr->delim_one_past_last = input.str;
state_ptr->emit_ptr = input.str;
state_ptr->ptr = input.str;
state_ptr->opl_ptr = input.str + input.size;
}
static b32
lex_full_input_cpp_breaks(Arena *arena, Token_List *list, Lex_State_Cpp *state_ptr, u64 max){
b32 result = false;
u64 emit_counter = 0;
Lex_State_Cpp state;
block_copy((&state), (state_ptr), sizeof(*(&state)));
{
state_label_1:
if (state.ptr == state.opl_ptr){
if ((true)){
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_EOF;
token.kind = 0;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
}
state.flags_ZF0 = 0;
result = true;
goto end;
}
}
switch (*state.ptr){
case 0x00:case 0x01:case 0x02:case 0x03:case 0x04:case 0x05:case 0x06:
case 0x07:case 0x08:case 0x0e:case 0x0f:case 0x10:case 0x11:case 0x12:
case 0x13:case 0x14:case 0x15:case 0x16:case 0x17:case 0x18:case 0x19:
case 0x1a:case 0x1b:case 0x1c:case 0x1d:case 0x1e:case 0x1f:case 0x40:
case 0x60:case 0x7f:
{
state.ptr += 1;
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_LexError;
token.kind = 2;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
goto state_label_1;
}break;
case 0x09:case 0x0b:case 0x0c:case 0x0d:case 0x20:
{
if (((((state.flags_KF0)&(0x2))!=0))){
state.ptr += 1;
goto state_label_4;
}
state.ptr += 1;
goto state_label_3;
}break;
case 0x0a:
{
state.ptr += 1;
state.flags_KB0 &= ~(0x1);
state.flags_KF0 &= ~(0x1);
state.flags_KF0 &= ~(0x2);
goto state_label_3;
}break;
case 0x21:
{
state.ptr += 1;
goto state_label_61;
}break;
case 0x22:
{
if (((((state.flags_KF0)&(0x1))!=0))){
state.ptr += 1;
goto state_label_26;
}
state.ptr += 1;
goto state_label_32;
}break;
case 0x23:
{
if ((!(((state.flags_KB0)&(0x1))!=0))){
state.ptr += 1;
goto state_label_23;
}
state.ptr += 1;
goto state_label_68;
}break;
default:
{
state.ptr += 1;
goto state_label_2;
}break;
case 0x25:
{
state.ptr += 1;
goto state_label_65;
}break;
case 0x26:
{
state.ptr += 1;
goto state_label_62;
}break;
case 0x27:
{
state.ptr += 1;
state.flags_ZF0 |= 0x40;
goto state_label_32;
}break;
case 0x28:
{
state.ptr += 1;
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_ParenOp;
token.kind = 13;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
goto state_label_1;
}break;
case 0x29:
{
state.ptr += 1;
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_ParenCl;
token.kind = 14;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
goto state_label_1;
}break;
case 0x2a:
{
state.ptr += 1;
goto state_label_64;
}break;
case 0x2b:
{
state.ptr += 1;
goto state_label_54;
}break;
case 0x2c:
{
state.ptr += 1;
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_Comma;
token.kind = 15;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
goto state_label_1;
}break;
case 0x2d:
{
state.ptr += 1;
goto state_label_55;
}break;
case 0x2e:
{
state.ptr += 1;
goto state_label_6;
}break;
case 0x2f:
{
state.ptr += 1;
goto state_label_7;
}break;
case 0x30:
{
state.ptr += 1;
goto state_label_9;
}break;
case 0x31:case 0x32:case 0x33:case 0x34:case 0x35:case 0x36:case 0x37:
case 0x38:case 0x39:
{
state.ptr += 1;
goto state_label_8;
}break;
case 0x3a:
{
state.ptr += 1;
goto state_label_53;
}break;
case 0x3b:
{
state.ptr += 1;
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_Semicolon;
token.kind = 15;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
goto state_label_1;
}break;
case 0x3c:
{
if ((!(((state.flags_KF0)&(0x1))!=0))){
state.ptr += 1;
goto state_label_57;
}
state.ptr += 1;
goto state_label_25;
}break;
case 0x3d:
{
state.ptr += 1;
goto state_label_60;
}break;
case 0x3e:
{
state.ptr += 1;
goto state_label_58;
}break;
case 0x3f:
{
state.ptr += 1;
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_Ternary;
token.kind = 7;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
goto state_label_1;
}break;
case 0x4c:
{
state.ptr += 1;
state.flags_ZF0 |= 0x4;
goto state_label_27;
}break;
case 0x52:
{
state.ptr += 1;
goto state_label_31;
}break;
case 0x55:
{
state.ptr += 1;
state.flags_ZF0 |= 0x20;
goto state_label_29;
}break;
case 0x5b:
{
state.ptr += 1;
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_BrackOp;
token.kind = 13;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
goto state_label_1;
}break;
case 0x5c:
{
state.ptr += 1;
goto state_label_5;
}break;
case 0x5d:
{
state.ptr += 1;
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_BrackCl;
token.kind = 14;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
goto state_label_1;
}break;
case 0x5e:
{
state.ptr += 1;
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_Xor;
token.kind = 7;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
goto state_label_1;
}break;
case 0x75:
{
state.ptr += 1;
state.flags_ZF0 |= 0x10;
goto state_label_28;
}break;
case 0x7b:
{
state.ptr += 1;
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_BraceOp;
token.kind = 11;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
goto state_label_1;
}break;
case 0x7c:
{
state.ptr += 1;
goto state_label_63;
}break;
case 0x7d:
{
state.ptr += 1;
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_BraceCl;
token.kind = 12;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
goto state_label_1;
}break;
case 0x7e:
{
state.ptr += 1;
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_Tilde;
token.kind = 7;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
goto state_label_1;
}break;
}
}
{
state_label_2:
if (state.ptr == state.opl_ptr){
if ((true)){
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
if ((((state.flags_KB0)&(0x1))!=0)){
Lexeme_Table_Lookup lookup = lexeme_table_lookup(cpp_pp_keys_hash_array, cpp_pp_keys_key_array, cpp_pp_keys_value_array, cpp_pp_keys_slot_count, cpp_pp_keys_seed, state.emit_ptr, token.size);
if (lookup.found_match){
token.kind = lookup.base_kind;
token.sub_kind = lookup.sub_kind;
break;
}
}
Lexeme_Table_Lookup lookup = lexeme_table_lookup(cpp_main_keys_hash_array, cpp_main_keys_key_array, cpp_main_keys_value_array, cpp_main_keys_slot_count, cpp_main_keys_seed, state.emit_ptr, token.size);
if (lookup.found_match){
token.kind = lookup.base_kind;
token.sub_kind = lookup.sub_kind;
break;
}
token.sub_kind = TokenCppKind_Identifier;
token.kind = 6;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
}
state.flags_ZF0 = 0;
goto state_label_1;
}
}
switch (*state.ptr){
case 0x00:case 0x01:case 0x02:case 0x03:case 0x04:case 0x05:case 0x06:
case 0x07:case 0x08:case 0x09:case 0x0a:case 0x0b:case 0x0c:case 0x0d:
case 0x0e:case 0x0f:case 0x10:case 0x11:case 0x12:case 0x13:case 0x14:
case 0x15:case 0x16:case 0x17:case 0x18:case 0x19:case 0x1a:case 0x1b:
case 0x1c:case 0x1d:case 0x1e:case 0x1f:case 0x20:case 0x21:case 0x22:
case 0x23:case 0x25:case 0x26:case 0x27:case 0x28:case 0x29:case 0x2a:
case 0x2b:case 0x2c:case 0x2d:case 0x2e:case 0x2f:case 0x3a:case 0x3b:
case 0x3c:case 0x3d:case 0x3e:case 0x3f:case 0x40:case 0x5b:case 0x5c:
case 0x5d:case 0x5e:case 0x60:case 0x7b:case 0x7c:case 0x7d:case 0x7e:
case 0x7f:
{
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
if ((((state.flags_KB0)&(0x1))!=0)){
Lexeme_Table_Lookup lookup = lexeme_table_lookup(cpp_pp_keys_hash_array, cpp_pp_keys_key_array, cpp_pp_keys_value_array, cpp_pp_keys_slot_count, cpp_pp_keys_seed, state.emit_ptr, token.size);
if (lookup.found_match){
token.kind = lookup.base_kind;
token.sub_kind = lookup.sub_kind;
break;
}
}
Lexeme_Table_Lookup lookup = lexeme_table_lookup(cpp_main_keys_hash_array, cpp_main_keys_key_array, cpp_main_keys_value_array, cpp_main_keys_slot_count, cpp_main_keys_seed, state.emit_ptr, token.size);
if (lookup.found_match){
token.kind = lookup.base_kind;
token.sub_kind = lookup.sub_kind;
break;
}
token.sub_kind = TokenCppKind_Identifier;
token.kind = 6;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
goto state_label_1;
}break;
default:
{
state.ptr += 1;
goto state_label_2;
}break;
}
}
{
state_label_3:
if (state.ptr == state.opl_ptr){
if ((true)){
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_Whitespace;
token.kind = 1;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
}
state.flags_ZF0 = 0;
goto state_label_1;
}
}
switch (*state.ptr){
default:
{
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_Whitespace;
token.kind = 1;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
goto state_label_1;
}break;
case 0x09:case 0x0b:case 0x0c:case 0x0d:case 0x20:
{
state.ptr += 1;
goto state_label_3;
}break;
case 0x0a:
{
state.ptr += 1;
state.flags_KB0 &= ~(0x1);
state.flags_KF0 &= ~(0x1);
state.flags_KF0 &= ~(0x2);
goto state_label_3;
}break;
}
}
{
state_label_4:
if (state.ptr == state.opl_ptr){
if ((true)){
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_PPErrorMessage;
token.kind = 10;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
}
state.flags_ZF0 = 0;
goto state_label_1;
}
}
switch (*state.ptr){
default:
{
state.ptr += 1;
goto state_label_4;
}break;
case 0x0a:
{
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_PPErrorMessage;
token.kind = 10;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
goto state_label_1;
}break;
}
}
{
state_label_5:
if (state.ptr == state.opl_ptr){
if ((true)){
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_Backslash;
token.kind = 1;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
}
state.flags_ZF0 = 0;
goto state_label_1;
}
}
switch (*state.ptr){
default:
{
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_Backslash;
token.kind = 1;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
goto state_label_1;
}break;
case 0x0a:
{
state.ptr += 1;
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_Backslash;
token.kind = 1;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
goto state_label_1;
}break;
case 0x0d:
{
state.ptr += 1;
goto state_label_5;
}break;
}
}
{
state_label_6:
if (state.ptr == state.opl_ptr){
if ((true)){
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_Dot;
token.kind = 7;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
}
state.flags_ZF0 = 0;
goto state_label_1;
}
}
switch (*state.ptr){
default:
{
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_Dot;
token.kind = 7;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
goto state_label_1;
}break;
case 0x2a:
{
state.ptr += 1;
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_DotStar;
token.kind = 7;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
goto state_label_1;
}break;
case 0x2e:
{
state.ptr += 1;
goto state_label_69;
}break;
case 0x30:case 0x31:case 0x32:case 0x33:case 0x34:case 0x35:case 0x36:
case 0x37:case 0x38:case 0x39:
{
state.ptr += 1;
goto state_label_10;
}break;
}
}
{
state_label_7:
if (state.ptr == state.opl_ptr){
if ((true)){
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_Div;
token.kind = 7;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
}
state.flags_ZF0 = 0;
goto state_label_1;
}
}
switch (*state.ptr){
default:
{
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_Div;
token.kind = 7;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
goto state_label_1;
}break;
case 0x2a:
{
state.ptr += 1;
goto state_label_49;
}break;
case 0x2f:
{
state.ptr += 1;
goto state_label_51;
}break;
case 0x3d:
{
state.ptr += 1;
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_DivEq;
token.kind = 7;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
goto state_label_1;
}break;
}
}
{
state_label_8:
if (state.ptr == state.opl_ptr){
if ((true)){
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_LiteralInteger;
token.kind = 8;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
}
state.flags_ZF0 = 0;
goto state_label_1;
}
}
switch (*state.ptr){
default:
{
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_LiteralInteger;
token.kind = 8;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
goto state_label_1;
}break;
case 0x2e:
{
state.ptr += 1;
goto state_label_10;
}break;
case 0x30:case 0x31:case 0x32:case 0x33:case 0x34:case 0x35:case 0x36:
case 0x37:case 0x38:case 0x39:
{
state.ptr += 1;
goto state_label_8;
}break;
case 0x45:case 0x65:
{
state.ptr += 1;
goto state_label_11;
}break;
case 0x4c:
{
state.ptr += 1;
goto state_label_18;
}break;
case 0x55:case 0x75:
{
state.ptr += 1;
goto state_label_17;
}break;
case 0x6c:
{
state.ptr += 1;
goto state_label_20;
}break;
}
}
{
state_label_9:
if (state.ptr == state.opl_ptr){
if ((true)){
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_LiteralInteger;
token.kind = 8;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
}
state.flags_ZF0 = 0;
goto state_label_1;
}
}
switch (*state.ptr){
default:
{
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_LiteralInteger;
token.kind = 8;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
goto state_label_1;
}break;
case 0x2e:
{
state.ptr += 1;
goto state_label_10;
}break;
case 0x30:case 0x31:case 0x32:case 0x33:case 0x34:case 0x35:case 0x36:
case 0x37:
{
state.ptr += 1;
state.flags_ZF0 |= 0x2;
goto state_label_16;
}break;
case 0x45:case 0x65:
{
state.ptr += 1;
goto state_label_11;
}break;
case 0x4c:
{
state.ptr += 1;
goto state_label_18;
}break;
case 0x55:case 0x75:
{
state.ptr += 1;
goto state_label_17;
}break;
case 0x58:case 0x78:
{
state.ptr += 1;
state.flags_ZF0 |= 0x1;
goto state_label_14;
}break;
case 0x6c:
{
state.ptr += 1;
goto state_label_20;
}break;
}
}
{
state_label_10:
if (state.ptr == state.opl_ptr){
if ((true)){
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_LiteralFloat64;
token.kind = 9;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
}
state.flags_ZF0 = 0;
goto state_label_1;
}
}
switch (*state.ptr){
default:
{
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_LiteralFloat64;
token.kind = 9;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
goto state_label_1;
}break;
case 0x30:case 0x31:case 0x32:case 0x33:case 0x34:case 0x35:case 0x36:
case 0x37:case 0x38:case 0x39:
{
state.ptr += 1;
goto state_label_10;
}break;
case 0x45:case 0x65:
{
state.ptr += 1;
goto state_label_11;
}break;
case 0x46:case 0x66:
{
state.ptr += 1;
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_LiteralFloat32;
token.kind = 9;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
goto state_label_1;
}break;
case 0x4c:case 0x6c:
{
state.ptr += 1;
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_LiteralFloat64;
token.kind = 9;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
goto state_label_1;
}break;
}
}
{
state_label_11:
if (state.ptr == state.opl_ptr){
if ((true)){
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_LiteralFloat64;
token.kind = 9;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
}
state.flags_ZF0 = 0;
goto state_label_1;
}
}
switch (*state.ptr){
default:
{
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_LiteralFloat64;
token.kind = 9;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
goto state_label_1;
}break;
case 0x2b:case 0x2d:
{
state.ptr += 1;
goto state_label_12;
}break;
case 0x30:case 0x31:case 0x32:case 0x33:case 0x34:case 0x35:case 0x36:
case 0x37:case 0x38:case 0x39:
{
state.ptr += 1;
goto state_label_13;
}break;
case 0x46:case 0x66:
{
state.ptr += 1;
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_LiteralFloat32;
token.kind = 9;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
goto state_label_1;
}break;
case 0x4c:case 0x6c:
{
state.ptr += 1;
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_LiteralFloat64;
token.kind = 9;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
goto state_label_1;
}break;
}
}
{
state_label_12:
if (state.ptr == state.opl_ptr){
if ((true)){
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_LiteralFloat64;
token.kind = 9;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
}
state.flags_ZF0 = 0;
goto state_label_1;
}
}
switch (*state.ptr){
default:
{
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_LiteralFloat64;
token.kind = 9;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
goto state_label_1;
}break;
case 0x30:case 0x31:case 0x32:case 0x33:case 0x34:case 0x35:case 0x36:
case 0x37:case 0x38:case 0x39:
{
state.ptr += 1;
goto state_label_13;
}break;
case 0x46:case 0x66:
{
state.ptr += 1;
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_LiteralFloat32;
token.kind = 9;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
goto state_label_1;
}break;
case 0x4c:case 0x6c:
{
state.ptr += 1;
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_LiteralFloat64;
token.kind = 9;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
goto state_label_1;
}break;
}
}
{
state_label_13:
if (state.ptr == state.opl_ptr){
if ((true)){
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_LiteralFloat64;
token.kind = 9;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
}
state.flags_ZF0 = 0;
goto state_label_1;
}
}
switch (*state.ptr){
default:
{
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_LiteralFloat64;
token.kind = 9;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
goto state_label_1;
}break;
case 0x30:case 0x31:case 0x32:case 0x33:case 0x34:case 0x35:case 0x36:
case 0x37:case 0x38:case 0x39:
{
state.ptr += 1;
goto state_label_13;
}break;
case 0x46:case 0x66:
{
state.ptr += 1;
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_LiteralFloat32;
token.kind = 9;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
goto state_label_1;
}break;
case 0x4c:case 0x6c:
{
state.ptr += 1;
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_LiteralFloat64;
token.kind = 9;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
goto state_label_1;
}break;
}
}
{
state_label_14:
if (state.ptr == state.opl_ptr){
if ((true)){
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_LexError;
token.kind = 2;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
}
state.flags_ZF0 = 0;
goto state_label_1;
}
}
switch (*state.ptr){
default:
{
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_LexError;
token.kind = 2;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
goto state_label_1;
}break;
case 0x30:case 0x31:case 0x32:case 0x33:case 0x34:case 0x35:case 0x36:
case 0x37:case 0x38:case 0x39:case 0x41:case 0x42:case 0x43:case 0x44:
case 0x45:case 0x46:case 0x61:case 0x62:case 0x63:case 0x64:case 0x65:
case 0x66:
{
state.ptr += 1;
goto state_label_15;
}break;
}
}
{
state_label_15:
if (state.ptr == state.opl_ptr){
if ((true)){
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_LiteralIntegerHex;
token.kind = 8;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
}
state.flags_ZF0 = 0;
goto state_label_1;
}
}
switch (*state.ptr){
default:
{
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_LiteralIntegerHex;
token.kind = 8;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
goto state_label_1;
}break;
case 0x30:case 0x31:case 0x32:case 0x33:case 0x34:case 0x35:case 0x36:
case 0x37:case 0x38:case 0x39:case 0x41:case 0x42:case 0x43:case 0x44:
case 0x45:case 0x46:case 0x61:case 0x62:case 0x63:case 0x64:case 0x65:
case 0x66:
{
state.ptr += 1;
goto state_label_15;
}break;
case 0x4c:
{
state.ptr += 1;
goto state_label_18;
}break;
case 0x55:case 0x75:
{
state.ptr += 1;
goto state_label_17;
}break;
case 0x6c:
{
state.ptr += 1;
goto state_label_20;
}break;
}
}
{
state_label_16:
if (state.ptr == state.opl_ptr){
if ((true)){
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_LiteralIntegerOct;
token.kind = 8;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
}
state.flags_ZF0 = 0;
goto state_label_1;
}
}
switch (*state.ptr){
default:
{
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_LiteralIntegerOct;
token.kind = 8;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
goto state_label_1;
}break;
case 0x30:case 0x31:case 0x32:case 0x33:case 0x34:case 0x35:case 0x36:
case 0x37:
{
state.ptr += 1;
state.flags_ZF0 |= 0x2;
goto state_label_16;
}break;
case 0x4c:
{
state.ptr += 1;
goto state_label_18;
}break;
case 0x55:case 0x75:
{
state.ptr += 1;
goto state_label_17;
}break;
case 0x6c:
{
state.ptr += 1;
goto state_label_20;
}break;
}
}
{
state_label_17:
if (state.ptr == state.opl_ptr){
if ((true)){
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
if ((((state.flags_ZF0)&(0x1))!=0)){
token.sub_kind = TokenCppKind_LiteralIntegerHexU;
token.kind = 8;
break;
}
if ((((state.flags_ZF0)&(0x2))!=0)){
token.sub_kind = TokenCppKind_LiteralIntegerOctU;
token.kind = 8;
break;
}
token.sub_kind = TokenCppKind_LiteralIntegerU;
token.kind = 8;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
}
state.flags_ZF0 = 0;
goto state_label_1;
}
}
switch (*state.ptr){
default:
{
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
if ((((state.flags_ZF0)&(0x1))!=0)){
token.sub_kind = TokenCppKind_LiteralIntegerHexU;
token.kind = 8;
break;
}
if ((((state.flags_ZF0)&(0x2))!=0)){
token.sub_kind = TokenCppKind_LiteralIntegerOctU;
token.kind = 8;
break;
}
token.sub_kind = TokenCppKind_LiteralIntegerU;
token.kind = 8;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
goto state_label_1;
}break;
case 0x4c:
{
state.ptr += 1;
goto state_label_19;
}break;
case 0x6c:
{
state.ptr += 1;
goto state_label_21;
}break;
}
}
{
state_label_18:
if (state.ptr == state.opl_ptr){
if ((true)){
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
if ((((state.flags_ZF0)&(0x1))!=0)){
token.sub_kind = TokenCppKind_LiteralIntegerHexL;
token.kind = 8;
break;
}
if ((((state.flags_ZF0)&(0x2))!=0)){
token.sub_kind = TokenCppKind_LiteralIntegerOctL;
token.kind = 8;
break;
}
token.sub_kind = TokenCppKind_LiteralIntegerL;
token.kind = 8;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
}
state.flags_ZF0 = 0;
goto state_label_1;
}
}
switch (*state.ptr){
default:
{
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
if ((((state.flags_ZF0)&(0x1))!=0)){
token.sub_kind = TokenCppKind_LiteralIntegerHexL;
token.kind = 8;
break;
}
if ((((state.flags_ZF0)&(0x2))!=0)){
token.sub_kind = TokenCppKind_LiteralIntegerOctL;
token.kind = 8;
break;
}
token.sub_kind = TokenCppKind_LiteralIntegerL;
token.kind = 8;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
goto state_label_1;
}break;
case 0x4c:
{
state.ptr += 1;
goto state_label_22;
}break;
case 0x55:case 0x75:
{
state.ptr += 1;
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
if ((((state.flags_ZF0)&(0x1))!=0)){
token.sub_kind = TokenCppKind_LiteralIntegerHexUL;
token.kind = 8;
break;
}
if ((((state.flags_ZF0)&(0x2))!=0)){
token.sub_kind = TokenCppKind_LiteralIntegerOctUL;
token.kind = 8;
break;
}
token.sub_kind = TokenCppKind_LiteralIntegerUL;
token.kind = 8;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
goto state_label_1;
}break;
}
}
{
state_label_19:
if (state.ptr == state.opl_ptr){
if ((true)){
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
if ((((state.flags_ZF0)&(0x1))!=0)){
token.sub_kind = TokenCppKind_LiteralIntegerHexUL;
token.kind = 8;
break;
}
if ((((state.flags_ZF0)&(0x2))!=0)){
token.sub_kind = TokenCppKind_LiteralIntegerOctUL;
token.kind = 8;
break;
}
token.sub_kind = TokenCppKind_LiteralIntegerUL;
token.kind = 8;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
}
state.flags_ZF0 = 0;
goto state_label_1;
}
}
switch (*state.ptr){
default:
{
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
if ((((state.flags_ZF0)&(0x1))!=0)){
token.sub_kind = TokenCppKind_LiteralIntegerHexUL;
token.kind = 8;
break;
}
if ((((state.flags_ZF0)&(0x2))!=0)){
token.sub_kind = TokenCppKind_LiteralIntegerOctUL;
token.kind = 8;
break;
}
token.sub_kind = TokenCppKind_LiteralIntegerUL;
token.kind = 8;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
goto state_label_1;
}break;
case 0x4c:
{
state.ptr += 1;
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
if ((((state.flags_ZF0)&(0x1))!=0)){
token.sub_kind = TokenCppKind_LiteralIntegerHexULL;
token.kind = 8;
break;
}
if ((((state.flags_ZF0)&(0x2))!=0)){
token.sub_kind = TokenCppKind_LiteralIntegerOctULL;
token.kind = 8;
break;
}
token.sub_kind = TokenCppKind_LiteralIntegerULL;
token.kind = 8;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
goto state_label_1;
}break;
}
}
{
state_label_20:
if (state.ptr == state.opl_ptr){
if ((true)){
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
if ((((state.flags_ZF0)&(0x1))!=0)){
token.sub_kind = TokenCppKind_LiteralIntegerHexL;
token.kind = 8;
break;
}
if ((((state.flags_ZF0)&(0x2))!=0)){
token.sub_kind = TokenCppKind_LiteralIntegerOctL;
token.kind = 8;
break;
}
token.sub_kind = TokenCppKind_LiteralIntegerL;
token.kind = 8;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
}
state.flags_ZF0 = 0;
goto state_label_1;
}
}
switch (*state.ptr){
default:
{
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
if ((((state.flags_ZF0)&(0x1))!=0)){
token.sub_kind = TokenCppKind_LiteralIntegerHexL;
token.kind = 8;
break;
}
if ((((state.flags_ZF0)&(0x2))!=0)){
token.sub_kind = TokenCppKind_LiteralIntegerOctL;
token.kind = 8;
break;
}
token.sub_kind = TokenCppKind_LiteralIntegerL;
token.kind = 8;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
goto state_label_1;
}break;
case 0x55:case 0x75:
{
state.ptr += 1;
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
if ((((state.flags_ZF0)&(0x1))!=0)){
token.sub_kind = TokenCppKind_LiteralIntegerHexUL;
token.kind = 8;
break;
}
if ((((state.flags_ZF0)&(0x2))!=0)){
token.sub_kind = TokenCppKind_LiteralIntegerOctUL;
token.kind = 8;
break;
}
token.sub_kind = TokenCppKind_LiteralIntegerUL;
token.kind = 8;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
goto state_label_1;
}break;
case 0x6c:
{
state.ptr += 1;
goto state_label_22;
}break;
}
}
{
state_label_21:
if (state.ptr == state.opl_ptr){
if ((true)){
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
if ((((state.flags_ZF0)&(0x1))!=0)){
token.sub_kind = TokenCppKind_LiteralIntegerHexUL;
token.kind = 8;
break;
}
if ((((state.flags_ZF0)&(0x2))!=0)){
token.sub_kind = TokenCppKind_LiteralIntegerOctUL;
token.kind = 8;
break;
}
token.sub_kind = TokenCppKind_LiteralIntegerUL;
token.kind = 8;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
}
state.flags_ZF0 = 0;
goto state_label_1;
}
}
switch (*state.ptr){
default:
{
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
if ((((state.flags_ZF0)&(0x1))!=0)){
token.sub_kind = TokenCppKind_LiteralIntegerHexUL;
token.kind = 8;
break;
}
if ((((state.flags_ZF0)&(0x2))!=0)){
token.sub_kind = TokenCppKind_LiteralIntegerOctUL;
token.kind = 8;
break;
}
token.sub_kind = TokenCppKind_LiteralIntegerUL;
token.kind = 8;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
goto state_label_1;
}break;
case 0x6c:
{
state.ptr += 1;
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
if ((((state.flags_ZF0)&(0x1))!=0)){
token.sub_kind = TokenCppKind_LiteralIntegerHexULL;
token.kind = 8;
break;
}
if ((((state.flags_ZF0)&(0x2))!=0)){
token.sub_kind = TokenCppKind_LiteralIntegerOctULL;
token.kind = 8;
break;
}
token.sub_kind = TokenCppKind_LiteralIntegerULL;
token.kind = 8;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
goto state_label_1;
}break;
}
}
{
state_label_22:
if (state.ptr == state.opl_ptr){
if ((true)){
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
if ((((state.flags_ZF0)&(0x1))!=0)){
token.sub_kind = TokenCppKind_LiteralIntegerHexLL;
token.kind = 8;
break;
}
if ((((state.flags_ZF0)&(0x2))!=0)){
token.sub_kind = TokenCppKind_LiteralIntegerOctLL;
token.kind = 8;
break;
}
token.sub_kind = TokenCppKind_LiteralIntegerLL;
token.kind = 8;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
}
state.flags_ZF0 = 0;
goto state_label_1;
}
}
switch (*state.ptr){
default:
{
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
if ((((state.flags_ZF0)&(0x1))!=0)){
token.sub_kind = TokenCppKind_LiteralIntegerHexLL;
token.kind = 8;
break;
}
if ((((state.flags_ZF0)&(0x2))!=0)){
token.sub_kind = TokenCppKind_LiteralIntegerOctLL;
token.kind = 8;
break;
}
token.sub_kind = TokenCppKind_LiteralIntegerLL;
token.kind = 8;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
goto state_label_1;
}break;
case 0x55:case 0x75:
{
state.ptr += 1;
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
if ((((state.flags_ZF0)&(0x1))!=0)){
token.sub_kind = TokenCppKind_LiteralIntegerHexULL;
token.kind = 8;
break;
}
if ((((state.flags_ZF0)&(0x2))!=0)){
token.sub_kind = TokenCppKind_LiteralIntegerOctULL;
token.kind = 8;
break;
}
token.sub_kind = TokenCppKind_LiteralIntegerULL;
token.kind = 8;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
goto state_label_1;
}break;
}
}
{
state_label_23:
if (state.ptr == state.opl_ptr){
if ((true)){
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_LexError;
token.kind = 2;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
}
state.flags_ZF0 = 0;
goto state_label_1;
}
}
switch (*state.ptr){
default:
{
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_LexError;
token.kind = 2;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
goto state_label_1;
}break;
case 0x09:case 0x0b:case 0x0c:case 0x20:
{
state.ptr += 1;
goto state_label_23;
}break;
case 0x30:case 0x31:case 0x32:case 0x33:case 0x34:case 0x35:case 0x36:
case 0x37:case 0x38:case 0x39:case 0x41:case 0x42:case 0x43:case 0x44:
case 0x45:case 0x46:case 0x47:case 0x48:case 0x49:case 0x4a:case 0x4b:
case 0x4c:case 0x4d:case 0x4e:case 0x4f:case 0x50:case 0x51:case 0x52:
case 0x53:case 0x54:case 0x55:case 0x56:case 0x57:case 0x58:case 0x59:
case 0x5a:case 0x5f:case 0x61:case 0x62:case 0x63:case 0x64:case 0x65:
case 0x66:case 0x67:case 0x68:case 0x69:case 0x6a:case 0x6b:case 0x6c:
case 0x6d:case 0x6e:case 0x6f:case 0x70:case 0x71:case 0x72:case 0x73:
case 0x74:case 0x75:case 0x76:case 0x77:case 0x78:case 0x79:case 0x7a:
{
state.delim_first = state.ptr;
state.flags_KB0 |= 0x1;
state.ptr += 1;
goto state_label_24;
}break;
}
}
{
state_label_24:
if (state.ptr == state.opl_ptr){
if ((true)){
state.delim_one_past_last = state.ptr;
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
Lexeme_Table_Lookup lookup = lexeme_table_lookup(cpp_pp_directives_hash_array, cpp_pp_directives_key_array, cpp_pp_directives_value_array, cpp_pp_directives_slot_count, cpp_pp_directives_seed, state.delim_first, (state.delim_one_past_last - state.delim_first));
if (lookup.found_match){
token.kind = lookup.base_kind;
token.sub_kind = lookup.sub_kind;
break;
}
token.sub_kind = TokenCppKind_PPUnknown;
token.kind = 2;
}while(0);
switch (token.sub_kind){
case TokenCppKind_PPInclude:
{
state.flags_KF0 |= 0x1;
}break;
case TokenCppKind_PPError:
{
state.flags_KF0 |= 0x2;
}break;
}
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
}
state.flags_ZF0 = 0;
goto state_label_1;
}
}
switch (*state.ptr){
default:
{
state.delim_one_past_last = state.ptr;
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
Lexeme_Table_Lookup lookup = lexeme_table_lookup(cpp_pp_directives_hash_array, cpp_pp_directives_key_array, cpp_pp_directives_value_array, cpp_pp_directives_slot_count, cpp_pp_directives_seed, state.delim_first, (state.delim_one_past_last - state.delim_first));
if (lookup.found_match){
token.kind = lookup.base_kind;
token.sub_kind = lookup.sub_kind;
break;
}
token.sub_kind = TokenCppKind_PPUnknown;
token.kind = 2;
}while(0);
switch (token.sub_kind){
case TokenCppKind_PPInclude:
{
state.flags_KF0 |= 0x1;
}break;
case TokenCppKind_PPError:
{
state.flags_KF0 |= 0x2;
}break;
}
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
goto state_label_1;
}break;
case 0x30:case 0x31:case 0x32:case 0x33:case 0x34:case 0x35:case 0x36:
case 0x37:case 0x38:case 0x39:case 0x41:case 0x42:case 0x43:case 0x44:
case 0x45:case 0x46:case 0x47:case 0x48:case 0x49:case 0x4a:case 0x4b:
case 0x4c:case 0x4d:case 0x4e:case 0x4f:case 0x50:case 0x51:case 0x52:
case 0x53:case 0x54:case 0x55:case 0x56:case 0x57:case 0x58:case 0x59:
case 0x5a:case 0x5f:case 0x61:case 0x62:case 0x63:case 0x64:case 0x65:
case 0x66:case 0x67:case 0x68:case 0x69:case 0x6a:case 0x6b:case 0x6c:
case 0x6d:case 0x6e:case 0x6f:case 0x70:case 0x71:case 0x72:case 0x73:
case 0x74:case 0x75:case 0x76:case 0x77:case 0x78:case 0x79:case 0x7a:
{
state.ptr += 1;
goto state_label_24;
}break;
}
}
{
state_label_25:
if (state.ptr == state.opl_ptr){
if ((true)){
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_LexError;
token.kind = 2;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
}
state.flags_ZF0 = 0;
goto state_label_1;
}
}
switch (*state.ptr){
default:
{
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_LexError;
token.kind = 2;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
goto state_label_1;
}break;
case 0x20:case 0x2e:case 0x2f:case 0x30:case 0x31:case 0x32:case 0x33:
case 0x34:case 0x35:case 0x36:case 0x37:case 0x38:case 0x39:case 0x41:
case 0x42:case 0x43:case 0x44:case 0x45:case 0x46:case 0x47:case 0x48:
case 0x49:case 0x4a:case 0x4b:case 0x4c:case 0x4d:case 0x4e:case 0x4f:
case 0x50:case 0x51:case 0x52:case 0x53:case 0x54:case 0x55:case 0x56:
case 0x57:case 0x58:case 0x59:case 0x5a:case 0x5c:case 0x5f:case 0x61:
case 0x62:case 0x63:case 0x64:case 0x65:case 0x66:case 0x67:case 0x68:
case 0x69:case 0x6a:case 0x6b:case 0x6c:case 0x6d:case 0x6e:case 0x6f:
case 0x70:case 0x71:case 0x72:case 0x73:case 0x74:case 0x75:case 0x76:
case 0x77:case 0x78:case 0x79:case 0x7a:
{
state.ptr += 1;
goto state_label_25;
}break;
case 0x3e:
{
state.ptr += 1;
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_PPIncludeFile;
token.kind = 10;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
goto state_label_1;
}break;
}
}
{
state_label_26:
if (state.ptr == state.opl_ptr){
if ((true)){
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_LexError;
token.kind = 2;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
}
state.flags_ZF0 = 0;
goto state_label_1;
}
}
switch (*state.ptr){
default:
{
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_LexError;
token.kind = 2;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
goto state_label_1;
}break;
case 0x20:case 0x2e:case 0x2f:case 0x30:case 0x31:case 0x32:case 0x33:
case 0x34:case 0x35:case 0x36:case 0x37:case 0x38:case 0x39:case 0x41:
case 0x42:case 0x43:case 0x44:case 0x45:case 0x46:case 0x47:case 0x48:
case 0x49:case 0x4a:case 0x4b:case 0x4c:case 0x4d:case 0x4e:case 0x4f:
case 0x50:case 0x51:case 0x52:case 0x53:case 0x54:case 0x55:case 0x56:
case 0x57:case 0x58:case 0x59:case 0x5a:case 0x5c:case 0x5f:case 0x61:
case 0x62:case 0x63:case 0x64:case 0x65:case 0x66:case 0x67:case 0x68:
case 0x69:case 0x6a:case 0x6b:case 0x6c:case 0x6d:case 0x6e:case 0x6f:
case 0x70:case 0x71:case 0x72:case 0x73:case 0x74:case 0x75:case 0x76:
case 0x77:case 0x78:case 0x79:case 0x7a:
{
state.ptr += 1;
goto state_label_26;
}break;
case 0x22:
{
state.ptr += 1;
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_PPIncludeFile;
token.kind = 10;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
goto state_label_1;
}break;
}
}
{
state_label_27:
if (state.ptr == state.opl_ptr){
if ((true)){
goto state_label_2;
}
}
switch (*state.ptr){
default:
{
goto state_label_2;
}break;
case 0x22:
{
state.ptr += 1;
goto state_label_32;
}break;
case 0x52:
{
state.ptr += 1;
goto state_label_31;
}break;
}
}
{
state_label_28:
if (state.ptr == state.opl_ptr){
if ((true)){
goto state_label_2;
}
}
switch (*state.ptr){
default:
{
goto state_label_2;
}break;
case 0x22:
{
state.ptr += 1;
goto state_label_32;
}break;
case 0x38:
{
state.ptr += 1;
state.flags_ZF0 |= 0x8;
goto state_label_30;
}break;
case 0x52:
{
state.ptr += 1;
goto state_label_31;
}break;
}
}
{
state_label_29:
if (state.ptr == state.opl_ptr){
if ((true)){
goto state_label_2;
}
}
switch (*state.ptr){
default:
{
goto state_label_2;
}break;
case 0x22:
{
state.ptr += 1;
goto state_label_32;
}break;
case 0x52:
{
state.ptr += 1;
goto state_label_31;
}break;
}
}
{
state_label_30:
if (state.ptr == state.opl_ptr){
if ((true)){
goto state_label_2;
}
}
switch (*state.ptr){
default:
{
goto state_label_2;
}break;
case 0x22:
{
state.ptr += 1;
goto state_label_32;
}break;
case 0x52:
{
state.ptr += 1;
goto state_label_31;
}break;
}
}
{
state_label_31:
if (state.ptr == state.opl_ptr){
if ((true)){
goto state_label_2;
}
}
switch (*state.ptr){
default:
{
goto state_label_2;
}break;
case 0x22:
{
state.ptr += 1;
state.delim_first = state.ptr;
goto state_label_45;
}break;
}
}
{
state_label_32:
if (state.ptr == state.opl_ptr){
if ((true)){
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_LexError;
token.kind = 2;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
}
state.flags_ZF0 = 0;
goto state_label_1;
}
}
switch (*state.ptr){
default:
{
state.ptr += 1;
goto state_label_32;
}break;
case 0x0a:
{
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_LexError;
token.kind = 2;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
goto state_label_1;
}break;
case 0x22:
{
if ((!(((state.flags_ZF0)&(0x40))!=0))){
state.ptr += 1;
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
if ((((state.flags_ZF0)&(0x4))!=0)){
token.sub_kind = TokenCppKind_LiteralStringWide;
token.kind = 10;
break;
}
if ((((state.flags_ZF0)&(0x8))!=0)){
token.sub_kind = TokenCppKind_LiteralStringUTF8;
token.kind = 10;
break;
}
if ((((state.flags_ZF0)&(0x10))!=0)){
token.sub_kind = TokenCppKind_LiteralStringUTF16;
token.kind = 10;
break;
}
if ((((state.flags_ZF0)&(0x20))!=0)){
token.sub_kind = TokenCppKind_LiteralStringUTF32;
token.kind = 10;
break;
}
token.sub_kind = TokenCppKind_LiteralString;
token.kind = 10;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
goto state_label_1;
}
state.ptr += 1;
goto state_label_32;
}break;
case 0x27:
{
if (((((state.flags_ZF0)&(0x40))!=0))){
state.ptr += 1;
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
if ((((state.flags_ZF0)&(0x4))!=0)){
token.sub_kind = TokenCppKind_LiteralCharacterWide;
token.kind = 10;
break;
}
if ((((state.flags_ZF0)&(0x8))!=0)){
token.sub_kind = TokenCppKind_LiteralCharacterUTF8;
token.kind = 10;
break;
}
if ((((state.flags_ZF0)&(0x10))!=0)){
token.sub_kind = TokenCppKind_LiteralCharacterUTF16;
token.kind = 10;
break;
}
if ((((state.flags_ZF0)&(0x20))!=0)){
token.sub_kind = TokenCppKind_LiteralCharacterUTF32;
token.kind = 10;
break;
}
token.sub_kind = TokenCppKind_LiteralCharacter;
token.kind = 10;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
goto state_label_1;
}
state.ptr += 1;
goto state_label_32;
}break;
case 0x5c:
{
state.ptr += 1;
goto state_label_33;
}break;
}
}
{
state_label_33:
if (state.ptr == state.opl_ptr){
if ((true)){
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_LexError;
token.kind = 2;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
}
state.flags_ZF0 = 0;
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_EOF;
token.kind = 0;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
}
state.flags_ZF0 = 0;
result = true;
goto end;
}
}
switch (*state.ptr){
default:
{
state.ptr += 1;
goto state_label_32;
}break;
case 0x30:case 0x31:case 0x32:case 0x33:case 0x34:case 0x35:case 0x36:
case 0x37:
{
state.ptr += 1;
goto state_label_34;
}break;
case 0x55:
{
state.ptr += 1;
goto state_label_37;
}break;
case 0x75:
{
state.ptr += 1;
goto state_label_41;
}break;
case 0x78:
{
state.ptr += 1;
goto state_label_36;
}break;
}
}
{
state_label_34:
if (state.ptr == state.opl_ptr){
if ((true)){
goto state_label_32;
}
}
switch (*state.ptr){
default:
{
goto state_label_32;
}break;
case 0x30:case 0x31:case 0x32:case 0x33:case 0x34:case 0x35:case 0x36:
case 0x37:
{
state.ptr += 1;
goto state_label_35;
}break;
}
}
{
state_label_35:
if (state.ptr == state.opl_ptr){
if ((true)){
goto state_label_32;
}
}
switch (*state.ptr){
default:
{
goto state_label_32;
}break;
case 0x30:case 0x31:case 0x32:case 0x33:case 0x34:case 0x35:case 0x36:
case 0x37:
{
state.ptr += 1;
goto state_label_32;
}break;
}
}
{
state_label_36:
if (state.ptr == state.opl_ptr){
if ((true)){
goto state_label_32;
}
}
switch (*state.ptr){
default:
{
goto state_label_32;
}break;
case 0x30:case 0x31:case 0x32:case 0x33:case 0x34:case 0x35:case 0x36:
case 0x37:case 0x38:case 0x39:case 0x41:case 0x42:case 0x43:case 0x44:
case 0x45:case 0x46:case 0x61:case 0x62:case 0x63:case 0x64:case 0x65:
case 0x66:
{
state.ptr += 1;
goto state_label_36;
}break;
}
}
{
state_label_37:
if (state.ptr == state.opl_ptr){
if ((true)){
goto state_label_32;
}
}
switch (*state.ptr){
default:
{
goto state_label_32;
}break;
case 0x30:case 0x31:case 0x32:case 0x33:case 0x34:case 0x35:case 0x36:
case 0x37:case 0x38:case 0x39:case 0x41:case 0x42:case 0x43:case 0x44:
case 0x45:case 0x46:case 0x61:case 0x62:case 0x63:case 0x64:case 0x65:
case 0x66:
{
state.ptr += 1;
goto state_label_38;
}break;
}
}
{
state_label_38:
if (state.ptr == state.opl_ptr){
if ((true)){
goto state_label_32;
}
}
switch (*state.ptr){
default:
{
goto state_label_32;
}break;
case 0x30:case 0x31:case 0x32:case 0x33:case 0x34:case 0x35:case 0x36:
case 0x37:case 0x38:case 0x39:case 0x41:case 0x42:case 0x43:case 0x44:
case 0x45:case 0x46:case 0x61:case 0x62:case 0x63:case 0x64:case 0x65:
case 0x66:
{
state.ptr += 1;
goto state_label_39;
}break;
}
}
{
state_label_39:
if (state.ptr == state.opl_ptr){
if ((true)){
goto state_label_32;
}
}
switch (*state.ptr){
default:
{
goto state_label_32;
}break;
case 0x30:case 0x31:case 0x32:case 0x33:case 0x34:case 0x35:case 0x36:
case 0x37:case 0x38:case 0x39:case 0x41:case 0x42:case 0x43:case 0x44:
case 0x45:case 0x46:case 0x61:case 0x62:case 0x63:case 0x64:case 0x65:
case 0x66:
{
state.ptr += 1;
goto state_label_40;
}break;
}
}
{
state_label_40:
if (state.ptr == state.opl_ptr){
if ((true)){
goto state_label_32;
}
}
switch (*state.ptr){
default:
{
goto state_label_32;
}break;
case 0x30:case 0x31:case 0x32:case 0x33:case 0x34:case 0x35:case 0x36:
case 0x37:case 0x38:case 0x39:case 0x41:case 0x42:case 0x43:case 0x44:
case 0x45:case 0x46:case 0x61:case 0x62:case 0x63:case 0x64:case 0x65:
case 0x66:
{
state.ptr += 1;
goto state_label_41;
}break;
}
}
{
state_label_41:
if (state.ptr == state.opl_ptr){
if ((true)){
goto state_label_32;
}
}
switch (*state.ptr){
default:
{
goto state_label_32;
}break;
case 0x30:case 0x31:case 0x32:case 0x33:case 0x34:case 0x35:case 0x36:
case 0x37:case 0x38:case 0x39:case 0x41:case 0x42:case 0x43:case 0x44:
case 0x45:case 0x46:case 0x61:case 0x62:case 0x63:case 0x64:case 0x65:
case 0x66:
{
state.ptr += 1;
goto state_label_42;
}break;
}
}
{
state_label_42:
if (state.ptr == state.opl_ptr){
if ((true)){
goto state_label_32;
}
}
switch (*state.ptr){
default:
{
goto state_label_32;
}break;
case 0x30:case 0x31:case 0x32:case 0x33:case 0x34:case 0x35:case 0x36:
case 0x37:case 0x38:case 0x39:case 0x41:case 0x42:case 0x43:case 0x44:
case 0x45:case 0x46:case 0x61:case 0x62:case 0x63:case 0x64:case 0x65:
case 0x66:
{
state.ptr += 1;
goto state_label_43;
}break;
}
}
{
state_label_43:
if (state.ptr == state.opl_ptr){
if ((true)){
goto state_label_32;
}
}
switch (*state.ptr){
default:
{
goto state_label_32;
}break;
case 0x30:case 0x31:case 0x32:case 0x33:case 0x34:case 0x35:case 0x36:
case 0x37:case 0x38:case 0x39:case 0x41:case 0x42:case 0x43:case 0x44:
case 0x45:case 0x46:case 0x61:case 0x62:case 0x63:case 0x64:case 0x65:
case 0x66:
{
state.ptr += 1;
goto state_label_44;
}break;
}
}
{
state_label_44:
if (state.ptr == state.opl_ptr){
if ((true)){
goto state_label_32;
}
}
switch (*state.ptr){
default:
{
goto state_label_32;
}break;
case 0x30:case 0x31:case 0x32:case 0x33:case 0x34:case 0x35:case 0x36:
case 0x37:case 0x38:case 0x39:case 0x41:case 0x42:case 0x43:case 0x44:
case 0x45:case 0x46:case 0x61:case 0x62:case 0x63:case 0x64:case 0x65:
case 0x66:
{
state.ptr += 1;
goto state_label_32;
}break;
}
}
{
state_label_45:
if (state.ptr == state.opl_ptr){
if ((true)){
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_LexError;
token.kind = 2;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
}
state.flags_ZF0 = 0;
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_EOF;
token.kind = 0;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
}
state.flags_ZF0 = 0;
result = true;
goto end;
}
}
switch (*state.ptr){
default:
{
state.ptr += 1;
goto state_label_45;
}break;
case 0x20:case 0x29:case 0x5c:
{
state.ptr += 1;
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_LexError;
token.kind = 2;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
goto state_label_1;
}break;
case 0x28:
{
state.delim_one_past_last = state.ptr;
state.ptr += 1;
goto state_label_46;
}break;
}
}
{
state_label_46:
if (state.ptr == state.opl_ptr){
if ((true)){
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_LexError;
token.kind = 2;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
}
state.flags_ZF0 = 0;
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_EOF;
token.kind = 0;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
}
state.flags_ZF0 = 0;
result = true;
goto end;
}
}
switch (*state.ptr){
default:
{
state.ptr += 1;
goto state_label_46;
}break;
case 0x29:
{
state.ptr += 1;
goto state_label_47;
}break;
}
}
{
state_label_47:
u64 delim_length = state.delim_one_past_last - state.delim_first;
u64 parse_length = 0;
for (;;){
if (parse_length == delim_length){
goto state_label_48;
}
if (state.ptr == state.opl_ptr){
goto state_label_48;
}
if (*state.ptr == state.delim_first[parse_length]){
state.ptr += 1;
parse_length += 1;
}
else{
goto state_label_46;
}
}
}
{
state_label_48:
if (state.ptr == state.opl_ptr){
if ((true)){
goto state_label_46;
}
}
switch (*state.ptr){
default:
{
goto state_label_46;
}break;
case 0x22:
{
state.ptr += 1;
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
if ((((state.flags_ZF0)&(0x4))!=0)){
token.sub_kind = TokenCppKind_LiteralStringWideRaw;
token.kind = 10;
break;
}
if ((((state.flags_ZF0)&(0x8))!=0)){
token.sub_kind = TokenCppKind_LiteralStringUTF8Raw;
token.kind = 10;
break;
}
if ((((state.flags_ZF0)&(0x10))!=0)){
token.sub_kind = TokenCppKind_LiteralStringUTF16Raw;
token.kind = 10;
break;
}
if ((((state.flags_ZF0)&(0x20))!=0)){
token.sub_kind = TokenCppKind_LiteralStringUTF32Raw;
token.kind = 10;
break;
}
token.sub_kind = TokenCppKind_LiteralStringRaw;
token.kind = 10;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
goto state_label_1;
}break;
}
}
{
state_label_49:
if (state.ptr == state.opl_ptr){
if ((true)){
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_BlockComment;
token.kind = 3;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
}
state.flags_ZF0 = 0;
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_EOF;
token.kind = 0;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
}
state.flags_ZF0 = 0;
result = true;
goto end;
}
}
switch (*state.ptr){
default:
{
state.ptr += 1;
goto state_label_49;
}break;
case 0x0a:
{
state.ptr += 1;
state.flags_KB0 &= ~(0x1);
state.flags_KF0 &= ~(0x1);
goto state_label_49;
}break;
case 0x2a:
{
state.ptr += 1;
goto state_label_50;
}break;
}
}
{
state_label_50:
if (state.ptr == state.opl_ptr){
if ((true)){
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_BlockComment;
token.kind = 3;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
}
state.flags_ZF0 = 0;
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_EOF;
token.kind = 0;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
}
state.flags_ZF0 = 0;
result = true;
goto end;
}
}
switch (*state.ptr){
default:
{
state.ptr += 1;
goto state_label_49;
}break;
case 0x2a:
{
state.ptr += 1;
goto state_label_50;
}break;
case 0x2f:
{
state.ptr += 1;
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_BlockComment;
token.kind = 3;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
goto state_label_1;
}break;
}
}
{
state_label_51:
if (state.ptr == state.opl_ptr){
if ((true)){
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_LineComment;
token.kind = 3;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
}
state.flags_ZF0 = 0;
goto state_label_1;
}
}
switch (*state.ptr){
default:
{
state.ptr += 1;
goto state_label_51;
}break;
case 0x0a:
{
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_LineComment;
token.kind = 3;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
goto state_label_1;
}break;
case 0x5c:
{
state.ptr += 1;
goto state_label_52;
}break;
}
}
{
state_label_52:
if (state.ptr == state.opl_ptr){
if ((true)){
result = true;
goto end;
}
}
switch (*state.ptr){
default:
{
state.ptr += 1;
goto state_label_51;
}break;
case 0x0d:
{
state.ptr += 1;
goto state_label_52;
}break;
}
}
{
state_label_53:
if (state.ptr == state.opl_ptr){
if ((true)){
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_Colon;
token.kind = 15;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
}
state.flags_ZF0 = 0;
goto state_label_1;
}
}
switch (*state.ptr){
default:
{
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_Colon;
token.kind = 15;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
goto state_label_1;
}break;
case 0x3a:
{
state.ptr += 1;
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_ColonColon;
token.kind = 7;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
goto state_label_1;
}break;
}
}
{
state_label_54:
if (state.ptr == state.opl_ptr){
if ((true)){
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_Plus;
token.kind = 7;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
}
state.flags_ZF0 = 0;
goto state_label_1;
}
}
switch (*state.ptr){
default:
{
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_Plus;
token.kind = 7;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
goto state_label_1;
}break;
case 0x2b:
{
state.ptr += 1;
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_PlusPlus;
token.kind = 7;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
goto state_label_1;
}break;
case 0x3d:
{
state.ptr += 1;
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_PlusEq;
token.kind = 7;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
goto state_label_1;
}break;
}
}
{
state_label_55:
if (state.ptr == state.opl_ptr){
if ((true)){
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_Minus;
token.kind = 7;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
}
state.flags_ZF0 = 0;
goto state_label_1;
}
}
switch (*state.ptr){
default:
{
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_Minus;
token.kind = 7;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
goto state_label_1;
}break;
case 0x2d:
{
state.ptr += 1;
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_MinusMinus;
token.kind = 7;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
goto state_label_1;
}break;
case 0x3d:
{
state.ptr += 1;
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_MinusEq;
token.kind = 7;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
goto state_label_1;
}break;
case 0x3e:
{
state.ptr += 1;
goto state_label_56;
}break;
}
}
{
state_label_56:
if (state.ptr == state.opl_ptr){
if ((true)){
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_Arrow;
token.kind = 7;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
}
state.flags_ZF0 = 0;
goto state_label_1;
}
}
switch (*state.ptr){
default:
{
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_Arrow;
token.kind = 7;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
goto state_label_1;
}break;
case 0x2a:
{
state.ptr += 1;
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_ArrowStar;
token.kind = 7;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
goto state_label_1;
}break;
}
}
{
state_label_57:
if (state.ptr == state.opl_ptr){
if ((true)){
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_Less;
token.kind = 7;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
}
state.flags_ZF0 = 0;
goto state_label_1;
}
}
switch (*state.ptr){
default:
{
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_Less;
token.kind = 7;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
goto state_label_1;
}break;
case 0x3c:
{
state.ptr += 1;
goto state_label_66;
}break;
case 0x3d:
{
state.ptr += 1;
goto state_label_59;
}break;
}
}
{
state_label_58:
if (state.ptr == state.opl_ptr){
if ((true)){
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_Grtr;
token.kind = 7;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
}
state.flags_ZF0 = 0;
goto state_label_1;
}
}
switch (*state.ptr){
default:
{
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_Grtr;
token.kind = 7;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
goto state_label_1;
}break;
case 0x3d:
{
state.ptr += 1;
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_GrtrEq;
token.kind = 7;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
goto state_label_1;
}break;
case 0x3e:
{
state.ptr += 1;
goto state_label_67;
}break;
}
}
{
state_label_59:
if (state.ptr == state.opl_ptr){
if ((true)){
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_LessEq;
token.kind = 7;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
}
state.flags_ZF0 = 0;
goto state_label_1;
}
}
switch (*state.ptr){
default:
{
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_LessEq;
token.kind = 7;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
goto state_label_1;
}break;
case 0x3e:
{
state.ptr += 1;
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_Compare;
token.kind = 7;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
goto state_label_1;
}break;
}
}
{
state_label_60:
if (state.ptr == state.opl_ptr){
if ((true)){
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_Eq;
token.kind = 7;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
}
state.flags_ZF0 = 0;
goto state_label_1;
}
}
switch (*state.ptr){
default:
{
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_Eq;
token.kind = 7;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
goto state_label_1;
}break;
case 0x3d:
{
state.ptr += 1;
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_EqEq;
token.kind = 7;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
goto state_label_1;
}break;
}
}
{
state_label_61:
if (state.ptr == state.opl_ptr){
if ((true)){
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_Not;
token.kind = 7;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
}
state.flags_ZF0 = 0;
goto state_label_1;
}
}
switch (*state.ptr){
default:
{
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_Not;
token.kind = 7;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
goto state_label_1;
}break;
case 0x3d:
{
state.ptr += 1;
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_NotEq;
token.kind = 7;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
goto state_label_1;
}break;
}
}
{
state_label_62:
if (state.ptr == state.opl_ptr){
if ((true)){
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_And;
token.kind = 7;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
}
state.flags_ZF0 = 0;
goto state_label_1;
}
}
switch (*state.ptr){
default:
{
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_And;
token.kind = 7;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
goto state_label_1;
}break;
case 0x26:
{
state.ptr += 1;
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_AndAnd;
token.kind = 7;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
goto state_label_1;
}break;
}
}
{
state_label_63:
if (state.ptr == state.opl_ptr){
if ((true)){
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_Or;
token.kind = 7;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
}
state.flags_ZF0 = 0;
goto state_label_1;
}
}
switch (*state.ptr){
default:
{
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_Or;
token.kind = 7;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
goto state_label_1;
}break;
case 0x7c:
{
state.ptr += 1;
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_OrOr;
token.kind = 7;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
goto state_label_1;
}break;
}
}
{
state_label_64:
if (state.ptr == state.opl_ptr){
if ((true)){
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_Star;
token.kind = 7;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
}
state.flags_ZF0 = 0;
goto state_label_1;
}
}
switch (*state.ptr){
default:
{
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_Star;
token.kind = 7;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
goto state_label_1;
}break;
case 0x3d:
{
state.ptr += 1;
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_StarEq;
token.kind = 7;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
goto state_label_1;
}break;
}
}
{
state_label_65:
if (state.ptr == state.opl_ptr){
if ((true)){
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_Mod;
token.kind = 7;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
}
state.flags_ZF0 = 0;
goto state_label_1;
}
}
switch (*state.ptr){
default:
{
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_Mod;
token.kind = 7;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
goto state_label_1;
}break;
case 0x3d:
{
state.ptr += 1;
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_ModEq;
token.kind = 7;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
goto state_label_1;
}break;
}
}
{
state_label_66:
if (state.ptr == state.opl_ptr){
if ((true)){
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_LeftLeft;
token.kind = 7;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
}
state.flags_ZF0 = 0;
goto state_label_1;
}
}
switch (*state.ptr){
default:
{
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_LeftLeft;
token.kind = 7;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
goto state_label_1;
}break;
case 0x3d:
{
state.ptr += 1;
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_LeftLeftEq;
token.kind = 7;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
goto state_label_1;
}break;
}
}
{
state_label_67:
if (state.ptr == state.opl_ptr){
if ((true)){
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_RightRight;
token.kind = 7;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
}
state.flags_ZF0 = 0;
goto state_label_1;
}
}
switch (*state.ptr){
default:
{
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_RightRight;
token.kind = 7;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
goto state_label_1;
}break;
case 0x3d:
{
state.ptr += 1;
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_RightRightEq;
token.kind = 7;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
goto state_label_1;
}break;
}
}
{
state_label_68:
if (state.ptr == state.opl_ptr){
if ((true)){
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_PPStringify;
token.kind = 15;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
}
state.flags_ZF0 = 0;
goto state_label_1;
}
}
switch (*state.ptr){
default:
{
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_PPStringify;
token.kind = 15;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
goto state_label_1;
}break;
case 0x23:
{
state.ptr += 1;
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_PPConcat;
token.kind = 15;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
goto state_label_1;
}break;
}
}
{
state_label_69:
if (state.ptr == state.opl_ptr){
if ((true)){
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_LexError;
token.kind = 2;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
}
state.flags_ZF0 = 0;
goto state_label_1;
}
}
switch (*state.ptr){
default:
{
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_LexError;
token.kind = 2;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
goto state_label_1;
}break;
case 0x2e:
{
state.ptr += 1;
{
Token token = {};
token.pos = (i64)(state.emit_ptr - state.base);
token.size = (i64)(state.ptr - state.emit_ptr);
token.flags = state.flags_KB0;
do{
token.sub_kind = TokenCppKind_DotDotDot;
token.kind = 7;
}while(0);
token_list_push(arena, list, &token);
emit_counter += 1;
state.emit_ptr = state.ptr;
if (emit_counter == max){
goto end;
}
}
state.flags_ZF0 = 0;
goto state_label_1;
}break;
}
}
end:;
block_copy((state_ptr), (&state), sizeof(*(state_ptr)));
return(result);
}
static Token_List
lex_full_input_cpp(Arena *arena, String_Const_u8 input){
Lex_State_Cpp state = {};
lex_full_input_cpp_init(&state, input);
Token_List list = {};
lex_full_input_cpp_breaks(arena, &list, &state, max_u64);
return(list);
}
# 88 "/home/sam/.bin/4coder/custom/4coder_default_include.cpp" 2

# 1 "/home/sam/.bin/4coder/custom/4coder_default_map.cpp" 1






static void
setup_default_mapping(Mapping *mapping, i64 global_id, i64 file_id, i64 code_id){
    Mapping *m = 0; Command_Map *map = 0;
    m = (mapping);

    map = mapping_get_or_make_map(m, (global_id));
    map_set_binding_l(m, map, default_startup, InputEventKind_Core, (CoreCode_Startup), 0);
    map_set_binding_l(m, map, default_try_exit, InputEventKind_Core, (CoreCode_TryExit), 0);
    map_set_binding_l(m, map, clipboard_record_clip, InputEventKind_Core, (CoreCode_NewClipboardContents), 0);
    map_set_binding_l(m, map, keyboard_macro_start_recording, InputEventKind_KeyStroke, (KeyCode_U), KeyCode_Control, 0);
    map_set_binding_l(m, map, keyboard_macro_finish_recording, InputEventKind_KeyStroke, (KeyCode_U), KeyCode_Control, KeyCode_Shift, 0);
    map_set_binding_l(m, map, keyboard_macro_replay, InputEventKind_KeyStroke, (KeyCode_U), KeyCode_Alt, 0);
    map_set_binding_l(m, map, change_active_panel, InputEventKind_KeyStroke, (KeyCode_Comma), KeyCode_Control, 0);
    map_set_binding_l(m, map, change_active_panel_backwards, InputEventKind_KeyStroke, (KeyCode_Comma), KeyCode_Control, KeyCode_Shift, 0);
    map_set_binding_l(m, map, interactive_new, InputEventKind_KeyStroke, (KeyCode_N), KeyCode_Control, 0);
    map_set_binding_l(m, map, interactive_open_or_new, InputEventKind_KeyStroke, (KeyCode_O), KeyCode_Control, 0);
    map_set_binding_l(m, map, open_in_other, InputEventKind_KeyStroke, (KeyCode_O), KeyCode_Alt, 0);
    map_set_binding_l(m, map, interactive_kill_buffer, InputEventKind_KeyStroke, (KeyCode_K), KeyCode_Control, 0);
    map_set_binding_l(m, map, interactive_switch_buffer, InputEventKind_KeyStroke, (KeyCode_I), KeyCode_Control, 0);
    map_set_binding_l(m, map, project_go_to_root_directory, InputEventKind_KeyStroke, (KeyCode_H), KeyCode_Control, 0);
    map_set_binding_l(m, map, save_all_dirty_buffers, InputEventKind_KeyStroke, (KeyCode_S), KeyCode_Control, KeyCode_Shift, 0);
    map_set_binding_l(m, map, change_to_build_panel, InputEventKind_KeyStroke, (KeyCode_Period), KeyCode_Alt, 0);
    map_set_binding_l(m, map, close_build_panel, InputEventKind_KeyStroke, (KeyCode_Comma), KeyCode_Alt, 0);
    map_set_binding_l(m, map, goto_next_jump, InputEventKind_KeyStroke, (KeyCode_N), KeyCode_Alt, 0);
    map_set_binding_l(m, map, goto_prev_jump, InputEventKind_KeyStroke, (KeyCode_N), KeyCode_Alt, KeyCode_Shift, 0);
    map_set_binding_l(m, map, build_in_build_panel, InputEventKind_KeyStroke, (KeyCode_M), KeyCode_Alt, 0);
    map_set_binding_l(m, map, goto_first_jump, InputEventKind_KeyStroke, (KeyCode_M), KeyCode_Alt, KeyCode_Shift, 0);
    map_set_binding_l(m, map, toggle_filebar, InputEventKind_KeyStroke, (KeyCode_B), KeyCode_Alt, 0);
    map_set_binding_l(m, map, execute_any_cli, InputEventKind_KeyStroke, (KeyCode_Z), KeyCode_Alt, 0);
    map_set_binding_l(m, map, execute_previous_cli, InputEventKind_KeyStroke, (KeyCode_Z), KeyCode_Alt, KeyCode_Shift, 0);
    map_set_binding_l(m, map, command_lister, InputEventKind_KeyStroke, (KeyCode_X), KeyCode_Alt, 0);
    map_set_binding_l(m, map, project_command_lister, InputEventKind_KeyStroke, (KeyCode_X), KeyCode_Alt, KeyCode_Shift, 0);
    map_set_binding_l(m, map, quick_swap_buffer, InputEventKind_KeyStroke, (KeyCode_BackwardSlash), KeyCode_Alt, 0);
    map_set_binding_l(m, map, jump_to_last_point, InputEventKind_KeyStroke, (KeyCode_P), KeyCode_Control, 0);
    map_set_binding_l(m, map, list_all_functions_current_buffer_lister, InputEventKind_KeyStroke, (KeyCode_I), KeyCode_Control, KeyCode_Shift, 0);
    map_set_binding_l(m, map, exit_4coder, InputEventKind_KeyStroke, (KeyCode_F4), KeyCode_Alt, 0);
    map_set_binding_l(m, map, project_fkey_command, InputEventKind_KeyStroke, (KeyCode_F1), 0);
    map_set_binding_l(m, map, project_fkey_command, InputEventKind_KeyStroke, (KeyCode_F2), 0);
    map_set_binding_l(m, map, project_fkey_command, InputEventKind_KeyStroke, (KeyCode_F3), 0);
    map_set_binding_l(m, map, project_fkey_command, InputEventKind_KeyStroke, (KeyCode_F4), 0);
    map_set_binding_l(m, map, project_fkey_command, InputEventKind_KeyStroke, (KeyCode_F5), 0);
    map_set_binding_l(m, map, project_fkey_command, InputEventKind_KeyStroke, (KeyCode_F6), 0);
    map_set_binding_l(m, map, project_fkey_command, InputEventKind_KeyStroke, (KeyCode_F7), 0);
    map_set_binding_l(m, map, project_fkey_command, InputEventKind_KeyStroke, (KeyCode_F8), 0);
    map_set_binding_l(m, map, project_fkey_command, InputEventKind_KeyStroke, (KeyCode_F9), 0);
    map_set_binding_l(m, map, project_fkey_command, InputEventKind_KeyStroke, (KeyCode_F10), 0);
    map_set_binding_l(m, map, project_fkey_command, InputEventKind_KeyStroke, (KeyCode_F11), 0);
    map_set_binding_l(m, map, project_fkey_command, InputEventKind_KeyStroke, (KeyCode_F12), 0);
    map_set_binding_l(m, map, project_fkey_command, InputEventKind_KeyStroke, (KeyCode_F13), 0);
    map_set_binding_l(m, map, project_fkey_command, InputEventKind_KeyStroke, (KeyCode_F14), 0);
    map_set_binding_l(m, map, project_fkey_command, InputEventKind_KeyStroke, (KeyCode_F15), 0);
    map_set_binding_l(m, map, project_fkey_command, InputEventKind_KeyStroke, (KeyCode_F16), 0);
    map_set_binding_l(m, map, mouse_wheel_scroll, InputEventKind_MouseWheel, 0, 0);
    map_set_binding_l(m, map, mouse_wheel_change_face_size, InputEventKind_MouseWheel, 0, KeyCode_Control, 0);

    map = mapping_get_or_make_map(m, (file_id));
    map_set_parent(m, map, (global_id));
    map_set_binding_text_input(map, write_text_input);
    map_set_binding_l(m, map, click_set_cursor_and_mark, InputEventKind_MouseButton, (MouseCode_Left), 0);
    map_set_binding_l(m, map, click_set_cursor, InputEventKind_MouseButtonRelease, (MouseCode_Left), 0);
    map_set_binding_l(m, map, click_set_cursor_and_mark, InputEventKind_Core, (CoreCode_ClickActivateView), 0);
    map_set_binding_l(m, map, click_set_cursor_if_lbutton, InputEventKind_MouseMove, 0, 0);
    map_set_binding_l(m, map, delete_char, InputEventKind_KeyStroke, (KeyCode_Delete), 0);
    map_set_binding_l(m, map, backspace_char, InputEventKind_KeyStroke, (KeyCode_Backspace), 0);
    map_set_binding_l(m, map, move_up, InputEventKind_KeyStroke, (KeyCode_Up), 0);
    map_set_binding_l(m, map, move_down, InputEventKind_KeyStroke, (KeyCode_Down), 0);
    map_set_binding_l(m, map, move_left, InputEventKind_KeyStroke, (KeyCode_Left), 0);
    map_set_binding_l(m, map, move_right, InputEventKind_KeyStroke, (KeyCode_Right), 0);
    map_set_binding_l(m, map, seek_end_of_line, InputEventKind_KeyStroke, (KeyCode_End), 0);
    map_set_binding_l(m, map, seek_beginning_of_line, InputEventKind_KeyStroke, (KeyCode_Home), 0);
    map_set_binding_l(m, map, page_up, InputEventKind_KeyStroke, (KeyCode_PageUp), 0);
    map_set_binding_l(m, map, page_down, InputEventKind_KeyStroke, (KeyCode_PageDown), 0);
    map_set_binding_l(m, map, goto_beginning_of_file, InputEventKind_KeyStroke, (KeyCode_PageUp), KeyCode_Control, 0);
    map_set_binding_l(m, map, goto_end_of_file, InputEventKind_KeyStroke, (KeyCode_PageDown), KeyCode_Control, 0);
    map_set_binding_l(m, map, move_up_to_blank_line_end, InputEventKind_KeyStroke, (KeyCode_Up), KeyCode_Control, 0);
    map_set_binding_l(m, map, move_down_to_blank_line_end, InputEventKind_KeyStroke, (KeyCode_Down), KeyCode_Control, 0);
    map_set_binding_l(m, map, move_left_whitespace_boundary, InputEventKind_KeyStroke, (KeyCode_Left), KeyCode_Control, 0);
    map_set_binding_l(m, map, move_right_whitespace_boundary, InputEventKind_KeyStroke, (KeyCode_Right), KeyCode_Control, 0);
    map_set_binding_l(m, map, move_line_up, InputEventKind_KeyStroke, (KeyCode_Up), KeyCode_Alt, 0);
    map_set_binding_l(m, map, move_line_down, InputEventKind_KeyStroke, (KeyCode_Down), KeyCode_Alt, 0);
    map_set_binding_l(m, map, backspace_alpha_numeric_boundary, InputEventKind_KeyStroke, (KeyCode_Backspace), KeyCode_Control, 0);
    map_set_binding_l(m, map, delete_alpha_numeric_boundary, InputEventKind_KeyStroke, (KeyCode_Delete), KeyCode_Control, 0);
    map_set_binding_l(m, map, snipe_backward_whitespace_or_token_boundary, InputEventKind_KeyStroke, (KeyCode_Backspace), KeyCode_Alt, 0);
    map_set_binding_l(m, map, snipe_forward_whitespace_or_token_boundary, InputEventKind_KeyStroke, (KeyCode_Delete), KeyCode_Alt, 0);
    map_set_binding_l(m, map, set_mark, InputEventKind_KeyStroke, (KeyCode_Space), KeyCode_Control, 0);
    map_set_binding_l(m, map, replace_in_range, InputEventKind_KeyStroke, (KeyCode_A), KeyCode_Control, 0);
    map_set_binding_l(m, map, copy, InputEventKind_KeyStroke, (KeyCode_C), KeyCode_Control, 0);
    map_set_binding_l(m, map, delete_range, InputEventKind_KeyStroke, (KeyCode_D), KeyCode_Control, 0);
    map_set_binding_l(m, map, delete_line, InputEventKind_KeyStroke, (KeyCode_D), KeyCode_Control, KeyCode_Shift, 0);
    map_set_binding_l(m, map, center_view, InputEventKind_KeyStroke, (KeyCode_E), KeyCode_Control, 0);
    map_set_binding_l(m, map, left_adjust_view, InputEventKind_KeyStroke, (KeyCode_E), KeyCode_Control, KeyCode_Shift, 0);
    map_set_binding_l(m, map, search, InputEventKind_KeyStroke, (KeyCode_F), KeyCode_Control, 0);
    map_set_binding_l(m, map, list_all_locations, InputEventKind_KeyStroke, (KeyCode_F), KeyCode_Control, KeyCode_Shift, 0);
    map_set_binding_l(m, map, list_all_substring_locations_case_insensitive, InputEventKind_KeyStroke, (KeyCode_F), KeyCode_Alt, 0);
    map_set_binding_l(m, map, goto_line, InputEventKind_KeyStroke, (KeyCode_G), KeyCode_Control, 0);
    map_set_binding_l(m, map, list_all_locations_of_selection, InputEventKind_KeyStroke, (KeyCode_G), KeyCode_Control, KeyCode_Shift, 0);
    map_set_binding_l(m, map, snippet_lister, InputEventKind_KeyStroke, (KeyCode_J), KeyCode_Control, 0);
    map_set_binding_l(m, map, kill_buffer, InputEventKind_KeyStroke, (KeyCode_K), KeyCode_Control, KeyCode_Shift, 0);
    map_set_binding_l(m, map, duplicate_line, InputEventKind_KeyStroke, (KeyCode_L), KeyCode_Control, 0);
    map_set_binding_l(m, map, cursor_mark_swap, InputEventKind_KeyStroke, (KeyCode_M), KeyCode_Control, 0);
    map_set_binding_l(m, map, reopen, InputEventKind_KeyStroke, (KeyCode_O), KeyCode_Control, KeyCode_Shift, 0);
    map_set_binding_l(m, map, query_replace, InputEventKind_KeyStroke, (KeyCode_Q), KeyCode_Control, 0);
    map_set_binding_l(m, map, query_replace_identifier, InputEventKind_KeyStroke, (KeyCode_Q), KeyCode_Control, KeyCode_Shift, 0);
    map_set_binding_l(m, map, query_replace_selection, InputEventKind_KeyStroke, (KeyCode_Q), KeyCode_Alt, 0);
    map_set_binding_l(m, map, reverse_search, InputEventKind_KeyStroke, (KeyCode_R), KeyCode_Control, 0);
    map_set_binding_l(m, map, save, InputEventKind_KeyStroke, (KeyCode_S), KeyCode_Control, 0);
    map_set_binding_l(m, map, save_all_dirty_buffers, InputEventKind_KeyStroke, (KeyCode_S), KeyCode_Control, KeyCode_Shift, 0);
    map_set_binding_l(m, map, search_identifier, InputEventKind_KeyStroke, (KeyCode_T), KeyCode_Control, 0);
    map_set_binding_l(m, map, list_all_locations_of_identifier, InputEventKind_KeyStroke, (KeyCode_T), KeyCode_Control, KeyCode_Shift, 0);
    map_set_binding_l(m, map, paste_and_indent, InputEventKind_KeyStroke, (KeyCode_V), KeyCode_Control, 0);
    map_set_binding_l(m, map, paste_next_and_indent, InputEventKind_KeyStroke, (KeyCode_V), KeyCode_Control, KeyCode_Shift, 0);
    map_set_binding_l(m, map, cut, InputEventKind_KeyStroke, (KeyCode_X), KeyCode_Control, 0);
    map_set_binding_l(m, map, redo, InputEventKind_KeyStroke, (KeyCode_Y), KeyCode_Control, 0);
    map_set_binding_l(m, map, undo, InputEventKind_KeyStroke, (KeyCode_Z), KeyCode_Control, 0);
    map_set_binding_l(m, map, view_buffer_other_panel, InputEventKind_KeyStroke, (KeyCode_1), KeyCode_Control, 0);
    map_set_binding_l(m, map, swap_panels, InputEventKind_KeyStroke, (KeyCode_2), KeyCode_Control, 0);
    map_set_binding_l(m, map, if_read_only_goto_position, InputEventKind_KeyStroke, (KeyCode_Return), 0);
    map_set_binding_l(m, map, if_read_only_goto_position_same_panel, InputEventKind_KeyStroke, (KeyCode_Return), KeyCode_Shift, 0);
    map_set_binding_l(m, map, view_jump_list_with_lister, InputEventKind_KeyStroke, (KeyCode_Period), KeyCode_Control, KeyCode_Shift, 0);

    map = mapping_get_or_make_map(m, (code_id));
    map_set_parent(m, map, (file_id));
    map_set_binding_text_input(map, write_text_and_auto_indent);
    map_set_binding_l(m, map, move_left_alpha_numeric_boundary, InputEventKind_KeyStroke, (KeyCode_Left), KeyCode_Control, 0);
    map_set_binding_l(m, map, move_right_alpha_numeric_boundary, InputEventKind_KeyStroke, (KeyCode_Right), KeyCode_Control, 0);
    map_set_binding_l(m, map, move_left_alpha_numeric_or_camel_boundary, InputEventKind_KeyStroke, (KeyCode_Left), KeyCode_Alt, 0);
    map_set_binding_l(m, map, move_right_alpha_numeric_or_camel_boundary, InputEventKind_KeyStroke, (KeyCode_Right), KeyCode_Alt, 0);
    map_set_binding_l(m, map, comment_line_toggle, InputEventKind_KeyStroke, (KeyCode_Semicolon), KeyCode_Control, 0);
    map_set_binding_l(m, map, word_complete, InputEventKind_KeyStroke, (KeyCode_Tab), 0);
    map_set_binding_l(m, map, auto_indent_range, InputEventKind_KeyStroke, (KeyCode_Tab), KeyCode_Control, 0);
    map_set_binding_l(m, map, auto_indent_line_at_cursor, InputEventKind_KeyStroke, (KeyCode_Tab), KeyCode_Shift, 0);
    map_set_binding_l(m, map, word_complete_drop_down, InputEventKind_KeyStroke, (KeyCode_Tab), KeyCode_Shift, KeyCode_Control, 0);
    map_set_binding_l(m, map, write_block, InputEventKind_KeyStroke, (KeyCode_R), KeyCode_Alt, 0);
    map_set_binding_l(m, map, write_todo, InputEventKind_KeyStroke, (KeyCode_T), KeyCode_Alt, 0);
    map_set_binding_l(m, map, write_note, InputEventKind_KeyStroke, (KeyCode_Y), KeyCode_Alt, 0);
    map_set_binding_l(m, map, list_all_locations_of_type_definition, InputEventKind_KeyStroke, (KeyCode_D), KeyCode_Alt, 0);
    map_set_binding_l(m, map, list_all_locations_of_type_definition_of_identifier, InputEventKind_KeyStroke, (KeyCode_T), KeyCode_Alt, KeyCode_Shift, 0);
    map_set_binding_l(m, map, open_long_braces, InputEventKind_KeyStroke, (KeyCode_LeftBracket), KeyCode_Control, 0);
    map_set_binding_l(m, map, open_long_braces_semicolon, InputEventKind_KeyStroke, (KeyCode_LeftBracket), KeyCode_Control, KeyCode_Shift, 0);
    map_set_binding_l(m, map, open_long_braces_break, InputEventKind_KeyStroke, (KeyCode_RightBracket), KeyCode_Control, KeyCode_Shift, 0);
    map_set_binding_l(m, map, select_surrounding_scope, InputEventKind_KeyStroke, (KeyCode_LeftBracket), KeyCode_Alt, 0);
    map_set_binding_l(m, map, select_surrounding_scope_maximal, InputEventKind_KeyStroke, (KeyCode_LeftBracket), KeyCode_Alt, KeyCode_Shift, 0);
    map_set_binding_l(m, map, select_prev_scope_absolute, InputEventKind_KeyStroke, (KeyCode_RightBracket), KeyCode_Alt, 0);
    map_set_binding_l(m, map, select_prev_top_most_scope, InputEventKind_KeyStroke, (KeyCode_RightBracket), KeyCode_Alt, KeyCode_Shift, 0);
    map_set_binding_l(m, map, select_next_scope_absolute, InputEventKind_KeyStroke, (KeyCode_Quote), KeyCode_Alt, 0);
    map_set_binding_l(m, map, select_next_scope_after_current, InputEventKind_KeyStroke, (KeyCode_Quote), KeyCode_Alt, KeyCode_Shift, 0);
    map_set_binding_l(m, map, place_in_scope, InputEventKind_KeyStroke, (KeyCode_ForwardSlash), KeyCode_Alt, 0);
    map_set_binding_l(m, map, delete_current_scope, InputEventKind_KeyStroke, (KeyCode_Minus), KeyCode_Alt, 0);
    map_set_binding_l(m, map, if0_off, InputEventKind_KeyStroke, (KeyCode_I), KeyCode_Alt, 0);
    map_set_binding_l(m, map, open_file_in_quotes, InputEventKind_KeyStroke, (KeyCode_1), KeyCode_Alt, 0);
    map_set_binding_l(m, map, open_matching_file_cpp, InputEventKind_KeyStroke, (KeyCode_2), KeyCode_Alt, 0);
    map_set_binding_l(m, map, write_zero_struct, InputEventKind_KeyStroke, (KeyCode_0), KeyCode_Control, 0);
    map_set_binding_l(m, map, jump_to_definition_at_cursor, InputEventKind_KeyStroke, (KeyCode_W), KeyCode_Control, 0);
}
# 90 "/home/sam/.bin/4coder/custom/4coder_default_include.cpp" 2
# 1 "/home/sam/.bin/4coder/custom/4coder_mac_map.cpp" 1






static void
setup_mac_mapping(Mapping *mapping, i64 global_id, i64 file_id, i64 code_id){
    Mapping *m = 0; Command_Map *map = 0;
    m = (mapping);

    map = mapping_get_or_make_map(m, (global_id));
    map_set_binding_l(m, map, default_startup, InputEventKind_Core, (CoreCode_Startup), 0);
    map_set_binding_l(m, map, default_try_exit, InputEventKind_Core, (CoreCode_TryExit), 0);
    map_set_binding_l(m, map, clipboard_record_clip, InputEventKind_Core, (CoreCode_NewClipboardContents), 0);
    map_set_binding_l(m, map, keyboard_macro_start_recording, InputEventKind_KeyStroke, (KeyCode_U), KeyCode_Command, 0);
    map_set_binding_l(m, map, keyboard_macro_finish_recording, InputEventKind_KeyStroke, (KeyCode_U), KeyCode_Command, KeyCode_Shift, 0);
    map_set_binding_l(m, map, keyboard_macro_replay, InputEventKind_KeyStroke, (KeyCode_U), KeyCode_Control, 0);
    map_set_binding_l(m, map, change_active_panel, InputEventKind_KeyStroke, (KeyCode_Comma), KeyCode_Command, 0);
    map_set_binding_l(m, map, change_active_panel_backwards, InputEventKind_KeyStroke, (KeyCode_Comma), KeyCode_Command, KeyCode_Shift, 0);
    map_set_binding_l(m, map, interactive_new, InputEventKind_KeyStroke, (KeyCode_N), KeyCode_Command, 0);
    map_set_binding_l(m, map, interactive_open_or_new, InputEventKind_KeyStroke, (KeyCode_O), KeyCode_Command, 0);
    map_set_binding_l(m, map, open_in_other, InputEventKind_KeyStroke, (KeyCode_O), KeyCode_Control, 0);
    map_set_binding_l(m, map, interactive_kill_buffer, InputEventKind_KeyStroke, (KeyCode_K), KeyCode_Command, 0);
    map_set_binding_l(m, map, interactive_switch_buffer, InputEventKind_KeyStroke, (KeyCode_I), KeyCode_Command, 0);
    map_set_binding_l(m, map, project_go_to_root_directory, InputEventKind_KeyStroke, (KeyCode_H), KeyCode_Command, 0);
    map_set_binding_l(m, map, save_all_dirty_buffers, InputEventKind_KeyStroke, (KeyCode_S), KeyCode_Command, KeyCode_Shift, 0);
    map_set_binding_l(m, map, change_to_build_panel, InputEventKind_KeyStroke, (KeyCode_Period), KeyCode_Control, 0);
    map_set_binding_l(m, map, close_build_panel, InputEventKind_KeyStroke, (KeyCode_Comma), KeyCode_Control, 0);
    map_set_binding_l(m, map, goto_next_jump, InputEventKind_KeyStroke, (KeyCode_N), KeyCode_Control, 0);
    map_set_binding_l(m, map, goto_prev_jump, InputEventKind_KeyStroke, (KeyCode_N), KeyCode_Control, KeyCode_Shift, 0);
    map_set_binding_l(m, map, build_in_build_panel, InputEventKind_KeyStroke, (KeyCode_M), KeyCode_Control, 0);
    map_set_binding_l(m, map, goto_first_jump, InputEventKind_KeyStroke, (KeyCode_M), KeyCode_Control, KeyCode_Shift, 0);
    map_set_binding_l(m, map, toggle_filebar, InputEventKind_KeyStroke, (KeyCode_B), KeyCode_Control, 0);
    map_set_binding_l(m, map, execute_any_cli, InputEventKind_KeyStroke, (KeyCode_Z), KeyCode_Control, 0);
    map_set_binding_l(m, map, execute_previous_cli, InputEventKind_KeyStroke, (KeyCode_Z), KeyCode_Control, KeyCode_Shift, 0);
    map_set_binding_l(m, map, command_lister, InputEventKind_KeyStroke, (KeyCode_X), KeyCode_Control, 0);
    map_set_binding_l(m, map, project_command_lister, InputEventKind_KeyStroke, (KeyCode_X), KeyCode_Control, KeyCode_Shift, 0);
    map_set_binding_l(m, map, quick_swap_buffer, InputEventKind_KeyStroke, (KeyCode_BackwardSlash), KeyCode_Command, 0);
    map_set_binding_l(m, map, jump_to_last_point, InputEventKind_KeyStroke, (KeyCode_P), KeyCode_Command, 0);
    map_set_binding_l(m, map, list_all_functions_current_buffer, InputEventKind_KeyStroke, (KeyCode_I), KeyCode_Command, KeyCode_Shift, 0);
    map_set_binding_l(m, map, project_fkey_command, InputEventKind_KeyStroke, (KeyCode_F1), 0);
    map_set_binding_l(m, map, project_fkey_command, InputEventKind_KeyStroke, (KeyCode_F2), 0);
    map_set_binding_l(m, map, project_fkey_command, InputEventKind_KeyStroke, (KeyCode_F3), 0);
    map_set_binding_l(m, map, project_fkey_command, InputEventKind_KeyStroke, (KeyCode_F4), 0);
    map_set_binding_l(m, map, project_fkey_command, InputEventKind_KeyStroke, (KeyCode_F5), 0);
    map_set_binding_l(m, map, project_fkey_command, InputEventKind_KeyStroke, (KeyCode_F6), 0);
    map_set_binding_l(m, map, project_fkey_command, InputEventKind_KeyStroke, (KeyCode_F7), 0);
    map_set_binding_l(m, map, project_fkey_command, InputEventKind_KeyStroke, (KeyCode_F8), 0);
    map_set_binding_l(m, map, project_fkey_command, InputEventKind_KeyStroke, (KeyCode_F9), 0);
    map_set_binding_l(m, map, project_fkey_command, InputEventKind_KeyStroke, (KeyCode_F10), 0);
    map_set_binding_l(m, map, project_fkey_command, InputEventKind_KeyStroke, (KeyCode_F11), 0);
    map_set_binding_l(m, map, project_fkey_command, InputEventKind_KeyStroke, (KeyCode_F12), 0);
    map_set_binding_l(m, map, project_fkey_command, InputEventKind_KeyStroke, (KeyCode_F13), 0);
    map_set_binding_l(m, map, project_fkey_command, InputEventKind_KeyStroke, (KeyCode_F14), 0);
    map_set_binding_l(m, map, project_fkey_command, InputEventKind_KeyStroke, (KeyCode_F15), 0);
    map_set_binding_l(m, map, project_fkey_command, InputEventKind_KeyStroke, (KeyCode_F16), 0);
    map_set_binding_l(m, map, exit_4coder, InputEventKind_KeyStroke, (KeyCode_F4), KeyCode_Alt, 0);
    map_set_binding_l(m, map, mouse_wheel_scroll, InputEventKind_MouseWheel, 0, 0);
    map_set_binding_l(m, map, mouse_wheel_change_face_size, InputEventKind_MouseWheel, 0, KeyCode_Command, 0);

    map = mapping_get_or_make_map(m, (file_id));
    map_set_parent(m, map, (global_id));
    map_set_binding_text_input(map, write_text_input);
    map_set_binding_l(m, map, click_set_cursor_and_mark, InputEventKind_MouseButton, (MouseCode_Left), 0);
    map_set_binding_l(m, map, click_set_cursor, InputEventKind_MouseButtonRelease, (MouseCode_Left), 0);
    map_set_binding_l(m, map, click_set_cursor_and_mark, InputEventKind_Core, (CoreCode_ClickActivateView), 0);
    map_set_binding_l(m, map, click_set_cursor_if_lbutton, InputEventKind_MouseMove, 0, 0);
    map_set_binding_l(m, map, delete_char, InputEventKind_KeyStroke, (KeyCode_Delete), 0);
    map_set_binding_l(m, map, backspace_char, InputEventKind_KeyStroke, (KeyCode_Backspace), 0);
    map_set_binding_l(m, map, move_up, InputEventKind_KeyStroke, (KeyCode_Up), 0);
    map_set_binding_l(m, map, move_down, InputEventKind_KeyStroke, (KeyCode_Down), 0);
    map_set_binding_l(m, map, move_left, InputEventKind_KeyStroke, (KeyCode_Left), 0);
    map_set_binding_l(m, map, move_right, InputEventKind_KeyStroke, (KeyCode_Right), 0);
    map_set_binding_l(m, map, seek_end_of_line, InputEventKind_KeyStroke, (KeyCode_End), 0);
    map_set_binding_l(m, map, seek_beginning_of_line, InputEventKind_KeyStroke, (KeyCode_Home), 0);
    map_set_binding_l(m, map, page_up, InputEventKind_KeyStroke, (KeyCode_PageUp), 0);
    map_set_binding_l(m, map, page_down, InputEventKind_KeyStroke, (KeyCode_PageDown), 0);
    map_set_binding_l(m, map, goto_beginning_of_file, InputEventKind_KeyStroke, (KeyCode_PageUp), KeyCode_Command, 0);
    map_set_binding_l(m, map, goto_end_of_file, InputEventKind_KeyStroke, (KeyCode_PageDown), KeyCode_Command, 0);
    map_set_binding_l(m, map, move_up_to_blank_line_end, InputEventKind_KeyStroke, (KeyCode_Up), KeyCode_Command, 0);
    map_set_binding_l(m, map, move_down_to_blank_line_end, InputEventKind_KeyStroke, (KeyCode_Down), KeyCode_Command, 0);
    map_set_binding_l(m, map, move_left_whitespace_boundary, InputEventKind_KeyStroke, (KeyCode_Left), KeyCode_Command, 0);
    map_set_binding_l(m, map, move_right_whitespace_boundary, InputEventKind_KeyStroke, (KeyCode_Right), KeyCode_Command, 0);
    map_set_binding_l(m, map, move_line_up, InputEventKind_KeyStroke, (KeyCode_Up), KeyCode_Alt, 0);
    map_set_binding_l(m, map, move_line_down, InputEventKind_KeyStroke, (KeyCode_Down), KeyCode_Alt, 0);
    map_set_binding_l(m, map, backspace_alpha_numeric_boundary, InputEventKind_KeyStroke, (KeyCode_Backspace), KeyCode_Command, 0);
    map_set_binding_l(m, map, delete_alpha_numeric_boundary, InputEventKind_KeyStroke, (KeyCode_Delete), KeyCode_Command, 0);
    map_set_binding_l(m, map, snipe_backward_whitespace_or_token_boundary, InputEventKind_KeyStroke, (KeyCode_Backspace), KeyCode_Control, 0);
    map_set_binding_l(m, map, snipe_forward_whitespace_or_token_boundary, InputEventKind_KeyStroke, (KeyCode_Delete), KeyCode_Control, 0);
    map_set_binding_l(m, map, set_mark, InputEventKind_KeyStroke, (KeyCode_Space), KeyCode_Control, 0);
    map_set_binding_l(m, map, set_mark, InputEventKind_KeyStroke, (KeyCode_ForwardSlash), KeyCode_Command, 0);
    map_set_binding_l(m, map, replace_in_range, InputEventKind_KeyStroke, (KeyCode_A), KeyCode_Command, 0);
    map_set_binding_l(m, map, copy, InputEventKind_KeyStroke, (KeyCode_C), KeyCode_Command, 0);
    map_set_binding_l(m, map, delete_range, InputEventKind_KeyStroke, (KeyCode_D), KeyCode_Command, 0);
    map_set_binding_l(m, map, delete_line, InputEventKind_KeyStroke, (KeyCode_D), KeyCode_Command, KeyCode_Shift, 0);
    map_set_binding_l(m, map, center_view, InputEventKind_KeyStroke, (KeyCode_E), KeyCode_Command, 0);
    map_set_binding_l(m, map, left_adjust_view, InputEventKind_KeyStroke, (KeyCode_E), KeyCode_Command, KeyCode_Shift, 0);
    map_set_binding_l(m, map, search, InputEventKind_KeyStroke, (KeyCode_F), KeyCode_Command, 0);
    map_set_binding_l(m, map, list_all_locations, InputEventKind_KeyStroke, (KeyCode_F), KeyCode_Command, KeyCode_Shift, 0);
    map_set_binding_l(m, map, list_all_substring_locations_case_insensitive, InputEventKind_KeyStroke, (KeyCode_F), KeyCode_Control, 0);
    map_set_binding_l(m, map, goto_line, InputEventKind_KeyStroke, (KeyCode_G), KeyCode_Command, 0);
    map_set_binding_l(m, map, list_all_locations_of_selection, InputEventKind_KeyStroke, (KeyCode_G), KeyCode_Command, KeyCode_Shift, 0);
    map_set_binding_l(m, map, snippet_lister, InputEventKind_KeyStroke, (KeyCode_J), KeyCode_Command, 0);
    map_set_binding_l(m, map, kill_buffer, InputEventKind_KeyStroke, (KeyCode_K), KeyCode_Command, KeyCode_Shift, 0);
    map_set_binding_l(m, map, duplicate_line, InputEventKind_KeyStroke, (KeyCode_L), KeyCode_Command, 0);
    map_set_binding_l(m, map, cursor_mark_swap, InputEventKind_KeyStroke, (KeyCode_M), KeyCode_Command, 0);
    map_set_binding_l(m, map, reopen, InputEventKind_KeyStroke, (KeyCode_O), KeyCode_Command, KeyCode_Shift, 0);
    map_set_binding_l(m, map, query_replace, InputEventKind_KeyStroke, (KeyCode_Q), KeyCode_Command, 0);
    map_set_binding_l(m, map, query_replace_identifier, InputEventKind_KeyStroke, (KeyCode_Q), KeyCode_Command, KeyCode_Shift, 0);
    map_set_binding_l(m, map, query_replace_selection, InputEventKind_KeyStroke, (KeyCode_Q), KeyCode_Control, 0);
    map_set_binding_l(m, map, reverse_search, InputEventKind_KeyStroke, (KeyCode_R), KeyCode_Command, 0);
    map_set_binding_l(m, map, save, InputEventKind_KeyStroke, (KeyCode_S), KeyCode_Command, 0);
    map_set_binding_l(m, map, save_all_dirty_buffers, InputEventKind_KeyStroke, (KeyCode_S), KeyCode_Command, KeyCode_Shift, 0);
    map_set_binding_l(m, map, search_identifier, InputEventKind_KeyStroke, (KeyCode_T), KeyCode_Command, 0);
    map_set_binding_l(m, map, list_all_locations_of_identifier, InputEventKind_KeyStroke, (KeyCode_T), KeyCode_Command, KeyCode_Shift, 0);
    map_set_binding_l(m, map, paste_and_indent, InputEventKind_KeyStroke, (KeyCode_V), KeyCode_Command, 0);
    map_set_binding_l(m, map, paste_next_and_indent, InputEventKind_KeyStroke, (KeyCode_V), KeyCode_Command, KeyCode_Shift, 0);
    map_set_binding_l(m, map, cut, InputEventKind_KeyStroke, (KeyCode_X), KeyCode_Command, 0);
    map_set_binding_l(m, map, redo, InputEventKind_KeyStroke, (KeyCode_Y), KeyCode_Command, 0);
    map_set_binding_l(m, map, undo, InputEventKind_KeyStroke, (KeyCode_Z), KeyCode_Command, 0);
    map_set_binding_l(m, map, view_buffer_other_panel, InputEventKind_KeyStroke, (KeyCode_1), KeyCode_Command, 0);
    map_set_binding_l(m, map, swap_panels, InputEventKind_KeyStroke, (KeyCode_2), KeyCode_Command, 0);
    map_set_binding_l(m, map, if_read_only_goto_position, InputEventKind_KeyStroke, (KeyCode_Return), 0);
    map_set_binding_l(m, map, if_read_only_goto_position_same_panel, InputEventKind_KeyStroke, (KeyCode_Return), KeyCode_Shift, 0);
    map_set_binding_l(m, map, view_jump_list_with_lister, InputEventKind_KeyStroke, (KeyCode_Period), KeyCode_Command, KeyCode_Shift, 0);

    map = mapping_get_or_make_map(m, (code_id));
    map_set_parent(m, map, (file_id));
    map_set_binding_text_input(map, write_text_and_auto_indent);
    map_set_binding_l(m, map, move_left_alpha_numeric_boundary, InputEventKind_KeyStroke, (KeyCode_Left), KeyCode_Command, 0);
    map_set_binding_l(m, map, move_right_alpha_numeric_boundary, InputEventKind_KeyStroke, (KeyCode_Right), KeyCode_Command, 0);
    map_set_binding_l(m, map, move_left_alpha_numeric_or_camel_boundary, InputEventKind_KeyStroke, (KeyCode_Left), KeyCode_Control, 0);
    map_set_binding_l(m, map, move_right_alpha_numeric_or_camel_boundary, InputEventKind_KeyStroke, (KeyCode_Right), KeyCode_Control, 0);
    map_set_binding_l(m, map, comment_line_toggle, InputEventKind_KeyStroke, (KeyCode_Semicolon), KeyCode_Command, 0);
    map_set_binding_l(m, map, word_complete, InputEventKind_KeyStroke, (KeyCode_Tab), 0);
    map_set_binding_l(m, map, auto_indent_range, InputEventKind_KeyStroke, (KeyCode_Tab), KeyCode_Command, 0);
    map_set_binding_l(m, map, auto_indent_line_at_cursor, InputEventKind_KeyStroke, (KeyCode_Tab), KeyCode_Shift, 0);
    map_set_binding_l(m, map, word_complete_drop_down, InputEventKind_KeyStroke, (KeyCode_Tab), KeyCode_Shift, KeyCode_Command, 0);
    map_set_binding_l(m, map, write_block, InputEventKind_KeyStroke, (KeyCode_R), KeyCode_Control, 0);
    map_set_binding_l(m, map, write_todo, InputEventKind_KeyStroke, (KeyCode_T), KeyCode_Control, 0);
    map_set_binding_l(m, map, write_note, InputEventKind_KeyStroke, (KeyCode_Y), KeyCode_Control, 0);
    map_set_binding_l(m, map, list_all_locations_of_type_definition, InputEventKind_KeyStroke, (KeyCode_D), KeyCode_Control, 0);
    map_set_binding_l(m, map, list_all_locations_of_type_definition_of_identifier, InputEventKind_KeyStroke, (KeyCode_T), KeyCode_Control, KeyCode_Shift, 0);
    map_set_binding_l(m, map, open_long_braces, InputEventKind_KeyStroke, (KeyCode_LeftBracket), KeyCode_Command, 0);
    map_set_binding_l(m, map, open_long_braces_semicolon, InputEventKind_KeyStroke, (KeyCode_LeftBracket), KeyCode_Command, KeyCode_Shift, 0);
    map_set_binding_l(m, map, open_long_braces_break, InputEventKind_KeyStroke, (KeyCode_RightBracket), KeyCode_Command, KeyCode_Shift, 0);
    map_set_binding_l(m, map, select_surrounding_scope, InputEventKind_KeyStroke, (KeyCode_LeftBracket), KeyCode_Control, 0);
    map_set_binding_l(m, map, select_surrounding_scope_maximal, InputEventKind_KeyStroke, (KeyCode_LeftBracket), KeyCode_Control, KeyCode_Shift, 0);
    map_set_binding_l(m, map, select_prev_scope_absolute, InputEventKind_KeyStroke, (KeyCode_RightBracket), KeyCode_Control, 0);
    map_set_binding_l(m, map, select_prev_top_most_scope, InputEventKind_KeyStroke, (KeyCode_RightBracket), KeyCode_Control, KeyCode_Shift, 0);
    map_set_binding_l(m, map, select_next_scope_absolute, InputEventKind_KeyStroke, (KeyCode_Quote), KeyCode_Control, 0);
    map_set_binding_l(m, map, select_next_scope_after_current, InputEventKind_KeyStroke, (KeyCode_Quote), KeyCode_Control, KeyCode_Shift, 0);
    map_set_binding_l(m, map, place_in_scope, InputEventKind_KeyStroke, (KeyCode_ForwardSlash), KeyCode_Control, 0);
    map_set_binding_l(m, map, delete_current_scope, InputEventKind_KeyStroke, (KeyCode_Minus), KeyCode_Control, 0);
    map_set_binding_l(m, map, if0_off, InputEventKind_KeyStroke, (KeyCode_I), KeyCode_Control, 0);
    map_set_binding_l(m, map, open_file_in_quotes, InputEventKind_KeyStroke, (KeyCode_1), KeyCode_Control, 0);
    map_set_binding_l(m, map, open_matching_file_cpp, InputEventKind_KeyStroke, (KeyCode_2), KeyCode_Control, 0);
    map_set_binding_l(m, map, write_zero_struct, InputEventKind_KeyStroke, (KeyCode_0), KeyCode_Command, 0);
    map_set_binding_l(m, map, jump_to_definition_at_cursor, InputEventKind_KeyStroke, (KeyCode_W), KeyCode_Command, 0);
}
# 91 "/home/sam/.bin/4coder/custom/4coder_default_include.cpp" 2

# 1 "/home/sam/.bin/4coder/custom/4coder_default_framework_variables.cpp" 1







CUSTOM_ID(attachment, view_rewrite_loc);
CUSTOM_ID(attachment, view_next_rewrite_loc);
CUSTOM_ID(attachment, view_paste_index_loc);
CUSTOM_ID(attachment, view_is_passive_loc);
CUSTOM_ID(attachment, view_snap_mark_to_cursor);
CUSTOM_ID(attachment, view_ui_data);
CUSTOM_ID(attachment, view_highlight_range);
CUSTOM_ID(attachment, view_highlight_buffer);
CUSTOM_ID(attachment, view_render_hook);
CUSTOM_ID(attachment, view_word_complete_menu);
CUSTOM_ID(attachment, view_lister_loc);
CUSTOM_ID(attachment, view_previous_buffer);

CUSTOM_ID(attachment, buffer_map_id);
CUSTOM_ID(attachment, buffer_eol_setting);
CUSTOM_ID(attachment, buffer_lex_task);
CUSTOM_ID(attachment, buffer_wrap_lines);

CUSTOM_ID(attachment, sticky_jump_marker_handle);
CUSTOM_ID(attachment, attachment_tokens);



CUSTOM_ID(command_map, mapid_global);
CUSTOM_ID(command_map, mapid_file);
CUSTOM_ID(command_map, mapid_code);



static b32 allow_immediate_close_without_checking_for_changes = false;

static char *default_extensions[] = {
    "cpp",
    "hpp",
    "c",
    "h",
    "cc",
    "cs",
    "java",
    "rs",
    "glsl",
    "m",
};




static b32 auto_center_after_jumps = true;
static u8 locked_buffer_space[256];
static String_Const_u8 locked_buffer = {};


static View_ID build_footer_panel_view_id = 0;

static u8 out_buffer_space[1024];
static u8 command_space[1024];
static char hot_directory_space[1024];

static b32 suppressing_mouse = false;

static b32 show_fps_hud = false;


static Heap global_heap;

enum{
    FCoderMode_Original = 0,
    FCoderMode_NotepadLike = 1,
};
static i32 fcoder_mode = FCoderMode_Original;

static ID_Pos_Jump_Location prev_location = {};


static Arena global_config_arena = {};
static Config_Data global_config = {};

static char previous_isearch_query[256] = {};

static Mapping framework_mapping = {};

static Buffer_Modified_Set global_buffer_modified_set = {};



static b32 global_keyboard_macro_is_recording = false;
static Range_i64 global_keyboard_macro_range = {};



static Fade_Range_List buffer_fade_ranges = {};
static Arena fade_range_arena = {};
static Fade_Range *free_fade_ranges = 0;



static Point_Stack point_stack = {};



static Clipboard clipboard0 = {};
# 93 "/home/sam/.bin/4coder/custom/4coder_default_include.cpp" 2
# 1 "/home/sam/.bin/4coder/custom/4coder_default_colors.cpp" 1






static Color_Array
finalize_color_array(Color_Table table, u64 id){
    return(table.arrays[id % table.count]);
}

static ARGB_Color
finalize_color(Color_Array array, i32 sub_index){
    ARGB_Color result = 0xFFFFFFFF;
    if (array.count > 0){
        result = array.vals[sub_index % array.count];
    }
    return(result);
}

static ARGB_Color
finalize_color(Color_Table color_table, u64 id, i32 sub_index){
    Color_Array array = finalize_color_array(color_table, id);
    return(finalize_color(array, sub_index));
}

static Color_Array
finalize_color_array(u64 id){
 return(finalize_color_array(active_color_table, id));
}

static ARGB_Color
finalize_color(u64 id, i32 sub_index){
 return(finalize_color(active_color_table, id, sub_index));
}



static Color_Array
make_colors(Arena *arena, ARGB_Color color){
    Color_Array result = {};
    result.count = 1;
    result.vals = ((ARGB_Color*)linalloc_wrap_unintialized(linalloc_push((arena), sizeof(ARGB_Color)*(1), SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_default_colors.cpp" ":" "43" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_default_colors.cpp" ":" "43" ":") - 1)))));
    result.vals[0] = color;
    return(result);
}

static Color_Array
make_colors(Arena *arena, ARGB_Color c1, ARGB_Color c2){
    Color_Array result = {};
    result.count = 2;
    result.vals = ((ARGB_Color*)linalloc_wrap_unintialized(linalloc_push((arena), sizeof(ARGB_Color)*(2), SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_default_colors.cpp" ":" "52" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_default_colors.cpp" ":" "52" ":") - 1)))));
    result.vals[0] = c1;
    result.vals[1] = c2;
    return(result);
}

static Color_Array
make_colors(Arena *arena, ARGB_Color c1, ARGB_Color c2, ARGB_Color c3){
    Color_Array result = {};
    result.count = 3;
    result.vals = ((ARGB_Color*)linalloc_wrap_unintialized(linalloc_push((arena), sizeof(ARGB_Color)*(3), SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_default_colors.cpp" ":" "62" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_default_colors.cpp" ":" "62" ":") - 1)))));
    result.vals[0] = c1;
    result.vals[1] = c2;
    result.vals[2] = c3;
    return(result);
}

static Color_Array
make_colors(Arena *arena, ARGB_Color c1, ARGB_Color c2, ARGB_Color c3, ARGB_Color c4){
    Color_Array result = {};
    result.count = 4;
    result.vals = ((ARGB_Color*)linalloc_wrap_unintialized(linalloc_push((arena), sizeof(ARGB_Color)*(4), SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_default_colors.cpp" ":" "73" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_default_colors.cpp" ":" "73" ":") - 1)))));
    result.vals[0] = c1;
    result.vals[1] = c2;
    result.vals[2] = c3;
    result.vals[3] = c4;
    return(result);
}

static Color_Array
make_colors(Arena *arena, ARGB_Color *colors, i32 count){
    Color_Array result = {};
    result.count = count;
    result.vals = ((ARGB_Color*)linalloc_wrap_write(linalloc_push((arena), sizeof(ARGB_Color)*(count), SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_default_colors.cpp" ":" "85" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_default_colors.cpp" ":" "85" ":") - 1))), sizeof(ARGB_Color)*(count), (colors)));
    return(result);
}

static Color_Table
make_color_table(Application_Links *app, Arena *arena){
    Managed_ID highest_color_id = managed_id_group_highest_id(app, SCu8((u8*)("colors"), (u64)(sizeof("colors") - 1)));
    Color_Table result = {};
    result.count = (u32)((((highest_color_id + 1)<(max_u32))?(highest_color_id + 1):(max_u32)));
    result.arrays = ((Color_Array*)linalloc_wrap_unintialized(linalloc_push((arena), sizeof(Color_Array)*(result.count), SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_default_colors.cpp" ":" "94" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_default_colors.cpp" ":" "94" ":") - 1)))));
    u32 *dummy = ((u32*)linalloc_wrap_unintialized(linalloc_push((arena), sizeof(u32)*(1), SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_default_colors.cpp" ":" "95" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_default_colors.cpp" ":" "95" ":") - 1)))));
    *dummy = 0xFF990099;
    for (i32 i = 0; i < result.count; i += 1){
        result.arrays[i].vals = dummy;
        result.arrays[i].count = 1;
    }
    return(result);
}

static void
set_default_color_scheme(Application_Links *app){
    if (global_theme_arena.base_allocator == 0){
        global_theme_arena = make_arena_system();
    }

    Arena *arena = &global_theme_arena;

    default_color_table = make_color_table(app, arena);

    default_color_table.arrays[0] = make_colors(arena, 0xFF90B080);
    default_color_table.arrays[defcolor_bar] = make_colors(arena, 0xFF888888);
    default_color_table.arrays[defcolor_base] = make_colors(arena, 0xFF000000);
    default_color_table.arrays[defcolor_pop1] = make_colors(arena, 0xFF3C57DC);
    default_color_table.arrays[defcolor_pop2] = make_colors(arena, 0xFFFF0000);
    default_color_table.arrays[defcolor_back] = make_colors(arena, 0xFF0C0C0C);
    default_color_table.arrays[defcolor_margin] = make_colors(arena, 0xFF181818);
    default_color_table.arrays[defcolor_margin_hover] = make_colors(arena, 0xFF252525);
    default_color_table.arrays[defcolor_margin_active] = make_colors(arena, 0xFF323232);
    default_color_table.arrays[defcolor_list_item] = make_colors(arena, 0xFF181818, 0xFF0C0C0C);
    default_color_table.arrays[defcolor_list_item_hover] = make_colors(arena, 0xFF252525, 0xFF181818);
    default_color_table.arrays[defcolor_list_item_active] = make_colors(arena, 0xFF323232, 0xFF323232);
    default_color_table.arrays[defcolor_cursor] = make_colors(arena, 0xFF00EE00, 0xFFEE7700);
    default_color_table.arrays[defcolor_at_cursor] = make_colors(arena, 0xFF0C0C0C);
    default_color_table.arrays[defcolor_highlight_cursor_line] = make_colors(arena, 0xFF1E1E1E);
    default_color_table.arrays[defcolor_highlight] = make_colors(arena, 0xFFDDEE00);
    default_color_table.arrays[defcolor_at_highlight] = make_colors(arena, 0xFFFF44DD);
    default_color_table.arrays[defcolor_mark] = make_colors(arena, 0xFF494949);
    default_color_table.arrays[defcolor_text_default] = make_colors(arena, 0xFF90B080);
    default_color_table.arrays[defcolor_comment] = make_colors(arena, 0xFF2090F0);
    default_color_table.arrays[defcolor_comment_pop] = make_colors(arena, 0xFF00A000, 0xFFA00000);
    default_color_table.arrays[defcolor_keyword] = make_colors(arena, 0xFFD08F20);
    default_color_table.arrays[defcolor_str_constant] = make_colors(arena, 0xFF50FF30);
    default_color_table.arrays[defcolor_char_constant] = make_colors(arena, 0xFF50FF30);
    default_color_table.arrays[defcolor_int_constant] = make_colors(arena, 0xFF50FF30);
    default_color_table.arrays[defcolor_float_constant] = make_colors(arena, 0xFF50FF30);
    default_color_table.arrays[defcolor_bool_constant] = make_colors(arena, 0xFF50FF30);
    default_color_table.arrays[defcolor_preproc] = make_colors(arena, 0xFFA0B8A0);
    default_color_table.arrays[defcolor_include] = make_colors(arena, 0xFF50FF30);
    default_color_table.arrays[defcolor_special_character] = make_colors(arena, 0xFFFF0000);
    default_color_table.arrays[defcolor_ghost_character] = make_colors(arena, 0xFF4E5E46);
    default_color_table.arrays[defcolor_highlight_junk] = make_colors(arena, 0xFF3A0000);
    default_color_table.arrays[defcolor_highlight_white] = make_colors(arena, 0xFF003A3A);
    default_color_table.arrays[defcolor_paste] = make_colors(arena, 0xFFDDEE00);
    default_color_table.arrays[defcolor_undo] = make_colors(arena, 0xFF00DDEE);
    default_color_table.arrays[defcolor_back_cycle] = make_colors(arena, 0xFF130707, 0xFF071307, 0xFF070713, 0xFF131307);
    default_color_table.arrays[defcolor_text_cycle] = make_colors(arena, 0xFFA00000, 0xFF00A000, 0xFF0030B0, 0xFFA0A000);
    default_color_table.arrays[defcolor_line_numbers_back] = make_colors(arena, 0xFF101010);
    default_color_table.arrays[defcolor_line_numbers_text] = make_colors(arena, 0xFF404040);

    active_color_table = default_color_table;
}



static void
set_active_color(Color_Table *table){
    if (table != 0){
        active_color_table = *table;
    }
}


static void
set_single_active_color(u64 id, ARGB_Color color){
    active_color_table.arrays[id] = make_colors(&global_theme_arena, color);
}

static void
save_theme(Color_Table table, String_Const_u8 name){
    Color_Table_Node *node = ((Color_Table_Node*)linalloc_wrap_unintialized(linalloc_push((&global_theme_arena), sizeof(Color_Table_Node)*(1), SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_default_colors.cpp" ":" "174" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_default_colors.cpp" ":" "174" ":") - 1)))));
    do{ if((node)){if((global_theme_list.first)){(global_theme_list.last)->next=(node);}else{(global_theme_list.first)=(node);}(global_theme_list.last)=(node);(global_theme_list.last)->next=0;} }while(0);
    global_theme_list.count += 1;
    node->name = push_string_copy(&global_theme_arena, name);
    node->table = table;
}



static Color_Table*
get_color_table_by_name(String_Const_u8 name){
    Color_Table *result = 0;
    for (Color_Table_Node *node = global_theme_list.first;
         node != 0;
         node = node->next){
        if (string_match(node->name, name)){
            result = &node->table;
            break;
        }
    }
    return(result);
}
# 94 "/home/sam/.bin/4coder/custom/4coder_default_include.cpp" 2
# 1 "/home/sam/.bin/4coder/custom/4coder_helper.cpp" 1
# 12 "/home/sam/.bin/4coder/custom/4coder_helper.cpp"
static i32
get_command_id(Custom_Command_Function *func){
    i32 result = -1;
    for (i32 i = 0; i < ((sizeof(fcoder_metacmd_table))/(sizeof(*fcoder_metacmd_table))); i += 1){
        if (func == fcoder_metacmd_table[i].proc){
            result = i;
            break;
        }
    }
    return(result);
}

static Command_Metadata*
get_command_metadata(Custom_Command_Function *func){
    Command_Metadata *result = 0;
    i32 id = get_command_id(func);
    if (id >= 0){
        result = &fcoder_metacmd_table[id];
    }
    return(result);
}



static Token_Array
get_token_array_from_buffer(Application_Links *app, Buffer_ID buffer){
    Token_Array result = {};
    Managed_Scope scope = buffer_get_managed_scope(app, buffer);
    Async_Task *lex_task_ptr = ((Async_Task*)managed_scope_get_attachment((app), (scope), (buffer_lex_task), sizeof(Async_Task)));
    if (lex_task_ptr != 0){
        async_task_wait(app, &global_async_system, *lex_task_ptr);
    }
    Token_Array *ptr = ((Token_Array*)managed_scope_get_attachment((app), (scope), (attachment_tokens), sizeof(Token_Array)));
    if (ptr != 0){
        result = *ptr;
    }
    return(result);
}



static Buffer_Seek
seek_location(ID_Line_Column_Jump_Location location){
    return(seek_line_col(location.line, location.column));
}

static Buffer_Seek
seek_location(ID_Pos_Jump_Location location){
    return(seek_pos(location.pos));
}

static Buffer_Seek
seek_location(Name_Line_Column_Location location){
    return(seek_line_col(location.line, location.column));
}

static Buffer_Seek
seek_jump(Parsed_Jump jump){
    return(seek_location(jump.location));
}



View_Context_Block::View_Context_Block(Application_Links *a, View_ID v,
                                       View_Context *ctx){
    this->app = a;
    this->view = v;
    view_push_context(a, v, ctx);
}

View_Context_Block::~View_Context_Block(){
    view_pop_context(this->app, this->view);
}



static Character_Predicate
character_predicate_from_function(Character_Predicate_Function *func){
    Character_Predicate predicate = {};
    i32 byte_index = 0;
    for (u32 i = 0; i <= 255;){
        b8 v[8];
        for (i32 bit_index = 0; bit_index < 8; i += 1, bit_index += 1){
            v[bit_index] = func((u8)i);
        }
        predicate.b[byte_index] = ((v[0] << 0) |
                                   (v[1] << 1) |
                                   (v[2] << 2) |
                                   (v[3] << 3) |
                                   (v[4] << 4) |
                                   (v[5] << 5) |
                                   (v[6] << 6) |
                                   (v[7] << 7));
        byte_index += 1;
    }
    return(predicate);
}

static Character_Predicate
character_predicate_from_character(u8 character){
    Character_Predicate predicate = {};
    predicate.b[character/8] = (1 << (character%8));
    return(predicate);
}



static Character_Predicate
character_predicate_or(Character_Predicate *a, Character_Predicate *b){
    Character_Predicate p = {};
    for (i32 i = 0; i < ((sizeof(p.b))/(sizeof(*p.b))); i += 1){
        p.b[i] = a->b[i] | b->b[i];
    }
    return(p);
}

static Character_Predicate
character_predicate_and(Character_Predicate *a, Character_Predicate *b){
    Character_Predicate p = {};
    for (i32 i = 0; i < ((sizeof(p.b))/(sizeof(*p.b))); i += 1){
        p.b[i] = a->b[i] & b->b[i];
    }
    return(p);
}

static Character_Predicate
character_predicate_not(Character_Predicate *a){
    Character_Predicate p = {};
    for (i32 i = 0; i < ((sizeof(p.b))/(sizeof(*p.b))); i += 1){
        p.b[i] = ~(a->b[i]);
    }
    return(p);
}

static i64
buffer_seek_character_class_change__inner(Application_Links *app, Buffer_ID buffer, Character_Predicate *positive, Character_Predicate *negative, Scan_Direction direction, i64 start_pos){
    i64 pos = start_pos;
    switch (direction){
        case Scan_Backward:
        {
            String_Match m1 = buffer_seek_character_class(app, buffer, negative, direction, pos);
            String_Match m2 = buffer_seek_character_class(app, buffer, positive, direction, m1.range.min);
            pos = m2.range.min;
            if (m1.buffer == buffer && m2.buffer == buffer){
                pos += 1;
            }
        }break;
        case Scan_Forward:
        {
            pos -= 1;
            String_Match m1 = buffer_seek_character_class(app, buffer, positive, direction, pos);
            String_Match m2 = buffer_seek_character_class(app, buffer, negative, direction, m1.range.min);
            pos = m2.range.min;
        }break;
    }
    return(pos);
}

static i64
buffer_seek_character_class_change_1_0(Application_Links *app, Buffer_ID buffer, Character_Predicate *predicate, Scan_Direction direction, i64 start_pos){
    Character_Predicate negative = character_predicate_not(predicate);
    return(buffer_seek_character_class_change__inner(app, buffer, predicate, &negative, direction, start_pos));
}

static i64
buffer_seek_character_class_change_0_1(Application_Links *app, Buffer_ID buffer, Character_Predicate *predicate, Scan_Direction direction, i64 start_pos){
    Character_Predicate negative = character_predicate_not(predicate);
    return(buffer_seek_character_class_change__inner(app, buffer, &negative, predicate, direction, start_pos));
}



static i64
view_pos_from_xy(Application_Links *app, View_ID view, Vec2_f32 p){
    Buffer_ID buffer = view_get_buffer(app, view, Access_ReadVisible);
    Rect_f32 region = view_get_buffer_region(app, view);
    f32 width = rect_width(region);
    Face_ID face_id = get_face_id(app, buffer);
    Buffer_Scroll scroll_vars = view_get_buffer_scroll(app, view);
    i64 line = scroll_vars.position.line_number;
    p = (p - region.p0) + scroll_vars.position.pixel_shift;
    return(buffer_pos_at_relative_xy(app, buffer, width, face_id, line, p));
}

static Buffer_Point
view_move_buffer_point(Application_Links *app, View_ID view, Buffer_Point buffer_point, Vec2_f32 delta){
    delta += buffer_point.pixel_shift;
    Line_Shift_Vertical shift = view_line_shift_y(app, view, buffer_point.line_number, delta.y);
    buffer_point.line_number = shift.line;
    buffer_point.pixel_shift = V2f32(delta.x, delta.y - shift.y_delta);
    return(buffer_point);
}

static void
view_zero_scroll(Application_Links *app, View_ID view){
    Buffer_Scroll scroll = {};
    view_set_buffer_scroll(app, view, scroll, SetBufferScroll_SnapCursorIntoView);
}

static Vec2_f32
view_relative_xy_of_pos(Application_Links *app, View_ID view, i64 base_line, i64 pos){
    Rect_f32 rect = view_relative_box_of_pos(app, view, base_line, pos);
    return(rect_center(rect));
}

static void
view_set_cursor_and_preferred_x(Application_Links *app, View_ID view, Buffer_Seek seek){
    view_set_cursor(app, view, seek);
    Buffer_Cursor cursor = view_compute_cursor(app, view, seek);
    Vec2_f32 p = view_relative_xy_of_pos(app, view, cursor.line, cursor.pos);
    view_set_preferred_x(app, view, p.x);
}

static i64
view_set_pos_by_character_delta(Application_Links *app, View_ID view, i64 pos, i64 character_delta){
    Buffer_Cursor cursor = view_compute_cursor(app, view, seek_pos(pos));
    i64 character = view_relative_character_from_pos(app, view, cursor.line, cursor.pos);
    i64 new_pos = view_pos_from_relative_character(app, view, cursor.line, character + character_delta);
    return(new_pos);
}

static i64
view_set_cursor_by_character_delta(Application_Links *app, View_ID view, i64 character_delta){
    i64 pos = view_get_cursor_pos(app, view);
    i64 new_pos = view_set_pos_by_character_delta(app, view, pos, character_delta);
    view_set_cursor_and_preferred_x(app, view, seek_pos(new_pos));
    return(new_pos);
}

static i64
view_correct_cursor(Application_Links *app, View_ID view){
    i64 pos = view_get_cursor_pos(app, view);
    i64 new_pos = view_set_pos_by_character_delta(app, view, pos, 0);
    view_set_cursor(app, view, seek_pos(new_pos));
    return(new_pos);
}

static i64
view_correct_mark(Application_Links *app, View_ID view){
    i64 pos = view_get_mark_pos(app, view);
    i64 new_pos = view_set_pos_by_character_delta(app, view, pos, 0);
    view_set_mark(app, view, seek_pos(new_pos));
    return(new_pos);
}

static Vec2_f32
buffer_point_difference(Application_Links *app, Buffer_ID buffer, f32 width, Face_ID face_id,
                        Buffer_Point a, Buffer_Point b){
    f32 y_difference = buffer_line_y_difference(app, buffer, width, face_id, a.line_number, b.line_number);
    Vec2_f32 result = a.pixel_shift - b.pixel_shift;
    result.y += y_difference;
    return(result);
}

static Vec2_f32
view_point_difference(Application_Links *app, View_ID view, Buffer_Point a, Buffer_Point b){
    f32 y_difference = view_line_y_difference(app, view, a.line_number, b.line_number);
    Vec2_f32 result = a.pixel_shift - b.pixel_shift;
    result.y += y_difference;
    return(result);
}



static Range_i64
buffer_range(Application_Links *app, Buffer_ID buffer){
    Range_i64 range = {};
    range.end = buffer_get_size(app, buffer);
    return(range);
}

static i64
buffer_side(Application_Links *app, Buffer_ID buffer, Side side){
    return(range_side(buffer_range(app, buffer), side));
}

static Range_i64
get_view_range(Application_Links *app, View_ID view){
    return(Ii64(view_get_cursor_pos(app, view), view_get_mark_pos(app, view)));
}

static void
set_view_range(Application_Links *app, View_ID view, Range_i64 range){
    i64 c = view_get_cursor_pos(app, view);
    i64 m = view_get_mark_pos(app, view);
    if (c < m){
        view_set_cursor_and_preferred_x(app, view, seek_pos(range.min));
        view_set_mark(app, view, seek_pos(range.max));
    }
    else{
        view_set_mark(app, view, seek_pos(range.min));
        view_set_cursor_and_preferred_x(app, view, seek_pos(range.max));
    }
}

static b32
is_valid_line(Application_Links *app, Buffer_ID buffer_id, i64 line){
    i64 max_line = buffer_get_line_count(app, buffer_id);
    return(1 <= line && line <= max_line);
}

static b32
is_valid_line_range(Application_Links *app, Buffer_ID buffer_id, Range_i64 range){
    i64 max_line = buffer_get_line_count(app, buffer_id);
    return(1 <= range.first && range.first <= range.end && range.end <= max_line);
}

static i64
get_line_number_from_pos(Application_Links *app, Buffer_ID buffer, i64 pos){
    Buffer_Cursor cursor = buffer_compute_cursor(app, buffer, seek_pos(pos));
    return(cursor.line);
}

static i64
buffer_get_character_legal_pos_from_pos(Application_Links *app, Buffer_ID buffer, f32 width, Face_ID face, i64 pos){
    Buffer_Cursor cursor = buffer_compute_cursor(app, buffer, seek_pos(pos));
    i64 character = buffer_relative_character_from_pos(app, buffer, width, face, cursor.line, pos);
    return(buffer_pos_from_relative_character(app, buffer, width, face, cursor.line, character));
}

static i64
view_get_character_legal_pos_from_pos(Application_Links *app, View_ID view, i64 pos){
    Buffer_Cursor cursor = view_compute_cursor(app, view, seek_pos(pos));
    i64 character = view_relative_character_from_pos(app, view, cursor.line, pos);
    return(view_pos_from_relative_character(app, view, cursor.line, character));
}

static Buffer_Cursor
get_line_side(Application_Links *app, Buffer_ID buffer, i64 line_number, Side side){
    i64 character_index = (side == Side_Min)?(1):(-1);
    return(buffer_compute_cursor(app, buffer, seek_line_col(line_number, character_index)));
}
static i64
get_line_side_pos(Application_Links *app, Buffer_ID buffer, i64 line_number, Side side){
    i64 pos = -1;
    Buffer_Cursor cursor = get_line_side(app, buffer, line_number, side);
    if (cursor.line != 0){
        pos = cursor.pos;
    }
    return(pos);
}

static Buffer_Cursor
get_line_start(Application_Links *app, Buffer_ID buffer, i64 line_number){
    return(get_line_side(app, buffer, line_number, Side_Min));
}
static i64
get_line_start_pos(Application_Links *app, Buffer_ID buffer, i64 line_number){
    return(get_line_side_pos(app, buffer, line_number, Side_Min));
}



static Buffer_Cursor
get_line_end(Application_Links *app, Buffer_ID buffer, i64 line_number){
    return(get_line_side(app, buffer, line_number, Side_Max));
}
static i64
get_line_end_pos(Application_Links *app, Buffer_ID buffer, i64 line_number){
    return(get_line_side_pos(app, buffer, line_number, Side_Max));
}


static Range_Cursor
get_line_range(Application_Links *app, Buffer_ID buffer, i64 line_number){
    b32 success = false;
    Range_Cursor result = {};
    result.start = get_line_start(app, buffer, line_number);
    if (result.start.line != 0){
        result.end = get_line_end(app, buffer, line_number);
        if (result.end.line != 0){
            success = true;
        }
    }
    if (!success){
        block_zero((&result), sizeof(*(&result)));
    }
    return(result);
}


static Range_i64
get_line_pos_range(Application_Links *app, Buffer_ID buffer, i64 line_number){
    Range_Cursor range = get_line_range(app, buffer, line_number);
    Range_i64 result = {};
    if (range.start.line != 0 && range.end.line != 0){
        result = Ii64(range.start.pos, range.end.pos);
    }
    return(result);
}

static Range_i64
make_range_from_cursors(Range_Cursor range){
    return(Ii64(range.start.pos, range.end.pos));
}

static i64
get_line_side_pos_from_pos(Application_Links *app, Buffer_ID buffer, i64 pos, Side side){
    i64 line_number = get_line_number_from_pos(app, buffer, pos);
    return(get_line_side_pos(app, buffer, line_number, side));
}
static i64
get_line_start_pos_from_pos(Application_Links *app, Buffer_ID buffer, i64 pos){
    return(get_line_side_pos_from_pos(app, buffer, pos, Side_Min));
}
static i64
get_line_end_pos_from_pos(Application_Links *app, Buffer_ID buffer, i64 pos){
    return(get_line_side_pos_from_pos(app, buffer, pos, Side_Max));
}

static Token*
get_first_token_from_line(Application_Links *app, Buffer_ID buffer, Token_Array tokens, i64 line){
    i64 line_start = get_line_start_pos(app, buffer, line);
    return(token_from_pos(&tokens, line_start));
}



static i64
scan_any_boundary(Application_Links *app, Boundary_Function *func, Buffer_ID buffer, Scan_Direction direction, i64 pos){
    i64 a = func(app, buffer, Side_Min, direction, pos);
    i64 b = func(app, buffer, Side_Max, direction, pos);
    i64 result = 0;
    if (direction == Scan_Forward){
        result = (((a)<(b))?(a):(b));
    }
    else{
        result = (((a)>(b))?(a):(b));
    }
    return(result);
}

static i64
scan(Application_Links *app, Boundary_Function *func, Buffer_ID buffer, Scan_Direction direction, i64 pos){
    Side side = (direction == Scan_Forward)?(Side_Max):(Side_Min);
    return(func(app, buffer, side, direction, pos));
}

static i64
scan(Application_Links *app, Boundary_Function_List funcs, Buffer_ID buffer, Scan_Direction direction, i64 start_pos){
    i64 result = 0;
    if (direction == Scan_Forward){
        i64 size = buffer_get_size(app, buffer);
        result = size + 1;
        for (Boundary_Function_Node *node = funcs.first;
             node != 0;
             node = node->next){
            i64 pos = scan(app, node->func, buffer, direction, start_pos);
            result = (((result)<(pos))?(result):(pos));
        }
    }
    else{
        result = -1;
        for (Boundary_Function_Node *node = funcs.first;
             node != 0;
             node = node->next){
            i64 pos = scan(app, node->func, buffer, direction, start_pos);
            result = (((result)>(pos))?(result):(pos));
        }
    }
    return(result);
}

static void
push_boundary(Arena *arena, Boundary_Function_List *list, Boundary_Function *func){
    Boundary_Function_Node *node = ((Boundary_Function_Node*)linalloc_wrap_unintialized(linalloc_push((arena), sizeof(Boundary_Function_Node)*(1), SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_helper.cpp" ":" "477" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_helper.cpp" ":" "477" ":") - 1)))));
    do{ if((node)){if((list->first)){(list->last)->next=(node);}else{(list->first)=(node);}(list->last)=(node);(list->last)->next=0;} }while(0);
    list->count += 1;
    node->func = func;
}

static Boundary_Function_List
push_boundary_list__innerv(Arena *arena, va_list args){
    Boundary_Function_List list = {};
    for (;;){
        Boundary_Function *func = 
# 487 "/home/sam/.bin/4coder/custom/4coder_helper.cpp" 3 4
                                 __builtin_va_arg(
# 487 "/home/sam/.bin/4coder/custom/4coder_helper.cpp"
                                 args
# 487 "/home/sam/.bin/4coder/custom/4coder_helper.cpp" 3 4
                                 ,
# 487 "/home/sam/.bin/4coder/custom/4coder_helper.cpp"
                                 Boundary_Function*
# 487 "/home/sam/.bin/4coder/custom/4coder_helper.cpp" 3 4
                                 )
# 487 "/home/sam/.bin/4coder/custom/4coder_helper.cpp"
                                                                 ;
        if (func == 0){
            break;
        }
        push_boundary(arena, &list, func);
    }
    return(list);
}
static Boundary_Function_List
push_boundary_list__inner(Arena *arena, ...){
    va_list args;
    
# 498 "/home/sam/.bin/4coder/custom/4coder_helper.cpp" 3 4
   __builtin_va_start(
# 498 "/home/sam/.bin/4coder/custom/4coder_helper.cpp"
   args
# 498 "/home/sam/.bin/4coder/custom/4coder_helper.cpp" 3 4
   ,
# 498 "/home/sam/.bin/4coder/custom/4coder_helper.cpp"
   arena
# 498 "/home/sam/.bin/4coder/custom/4coder_helper.cpp" 3 4
   )
# 498 "/home/sam/.bin/4coder/custom/4coder_helper.cpp"
                        ;
    Boundary_Function_List result = push_boundary_list__innerv(arena, args);
    
# 500 "/home/sam/.bin/4coder/custom/4coder_helper.cpp" 3 4
   __builtin_va_end(
# 500 "/home/sam/.bin/4coder/custom/4coder_helper.cpp"
   args
# 500 "/home/sam/.bin/4coder/custom/4coder_helper.cpp" 3 4
   )
# 500 "/home/sam/.bin/4coder/custom/4coder_helper.cpp"
               ;
    return(result);
}


static i64
boundary_predicate(Application_Links *app, Buffer_ID buffer, Side side, Scan_Direction direction, i64 pos, Character_Predicate *predicate){
    i64 result = 0;
    switch (side){
        case Side_Min:
        {
            result = buffer_seek_character_class_change_0_1(app, buffer, predicate, direction, pos);
        }break;
        case Side_Max:
        {
            result = buffer_seek_character_class_change_1_0(app, buffer, predicate, direction, pos);
        }break;
    }
    return(result);
}

static i64
boundary_non_whitespace(Application_Links *app, Buffer_ID buffer, Side side, Scan_Direction direction, i64 pos){
    return(boundary_predicate(app, buffer, side, direction, pos, &character_predicate_non_whitespace));
}

static i64
boundary_base10(Application_Links *app, Buffer_ID buffer, Side side, Scan_Direction direction, i64 pos){
    return(boundary_predicate(app, buffer, side, direction, pos, &character_predicate_base10));
}

static i64
boundary_base10_colon(Application_Links *app, Buffer_ID buffer, Side side, Scan_Direction direction, i64 pos){
    static Character_Predicate predicate = {};
    static b32 first_call = true;
    if (first_call){
        first_call = false;
        Character_Predicate colon = character_predicate_from_character((u8)':');
        predicate = character_predicate_or(&character_predicate_base10, &colon);
    }
    return(boundary_predicate(app, buffer, side, direction, pos, &predicate));
}

static i64
boundary_base16(Application_Links *app, Buffer_ID buffer, Side side, Scan_Direction direction, i64 pos){
    return(boundary_predicate(app, buffer, side, direction, pos, &character_predicate_base16));
}

static i64
boundary_alpha_numeric(Application_Links *app, Buffer_ID buffer, Side side, Scan_Direction direction, i64 pos){
    return(boundary_predicate(app, buffer, side, direction, pos, &character_predicate_alpha_numeric));
}

static i64
boundary_alpha_numeric_unicode(Application_Links *app, Buffer_ID buffer, Side side, Scan_Direction direction, i64 pos){
    return(boundary_predicate(app, buffer, side, direction, pos, &character_predicate_alpha_numeric_underscore_utf8));
}

static i64
boundary_alpha_numeric_underscore(Application_Links *app, Buffer_ID buffer, Side side, Scan_Direction direction, i64 pos){
    return(boundary_predicate(app, buffer, side, direction, pos, &character_predicate_alpha_numeric_underscore));
}

static i64
boundary_alpha_numeric_underscore_utf8(Application_Links *app, Buffer_ID buffer, Side side, Scan_Direction direction, i64 pos){
    return(boundary_predicate(app, buffer, side, direction, pos, &character_predicate_alpha_numeric_underscore_utf8));
}

static i64
boundary_alpha_numeric_camel(Application_Links *app, Buffer_ID buffer, Side side, Scan_Direction direction, i64 pos){
    i64 an_pos = boundary_alpha_numeric(app, buffer, side, direction, pos);
    String_Match m = buffer_seek_character_class(app, buffer, &character_predicate_uppercase, direction, pos);
    i64 cap_pos = m.range.min;
    if (side == Side_Max){
        i64 an_left_pos = boundary_alpha_numeric(app, buffer, flip_side(side), flip_direction(direction), an_pos);
        if (cap_pos == an_left_pos){
            m = buffer_seek_character_class(app, buffer, &character_predicate_uppercase, direction, cap_pos);
            cap_pos = m.range.min;
        }
    }
    i64 result = 0;
    if (direction == Scan_Backward){
        result = (((an_pos)>(cap_pos))?(an_pos):(cap_pos));
    }
    else{
        result = (((an_pos)<(cap_pos))?(an_pos):(cap_pos));
    }
    return(result);
}

static i64
boundary_inside_quotes(Application_Links *app, Buffer_ID buffer, Side side, Scan_Direction direction, i64 pos){
    static Character_Predicate predicate = {};
    static b32 first_call = true;
    if (first_call){
        first_call = false;
        predicate = character_predicate_from_character((u8)'"');
        predicate = character_predicate_not(&predicate);
    }
    return(boundary_predicate(app, buffer, side, direction, pos, &predicate));
}

static i64
boundary_token(Application_Links *app, Buffer_ID buffer, Side side, Scan_Direction direction, i64 pos){
    i64 result = boundary_non_whitespace(app, buffer, side, direction, pos);
    Token_Array tokens = get_token_array_from_buffer(app, buffer);
    if (tokens.tokens != 0){
        switch (direction){
            case Scan_Forward:
            {
                i64 buffer_size = buffer_get_size(app, buffer);
                result = buffer_size;
                if (tokens.count > 0){
                    Token_Iterator_Array it = token_iterator_pos(0, &tokens, pos);
                    Token *token = token_it_read(&it);
                    if (token->kind == TokenBaseKind_Whitespace){
                        token_it_inc_non_whitespace(&it);
                        token = token_it_read(&it);
                    }
                    if (token != 0){
                        if (side == Side_Max){
                            result = token->pos + token->size;
                        }
                        else{
                            if (token->pos <= pos){
                                token_it_inc_non_whitespace(&it);
                                token = token_it_read(&it);
                            }
                            if (token != 0){
                                result = token->pos;
                            }
                        }
                    }
                }
            }break;

            case Scan_Backward:
            {
                result = 0;
                if (tokens.count > 0){
                    Token_Iterator_Array it = token_iterator_pos(0, &tokens, pos);
                    Token *token = token_it_read(&it);
                    if (token->kind == TokenBaseKind_Whitespace){
                        token_it_dec_non_whitespace(&it);
                        token = token_it_read(&it);
                    }
                    if (token != 0){
                        if (side == Side_Min){
                            if (token->pos >= pos){
                                token_it_dec_non_whitespace(&it);
                                token = token_it_read(&it);
                            }
                            result = token->pos;
                        }
                        else{
                            if (token->pos + token->size >= pos){
                                token_it_dec_non_whitespace(&it);
                                token = token_it_read(&it);
                            }
                            result = token->pos + token->size;
                        }
                    }
                }
            }break;
        }
    }
    return(result);
}

static i64
boundary_line(Application_Links *app, Buffer_ID buffer, Side side, Scan_Direction direction, i64 pos){
    i64 line_number = get_line_number_from_pos(app, buffer, pos);
    i64 new_pos = get_line_side_pos(app, buffer, line_number, side);
    if (direction == Scan_Backward && new_pos >= pos){
        if (line_number > 1){
            new_pos = get_line_side_pos(app, buffer, line_number - 1, side);
        }
        else{
            new_pos = 0;
        }
    }
    else if (direction == Scan_Forward && new_pos <= pos){
        new_pos = get_line_side_pos(app, buffer, line_number + 1, side);
        if (new_pos <= pos){
            new_pos = (i32)buffer_get_size(app, buffer);
        }
    }
    return(new_pos);
}




static void
seek_string_forward(Application_Links *app, Buffer_ID buffer, i64 pos, i64 end, String_Const_u8 needle, i64 *result){
    if (end == 0){
        end = (i32)buffer_get_size(app, buffer);
    }
    String_Match match = {};
    match.range.first = pos;
    for (;;){
        match = buffer_seek_string(app, buffer, needle, Scan_Forward, (i32)match.range.first);
        if ((((match.flags)&(StringMatch_CaseSensitive))!=0) ||
            match.buffer != buffer || match.range.first >= end) break;
    }
    if (match.range.first < end && match.buffer == buffer){
        *result = match.range.first;
    }
    else{
        *result = buffer_get_size(app, buffer);
    }
}

static void
seek_string_backward(Application_Links *app, Buffer_ID buffer, i64 pos, i64 min, String_Const_u8 needle, i64 *result){
    String_Match match = {};
    match.range.first = pos;
    for (;;){
        match = buffer_seek_string(app, buffer, needle, Scan_Backward, match.range.first);
        if ((((match.flags)&(StringMatch_CaseSensitive))!=0) ||
            match.buffer != buffer || match.range.first < min) break;
    }
    if (match.range.first >= min && match.buffer == buffer){
        *result = match.range.first;
    }
    else{
        *result = -1;
    }
}

static void
seek_string_insensitive_forward(Application_Links *app, Buffer_ID buffer, i64 pos, i64 end, String_Const_u8 needle, i64 *result){
    if (end == 0){
        end = (i32)buffer_get_size(app, buffer);
    }
    String_Match match = buffer_seek_string(app, buffer, needle, Scan_Forward, pos);
    if (match.range.first < end && match.buffer == buffer){
        *result = match.range.first;
    }
    else{
        *result = buffer_get_size(app, buffer);
    }
}

static void
seek_string_insensitive_backward(Application_Links *app, Buffer_ID buffer, i64 pos, i64 min, String_Const_u8 needle, i64 *result){
    String_Match match = buffer_seek_string(app, buffer, needle, Scan_Backward, pos);
    if (match.range.first >= min && match.buffer == buffer){
        *result = match.range.first;
    }
    else{
        *result = -1;
    }
}

static void
seek_string(Application_Links *app, Buffer_ID buffer_id, i64 pos, i64 end, i64 min, String_Const_u8 str, i64 *result, Buffer_Seek_String_Flags flags){
    switch (flags & 3){
        case 0:
        {
            seek_string_forward(app, buffer_id, pos, end, str, result);
        }break;

        case BufferSeekString_Backward:
        {
            seek_string_backward(app, buffer_id, pos, min, str, result);
        }break;

        case BufferSeekString_CaseInsensitive:
        {
            seek_string_insensitive_forward(app, buffer_id, pos, end, str, result);
        }break;

        case BufferSeekString_Backward|BufferSeekString_CaseInsensitive:
        {
            seek_string_insensitive_backward(app, buffer_id, pos, min, str, result);
        }break;
    }
}



static Range_i64
get_line_range_from_pos_range(Application_Links *app, Buffer_ID buffer, Range_i64 pos_range){
    Range_i64 line_range = {};
    line_range.first = get_line_number_from_pos(app, buffer, pos_range.first);
    if (line_range.first != 0){
        line_range.end = get_line_number_from_pos(app, buffer, pos_range.one_past_last);
        if (line_range.end == 0){
            line_range.first = 0;
        }
    }
    return(line_range);
}



static Range_i64
get_pos_range_from_line_range(Application_Links *app, Buffer_ID buffer, Range_i64 line_range){
    Range_i64 pos_range = {};
    if (is_valid_line_range(app, buffer, line_range)){
        pos_range.first = get_line_start_pos(app, buffer, line_range.first);
        pos_range.one_past_last = get_line_end_pos(app, buffer, line_range.end);
    }
    return(pos_range);
}

static Range_i64
enclose_boundary(Application_Links *app, Buffer_ID buffer, Range_i64 range,
                 Boundary_Function *func){
    i64 new_min = func(app, buffer, Side_Min, Scan_Backward, range.min + 1);
    i64 new_min_check = func(app, buffer, Side_Max, Scan_Backward, range.min + 1);
    if (new_min_check <= new_min && new_min < range.min){
        range.min = new_min;
    }
    i64 new_max = func(app, buffer, Side_Max, Scan_Forward, range.max - 1);
    i64 new_max_check = func(app, buffer, Side_Min, Scan_Forward, range.max);
    if (new_max_check >= new_max && new_max > range.max){
        range.max = new_max;
    }
    return(range);
}

static Range_i64
left_enclose_boundary(Application_Links *app, Buffer_ID buffer, Range_i64 range,
                      Boundary_Function *func){
    i64 new_min = func(app, buffer, Side_Min, Scan_Backward, range.min + 1);
    i64 new_min_check = func(app, buffer, Side_Max, Scan_Backward, range.min + 1);
    if (new_min_check <= new_min && new_min < range.min){
        range.min = new_min;
    }
    return(range);
}

static Range_i64
right_enclose_boundary(Application_Links *app, Buffer_ID buffer, Range_i64 range,
                       Boundary_Function *func){
    i64 new_max = func(app, buffer, Side_Max, Scan_Forward, range.max - 1);
    i64 new_max_check = func(app, buffer, Side_Min, Scan_Forward, range.max - 1);
    if (new_max_check >= new_max && new_max > range.max){
        range.max = new_max;
    }
    return(range);
}

static Range_i64
enclose_non_whitespace(Application_Links *app, Buffer_ID buffer, Range_i64 range){
    return(enclose_boundary(app, buffer, range, boundary_non_whitespace));
}
static Range_i64
enclose_pos_non_whitespace(Application_Links *app, Buffer_ID buffer, i64 pos){
    return(enclose_boundary(app, buffer, Ii64(pos), boundary_non_whitespace));
}

static Range_i64
enclose_tokens(Application_Links *app, Buffer_ID buffer, Range_i64 range){
    return(enclose_boundary(app, buffer, range, boundary_token));
}
static Range_i64
enclose_pos_tokens(Application_Links *app, Buffer_ID buffer, i64 pos){
    return(enclose_boundary(app, buffer, Ii64(pos), boundary_token));
}

static Range_i64
enclose_base10(Application_Links *app, Buffer_ID buffer, Range_i64 range){
    return(enclose_boundary(app, buffer, range, boundary_base10));
}
static Range_i64
enclose_pos_base10(Application_Links *app, Buffer_ID buffer, i64 pos){
    return(enclose_boundary(app, buffer, Ii64(pos), boundary_base10));
}

static Range_i64
enclose_base16(Application_Links *app, Buffer_ID buffer, Range_i64 range){
    return(enclose_boundary(app, buffer, range, boundary_base16));
}
static Range_i64
enclose_pos_base16(Application_Links *app, Buffer_ID buffer, i64 pos){
    return(enclose_boundary(app, buffer, Ii64(pos), boundary_base16));
}

static Range_i64
enclose_base10_colon(Application_Links *app, Buffer_ID buffer, Range_i64 range){
    return(enclose_boundary(app, buffer, range, boundary_base10_colon));
}
static Range_i64
enclose_pos_base10_colon(Application_Links *app, Buffer_ID buffer, i64 pos){
    return(enclose_boundary(app, buffer, Ii64(pos), boundary_base10_colon));
}

static Range_i64
enclose_alpha_numeric(Application_Links *app, Buffer_ID buffer, Range_i64 range){
    return(enclose_boundary(app, buffer, range, boundary_alpha_numeric));
}
static Range_i64
enclose_pos_alpha_numeric(Application_Links *app, Buffer_ID buffer, i64 pos){
    return(enclose_boundary(app, buffer, Ii64(pos), boundary_alpha_numeric));
}

static Range_i64
enclose_alpha_numeric_unicode(Application_Links *app, Buffer_ID buffer, Range_i64 range){
    return(enclose_boundary(app, buffer, range, boundary_alpha_numeric_unicode));
}
static Range_i64
enclose_pos_alpha_numeric_unicode(Application_Links *app, Buffer_ID buffer, i64 pos){
    return(enclose_boundary(app, buffer, Ii64(pos), boundary_alpha_numeric_unicode));
}

static Range_i64
enclose_alpha_numeric_underscore(Application_Links *app, Buffer_ID buffer, Range_i64 range){
    return(enclose_boundary(app, buffer, range, boundary_alpha_numeric_underscore));
}
static Range_i64
enclose_pos_alpha_numeric_underscore(Application_Links *app, Buffer_ID buffer, i64 pos){
    return(enclose_boundary(app, buffer, Ii64(pos), boundary_alpha_numeric_underscore));
}
static Range_i64
right_enclose_alpha_numeric_underscore(Application_Links *app, Buffer_ID buffer,
                                       Range_i64 range){
    return(right_enclose_boundary(app, buffer, range, boundary_alpha_numeric_underscore));
}

static Range_i64
enclose_alpha_numeric_underscore_utf8(Application_Links *app, Buffer_ID buffer, Range_i64 range){
    return(enclose_boundary(app, buffer, range, boundary_alpha_numeric_underscore_utf8));
}
static Range_i64
enclose_pos_alpha_numeric_underscore_utf8(Application_Links *app, Buffer_ID buffer, i64 pos){
    return(enclose_boundary(app, buffer, Ii64(pos), boundary_alpha_numeric_underscore_utf8));
}
static Range_i64
right_enclose_alpha_numeric_underscore_utf8(Application_Links *app, Buffer_ID buffer,
                                            Range_i64 range){
    return(right_enclose_boundary(app, buffer, range, boundary_alpha_numeric_underscore_utf8));
}


static Range_i64
enclose_alpha_numeric_camel(Application_Links *app, Buffer_ID buffer, Range_i64 range){
    return(enclose_boundary(app, buffer, range, boundary_alpha_numeric_camel));
}
static Range_i64
enclose_pos_alpha_numeric_camel(Application_Links *app, Buffer_ID buffer, i64 pos){
    return(enclose_boundary(app, buffer, Ii64(pos), boundary_alpha_numeric_camel));
}

static Range_i64
enclose_pos_inside_quotes(Application_Links *app, Buffer_ID buffer, i64 pos){
    return(enclose_boundary(app, buffer, Ii64(pos), boundary_inside_quotes));
}

static Range_i64
enclose_whole_lines(Application_Links *app, Buffer_ID buffer, Range_i64 range){
    return(enclose_boundary(app, buffer, range, boundary_line));
}
static Range_i64
enclose_pos_whole_lines(Application_Links *app, Buffer_ID buffer, i64 pos){
    return(enclose_boundary(app, buffer, Ii64(pos), boundary_line));
}



static Range_i64
get_snipe_range(Application_Links *app, Boundary_Function_List funcs, Buffer_ID buffer, i64 pos, Scan_Direction direction){
    Range_i64 result = {};
    i64 buffer_size = buffer_get_size(app, buffer);
    i64 pos0 = pos;
    i64 pos1 = scan(app, funcs, buffer, direction, pos0);
    if (0 <= pos1 && pos1 <= buffer_size){
        i64 pos2 = scan(app, funcs, buffer, flip_direction(direction), pos1);
        if (0 <= pos2 && pos2 <= buffer_size){
            if (direction == Scan_Backward){
                pos2 = (((pos2)>(pos0))?(pos2):(pos0));
            }
            else{
                pos2 = (((pos2)<(pos0))?(pos2):(pos0));
            }
            result = Ii64(pos1, pos2);
        }
    }
    return(result);
}

static Range_i64
get_snipe_range(Application_Links *app, Boundary_Function *func, Buffer_ID buffer, i64 pos, Scan_Direction direction){
    Scratch_Block scratch(app);
    return(get_snipe_range(app, push_boundary_list__inner((scratch), func, 0), buffer, pos, direction));
}



static String_Const_u8
push_buffer_range(Application_Links *app, Arena *arena, Buffer_ID buffer, Range_i64 range){
    String_Const_u8 result = {};
    i64 length = range_size(range);
    if (length > 0){
        Temp_Memory restore_point = begin_temp(arena);
        u8 *memory = ((u8*)linalloc_wrap_unintialized(linalloc_push((arena), sizeof(u8)*(length), SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_helper.cpp" ":" "997" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_helper.cpp" ":" "997" ":") - 1)))));
        if (buffer_read_range(app, buffer, range, memory)){
            result = SCu8(memory, length);
        }
        else{
            end_temp(restore_point);
        }
    }
    return(result);
}

static String_Const_u8
push_token_lexeme(Application_Links *app, Arena *arena, Buffer_ID buffer, Token *token){
    return(push_buffer_range(app, arena, buffer, Ii64(token)));
}

static String_Const_u8
push_buffer_line(Application_Links *app, Arena *arena, Buffer_ID buffer, i64 line_number){
    return(push_buffer_range(app, arena, buffer, get_line_pos_range(app, buffer, line_number)));
}

static String_Const_u8
push_whole_buffer(Application_Links *app, Arena *arena, Buffer_ID buffer){
    return(push_buffer_range(app, arena, buffer, buffer_range(app, buffer)));
}

static String_Const_u8
push_view_range_string(Application_Links *app, Arena *arena, View_ID view){
    Buffer_ID buffer = view_get_buffer(app, view, Access_ReadVisible);
    return(push_buffer_range(app, arena, buffer, get_view_range(app, view)));
}

static String_Const_u8
push_view_range_string(Application_Links *app, Arena *arena){
    View_ID view = get_active_view(app, Access_Always);
    return(push_view_range_string(app, arena, view));
}

static String_Const_u8
push_enclose_range_at_pos(Application_Links *app, Arena *arena, Buffer_ID buffer, i64 pos, Enclose_Function *enclose){
    Range_i64 range = enclose(app, buffer, Ii64(pos));
    return(push_buffer_range(app, arena, buffer, range));
}



static String_Const_u8
token_it_lexeme(Application_Links *app, Arena *arena, Token_Iterator_Array *it){
    String_Const_u8 result = {};
    Token *token = token_it_read(it);
    if (token != 0){
        result = push_token_lexeme(app, arena, (Buffer_ID)it->user_id, token);
    }
    return(result);
}

static b32
token_it_check_and_get_lexeme(Application_Links *app, Arena *arena, Token_Iterator_Array *it, Token_Base_Kind kind, String_Const_u8 *lexeme_out){
    Token *token = token_it_read(it);
    b32 result = {};
    if (token != 0 && token->kind == kind){
        result = true;
        *lexeme_out = push_token_lexeme(app, arena, (Buffer_ID)it->user_id, token);
    }
    return(result);
}

static String_Const_u8
token_it_lexeme(Application_Links *app, Arena *arena, Token_Iterator_List *it){
    String_Const_u8 result = {};
    Token *token = token_it_read(it);
    if (token != 0){
        result = push_token_lexeme(app, arena, (Buffer_ID)it->user_id, token);
    }
    return(result);
}

static b32
token_it_check_and_get_lexeme(Application_Links *app, Arena *arena, Token_Iterator_List *it, Token_Base_Kind kind, String_Const_u8 *lexeme_out){
    Token *token = token_it_read(it);
    b32 result = {};
    if (token != 0 && token->kind == kind){
        result = true;
        *lexeme_out = push_token_lexeme(app, arena, (Buffer_ID)it->user_id, token);
    }
    return(result);
}



static b32
buffer_has_name_with_star(Application_Links *app, Buffer_ID buffer){
    Scratch_Block scratch(app);
    String_Const_u8 str = push_buffer_unique_name(app, scratch, buffer);
    return(str.size > 0 && str.str[0] == '*');
}

static u8
buffer_get_char(Application_Links *app, Buffer_ID buffer_id, i64 pos){
    i64 buffer_size = buffer_get_size(app, buffer_id);
    u8 result = ' ';
    if (0 <= pos && pos < buffer_size){
        buffer_read_range(app, buffer_id, Ii64(pos, pos + 1), &result);
    }
    return(result);
}

static b32
line_is_valid_and_blank(Application_Links *app, Buffer_ID buffer, i64 line_number){
    b32 result = false;
    if (is_valid_line(app, buffer, line_number)){
        Scratch_Block scratch(app);
        String_Const_u8 line = push_buffer_line(app, scratch, buffer, line_number);
        result = true;
        for (u64 i = 0; i < line.size; i += 1){
            if (!character_is_whitespace(line.str[i])){
                result = false;
                break;
            }
        }
    }
    return(result);
}



static i64
get_pos_past_lead_whitespace_from_line_number(Application_Links *app, Buffer_ID buffer, i64 line_number){
    Scratch_Block scratch(app);
    Range_i64 line_range = get_line_pos_range(app, buffer, line_number);
    String_Const_u8 line = push_buffer_range(app, scratch, buffer, line_range);
    i64 result = line_range.end;
    for (u64 i = 0; i < line.size; i += 1){
        if (!character_is_whitespace(line.str[i])){
            result = line_range.start + i;
            break;
        }
    }
    return(result);
}

static i64
get_pos_past_lead_whitespace(Application_Links *app, Buffer_ID buffer, i64 pos){
    i64 line_number = get_line_number_from_pos(app, buffer, pos);
    i64 result = get_pos_past_lead_whitespace_from_line_number(app, buffer, line_number);
    result = (((pos)>(result))?(pos):(result));
    return(result);
}

static void
move_past_lead_whitespace(Application_Links *app, View_ID view, Buffer_ID buffer){
    i64 pos = view_get_cursor_pos(app, view);
    i64 new_pos = get_pos_past_lead_whitespace(app, buffer, pos);
    view_set_cursor_and_preferred_x(app, view, seek_pos(new_pos));
}

static void
move_past_lead_whitespace(Application_Links *app, View_ID view){
    Buffer_ID buffer = view_get_buffer(app, view, Access_ReadVisible);
    move_past_lead_whitespace(app, view, buffer);
}

static b32
line_is_blank(Application_Links *app, Buffer_ID buffer, i64 line_number){
    Scratch_Block scratch(app);
    String_Const_u8 line = push_buffer_line(app, scratch, buffer, line_number);
    b32 is_blank = true;
    for (u64 i = 0; i < line.size; i += 1){
        if (!character_is_whitespace(line.str[i])){
            is_blank = false;
            break;
        }
    }
    return(is_blank);
}

static i64
get_line_number_of__whitespace_status_line(Application_Links *app, Buffer_ID buffer, Scan_Direction direction, i64 line_number_start, b32 get_blank_line){
    i64 line_count = buffer_get_line_count(app, buffer);
    i64 line_number = line_number_start + direction;
    for (;1 <= line_number && line_number <= line_count; line_number += direction){
        b32 is_blank = line_is_blank(app, buffer, line_number);
        if (is_blank == get_blank_line){
            break;
        }
    }
    line_number = (((1)>(line_number))?(1):(((line_count)<(line_number))?(line_count):(line_number)));
    return(line_number);
}

static i64
get_line_number_of_non_blank_line(Application_Links *app, Buffer_ID buffer, Scan_Direction direction, i64 line_number_start){
    return(get_line_number_of__whitespace_status_line(app, buffer, direction, line_number_start, false));
}

static i64
get_line_number_of_blank_line(Application_Links *app, Buffer_ID buffer, Scan_Direction direction, i64 line_number_start){
    return(get_line_number_of__whitespace_status_line(app, buffer, direction, line_number_start, true));
}

static i64
get_pos_of_blank_line(Application_Links *app, Buffer_ID buffer, Scan_Direction direction, i64 pos_start){
    i64 line_number_start = get_line_number_from_pos(app, buffer, pos_start);
    i64 blank_line = get_line_number_of_blank_line(app, buffer, direction, line_number_start);
    i64 pos = get_line_start_pos(app, buffer, blank_line);
    return(pos);
}

static i64
get_line_number_of_blank_line_grouped(Application_Links *app, Buffer_ID buffer, Scan_Direction direction, i64 line_number_start){
    i64 line_number = line_number_start;
    if (line_is_blank(app, buffer, line_number)){
        line_number = get_line_number_of_non_blank_line(app, buffer, direction, line_number);
    }
    line_number = get_line_number_of_blank_line(app, buffer, direction, line_number);
    return(line_number);
}

static i64
get_pos_of_blank_line_grouped(Application_Links *app, Buffer_ID buffer, Scan_Direction direction, i64 pos_start){
    i64 line_number_start = get_line_number_from_pos(app, buffer, pos_start);
    i64 blank_line = get_line_number_of_blank_line_grouped(app, buffer, direction, line_number_start);
    i64 pos = get_line_start_pos(app, buffer, blank_line);
    return(pos);
}

static Indent_Info
get_indent_info_range(Application_Links *app, Buffer_ID buffer, Range_i64 range, i32 tab_width){
    Scratch_Block scratch(app);
    String_Const_u8 s = push_buffer_range(app, scratch, buffer, range);

    Indent_Info info = {};
    info.first_char_pos = range.end;
    info.is_blank = true;
    info.all_space = true;

    for (u64 i = 0; i < s.size; i += 1){
        u8 c = s.str[i];
        if (!character_is_whitespace(c)){
            info.is_blank = false;
            info.all_space = false;
            info.first_char_pos = range.start + (i64)i;
            break;
        }
        if (c == ' '){
            info.indent_pos += 1;
        }
        else{
            info.all_space = false;
        }
        if (c == '\t'){
            info.indent_pos += tab_width;
        }
    }

    return(info);
}

static Indent_Info
get_indent_info_line_number_and_start(Application_Links *app, Buffer_ID buffer, i64 line_number, i64 line_start, i32 tab_width){
    i64 end = get_line_side_pos(app, buffer, line_number, Side_Max);
    return(get_indent_info_range(app, buffer, Ii64(line_start, end), tab_width));
}



static History_Group
history_group_begin(Application_Links *app, Buffer_ID buffer){
    History_Group group = {};
    group.app = app;
    group.buffer = buffer;
    group.first = buffer_history_get_current_state_index(app, buffer);
    group.first += 1;
    return(group);
}

static void
history_group_end(History_Group group){
    History_Record_Index last = buffer_history_get_current_state_index(group.app, group.buffer);
    if (group.first < last){
        buffer_history_merge_record_range(group.app, group.buffer, group.first, last, RecordMergeFlag_StateInRange_MoveStateForward);
    }
}



static void
replace_in_range(Application_Links *app, Buffer_ID buffer, Range_i64 range, String_Const_u8 needle, String_Const_u8 string){

    History_Group group = history_group_begin(app, buffer);
    i64 pos = range.min - 1;
    i64 new_pos = 0;
    seek_string_forward(app, buffer, pos, range.end, needle, &new_pos);
    i64 shift = replace_range_shift(needle.size, string.size);
    for (; new_pos + (i64)needle.size <= range.end;){
        Range_i64 needle_range = Ii64(new_pos, new_pos + (i32)needle.size);
        buffer_replace_range(app, buffer, needle_range, string);
        range.end += shift;
        pos = new_pos + (i32)string.size - 1;
        seek_string_forward(app, buffer, pos, range.end, needle, &new_pos);
    }
    history_group_end(group);
}

static Range_i64
swap_lines(Application_Links *app, Buffer_ID buffer, i64 line_1, i64 line_2){
    Range_i64 result = {};
    i64 line_count = buffer_get_line_count(app, buffer);
    if (1 <= line_1 && line_2 <= line_count){
        Range_i64 range_1 = get_line_pos_range(app, buffer, line_1);
        Range_i64 range_2 = get_line_pos_range(app, buffer, line_2);

        Scratch_Block scratch(app);

        String_Const_u8 text_1 = push_buffer_range(app, scratch, buffer, range_1);
        String_Const_u8 text_2 = push_buffer_range(app, scratch, buffer, range_2);

        History_Group group = history_group_begin(app, buffer);
        buffer_replace_range(app, buffer, range_2, text_1);
        buffer_replace_range(app, buffer, range_1, text_2);
        history_group_end(group);

        i64 shift = replace_range_shift(range_1, text_2.size);
        result.min = range_1.min;
        result.max = range_2.min + shift;
    }
    return(result);
}

static i64
move_line(Application_Links *app, Buffer_ID buffer, i64 line_number, Scan_Direction direction){
    i64 line_1 = 0;
    i64 line_2 = 0;
    if (direction == Scan_Forward){
        line_1 = line_number;
        line_2 = line_number + 1;
    }
    else{
        line_1 = line_number - 1;
        line_2 = line_number;
    }
    Range_i64 line_starts = swap_lines(app, buffer, line_1, line_2);
    i64 result = 0;
    if (line_starts.min < line_starts.max){
        if (direction == Scan_Forward){
            result = line_starts.max;
        }
        else{
            result = line_starts.min;
        }
    }
    else{
        result = get_line_side_pos(app, buffer, line_number, Side_Min);
    }
    return(result);
}

static void
clear_buffer(Application_Links *app, Buffer_ID buffer){
    buffer_replace_range(app, buffer, buffer_range(app, buffer), SCu8((u8*)(""), (u64)(sizeof("") - 1)));
}



static String_Match_List
find_all_matches_all_buffers(Application_Links *app, Arena *arena, String_Const_u8_Array match_patterns, String_Match_Flag must_have_flags, String_Match_Flag must_not_have_flags){
    String_Match_List all_matches = {};
    for (Buffer_ID buffer = get_buffer_next(app, 0, Access_Always);
         buffer != 0;
         buffer = get_buffer_next(app, buffer, Access_Always)){
        String_Match_List buffer_matches = {};
        for (i32 i = 0; i < match_patterns.count; i += 1){
            Range_i64 range = buffer_range(app, buffer);
            String_Match_List pattern_matches = buffer_find_all_matches(app, arena, buffer, i, range, match_patterns.vals[i],
                                                                        &character_predicate_alpha_numeric_underscore_utf8, Scan_Forward);
            string_match_list_filter_flags(&pattern_matches, must_have_flags, must_not_have_flags);
            if (pattern_matches.count > 0){
                if (buffer_matches.count == 0){
                    buffer_matches = pattern_matches;
                }
                else{
                    buffer_matches = string_match_list_merge_front_to_back(&buffer_matches, &pattern_matches);
                }
            }
        }
        all_matches = string_match_list_join(&all_matches, &buffer_matches);
    }
    return(all_matches);
}

static String_Match_List
find_all_matches_all_buffers(Application_Links *app, Arena *arena, String_Const_u8 pattern, String_Match_Flag must_have_flags, String_Match_Flag must_not_have_flags){
    String_Const_u8_Array array = {&pattern, 1};
    return(find_all_matches_all_buffers(app, arena, array, must_have_flags, must_not_have_flags));
}



static b32
is_modified(User_Input *input){
    return(is_modified(&input->event));
}

static String_Const_u8
to_writable(User_Input *in){
    return(to_writable(&in->event));
}

static b32
has_modifier(User_Input *in, Key_Code key_code){
    b32 result = false;
    Input_Modifier_Set *mods = get_modifiers(&in->event);
    if (mods != 0){
        result = has_modifier(mods, key_code);
    }
    return(result);
}

static b32
match_key_code(User_Input *in, Key_Code key_code){
    return(match_key_code(&in->event, key_code));
}

static b32
match_core_code(User_Input *in, Key_Code core_code){
    return(match_core_code(&in->event, core_code));
}

static String_Const_u8
backspace_utf8(String_Const_u8 string){
    if (string.size > 0){
        u64 i = string.size - 1;
        for (; i > 0; --i){
            if (string.str[i] <= 0x7F || string.str[i] >= 0xC0){
                break;
            }
        }
        string.size = i;
    }
    return(string);
}



static User_Input
get_next_input(Application_Links *app, Event_Property use_flags, Event_Property abort_flags){
    User_Input in = {};
    if (use_flags != 0){
        for (;;){
            in = get_next_input_raw(app);
            if (in.abort){
                break;
            }
            Event_Property event_flags = get_event_properties(&in.event);
            if ((event_flags & abort_flags) != 0){
                in.abort = true;
                break;
            }
            if ((event_flags & use_flags) != 0){
                break;
            }
        }
    }
    return(in);
}



Query_Bar_Group::Query_Bar_Group(Application_Links *app){
    this->app = app;
    this->view = get_active_view(app, Access_Always);
}

Query_Bar_Group::Query_Bar_Group(Application_Links *app, View_ID view){
    this->app = app;
    this->view = view;
}

Query_Bar_Group::~Query_Bar_Group(){
    clear_all_query_bars(this->app, this->view);
}

static b32
query_user_general(Application_Links *app, Query_Bar *bar, b32 force_number, String_Const_u8 init_string){
    if (start_query_bar(app, bar, 0) == 0){
        return(false);
    }

    if (init_string.size > 0){
        String_u8 string = Su8(bar->string.str, bar->string.size, bar->string_capacity);
        string_append(&string, init_string);
        bar->string.size = string.string.size;
    }

    b32 success = true;
    for (;;){
        User_Input in = get_next_input(app, EventPropertyGroup_Any,
                                       EventProperty_Escape|EventProperty_MouseButton);
        if (in.abort){
            success = false;
            break;
        }

        Scratch_Block scratch(app);
        b32 good_insert = false;
        String_Const_u8 insert_string = to_writable(&in);
        if (insert_string.str != 0 && insert_string.size > 0){
            insert_string = string_replace(scratch, insert_string,
                                           SCu8((u8*)("\n"), (u64)(sizeof("\n") - 1)),
                                           SCu8((u8*)(""), (u64)(sizeof("") - 1)));
            insert_string = string_replace(scratch, insert_string,
                                           SCu8((u8*)("\t"), (u64)(sizeof("\t") - 1)),
                                           SCu8((u8*)(""), (u64)(sizeof("") - 1)));
            if (force_number){
                if (string_is_integer(insert_string, 10)){
                    good_insert = true;
                }
            }
            else{
                good_insert = true;
            }
        }

        if (in.event.kind == InputEventKind_KeyStroke &&
            (in.event.key.code == KeyCode_Return || in.event.key.code == KeyCode_Tab)){
            break;
        }
        else if (in.event.kind == InputEventKind_KeyStroke &&
                 in.event.key.code == KeyCode_Backspace){
            bar->string = backspace_utf8(bar->string);
        }
        else if (good_insert){
            String_u8 string = Su8(bar->string.str, bar->string.size, bar->string_capacity);
            string_append(&string, insert_string);
            bar->string.size = string.string.size;
        }
        else{

            View_ID view = get_this_ctx_view(app, Access_Always);
            View_Context ctx = view_current_context(app, view);
            Mapping *mapping = ctx.mapping;
            Command_Map *map = mapping_get_map(mapping, ctx.map_id);
            Command_Binding binding = map_get_binding_recursive(mapping, map, &in.event);
            if (binding.custom != 0){
                Command_Metadata *metadata = get_command_metadata(binding.custom);
                if (metadata != 0){
                    if (metadata->is_ui){
                        view_enqueue_command_function(app, view, binding.custom);
                        break;
                    }
                }
                binding.custom(app);
            }
            else{
                leave_current_input_unhandled(app);
            }
        }
    }

    return(success);
}

static b32
query_user_string(Application_Links *app, Query_Bar *bar){
    return(query_user_general(app, bar, false, string_u8_empty));
}

static b32
query_user_number(Application_Links *app, Query_Bar *bar){
    return(query_user_general(app, bar, true, string_u8_empty));
}

static b32
query_user_number(Application_Links *app, Query_Bar *bar, i32 x){
    Scratch_Block scratch(app);
    String_Const_u8 string = push_u8_stringf(scratch, "%d", x);
    return(query_user_general(app, bar, true, string));
}



static Buffer_Identifier
buffer_identifier(char *str, i32 len){
    Buffer_Identifier identifier;
    identifier.name = str;
    identifier.name_len = len;
    identifier.id = 0;
    return(identifier);
}

static Buffer_Identifier
buffer_identifier(String_Const_u8 str){
    return(buffer_identifier((char*)str.str, (i32)str.size));
}

static Buffer_Identifier
buffer_identifier(Buffer_ID id){
    Buffer_Identifier identifier;
    identifier.name = 0;
    identifier.name_len = 0;
    identifier.id = id;
    return(identifier);
}

static Buffer_ID
buffer_identifier_to_id(Application_Links *app, Buffer_Identifier identifier){
    Buffer_ID id = 0;
    if (identifier.id != 0){
        id = identifier.id;
    }
    else{
        String_Const_u8 name = SCu8(identifier.name, identifier.name_len);
        id = get_buffer_by_name(app, name, Access_Always);
        if (id == 0){
            id = get_buffer_by_file_name(app, name, Access_Always);
        }
    }
    return(id);
}

static Buffer_ID
buffer_identifier_to_id_create_out_buffer(Application_Links *app, Buffer_Identifier buffer_id){
    Buffer_ID result = 0;
    if (buffer_id.name != 0 && buffer_id.name_len > 0){
        String_Const_u8 buffer_name = SCu8(buffer_id.name, buffer_id.name_len);
        Buffer_ID buffer_attach_id = get_buffer_by_name(app, buffer_name, Access_Always);
        if (buffer_attach_id != 0){
            result = buffer_attach_id;
        }
        else{
            buffer_attach_id = create_buffer(app, buffer_name, BufferCreate_AlwaysNew|BufferCreate_NeverAttachToFile);
            if (buffer_attach_id != 0){
                buffer_set_setting(app, buffer_attach_id, BufferSetting_ReadOnly, true);
                buffer_set_setting(app, buffer_attach_id, BufferSetting_Unimportant, true);
                result = buffer_attach_id;
            }
        }
    }
    else{
        result = buffer_id.id;
    }
    return(result);
}



static void
place_begin_and_end_on_own_lines(Application_Links *app, char *begin, char *end){
    View_ID view = get_active_view(app, Access_ReadWriteVisible);
    Buffer_ID buffer = view_get_buffer(app, view, Access_ReadWriteVisible);

    Range_i64 range = get_view_range(app, view);
    Range_i64 lines = get_line_range_from_pos_range(app, buffer, range);
    range = get_pos_range_from_line_range(app, buffer, lines);

    Scratch_Block scratch(app);

    b32 min_line_blank = line_is_valid_and_blank(app, buffer, lines.min);
    b32 max_line_blank = line_is_valid_and_blank(app, buffer, lines.max);

    if ((lines.min < lines.max) || (!min_line_blank)){
        String_Const_u8 begin_str = {};
        String_Const_u8 end_str = {};

        i64 min_adjustment = 0;
        i64 max_adjustment = 0;

        if (min_line_blank){
            begin_str = push_u8_stringf(scratch, "\n%s", begin);
            min_adjustment += 1;
        }
        else{
            begin_str = push_u8_stringf(scratch, "%s\n", begin);
        }
        if (max_line_blank){
            end_str = push_u8_stringf(scratch, "%s\n", end);
        }
        else{
            end_str = push_u8_stringf(scratch, "\n%s", end);
            max_adjustment += 1;
        }

        max_adjustment += begin_str.size;
        Range_i64 new_pos = Ii64(range.min + min_adjustment, range.max + max_adjustment);

        History_Group group = history_group_begin(app, buffer);
        buffer_replace_range(app, buffer, Ii64(range.min), begin_str);
        buffer_replace_range(app, buffer, Ii64(range.max + begin_str.size), end_str);
        history_group_end(group);

        set_view_range(app, view, new_pos);
    }
    else{
        String_Const_u8 str = push_u8_stringf(scratch, "%s\n\n%s", begin, end);
        buffer_replace_range(app, buffer, range, str);
        i64 center_pos = range.min + cstring_length(begin) + 1;
        view_set_cursor_and_preferred_x(app, view, seek_pos(center_pos));
        view_set_mark(app, view, seek_pos(center_pos));
    }
}



static Face_ID
get_view_face_id(Application_Links *app, View_ID view){
    Buffer_ID buffer = view_get_buffer(app, view, Access_Always);
    return(get_face_id(app, buffer));
}

static Face_Metrics
get_view_face_metrics(Application_Links *app, View_ID view){
    Face_ID face = get_view_face_id(app, view);
    return(get_face_metrics(app, face));
}

static f32
get_view_line_height(Application_Links *app, View_ID view){
    Face_Metrics metrics = get_view_face_metrics(app, view);
    return(metrics.line_height);
}

static View_ID
open_view(Application_Links *app, View_ID view_location, View_Split_Position position){
    View_ID result = 0;
    if (view_location != 0 && view_exists(app, view_location)){
        Panel_ID panel_id = view_get_panel(app, view_location);
        if (panel_id != 0){
            Dimension split = (position == ViewSplit_Left ||
                               position == ViewSplit_Right)?Dimension_X:Dimension_Y;
            Side side = (position == ViewSplit_Left ||
                         position == ViewSplit_Top)?Side_Min:Side_Max;
            if (panel_split(app, panel_id, split)){
                Panel_ID new_panel_id = panel_get_child(app, panel_id, side);
                if (new_panel_id != 0){
                    View_ID new_view_id = panel_get_view(app, new_panel_id,
                                                         Access_Always);
                    if (new_view_id != 0){
                        result = new_view_id;
                    }
                }
            }
        }
    }
    return(result);
}

static View_ID
get_first_view_with_buffer(Application_Links *app, Buffer_ID buffer_id){
    View_ID result = {};
    if (buffer_id != 0){
        for (View_ID test = get_view_next(app, 0, Access_Always);
             test != 0;
             test = get_view_next(app, test, Access_Always)){
            Buffer_ID test_buffer = view_get_buffer(app, test, Access_Always);
            if (test_buffer == buffer_id){
                result = test;
                break;
            }
        }
    }
    return(result);
}

static b32
open_file(Application_Links *app, Buffer_ID *buffer_out, String_Const_u8 file_name, b32 background, b32 never_new){
    b32 result = false;
    Buffer_ID buffer = get_buffer_by_name(app, file_name, Access_ReadVisible);
    b32 exists = buffer_exists(app, buffer);
    if (!exists){
        Buffer_Create_Flag flags = 0;
        if (background){
            flags |= BufferCreate_Background;
        }
        if (never_new){
            flags |= BufferCreate_NeverNew;
        }
        buffer = create_buffer(app, file_name, flags);
        exists = buffer_exists(app, buffer);
    }
    if (exists){
        if (buffer_out != 0){
            *buffer_out = buffer;
        }
        result = true;
    }
    return(result);
}

static b32
view_open_file(Application_Links *app, View_ID view, String_Const_u8 file_name, b32 never_new){
    b32 result = false;
    if (view != 0){
        Buffer_ID buffer = 0;
        if (open_file(app, &buffer, file_name, false, never_new)){
            view_set_buffer(app, view, buffer, 0);
            result = true;
        }
    }
    return(result);
}

static void
view_disable_highlight_range(Application_Links *app, View_ID view){
    Managed_Scope scope = view_get_managed_scope(app, view);
    Managed_Object *highlight = ((Managed_Object*)managed_scope_get_attachment((app), (scope), (view_highlight_range), sizeof(Managed_Object)));
    if (*highlight != 0){
        managed_object_free(app, *highlight);
    }
    managed_scope_attachment_erase(app, scope, view_highlight_range);
    managed_scope_attachment_erase(app, scope, view_highlight_buffer);
}

static void
view_set_highlight_range(Application_Links *app, View_ID view, Range_i64 range){
    view_disable_highlight_range(app, view);

    Buffer_ID buffer = view_get_buffer(app, view, Access_Always);
    Managed_Scope scope = view_get_managed_scope(app, view);
    Managed_Object *highlight = ((Managed_Object*)managed_scope_get_attachment((app), (scope), (view_highlight_range), sizeof(Managed_Object)));
    *highlight = alloc_buffer_markers_on_buffer(app, buffer, 2, &scope);
    Marker markers[2] = {};
    markers[0].pos = range.min;
    markers[1].pos = range.max;
    managed_object_store_data(app, *highlight, 0, 2, markers);
    Buffer_ID *highlight_buffer = ((Buffer_ID*)managed_scope_get_attachment((app), (scope), (view_highlight_buffer), sizeof(Buffer_ID)));
    *highlight_buffer = buffer;
}

static void
view_look_at_region(Application_Links *app, View_ID view, i64 major_pos, i64 minor_pos){
    Range_i64 range = Ii64(major_pos, minor_pos);
    b32 bottom_major = false;
    if (major_pos == range.max){
        bottom_major = true;
    }

    Buffer_Cursor top = view_compute_cursor(app, view, seek_pos(range.min));
    if (top.line > 0){
        Buffer_Cursor bottom = view_compute_cursor(app, view, seek_pos(range.max));
        if (bottom.line > 0){
            Rect_f32 region = view_get_buffer_region(app, view);
            f32 view_height = rect_height(region);
            f32 skirt_height = view_height*.1f;
            Range_f32 acceptable_y = If32(skirt_height, view_height*.9f);

            f32 target_height = view_line_y_difference(app, view, bottom.line + 1, top.line);

            f32 line_height = get_view_line_height(app, view);
            if (target_height + 2*line_height > view_height){
                i64 major_line = bottom.line;
                if (range.min == major_pos){
                    major_line = top.line;
                }

                Buffer_Scroll scroll = view_get_buffer_scroll(app, view);
                scroll.target.line_number = major_line;
                scroll.target.pixel_shift.y = -skirt_height;
                view_set_buffer_scroll(app, view, scroll, SetBufferScroll_SnapCursorIntoView);
            }
            else{
                Buffer_Scroll scroll = view_get_buffer_scroll(app, view);
                Vec2_f32 top_p = view_relative_xy_of_pos(app, view, scroll.position.line_number, range.min);
                top_p -= scroll.position.pixel_shift;
                if (top_p.y < acceptable_y.min){
                    scroll.target.line_number = top.line;
                    scroll.target.pixel_shift.y = -skirt_height;
                    view_set_buffer_scroll(app, view, scroll, SetBufferScroll_NoCursorChange);
                }
                else{
                    Vec2_f32 bot_p = view_relative_xy_of_pos(app, view, scroll.position.line_number, range.max);
                    bot_p -= scroll.position.pixel_shift;
                    if (bot_p.y > acceptable_y.max){
                        scroll.target.line_number = bottom.line;
                        scroll.target.pixel_shift.y = skirt_height - view_height;
                        view_set_buffer_scroll(app, view, scroll, SetBufferScroll_NoCursorChange);
                    }
                }
            }
        }
    }
}

static void
view_look_at_region(Application_Links *app, View_ID view, Range_i64 range){
    view_look_at_region(app, view, range.min, range.max);
}



static Buffer_ID
get_buffer_next_looped(Application_Links *app, Buffer_ID buffer, Access_Flag access){
    buffer = get_buffer_next(app, buffer, access);
    if (buffer == 0){
        buffer = get_buffer_next(app, 0, access);
    }
    return(buffer);
}



static View_ID
get_next_view_looped_all_panels(Application_Links *app, View_ID view_id, Access_Flag access){
    view_id = get_view_next(app, view_id, access);
    if (view_id == 0){
        view_id = get_view_next(app, 0, access);
    }
    return(view_id);
}

static View_ID
get_prev_view_looped_all_panels(Application_Links *app, View_ID view_id, Access_Flag access){
    view_id = get_view_prev(app, view_id, access);
    if (view_id == 0){
        view_id = get_view_prev(app, 0, access);
    }
    return(view_id);
}



static Buffer_Kill_Result
try_buffer_kill(Application_Links *app, Buffer_ID buffer, View_ID gui_view_id, Buffer_Kill_Flag flags){
    Buffer_Kill_Result result = buffer_kill(app, buffer, flags);
    if (result == BufferKillResult_Dirty){
        if (do_buffer_kill_user_check(app, buffer, gui_view_id)){
            result = buffer_kill(app, buffer, BufferKill_AlwaysKill);
        }
    }
    return(result);
}



static String_Const_u8
get_query_string(Application_Links *app, char *query_str, u8 *string_space, i32 space_size){
    Query_Bar_Group group(app);
    Query_Bar bar = {};
    bar.prompt = SCu8((u8*)query_str);
    bar.string = SCu8(string_space, (u64)0);
    bar.string_capacity = space_size;
    if (!query_user_string(app, &bar)){
        bar.string.size = 0;
    }
    return(bar.string);
}

static Token*
get_token_from_pos(Application_Links *app, Token_Array *array, u64 pos){
    Token *result = 0;
    if (array->count > 0){
        i64 index = token_index_from_pos(array, pos);
        result = array->tokens + index;
    }
    return(result);
}

static Token*
get_token_from_pos(Application_Links *app, Buffer_ID buffer, u64 pos){
    Token_Array array = get_token_array_from_buffer(app, buffer);
    return(get_token_from_pos(app, &array, pos));
}

static String_Const_u8
push_token_or_word_under_pos(Application_Links *app, Arena *arena, Buffer_ID buffer, u64 pos){
    String_Const_u8 result = {};
    Token *token = get_token_from_pos(app, buffer, pos);
    if (token != 0 && token->size > 0 && token->kind != TokenBaseKind_Whitespace){
        Range_i64 range = Ii64(token);
        result = push_buffer_range(app, arena, buffer, range);
    }
    return(result);
}

static String_Const_u8
push_token_or_word_under_active_cursor(Application_Links *app, Arena *arena){
    View_ID view = get_active_view(app, Access_Always);
    Buffer_ID buffer = view_get_buffer(app, view, Access_Always);
    i64 pos = view_get_cursor_pos(app, view);
    return(push_token_or_word_under_pos(app, arena, buffer, pos));
}



static b32
file_exists(Application_Links *app, String_Const_u8 file_name){
    Scratch_Block scratch(app);
    File_Attributes attributes = system_quick_file_attributes(scratch, file_name);
    return(attributes.last_write_time > 0);
}

static b32
file_exists_and_is_file(Application_Links *app, String_Const_u8 file_name){
    Scratch_Block scratch(app);
    File_Attributes attributes = system_quick_file_attributes(scratch, file_name);
    return(attributes.last_write_time > 0 && !(((attributes.flags)&(FileAttribute_IsDirectory))!=0));
}

static b32
file_exists_and_is_folder(Application_Links *app, String_Const_u8 file_name){
    Scratch_Block scratch(app);
    File_Attributes attributes = system_quick_file_attributes(scratch, file_name);
    return(attributes.last_write_time > 0 && (((attributes.flags)&(FileAttribute_IsDirectory))!=0));
}

static Data
dump_file_handle(Arena *arena, FILE *file){
    Data result = {};
    if (file != 0){
        fseek(file, 0, 
# 2005 "/home/sam/.bin/4coder/custom/4coder_helper.cpp" 3 4
                      2
# 2005 "/home/sam/.bin/4coder/custom/4coder_helper.cpp"
                              );
        u64 size = ftell(file);
        char *mem = ((char*)linalloc_wrap_unintialized(linalloc_push((arena), sizeof(char)*(size), SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_helper.cpp" ":" "2007" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_helper.cpp" ":" "2007" ":") - 1)))));
        if (mem != 0){
            fseek(file, 0, 
# 2009 "/home/sam/.bin/4coder/custom/4coder_helper.cpp" 3 4
                          0
# 2009 "/home/sam/.bin/4coder/custom/4coder_helper.cpp"
                                  );
            fread(mem, 1, (size_t)size, file);
            result = make_data(mem, size);
        }
    }
    return(result);
}

static String_Const_u8
push_file_search_up_path(Application_Links *app, Arena *arena, String_Const_u8 start_path, String_Const_u8 file_name){
    String_Const_u8 result = {};
    String_Const_u8 path = start_path;
    for (;path.size > 0;){
        Temp_Memory temp = begin_temp(arena);
        if (character_is_slash(string_get_character(path, path.size - 1))){
            path = string_chop(path, 1);
        }
        String_Const_u8 full_path = push_u8_stringf(arena, "%.*s/%.*s",
                                                    (i32)(path).size, (char*)(path).str,
                                                    (i32)(file_name).size, (char*)(file_name).str);
        if (file_exists(app, full_path)){
            result = full_path;
            break;
        }
        path = string_remove_last_folder(path);
        end_temp(temp);
    }
    return(result);
}

static FILE*
open_file_try_current_path_then_binary_path(Application_Links *app, char *file_name){
    FILE *file = fopen(file_name, "rb");
    if (file == 0){
        Scratch_Block scratch(app);
        List_String_Const_u8 list = {};
        string_list_push(scratch, &list, system_get_path(scratch, SystemPath_Binary));
        string_list_push_overlap(scratch, &list, '/', SCu8(file_name));
        String_Const_u8 str = string_list_flatten(scratch, list, StringFill_NullTerminate);
        file = fopen((char*)str.str, "rb");
    }
    return(file);
}

static FILE*
open_file(Arena *scratch, String_Const_u8 name){
    Temp_Memory temp = begin_temp(scratch);
    String_Const_u8 name_copy = push_string_copy(scratch, name);
    FILE *file = fopen((char*)name_copy.str, "rb");
    end_temp(temp);
    return(file);
}

static File_Name_Data
dump_file(Arena *arena, String_Const_u8 file_name){
    File_Name_Data result = {};
    FILE *file = open_file(arena, file_name);
    if (file != 0){
        result.file_name = file_name;
        result.data = dump_file_handle(arena, file);
        fclose(file);
    }
    return(result);
}

static File_Name_Data
dump_file_search_up_path(Application_Links *app, Arena *arena, String_Const_u8 path, String_Const_u8 file_name){
    File_Name_Data result = {};
    String_Const_u8 full_path = push_file_search_up_path(app, arena, path, file_name);
    if (full_path.size > 0){
        result = dump_file(arena, full_path);
    }
    return(result);
}

static void
sort_pairs_by_key__quick(Sort_Pair_i32 *pairs, i32 first, i32 one_past_last){
    i32 dif = one_past_last - first;
    if (dif >= 2){
        i32 pivot = one_past_last - 1;
        Sort_Pair_i32 pivot_pair = pairs[pivot];
        i32 j = first;
        b32 interleave = false;
        for (i32 i = first; i < pivot; i += 1){
            Sort_Pair_i32 pair = pairs[i];
            if (pair.key < pivot_pair.key){
                pairs[i] = pairs[j];
                pairs[j] = pair;
                j += 1;
            }
            else if (pair.key == pivot_pair.key){
                if (interleave){
                    pairs[i] = pairs[j];
                    pairs[j] = pair;
                    j += 1;
                }
                interleave = !interleave;
            }
        }
        pairs[pivot] = pairs[j];
        pairs[j] = pivot_pair;
        sort_pairs_by_key__quick(pairs, first, j);
        sort_pairs_by_key__quick(pairs, j + 1, one_past_last);
    }
}

static void
sort_pairs_by_key(Sort_Pair_i32 *pairs, i32 count){
    sort_pairs_by_key__quick(pairs, 0, count);
}

static Range_i32_Array
get_ranges_of_duplicate_keys(Arena *arena, i32 *keys, i32 stride, i32 count){
    Range_i32_Array result = {};
    result.ranges = ((Range_i32*)linalloc_wrap_unintialized(linalloc_push((arena), sizeof(Range_i32)*(count), SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_helper.cpp" ":" "2123" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_helper.cpp" ":" "2123" ":") - 1)))));
    u8 *ptr = (u8*)keys;
    i32 start_i = 0;
    for (i32 i = 1; i <= count; i += 1){
        b32 is_end = false;
        if (i == count){
            is_end = true;
        }
        else if (*(i32*)(ptr + i*stride) != *(i32*)(ptr + start_i*stride)){
            is_end = true;
        }
        if (is_end){
            Range_i32 *new_range = &result.ranges[result.count++];
            new_range->first = start_i;
            new_range->one_past_last = i;
            start_i = i;
        }
    }
    (linalloc_pop((arena), sizeof(Range_i32)*(count - result.count)));
    return(result);
}

static void
no_mark_snap_to_cursor(Application_Links *app, Managed_Scope view_scope){
    b32 *snap_to_cursor = ((b32*)managed_scope_get_attachment((app), (view_scope), (view_snap_mark_to_cursor), sizeof(b32)));
    *snap_to_cursor = false;
}

static void
no_mark_snap_to_cursor(Application_Links *app, View_ID view_id){
    Managed_Scope scope = view_get_managed_scope(app, view_id);
    no_mark_snap_to_cursor(app, scope);
}

static void
no_mark_snap_to_cursor_if_shift(Application_Links *app, View_ID view_id){
    Scratch_Block scratch(app);
    Input_Modifier_Set mods = system_get_keyboard_modifiers(scratch);
    if (has_modifier(&mods, KeyCode_Shift)){
        no_mark_snap_to_cursor(app, view_id);
    }
}

static b32
view_has_highlighted_range(Application_Links *app, View_ID view){
    b32 result = false;
    if (fcoder_mode == FCoderMode_NotepadLike){
        i64 pos = view_get_cursor_pos(app, view);
        i64 mark = view_get_mark_pos(app, view);
        result = (pos != mark);
    }
    return(result);
}

static b32
if_view_has_highlighted_range_delete_range(Application_Links *app, View_ID view_id){
    b32 result = false;
    if (view_has_highlighted_range(app, view_id)){
        Range_i64 range = get_view_range(app, view_id);
        Buffer_ID buffer = view_get_buffer(app, view_id, Access_ReadWriteVisible);
        buffer_replace_range(app, buffer, range, SCu8((u8*)(""), (u64)(sizeof("") - 1)));
        result = true;
    }
    return(result);
}

static void
begin_notepad_mode(Application_Links *app){
    fcoder_mode = FCoderMode_NotepadLike;
    for (View_ID view = get_view_next(app, 0, Access_Always);
         view != 0;
         view = get_view_next(app, view, Access_Always)){
        i64 pos = view_get_cursor_pos(app, view);
        view_set_mark(app, view, seek_pos(pos));
    }
}



static void
seek_pos_of_textual_line(Application_Links *app, Side side){
    View_ID view = get_active_view(app, Access_ReadVisible);
    Buffer_ID buffer = view_get_buffer(app, view, Access_ReadVisible);
    i64 pos = view_get_cursor_pos(app, view);
    i64 new_pos = get_line_side_pos_from_pos(app, buffer, pos, side);
    view_set_cursor_and_preferred_x(app, view, seek_pos(new_pos));
    no_mark_snap_to_cursor_if_shift(app, view);
}

static void
seek_pos_of_visual_line(Application_Links *app, Side side){
    View_ID view = get_active_view(app, Access_ReadVisible);
    i64 pos = view_get_cursor_pos(app, view);
    Buffer_Cursor cursor = view_compute_cursor(app, view, seek_pos(pos));
    Vec2_f32 p = view_relative_xy_of_pos(app, view, cursor.line, pos);
    p.x = (side == Side_Min)?(0.f):(max_f32);
    i64 new_pos = view_pos_at_relative_xy(app, view, cursor.line, p);
    view_set_cursor_and_preferred_x(app, view, seek_pos(new_pos));
    no_mark_snap_to_cursor_if_shift(app, view);
}

CUSTOM_COMMAND(seek_beginning_of_textual_line, "/home/sam/.bin/4coder/custom/4coder_helper.cpp", 2224, Normal)
CUSTOM_DOC("Seeks the cursor to the beginning of the line across all text.")
{
    seek_pos_of_textual_line(app, Side_Min);
}

CUSTOM_COMMAND(seek_end_of_textual_line, "/home/sam/.bin/4coder/custom/4coder_helper.cpp", 2230, Normal)
CUSTOM_DOC("Seeks the cursor to the end of the line across all text.")
{
    seek_pos_of_textual_line(app, Side_Max);
}

CUSTOM_COMMAND(seek_beginning_of_line, "/home/sam/.bin/4coder/custom/4coder_helper.cpp", 2236, Normal)
CUSTOM_DOC("Seeks the cursor to the beginning of the visual line.")
{
    seek_pos_of_visual_line(app, Side_Min);
}

CUSTOM_COMMAND(seek_end_of_line, "/home/sam/.bin/4coder/custom/4coder_helper.cpp", 2242, Normal)
CUSTOM_DOC("Seeks the cursor to the end of the visual line.")
{
    seek_pos_of_visual_line(app, Side_Max);
}

CUSTOM_COMMAND(goto_beginning_of_file, "/home/sam/.bin/4coder/custom/4coder_helper.cpp", 2248, Normal)
CUSTOM_DOC("Sets the cursor to the beginning of the file.")
{
    View_ID view = get_active_view(app, Access_ReadVisible);
    view_set_cursor_and_preferred_x(app, view, seek_pos(0));
    no_mark_snap_to_cursor_if_shift(app, view);
}

CUSTOM_COMMAND(goto_end_of_file, "/home/sam/.bin/4coder/custom/4coder_helper.cpp", 2256, Normal)
CUSTOM_DOC("Sets the cursor to the end of the file.")
{
    View_ID view = get_active_view(app, Access_ReadVisible);
    Buffer_ID buffer_id = view_get_buffer(app, view, Access_ReadVisible);
    i32 size = (i32)buffer_get_size(app, buffer_id);
    view_set_cursor_and_preferred_x(app, view, seek_pos(size));
    no_mark_snap_to_cursor_if_shift(app, view);
}



static b32
view_set_split(Application_Links *app, View_ID view, View_Split_Kind kind, f32 t){
    b32 result = false;
    if (view != 0){
        Panel_ID panel_id = view_get_panel(app, view);
        if (panel_id != 0){
            Panel_ID parent_panel_id = panel_get_parent(app, panel_id);
            if (parent_panel_id != 0){
                Panel_ID min_child_id = panel_get_child(app, parent_panel_id, Side_Min);
                if (min_child_id != 0){
                    b32 panel_is_min = (min_child_id == panel_id);
                    Panel_Split_Kind panel_kind = ((kind == ViewSplitKind_Ratio)?
                                                   (panel_is_min?PanelSplitKind_Ratio_Min:PanelSplitKind_Ratio_Max):
                                                   (panel_is_min?PanelSplitKind_FixedPixels_Min:PanelSplitKind_FixedPixels_Max));
                    result = panel_set_split(app, parent_panel_id, panel_kind, t);
                }
            }
        }
    }
    return(result);
}

static b32
view_set_split_proportion(Application_Links *app, View_ID view, f32 t){
    return(view_set_split(app, view, ViewSplitKind_Ratio, t));
}

static b32
view_set_split_pixel_size(Application_Links *app, View_ID view, i32 t){
    return(view_set_split(app, view, ViewSplitKind_FixedPixels, (f32)t));
}



static Record_Info
get_single_record(Application_Links *app, Buffer_ID buffer_id, History_Record_Index index){
    Record_Info record = buffer_history_get_record_info(app, buffer_id, index);
    if (record.error == RecordError_NoError && record.kind == RecordKind_Group){
        record = buffer_history_get_group_sub_record(app, buffer_id, index, record.group_count - 1);
    }
    return(record);
}



static Nest_Delimiter_Kind
get_nest_delimiter_kind(Token_Base_Kind kind, Find_Nest_Flag flags){
    Nest_Delimiter_Kind result = NestDelim_None;
    switch (kind){
        case TokenBaseKind_ScopeOpen:
        {
            if ((((flags)&(FindNest_Scope))!=0)){
                result = NestDelim_Open;
            }
        }break;
        case TokenBaseKind_ScopeClose:
        {
            if ((((flags)&(FindNest_Scope))!=0)){
                result = NestDelim_Close;
            }
        }break;
        case TokenBaseKind_ParentheticalOpen:
        {
            if ((((flags)&(FindNest_Paren))!=0)){
                result = NestDelim_Open;
            }
        }break;
        case TokenBaseKind_ParentheticalClose:
        {
            if ((((flags)&(FindNest_Paren))!=0)){
                result = NestDelim_Close;
            }
        }break;
    }
    return(result);
}

static b32
find_nest_side(Application_Links *app, Buffer_ID buffer, i64 pos,
               Find_Nest_Flag flags, Scan_Direction scan, Nest_Delimiter_Kind delim,
               Range_i64 *out){
    b32 result = false;

    b32 balanced = (((flags)&(FindNest_Balanced))!=0);
    if (balanced){
        if ((delim == NestDelim_Open && scan == Scan_Forward) ||
            (delim == NestDelim_Close && scan == Scan_Backward)){
            balanced = false;
        }
    }

    Managed_Scope scope = buffer_get_managed_scope(app, buffer);
    Token_Array *tokens = ((Token_Array*)managed_scope_get_attachment((app), (scope), (attachment_tokens), sizeof(Token_Array)));
    if (tokens != 0 && tokens->count > 0){
        Token_Iterator_Array it = token_iterator_pos(0, tokens, pos);
        i32 level = 0;
        for (;;){
            Token *token = token_it_read(&it);
            Nest_Delimiter_Kind token_delim = get_nest_delimiter_kind(token->kind, flags);

            if (level == 0 && token_delim == delim){
                *out = Ii64_size(token->pos, token->size);
                result = true;
                break;
            }

            if (balanced && token_delim != NestDelim_None){
                level += (token_delim == delim)?-1:1;
            }

            b32 good = false;
            if (scan == Scan_Forward){
                good = token_it_inc(&it);
            }
            else{
                good = token_it_dec(&it);
            }
            if (!good){
                break;
            }
        }
    }

    return(result);
}

static b32
find_nest_side(Application_Links *app, Buffer_ID buffer, i64 pos,
               Find_Nest_Flag flags, Scan_Direction scan, Nest_Delimiter_Kind delim,
               i64 *out){
    Range_i64 range = {};
    b32 result = find_nest_side(app, buffer, pos, flags, scan, delim, &range);
    if (result){
        if ((((flags)&(FindNest_EndOfToken))!=0)){
            *out = range.end;
        }
        else{
            *out = range.start;
        }
    }
    return(result);
}

static b32
find_surrounding_nest(Application_Links *app, Buffer_ID buffer, i64 pos,
                      Find_Nest_Flag flags, Range_i64 *out){
    b32 result = false;
    Range_i64 range = {};
    if (find_nest_side(app, buffer, pos - 1, flags|FindNest_Balanced,
                       Scan_Backward, NestDelim_Open, &range.start) &&
        find_nest_side(app, buffer, pos, flags|FindNest_Balanced|FindNest_EndOfToken,
                       Scan_Forward, NestDelim_Close, &range.end)){
        *out = range;
        result = true;
    }
    return(result);
}

static void
select_scope(Application_Links *app, View_ID view, Range_i64 range){
    view_set_cursor_and_preferred_x(app, view, seek_pos(range.first));
    view_set_mark(app, view, seek_pos(range.end));
    view_look_at_region(app, view, range.first, range.end);
    no_mark_snap_to_cursor(app, view);
}



static Line_Ending_Kind
guess_line_ending_kind_from_buffer(Application_Links *app, Buffer_ID buffer){
    u64 size = buffer_get_size(app, buffer);
    size = (((size)<(((8) << 10)))?(size):(((8) << 10)));
    Scratch_Block scratch(app);
    String_Const_u8 string = push_buffer_range(app, scratch, buffer, Ii64(0, size));
    return(string_guess_line_ending_kind(string));
}





static Child_Process_Set_Target_Flags
flags_system_command(Command_Line_Interface_Flag flags){
    Child_Process_Set_Target_Flags set_buffer_flags = 0;
    if (!(((flags)&(CLI_OverlapWithConflict))!=0)){
        set_buffer_flags |= ChildProcessSet_FailIfBufferAlreadyAttachedToAProcess;
    }
    if ((((flags)&(CLI_CursorAtEnd))!=0)){
        set_buffer_flags |= ChildProcessSet_CursorAtEnd;
    }
    return(set_buffer_flags);
}

static b32
set_buffer_system_command(Application_Links *app, Child_Process_ID process, Buffer_ID buffer, Command_Line_Interface_Flag flags){
    b32 result = false;
    Child_Process_Set_Target_Flags set_buffer_flags = flags_system_command(flags);
    if (child_process_set_target_buffer(app, process, buffer, set_buffer_flags)){
        clear_buffer(app, buffer);
        if ((((flags)&(CLI_SendEndSignal))!=0)){
            buffer_send_end_signal(app, buffer);

            Buffer_Hook_Function *begin_buffer = (Buffer_Hook_Function*)get_custom_hook(app, HookID_BeginBuffer);
            if (begin_buffer != 0){
                begin_buffer(app, buffer);
            }
        }
        result = true;
    }
    return(result);
}

static b32
exec_system_command(Application_Links *app, View_ID view, Buffer_Identifier buffer_id,
                    String_Const_u8 path, String_Const_u8 command, Command_Line_Interface_Flag flags){
    b32 result = false;
    Child_Process_ID child_process_id = create_child_process(app, path, command);
    if (child_process_id != 0){
        result = true;
        Buffer_ID buffer_attach_id = buffer_identifier_to_id_create_out_buffer(app, buffer_id);
        if (buffer_attach_id != 0){
            if (set_buffer_system_command(app, child_process_id, buffer_attach_id, flags)){
                if (view != 0){
                    view_set_buffer(app, view, buffer_attach_id, 0);
                    view_set_cursor(app, view, seek_pos(0));
                }
            }
        }
    }
    return(result);
}





static f32
font_get_glyph_advance(Face_Advance_Map *map, Face_Metrics *metrics, u32 codepoint){
    return(font_get_glyph_advance(map, metrics, codepoint, (f32)global_config.default_tab_width));
}
static f32
font_get_max_glyph_advance_range(Face_Advance_Map *map, Face_Metrics *metrics,
                                 u32 codepoint_first, u32 codepoint_last){
    return(font_get_max_glyph_advance_range(map, metrics, codepoint_first, codepoint_last,
                                            (f32)global_config.default_tab_width));
}
static f32
font_get_average_glyph_advance_range(Face_Advance_Map *map, Face_Metrics *metrics,
                                     u32 codepoint_first, u32 codepoint_last){
    return(font_get_average_glyph_advance_range(map, metrics, codepoint_first, codepoint_last,
                                                (f32)global_config.default_tab_width));
}
# 95 "/home/sam/.bin/4coder/custom/4coder_default_include.cpp" 2
# 1 "/home/sam/.bin/4coder/custom/4coder_delta_rule.cpp" 1






static u64
delta_ctx_size(u64 base_size){
    return(base_size + sizeof(Delta_Context_Header));
}

static Delta_Context_Header*
delta_ctx_get_header(Data delta_ctx){
    return((Delta_Context_Header*)delta_ctx.data);
}

static void*
delta_ctx_get_user_data(Data delta_ctx){
    Delta_Context_Header *ctx = (Delta_Context_Header*)delta_ctx.data;
    return(ctx + 1);
}

static Buffer_Point_Delta_Result
delta_apply(Application_Links *app, View_ID view,
            Delta_Rule_Function *func, Data delta_ctx,
            f32 dt, Buffer_Point position, Buffer_Point target){
    Buffer_Point_Delta_Result result = {};
    Vec2_f32 pending = view_point_difference(app, view, target, position);
    if (!near_zero(pending, 0.5f)){
        Delta_Context_Header *ctx = delta_ctx_get_header(delta_ctx);
        b32 is_new_target = false;
        if (!block_match((&ctx->point), (&target), sizeof(*(&ctx->point)))){
            block_copy((&ctx->point), (&target), sizeof(*(&ctx->point)));
            is_new_target = true;
        }
        void *rule_data = delta_ctx_get_user_data(delta_ctx);
        Vec2_f32 partial = func(pending, is_new_target, dt, rule_data);



        Range_f32 x = If32(pending.x, 0.f);
        Range_f32 y = If32(pending.y, 0.f);
        partial.x = clamp_range(x, partial.x);
        partial.y = clamp_range(y, partial.y);

        result.point = view_move_buffer_point(app, view, position, partial);
        result.still_animating = true;
    }
    else{
        result.point = target;
    }
    return(result);
}

static Buffer_Point_Delta_Result
delta_apply(Application_Links *app, View_ID view,
            Delta_Rule_Function *func, Data delta_ctx,
            f32 dt, Buffer_Scroll scroll){
    return(delta_apply(app, view, func, delta_ctx,
                       dt, scroll.position, scroll.target));
}

static Buffer_Point_Delta_Result
delta_apply(Application_Links *app, View_ID view,
            f32 dt, Buffer_Point position, Buffer_Point target){
    View_Context ctx = view_current_context(app, view);
    Data delta_ctx = view_current_context_hook_memory(app, view, HookID_DeltaRule);
    return(delta_apply(app, view, ctx.delta_rule, delta_ctx,
                       dt, position, target));
}

static Buffer_Point_Delta_Result
delta_apply(Application_Links *app, View_ID view,
            f32 dt, Buffer_Scroll scroll){
    View_Context ctx = view_current_context(app, view);
    Data delta_ctx = view_current_context_hook_memory(app, view, HookID_DeltaRule);
    return(delta_apply(app, view, ctx.delta_rule, delta_ctx,
                       dt, scroll.position, scroll.target));
}

static Vec2_f32_Delta_Result
delta_apply(Application_Links *app, View_ID view,
            Delta_Rule_Function *func, Data delta_ctx,
            f32 dt, Vec2_f32 position, Vec2_f32 target){
    Vec2_f32_Delta_Result result = {};
    Vec2_f32 pending = target - position;
    if (!near_zero(pending, 0.5f)){
        Delta_Context_Header *ctx = delta_ctx_get_header(delta_ctx);
        b32 is_new_target = false;
        if (!near_zero(ctx->p - target, 0.1f)){
            block_copy((&ctx->p), (&target), sizeof(*(&ctx->p)));
            is_new_target = true;
        }
        void *rule_data = delta_ctx_get_user_data(delta_ctx);
        Vec2_f32 partial = func(pending, is_new_target, dt, rule_data);



        Range_f32 x = If32(pending.x, 0.f);
        Range_f32 y = If32(pending.y, 0.f);
        partial.x = clamp_range(x, partial.x);
        partial.y = clamp_range(y, partial.y);

        result.p = position + partial;
        result.still_animating = true;
    }
    else{
        result.p = target;
    }
    return(result);
}

static Vec2_f32_Delta_Result
delta_apply(Application_Links *app, View_ID view,
            Delta_Rule_Function *func, Data delta_ctx,
            f32 dt, Basic_Scroll scroll){
    return(delta_apply(app, view, func, delta_ctx,
                       dt, scroll.position, scroll.target));
}

static Vec2_f32_Delta_Result
delta_apply(Application_Links *app, View_ID view,
            f32 dt, Vec2_f32 position, Vec2_f32 target){
    View_Context ctx = view_current_context(app, view);
    Data delta_ctx = view_current_context_hook_memory(app, view, HookID_DeltaRule);
    return(delta_apply(app, view, ctx.delta_rule, delta_ctx,
                       dt, position, target));
}

static Vec2_f32_Delta_Result
delta_apply(Application_Links *app, View_ID view,
            f32 dt, Basic_Scroll scroll){
    View_Context ctx = view_current_context(app, view);
    Data delta_ctx = view_current_context_hook_memory(app, view, HookID_DeltaRule);
    return(delta_apply(app, view, ctx.delta_rule, delta_ctx,
                       dt, scroll.position, scroll.target));
}



static Smooth_Step
smooth_camera_step(f32 target, f32 v, f32 S, f32 T){
    Smooth_Step step = {};
    step.v = v;
    if (step.p != target){
        if (step.p > target - .1f && step.p < target + .1f){
            step.p = target;
            step.v = 1.f;
        }
        else{
            f32 L = step.p + T*(target - step.p);
            i32 sign = (target > step.p) - (target < step.p);
            f32 V = step.p + sign*step.v;
            if (sign > 0){
                step.p = (L<V)?(L):(V);
            }
            else{
                step.p = (L>V)?(L):(V);
            }
            if (step.p == V){
                step.v *= S;
            }
        }
    }
    return(step);
}
Vec2_f32 original_delta(Vec2_f32 pending, b32 is_new_target, f32 dt, void *data){
    Vec2_f32 *velocity = (Vec2_f32*)data;
    if (velocity->x == 0.f){
        velocity->x = 1.f;
        velocity->y = 1.f;
    }
    Smooth_Step step_x = smooth_camera_step(pending.x, velocity->x, 80.f, 1.f/2.f);
    Smooth_Step step_y = smooth_camera_step(pending.y, velocity->y, 80.f, 1.f/2.f);
    *velocity = V2f32(step_x.v, step_y.v);
    return(V2f32(step_x.p, step_y.p));
}
static const u64 original_delta_memory_size = sizeof(Vec2_f32);

Vec2_f32 snap_delta(Vec2_f32 pending, b32 is_new_target, f32 dt, void *data){
    return(pending);
}
static const u64 snap_delta_memory_size = 0;

static f32
cubic_reinterpolate(f32 t){
    f32 t2 = t*t;
    f32 t3 = t2*t;
    return(3*t2 - 2*t3);
}
Vec2_f32 fixed_time_cubic_delta(Vec2_f32 pending, b32 is_new_target, f32 dt, void *data){
    static const f32 duration_in_seconds = (1.f/8.f);
    static const f32 dt_multiplier = 1.f/duration_in_seconds;
    f32 step = dt*dt_multiplier;
    f32 *t = (f32*)data;
    *t = (((0.f)>(*t))?(0.f):(((1.f)<(*t))?(1.f):(*t)));
    f32 prev_t = *t;
    if (is_new_target){
        prev_t = 0.f;
        *t = step;
    }
    else{
        *t += step;
    }
    *t = (((0.f)>(*t))?(0.f):(((1.f)<(*t))?(1.f):(*t)));
    Vec2_f32 result = pending;
    if (*t < 1.f){
        f32 prev_x = cubic_reinterpolate(prev_t);
        f32 x = cubic_reinterpolate(*t);
        f32 portion = ((x - prev_x)/(1.f - prev_x));
        result *= portion;
    }
    return(result);
}
static const u64 fixed_time_cubic_delta_memory_size = sizeof(f32);
# 96 "/home/sam/.bin/4coder/custom/4coder_default_include.cpp" 2
# 1 "/home/sam/.bin/4coder/custom/4coder_layout_rule.cpp" 1






static Layout_Reflex
get_layout_reflex(Layout_Item_List *list, Buffer_ID buffer, f32 width, Face_ID face){
    Layout_Reflex reflex = {};
    reflex.list = list;
    reflex.buffer = buffer;
    reflex.width = width;
    reflex.face = face;
    return(reflex);
}

static Rect_f32
layout_reflex_get_rect(Application_Links *app, Layout_Reflex *reflex, i64 pos, b32 *unresolved_dependence){
    Rect_f32 rect = {};
 pos = (((0)>(pos))?(0):(pos));
    if (range_contains(reflex->list->input_index_range, pos)){
        if (range_contains(reflex->list->manifested_index_range, pos)){
            rect = layout_box_of_pos(*reflex->list, pos);
            *unresolved_dependence = false;
        }
        else{
            *unresolved_dependence = true;
        }
    }
    else{
    Buffer_Cursor cursor = buffer_compute_cursor(app, reflex->buffer, seek_pos(pos));
        rect = buffer_relative_box_of_pos(app, reflex->buffer, reflex->width, reflex->face, cursor.line, cursor.pos);
        *unresolved_dependence = false;
    }
    return(rect);
}



static i64
layout_index_from_ptr(u8 *ptr, u8 *string_base, i64 index_base){
    return((i64)(ptr - string_base) + index_base);
}

static Layout_Item_List
get_empty_item_list(Range_i64 input_range){
    Layout_Item_List list = {};
    list.input_index_range = input_range;
    list.manifested_index_range = Ii64_neg_inf;
    return(list);
}

static void
layout_item_list_finish(Layout_Item_List *list, f32 bottom_padding){
    list->bottom_padding = bottom_padding;
    list->height += bottom_padding;
}

static void
layout_write(Arena *arena, Layout_Item_List *list, Face_ID face, i64 index, u32 codepoint, Layout_Item_Flag flags, Rect_f32 rect, f32 padded_y1){
    Temp_Memory restore_point = begin_temp(arena);
    Layout_Item *item = ((Layout_Item*)linalloc_wrap_unintialized(linalloc_push((arena), sizeof(Layout_Item)*(1), SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_layout_rule.cpp" ":" "62" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_layout_rule.cpp" ":" "62" ":") - 1)))));
    Layout_Item_Block *block = list->last;
    if (block != 0){
        if (block->face != face){
            block = 0;
        }
        else if (block->items + block->item_count == item){
            block->item_count += 1;
        }
        else{
            block = 0;
        }
    }
    if (block == 0){
        end_temp(restore_point);
        block = ((Layout_Item_Block*)linalloc_wrap_unintialized(linalloc_push((arena), sizeof(Layout_Item_Block)*(1), SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_layout_rule.cpp" ":" "77" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_layout_rule.cpp" ":" "77" ":") - 1)))));
        item = ((Layout_Item*)linalloc_wrap_unintialized(linalloc_push((arena), sizeof(Layout_Item)*(1), SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_layout_rule.cpp" ":" "78" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_layout_rule.cpp" ":" "78" ":") - 1)))));
        do{ if((block)){if((list->first)){(list->last)->next=(block);}else{(list->first)=(block);}(list->last)=(block);(list->last)->next=0;} }while(0);
        list->node_count += 1;
        block->items = item;
        block->item_count = 1;
        block->face = face;
    }

    list->item_count += 1;
    list->manifested_index_range.min = (((list->manifested_index_range.min)<(index))?(list->manifested_index_range.min):(index));
    list->manifested_index_range.max = (((list->manifested_index_range.max)>(index))?(list->manifested_index_range.max):(index));

    if (!(((flags)&(LayoutItemFlag_Ghost_Character))!=0)){
        block->character_count += 1;
        list->character_count += 1;
    }

    item->index = index;
    item->codepoint = codepoint;
    item->flags = flags;
    item->rect = rect;
    item->padded_y1 = padded_y1;
    list->height = (((list->height)>(rect.y1))?(list->height):(rect.y1));
}



static Newline_Layout_Vars
get_newline_layout_vars(void){
    Newline_Layout_Vars result = {};
    result.newline_character_index = -1;
    return(result);
}

static void
newline_layout_consume_CR(Newline_Layout_Vars *vars, i64 index){
    if (!vars->consuming_newline_characters){
        vars->consuming_newline_characters = true;
        vars->newline_character_index = index;
    }
    vars->prev_did_emit_newline = false;
}

static i64
newline_layout_consume_LF(Newline_Layout_Vars *vars, i64 index){
    if (!vars->consuming_newline_characters){
        vars->newline_character_index = index;
    }
    vars->prev_did_emit_newline = true;
    vars->consuming_newline_characters = false;
    return(vars->newline_character_index);
}

static void
newline_layout_consume_default(Newline_Layout_Vars *vars){
    vars->consuming_newline_characters = false;
    vars->prev_did_emit_newline = false;
}

static b32
newline_layout_consume_finish(Newline_Layout_Vars *vars){
    return((!vars->prev_did_emit_newline));
}



static LefRig_TopBot_Layout_Vars
get_lr_tb_layout_vars(Face_Advance_Map *advance_map, Face_Metrics *metrics, f32 width){
    f32 text_height = metrics->text_height;
    f32 line_height = metrics->line_height;

    LefRig_TopBot_Layout_Vars result = {};
    result.advance_map = advance_map;
    result.metrics = metrics;
    result.line_to_text_shift = text_height - line_height;

    result.blank_dim = V2f32(metrics->space_advance, text_height);

    result.line_y = line_height;
    result.text_y = text_height;
    result.width = width;
    return(result);
}

static b32
lr_tb_crosses_width(LefRig_TopBot_Layout_Vars *vars, f32 advance, f32 width){
    return(vars->p.x + advance > width);
}

static b32
lr_tb_crosses_width(LefRig_TopBot_Layout_Vars *vars, f32 advance){
    return(vars->p.x + advance > vars->width);
}

static f32
lr_tb_advance(LefRig_TopBot_Layout_Vars *vars, Face_ID face, u32 codepoint){
    return(font_get_glyph_advance(vars->advance_map, vars->metrics, codepoint));
}

static void
lr_tb_write_with_advance_with_flags(LefRig_TopBot_Layout_Vars *vars, Face_ID face, f32 advance, Arena *arena, Layout_Item_List *list, i64 index, u32 codepoint, Layout_Item_Flag flags){
    if (codepoint == '\t'){
        codepoint = ' ';
    }
    vars->p.x = f32_ceil32(vars->p.x);
    f32 next_x = vars->p.x + advance;
    layout_write(arena, list, face, index, codepoint, flags, Rf32(vars->p, V2f32(next_x, vars->text_y)), vars->line_y);
    vars->p.x = next_x;
}

static void
lr_tb_write_with_advance(LefRig_TopBot_Layout_Vars *vars, Face_ID face, f32 advance, Arena *arena, Layout_Item_List *list, i64 index, u32 codepoint){
    lr_tb_write_with_advance_with_flags(vars, face, advance, arena, list, index, codepoint, 0);
}

static void
lr_tb_write(LefRig_TopBot_Layout_Vars *vars, Face_ID face, Arena *arena, Layout_Item_List *list, i64 index, u32 codepoint){
    f32 advance = lr_tb_advance(vars, face, codepoint);
    lr_tb_write_with_advance(vars, face, advance, arena, list, index, codepoint);
}

static void
lr_tb_write_ghost(LefRig_TopBot_Layout_Vars *vars, Face_ID face, Arena *arena, Layout_Item_List *list, i64 index, u32 codepoint){
    f32 advance = lr_tb_advance(vars, face, codepoint);
    lr_tb_write_with_advance_with_flags(vars, face, advance, arena, list, index, codepoint, LayoutItemFlag_Ghost_Character);
}

static f32
lr_tb_advance_byte(LefRig_TopBot_Layout_Vars *vars){
    return(vars->metrics->byte_advance);
}

static void
lr_tb_write_byte_with_advance(LefRig_TopBot_Layout_Vars *vars, Face_ID face, f32 advance, Arena *arena, Layout_Item_List *list, i64 index, u8 byte){
    Face_Metrics *metrics = vars->metrics;

    f32 final_next_x = vars->p.x + advance;
    u32 lo = ((u32)byte )&0xF;
    u32 hi = ((u32)byte >> 4)&0xF;

    Vec2_f32 p = vars->p;
    p.x = f32_ceil32(p.x);
    f32 next_x = p.x + metrics->byte_sub_advances[0];
    f32 text_y = vars->text_y;

    Layout_Item_Flag flags = LayoutItemFlag_Special_Character;
    layout_write(arena, list, face, index, '\\', flags, Rf32(p, V2f32(next_x, text_y)), vars->line_y);
    p.x = next_x;

    flags = LayoutItemFlag_Ghost_Character;
    next_x += metrics->byte_sub_advances[1];
    layout_write(arena, list, face, index, integer_symbols[hi], flags, Rf32(p, V2f32(next_x, text_y)), vars->line_y);
    p.x = next_x;
    next_x += metrics->byte_sub_advances[2];
    layout_write(arena, list, face, index, integer_symbols[lo], flags, Rf32(p, V2f32(next_x, text_y)), vars->line_y);

    vars->p.x = final_next_x;
}

static void
lr_tb_write_byte(LefRig_TopBot_Layout_Vars *vars, Face_ID face,
                 Arena *arena, Layout_Item_List *list, i64 index, u8 byte){
    lr_tb_write_byte_with_advance(vars, face, vars->metrics->byte_advance,
                                  arena, list, index, byte);
}

static void
lr_tb_write_blank_dim(LefRig_TopBot_Layout_Vars *vars, Face_ID face, Vec2_f32 dim,
                      Arena *arena, Layout_Item_List *list, i64 index){
    layout_write(arena, list, face, index, ' ', 0, Rf32_xy_wh(vars->p, dim), vars->line_y);
    vars->p.x += dim.x;
}

static void
lr_tb_write_blank(LefRig_TopBot_Layout_Vars *vars, Face_ID face,
                  Arena *arena, Layout_Item_List *list, i64 index){
    lr_tb_write_blank_dim(vars, face, vars->blank_dim, arena, list, index);
}

static void
lr_tb_next_line(LefRig_TopBot_Layout_Vars *vars){
    vars->p.x = 0.f;
    vars->p.y = vars->line_y;
    vars->line_y += vars->metrics->line_height;
    vars->text_y = vars->line_y + vars->line_to_text_shift;
}

static void
lr_tb_next_line_padded(LefRig_TopBot_Layout_Vars *vars, f32 top, f32 bot){
    vars->p.x = 0.f;
    vars->p.y = vars->line_y + top;
    vars->line_y += top + vars->metrics->line_height;
    vars->text_y = vars->line_y + vars->line_to_text_shift;
    vars->line_y += bot;
}

static void
lr_tb_advance_x_without_item(LefRig_TopBot_Layout_Vars *vars, f32 advance){
    vars->p.x += advance;
}

static void
lr_tb_align_rightward(LefRig_TopBot_Layout_Vars *vars, f32 align_x){
    vars->p.x = (((align_x)>(vars->p.x))?(align_x):(vars->p.x));
}



static Layout_Item_List
layout_unwrapped_small_blank_lines(Application_Links *app, Arena *arena, Buffer_ID buffer, Range_i64 range, Face_ID face, f32 width){
    Layout_Item_List list = get_empty_item_list(range);

    Scratch_Block scratch(app);
    String_Const_u8 text = push_buffer_range(app, scratch, buffer, range);

    Face_Advance_Map advance_map = get_face_advance_map(app, face);
    Face_Metrics metrics = get_face_metrics(app, face);
    LefRig_TopBot_Layout_Vars pos_vars = get_lr_tb_layout_vars(&advance_map, &metrics, width);

    pos_vars.blank_dim = V2f32(metrics.space_advance, metrics.text_height*0.5f);

    if (text.size == 0){
        lr_tb_write_blank(&pos_vars, face, arena, &list, range.start);
    }
    else{
        Newline_Layout_Vars newline_vars = get_newline_layout_vars();

        b32 all_whitespace = true;
        for (u64 i = 0; i < text.size; i += 1){
            if (!character_is_whitespace(text.str[i])){
                all_whitespace = false;
                break;
            }
        }

        if (!all_whitespace){
            pos_vars.blank_dim.y = metrics.text_height;
        }

        u8 *ptr = text.str;
        u8 *end_ptr = ptr + text.size;
        for (;ptr < end_ptr;){
            Character_Consume_Result consume = utf8_consume(ptr, (u64)(end_ptr - ptr));

            i64 index = layout_index_from_ptr(ptr, text.str, range.first);
            switch (consume.codepoint){
                case '\t':
                {
                    newline_layout_consume_default(&newline_vars);
                    Vec2_f32 dim = pos_vars.blank_dim;
                    dim.x = lr_tb_advance(&pos_vars, face, '\t');
                    lr_tb_write_blank_dim(&pos_vars, face, dim, arena, &list, index);
                }break;

                case ' ':
                case '\f':
                case '\v':
                {
                    newline_layout_consume_default(&newline_vars);
                    lr_tb_write_blank(&pos_vars, face, arena, &list, index);
                }break;

                default:
                {
                    newline_layout_consume_default(&newline_vars);
                    lr_tb_write(&pos_vars, face, arena, &list, index, consume.codepoint);
                }break;

                case '\r':
                {
                    newline_layout_consume_CR(&newline_vars, index);
                }break;

                case '\n':
                {
                    i64 newline_index = newline_layout_consume_LF(&newline_vars, index);
                    lr_tb_write_blank(&pos_vars, face, arena, &list, newline_index);
                    lr_tb_next_line(&pos_vars);
                }break;

                case max_u32:
                {
                    newline_layout_consume_default(&newline_vars);
                    lr_tb_write_byte(&pos_vars, face, arena, &list, index, *ptr);
                }break;
            }

            ptr += consume.inc;
        }

        if (newline_layout_consume_finish(&newline_vars)){
            i64 index = layout_index_from_ptr(ptr, text.str, range.first);
            lr_tb_write_blank(&pos_vars, face, arena, &list, index);
        }
    }

    layout_item_list_finish(&list, -pos_vars.line_to_text_shift);

    return(list);
}

static Layout_Item_List
layout_wrap_anywhere(Application_Links *app, Arena *arena, Buffer_ID buffer, Range_i64 range, Face_ID face, f32 width){
    Scratch_Block scratch(app);

    Layout_Item_List list = get_empty_item_list(range);

    String_Const_u8 text = push_buffer_range(app, scratch, buffer, range);

    Face_Advance_Map advance_map = get_face_advance_map(app, face);
    Face_Metrics metrics = get_face_metrics(app, face);
    LefRig_TopBot_Layout_Vars pos_vars = get_lr_tb_layout_vars(&advance_map, &metrics, width);

    if (text.size == 0){
        lr_tb_write_blank(&pos_vars, face, arena, &list, range.first);
    }
    else{
        b32 first_of_the_line = true;
        Newline_Layout_Vars newline_vars = get_newline_layout_vars();

        u8 *ptr = text.str;
        u8 *end_ptr = ptr + text.size;
        for (;ptr < end_ptr;){
            Character_Consume_Result consume = utf8_consume(ptr, (u64)(end_ptr - ptr));
            i64 index = layout_index_from_ptr(ptr, text.str, range.first);
            switch (consume.codepoint){
                default:
                {
                    newline_layout_consume_default(&newline_vars);
                    f32 advance = lr_tb_advance(&pos_vars, face, consume.codepoint);
                    if (!first_of_the_line && lr_tb_crosses_width(&pos_vars, advance)){
                        lr_tb_next_line(&pos_vars);
                    }
                    lr_tb_write_with_advance(&pos_vars, face, advance, arena, &list, index, consume.codepoint);
                    first_of_the_line = false;
                }break;

                case '\r':
                {
                    newline_layout_consume_CR(&newline_vars, index);
                }break;

                case '\n':
                {
                    i64 newline_index = newline_layout_consume_LF(&newline_vars, index);
                    lr_tb_write_blank(&pos_vars, face, arena, &list, newline_index);
                    lr_tb_next_line(&pos_vars);
                    first_of_the_line = true;
                }break;

                case max_u32:
                {
                    newline_layout_consume_default(&newline_vars);
                    f32 advance = lr_tb_advance_byte(&pos_vars);
                    if (!first_of_the_line && lr_tb_crosses_width(&pos_vars, advance)){
                        lr_tb_next_line(&pos_vars);
                    }
                    lr_tb_write_byte_with_advance(&pos_vars, face, advance, arena, &list, index, *ptr);
                    first_of_the_line = false;
                }break;
            }
            ptr += consume.inc;
        }

        if (newline_layout_consume_finish(&newline_vars)){
            i64 index = layout_index_from_ptr(ptr, text.str, range.first);
            lr_tb_write_blank(&pos_vars, face, arena, &list, index);
        }
    }

    layout_item_list_finish(&list, -pos_vars.line_to_text_shift);

    return(list);
}

static Layout_Item_List
layout_unwrapped__inner(Application_Links *app, Arena *arena, Buffer_ID buffer, Range_i64 range, Face_ID face, f32 width, Layout_Virtual_Indent virt_indent){
    Layout_Item_List list = get_empty_item_list(range);

    Scratch_Block scratch(app);
    String_Const_u8 text = push_buffer_range(app, scratch, buffer, range);

    Face_Advance_Map advance_map = get_face_advance_map(app, face);
    Face_Metrics metrics = get_face_metrics(app, face);
    LefRig_TopBot_Layout_Vars pos_vars = get_lr_tb_layout_vars(&advance_map, &metrics, width);

    if (text.size == 0){
        lr_tb_write_blank(&pos_vars, face, arena, &list, range.first);
    }
    else{
        b32 skipping_leading_whitespace = (virt_indent == LayoutVirtualIndent_On);
        Newline_Layout_Vars newline_vars = get_newline_layout_vars();

        u8 *ptr = text.str;
        u8 *end_ptr = ptr + text.size;
        for (;ptr < end_ptr;){
            Character_Consume_Result consume = utf8_consume(ptr, (u64)(end_ptr - ptr));

            i64 index = layout_index_from_ptr(ptr, text.str, range.first);
            switch (consume.codepoint){
                case '\t':
                case ' ':
                {
                    newline_layout_consume_default(&newline_vars);
                    f32 advance = lr_tb_advance(&pos_vars, face, consume.codepoint);
                    if (!skipping_leading_whitespace){
                        lr_tb_write_with_advance(&pos_vars, face, advance, arena, &list, index, consume.codepoint);
                    }
                    else{
                        lr_tb_advance_x_without_item(&pos_vars, advance);
                    }
                }break;

                default:
                {
                    newline_layout_consume_default(&newline_vars);
                    lr_tb_write(&pos_vars, face, arena, &list, index, consume.codepoint);
                }break;

                case '\r':
                {
                    newline_layout_consume_CR(&newline_vars, index);
                }break;

                case '\n':
                {
                    i64 newline_index = newline_layout_consume_LF(&newline_vars, index);
                    lr_tb_write_blank(&pos_vars, face, arena, &list, newline_index);
                    lr_tb_next_line(&pos_vars);
                }break;

                case max_u32:
                {
                    newline_layout_consume_default(&newline_vars);
                    lr_tb_write_byte(&pos_vars, face, arena, &list, index, *ptr);
                }break;
            }

            ptr += consume.inc;
        }

        if (newline_layout_consume_finish(&newline_vars)){
            i64 index = layout_index_from_ptr(ptr, text.str, range.first);
            lr_tb_write_blank(&pos_vars, face, arena, &list, index);
        }
    }

    layout_item_list_finish(&list, -pos_vars.line_to_text_shift);

    return(list);
}

static Layout_Item_List
layout_wrap_whitespace__inner(Application_Links *app, Arena *arena, Buffer_ID buffer, Range_i64 range, Face_ID face, f32 width, Layout_Virtual_Indent virt_indent){
    Scratch_Block scratch(app);

    Layout_Item_List list = get_empty_item_list(range);

    String_Const_u8 text = push_buffer_range(app, scratch, buffer, range);

    Face_Advance_Map advance_map = get_face_advance_map(app, face);
    Face_Metrics metrics = get_face_metrics(app, face);
    LefRig_TopBot_Layout_Vars pos_vars = get_lr_tb_layout_vars(&advance_map, &metrics, width);

    if (text.size == 0){
        lr_tb_write_blank(&pos_vars, face, arena, &list, range.first);
    }
    else{
        b32 skipping_leading_whitespace = false;
        b32 first_of_the_line = true;
        Newline_Layout_Vars newline_vars = get_newline_layout_vars();

        u8 *ptr = text.str;
        u8 *end_ptr = ptr + text.size;
        u8 *word_ptr = ptr;

        if (character_is_whitespace(*ptr)){
             skipping_leading_whitespace = (virt_indent == LayoutVirtualIndent_On);
            goto consuming_whitespace;
        }

        consuming_non_whitespace:
        for (;ptr <= end_ptr; ptr += 1){
            if (ptr == end_ptr || character_is_whitespace(*ptr)){
                break;
            }
        }

        {
            newline_layout_consume_default(&newline_vars);

            String_Const_u8 word = SCu8(word_ptr, ptr);
            u8 *word_end = ptr;

            if (!first_of_the_line){
                f32 total_advance = 0.f;
                ptr = word.str;
                for (;ptr < word_end;){
                    Character_Consume_Result consume =
                        utf8_consume(ptr, (u64)(word_end - ptr));
                    if (consume.codepoint != max_u32){
                        total_advance += lr_tb_advance(&pos_vars, face, consume.codepoint);
                    }
                    else{
                        total_advance += lr_tb_advance_byte(&pos_vars);
                    }
                    ptr += consume.inc;
                }

                if (lr_tb_crosses_width(&pos_vars, total_advance)){
                    lr_tb_next_line(&pos_vars);
                }
            }

            ptr = word.str;

            for (;ptr < word_end;){
                Character_Consume_Result consume =
                    utf8_consume(ptr, (u64)(word_end - ptr));
                i64 index = layout_index_from_ptr(ptr, text.str, range.first);

                if (consume.codepoint != max_u32){
                    lr_tb_write(&pos_vars, face, arena, &list, index, consume.codepoint);
                }
                else{
                    lr_tb_write_byte(&pos_vars, face, arena, &list, index, *ptr);
                }

                ptr += consume.inc;
            }

            first_of_the_line = false;
        }

        consuming_whitespace:
        for (; ptr < end_ptr; ptr += 1){
            if (!character_is_whitespace(*ptr)){
                word_ptr = ptr;
                goto consuming_non_whitespace;
            }

            i64 index = layout_index_from_ptr(ptr, text.str, range.first);
            switch (*ptr){
                case '\t':
                case ' ':
                {
                    newline_layout_consume_default(&newline_vars);
                    f32 advance = lr_tb_advance(&pos_vars, face, *ptr);
                    if (!skipping_leading_whitespace){
                        if (!first_of_the_line && lr_tb_crosses_width(&pos_vars, advance)){
                            lr_tb_next_line(&pos_vars);
                        }
                        lr_tb_write_with_advance(&pos_vars, face, advance, arena, &list, index, *ptr);
                        first_of_the_line = false;
                    }
                    else{
                        lr_tb_advance_x_without_item(&pos_vars, advance);
                    }
                }break;

                default:
                {
                    newline_layout_consume_default(&newline_vars);
                    f32 advance = lr_tb_advance(&pos_vars, face, *ptr);
                    if (!first_of_the_line && lr_tb_crosses_width(&pos_vars, advance)){
                        lr_tb_next_line(&pos_vars);
                    }
                    lr_tb_write_with_advance(&pos_vars, face, advance, arena, &list, index, *ptr);
                    first_of_the_line = false;
                }break;

                case '\r':
                {
                    newline_layout_consume_CR(&newline_vars, index);
                }break;

                case '\n':
                {
                    u64 newline_index = newline_layout_consume_LF(&newline_vars, index);
                    lr_tb_write_blank(&pos_vars, face, arena, &list, newline_index);
                    lr_tb_next_line(&pos_vars);
                    first_of_the_line = true;
                }break;
            }
        }

        if (newline_layout_consume_finish(&newline_vars)){
            i64 index = layout_index_from_ptr(ptr, text.str, range.first);
            lr_tb_write_blank(&pos_vars, face, arena, &list, index);
        }
    }

    layout_item_list_finish(&list, -pos_vars.line_to_text_shift);

    return(list);
}

static Layout_Item_List
layout_unwrapped(Application_Links *app, Arena *arena, Buffer_ID buffer, Range_i64 range, Face_ID face, f32 width){
    return(layout_unwrapped__inner(app, arena, buffer, range, face, width, LayoutVirtualIndent_Off));
}

static Layout_Item_List
layout_wrap_whitespace(Application_Links *app, Arena *arena, Buffer_ID buffer, Range_i64 range, Face_ID face, f32 width){
    return(layout_wrap_whitespace__inner(app, arena, buffer, range, face, width, LayoutVirtualIndent_Off));
}

static Layout_Item_List
layout_basic(Application_Links *app, Arena *arena, Buffer_ID buffer, Range_i64 range, Face_ID face, f32 width, Layout_Wrap_Kind kind){
    Layout_Item_List result = {};
    switch (kind){
        case Layout_Unwrapped:
        {
            result = layout_unwrapped(app, arena, buffer, range, face, width);
        }break;
        case Layout_Wrapped:
        {
            result = layout_wrap_whitespace(app, arena, buffer, range, face, width);
        }break;
    }
    return(result);
}

static Layout_Item_List
layout_generic(Application_Links *app, Arena *arena, Buffer_ID buffer, Range_i64 range, Face_ID face, f32 width){
    Managed_Scope scope = buffer_get_managed_scope(app, buffer);
    b32 *wrap_lines_ptr = ((b32*)managed_scope_get_attachment((app), (scope), (buffer_wrap_lines), sizeof(b32)));
    b32 wrap_lines = (wrap_lines_ptr != 0 && *wrap_lines_ptr);
    return(layout_basic(app, arena, buffer, range, face, width, wrap_lines?Layout_Wrapped:Layout_Unwrapped));
}

static Layout_Item_List
layout_virt_indent_literal_unwrapped(Application_Links *app, Arena *arena, Buffer_ID buffer, Range_i64 range, Face_ID face, f32 width){
    return(layout_unwrapped__inner(app, arena, buffer, range, face, width, LayoutVirtualIndent_On));
}

static Layout_Item_List
layout_virt_indent_literal_wrapped(Application_Links *app, Arena *arena, Buffer_ID buffer, Range_i64 range, Face_ID face, f32 width){
    return(layout_wrap_whitespace__inner(app, arena, buffer, range, face, width, LayoutVirtualIndent_On));
}

static Layout_Item_List
layout_virt_indent_literal(Application_Links *app, Arena *arena, Buffer_ID buffer, Range_i64 range, Face_ID face, f32 width, Layout_Wrap_Kind kind){
    Layout_Item_List result = {};
    switch (kind){
        case Layout_Unwrapped:
        {
            result = layout_virt_indent_literal_unwrapped(app, arena, buffer, range, face, width);
        }break;
        case Layout_Wrapped:
        {
            result = layout_virt_indent_literal_wrapped(app, arena, buffer, range, face, width);
        }break;
    }
    return(result);
}

static Layout_Item_List
layout_virt_indent_literal_generic(Application_Links *app, Arena *arena, Buffer_ID buffer, Range_i64 range, Face_ID face, f32 width){
    Managed_Scope scope = buffer_get_managed_scope(app, buffer);
    b32 *wrap_lines_ptr = ((b32*)managed_scope_get_attachment((app), (scope), (buffer_wrap_lines), sizeof(b32)));
    b32 wrap_lines = (wrap_lines_ptr != 0 && *wrap_lines_ptr);
    return(layout_virt_indent_literal(app, arena, buffer, range, face, width, wrap_lines?Layout_Wrapped:Layout_Unwrapped));
}
# 97 "/home/sam/.bin/4coder/custom/4coder_default_include.cpp" 2
# 1 "/home/sam/.bin/4coder/custom/4coder_code_index.cpp" 1






static Code_Index global_code_index = {};

static void
code_index_init(void){
    global_code_index.mutex = system_mutex_make();
    global_code_index.node_arena = make_arena_system(((4) << 10));
    global_code_index.buffer_to_index_file = make_table_u64_u64__inner((global_code_index.node_arena.base_allocator),(500),SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_code_index.cpp" ":" "13" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_code_index.cpp" ":" "13" ":") - 1)));
}

static Code_Index_File_Storage*
code_index__alloc_storage(void){
    Code_Index_File_Storage *result = global_code_index.free_storage;
    if (result == 0){
        result = ((Code_Index_File_Storage*)linalloc_wrap_zero(linalloc_push((&global_code_index.node_arena), sizeof(Code_Index_File_Storage)*(1), SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_code_index.cpp" ":" "20" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_code_index.cpp" ":" "20" ":") - 1)))));
    }
    else{
        ((global_code_index.free_storage)=(global_code_index.free_storage)=(global_code_index.free_storage)->next);
    }
    (((global_code_index.storage_first)==0)?((result)->next=(result)->prev=0,(global_code_index.storage_first)=(global_code_index.storage_last)=(result)):((result)->prev=(global_code_index.storage_last),(result)->next=0,(global_code_index.storage_last)->next=(result),(global_code_index.storage_last)=(result)));
    global_code_index.storage_count += 1;
    return(result);
}

static void
code_index__free_storage(Code_Index_File_Storage *storage){
    (((global_code_index.storage_last)==(storage))?((((global_code_index.storage_first)==(global_code_index.storage_last))?((global_code_index.storage_first)=(global_code_index.storage_last)=0):((global_code_index.storage_last)->prev->next=0,(global_code_index.storage_last)=(global_code_index.storage_last)->prev))) :((global_code_index.storage_first)==(storage))?((((global_code_index.storage_last)==(global_code_index.storage_first))?((global_code_index.storage_last)=(global_code_index.storage_first)=0):((global_code_index.storage_first)->next->prev=0,(global_code_index.storage_first)=(global_code_index.storage_first)->next))) : ((storage)->next->prev=(storage)->prev,(storage)->prev->next=(storage)->next,(storage)->next=(storage)->prev=0));
    global_code_index.storage_count -= 1;
    ((storage)->next=(global_code_index.free_storage),(global_code_index.free_storage)=(storage));
}

static void
code_index_push_nest(Code_Index_Nest_List *list, Code_Index_Nest *nest){
    do{ if((nest)){if((list->first)){(list->last)->next=(nest);}else{(list->first)=(nest);}(list->last)=(nest);(list->last)->next=0;} }while(0);
    list->count += 1;
}

static Code_Index_Nest_Ptr_Array
code_index_nest_ptr_array_from_list(Arena *arena, Code_Index_Nest_List *list){
    Code_Index_Nest_Ptr_Array array = {};
    array.ptrs = ((Code_Index_Nest**)linalloc_wrap_zero(linalloc_push((arena), sizeof(Code_Index_Nest*)*(list->count), SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_code_index.cpp" ":" "46" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_code_index.cpp" ":" "46" ":") - 1)))));
    array.count = list->count;
    i32 counter = 0;
    for (Code_Index_Nest *node = list->first;
         node != 0;
         node = node->next){
        array.ptrs[counter] = node;
        counter += 1;
    }
    return(array);
}

static Code_Index_Note_Ptr_Array
code_index_note_ptr_array_from_list(Arena *arena, Code_Index_Note_List *list){
    Code_Index_Note_Ptr_Array array = {};
    array.ptrs = ((Code_Index_Note**)linalloc_wrap_zero(linalloc_push((arena), sizeof(Code_Index_Note*)*(list->count), SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_code_index.cpp" ":" "61" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_code_index.cpp" ":" "61" ":") - 1)))));
    array.count = list->count;
    i32 counter = 0;
    for (Code_Index_Note *node = list->first;
         node != 0;
         node = node->next){
        array.ptrs[counter] = node;
        counter += 1;
    }
    return(array);
}

static void
code_index_lock(void){
    system_mutex_acquire(global_code_index.mutex);
}

static void
code_index_unlock(void){
    system_mutex_release(global_code_index.mutex);
}

static void
code_index_set_file(Buffer_ID buffer, Arena arena, Code_Index_File *index){
    Code_Index_File_Storage *storage = 0;
    Table_Lookup lookup = table_lookup(&global_code_index.buffer_to_index_file, buffer);
    if (lookup.found_match){
        u64 val = 0;
        table_read(&global_code_index.buffer_to_index_file, lookup, &val);
        storage = (Code_Index_File_Storage*)(void*)(((u8*)0) + val);
        linalloc_clear(&storage->arena);
    }
    else{
        storage = code_index__alloc_storage();
        table_insert(&global_code_index.buffer_to_index_file, buffer, (u64)((u8*)(storage) - (u8*)(0)));
    }
    storage->arena = arena;
    storage->file = index;
}

static void
code_index_erase_file(Buffer_ID buffer){
    Table_Lookup lookup = table_lookup(&global_code_index.buffer_to_index_file, buffer);
    if (lookup.found_match){
        u64 val = 0;
        table_read(&global_code_index.buffer_to_index_file, lookup, &val);
        Code_Index_File_Storage *storage = (Code_Index_File_Storage*)(void*)(((u8*)0) + val);
        linalloc_clear(&storage->arena);
        table_erase(&global_code_index.buffer_to_index_file, lookup);
        code_index__free_storage(storage);
    }
}

static Code_Index_File*
code_index_get_file(Buffer_ID buffer){
    Code_Index_File *result = 0;
    Table_Lookup lookup = table_lookup(&global_code_index.buffer_to_index_file, buffer);
    if (lookup.found_match){
        u64 val = 0;
        table_read(&global_code_index.buffer_to_index_file, lookup, &val);
        Code_Index_File_Storage *storage = (Code_Index_File_Storage*)(void*)(((u8*)0) + val);
        result = storage->file;
    }
    return(result);
}

static Code_Index_Nest*
code_index_get_nest(Code_Index_Nest_Ptr_Array *array, i64 pos){
    Code_Index_Nest *result = 0;
    i32 count = array->count;
    Code_Index_Nest **nest_ptrs = array->ptrs;
    for (i32 i = 0; i < count; i += 1){
        Code_Index_Nest *nest = nest_ptrs[i];
        if (nest->open.max <= pos && pos <= nest->close.min){
            Code_Index_Nest *sub_nest =
                code_index_get_nest(&nest->nest_array, pos);
            if (sub_nest != 0){
                result = sub_nest;
            }
            else{
                result = nest;
            }
            break;
        }
    }
    return(result);
}

static Code_Index_Nest*
code_index_get_nest(Code_Index_Nest *nest, i64 pos){
    return(code_index_get_nest(&nest->nest_array, pos));
}

static Code_Index_Nest*
code_index_get_nest(Code_Index_File *file, i64 pos){
    return(code_index_get_nest(&file->nest_array, pos));
}

static void
index_shift(i64 *ptr, Range_i64 old_range, u64 new_size){
    i64 i = *ptr;
    if (old_range.min <= i && i < old_range.max){
        *ptr = old_range.first;
    }
    else if (old_range.max <= i){
        *ptr = i + new_size - (old_range.max - old_range.min);
    }
}

static void
code_index_shift(Code_Index_Nest_Ptr_Array *array,
                 Range_i64 old_range, u64 new_size){
    i32 count = array->count;
    Code_Index_Nest **nest_ptr = array->ptrs;
    for (i32 i = 0; i < count; i += 1, nest_ptr += 1){
        Code_Index_Nest *nest = *nest_ptr;
        index_shift(&nest->open.min, old_range, new_size);
        index_shift(&nest->open.max, old_range, new_size);
        if (nest->is_closed){
            index_shift(&nest->close.min, old_range, new_size);
            index_shift(&nest->close.max, old_range, new_size);
        }
        code_index_shift(&nest->nest_array, old_range, new_size);
    }
}

static void
code_index_shift(Code_Index_File *file, Range_i64 old_range, u64 new_size){
    code_index_shift(&file->nest_array, old_range, new_size);
}



static void
generic_parse_inc(Generic_Parse_State *state){
    if (!token_it_inc_all(&state->it)){
        state->finished = true;
    }
}

static void
generic_parse_skip_soft_tokens(Code_Index_File *index, Generic_Parse_State *state){
    Token *token = token_it_read(&state->it);
    for (;token != 0 && !state->finished;){
        if (state->in_preprocessor && !(((token->flags)&(TokenBaseFlag_PreprocessorBody))!=0)){
            break;
        }
        if (token->kind == TokenBaseKind_Comment){
            state->handle_comment(state->app, state->arena, index, token, state->contents);
        }
        else if (token->kind == TokenBaseKind_Whitespace){
            Range_i64 range = Ii64(token);
            u8 *ptr = state->contents.str + range.one_past_last - 1;
            for (i64 i = range.one_past_last - 1;
                 i >= range.first;
                 i -= 1, ptr -= 1){
                if (*ptr == '\n'){
                    state->prev_line_start = ptr + 1;
                    break;
                }
            }
        }
        else{
            break;
        }
        generic_parse_inc(state);
        token = token_it_read(&state->it);
    }
}

static void
generic_parse_init(Application_Links *app, Arena *arena, String_Const_u8 contents, Token_Array *tokens, Generic_Parse_Comment_Function *handle_comment, Generic_Parse_State *state){
    state->app = app;
    state->arena = arena;
    state->contents = contents;
    state->it = token_iterator(0, tokens);
    state->handle_comment = handle_comment;
    state->prev_line_start = contents.str;
}
# 276 "/home/sam/.bin/4coder/custom/4coder_code_index.cpp"
static Code_Index_Note*
index_new_note(Code_Index_File *index, Generic_Parse_State *state, Range_i64 range, Code_Index_Note_Kind kind, Code_Index_Nest *parent){
    Code_Index_Note *result = ((Code_Index_Note*)linalloc_wrap_unintialized(linalloc_push((state->arena), sizeof(Code_Index_Note)*(1), SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_code_index.cpp" ":" "278" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_code_index.cpp" ":" "278" ":") - 1)))));
    do{ if((result)){if((index->note_list.first)){(index->note_list.last)->next=(result);}else{(index->note_list.first)=(result);}(index->note_list.last)=(result);(index->note_list.last)->next=0;} }while(0);
    index->note_list.count += 1;
    result->note_kind = kind;
    result->pos = range;
    result->text = push_string_copy(state->arena, string_substring(state->contents, range));
    result->file = index;
    result->parent = parent;
    return(result);
}

static void
cpp_parse_type_structure(Code_Index_File *index, Generic_Parse_State *state, Code_Index_Nest *parent){
    generic_parse_inc(state);
    generic_parse_skip_soft_tokens(index, state);
    if (state->finished){
        return;
    }
    Token *token = token_it_read(&state->it);
    if (token != 0 && token->kind == TokenBaseKind_Identifier){
        generic_parse_inc(state);
        generic_parse_skip_soft_tokens(index, state);
        Token *peek = token_it_read(&state->it);
        if (peek != 0 && peek->kind == TokenBaseKind_StatementClose ||
            peek->kind == TokenBaseKind_ScopeOpen){
            index_new_note(index, state, Ii64(token), CodeIndexNote_Type, parent);
        }
    }
}

static void
cpp_parse_type_def(Code_Index_File *index, Generic_Parse_State *state, Code_Index_Nest *parent){
    generic_parse_inc(state);
    generic_parse_skip_soft_tokens(index, state);
    for (;;){
        b32 did_advance = false;
        Token *token = token_it_read(&state->it);
        if (token == 0 || state->finished){
            break;
        }
        if (token->kind == TokenBaseKind_Identifier){
            generic_parse_inc(state);
            generic_parse_skip_soft_tokens(index, state);
            did_advance = true;
            Token *peek = token_it_read(&state->it);
            if (peek != 0 && peek->kind == TokenBaseKind_StatementClose ||
                peek->kind == TokenBaseKind_ParentheticalOpen){
                index_new_note(index, state, Ii64(token), CodeIndexNote_Type, parent);
                break;
            }
        }
        else if (token->kind == TokenBaseKind_StatementClose ||
                 token->kind == TokenBaseKind_ScopeOpen ||
                 token->kind == TokenBaseKind_ScopeClose ||
                 token->kind == TokenBaseKind_ScopeOpen ||
                 token->kind == TokenBaseKind_ScopeClose){
            break;
        }
        else if (token->kind == TokenBaseKind_Keyword){
            String_Const_u8 lexeme = string_substring(state->contents, Ii64(token));
            if (string_match(lexeme, SCu8((u8*)("struct"), (u64)(sizeof("struct") - 1))) ||
                string_match(lexeme, SCu8((u8*)("union"), (u64)(sizeof("union") - 1))) ||
                string_match(lexeme, SCu8((u8*)("enum"), (u64)(sizeof("enum") - 1)))){
                break;
            }
        }
        if (!did_advance){
            generic_parse_inc(state);
            generic_parse_skip_soft_tokens(index, state);
        }
    }
}

static void
cpp_parse_function(Code_Index_File *index, Generic_Parse_State *state, Code_Index_Nest *parent){
    Token *token = token_it_read(&state->it);
    generic_parse_inc(state);
    generic_parse_skip_soft_tokens(index, state);
    if (state->finished){
        return;
    }
    Token *peek = token_it_read(&state->it);
    Token *reset_point = peek;
    if (peek != 0 && peek->sub_kind == TokenCppKind_ParenOp){
        b32 at_paren_close = false;
        i32 paren_nest_level = 0;
        for (; peek != 0;){
            generic_parse_inc(state);
            generic_parse_skip_soft_tokens(index, state);
            peek = token_it_read(&state->it);
            if (peek == 0 || state->finished){
                break;
            }

            if (peek->kind == TokenBaseKind_ParentheticalOpen){
                paren_nest_level += 1;
            }
            else if (peek->kind == TokenBaseKind_ParentheticalClose){
                if (paren_nest_level > 0){
                    paren_nest_level -= 1;
                }
                else{
                    at_paren_close = true;
                    break;
                }
            }
        }

        if (at_paren_close){
            generic_parse_inc(state);
            generic_parse_skip_soft_tokens(index, state);
            peek = token_it_read(&state->it);
            if (peek != 0 &&
                peek->kind == TokenBaseKind_ScopeOpen ||
                peek->kind == TokenBaseKind_StatementClose){
                index_new_note(index, state, Ii64(token), CodeIndexNote_Function, parent);
            }
        }
    }
    state->it = token_iterator(state->it.user_id, state->it.tokens, state->it.count, reset_point);
}

static Code_Index_Nest*
generic_parse_statement(Code_Index_File *index, Generic_Parse_State *state);

static Code_Index_Nest*
generic_parse_preprocessor(Code_Index_File *index, Generic_Parse_State *state);

static Code_Index_Nest*
generic_parse_scope(Code_Index_File *index, Generic_Parse_State *state);

static Code_Index_Nest*
generic_parse_paren(Code_Index_File *index, Generic_Parse_State *state);

static Code_Index_Nest*
generic_parse_statement(Code_Index_File *index, Generic_Parse_State *state){
    Token *token = token_it_read(&state->it);
    Code_Index_Nest *result = ((Code_Index_Nest*)linalloc_wrap_zero(linalloc_push((state->arena), sizeof(Code_Index_Nest)*(1), SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_code_index.cpp" ":" "415" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_code_index.cpp" ":" "415" ":") - 1)))));
    result->kind = CodeIndexNest_Statement;
    result->open = Ii64(token->pos);
    result->close = Ii64(max_i64);
    result->file = index;

    state->in_statement = true;

    for (;;){
        generic_parse_skip_soft_tokens(index, state);
        token = token_it_read(&state->it);
        if (token == 0 || state->finished){
            break;
        }

        if (state->in_preprocessor){
            if (!(((token->flags)&(TokenBaseFlag_PreprocessorBody))!=0) ||
                token->kind == TokenBaseKind_Preprocessor){
                result->is_closed = true;
                result->close = Ii64(token->pos);
                break;
            }
        }
        else{
            if (token->kind == TokenBaseKind_Preprocessor){
                result->is_closed = true;
                result->close = Ii64(token->pos);
                break;
            }
        }

        if (token->kind == TokenBaseKind_ScopeOpen ||
            token->kind == TokenBaseKind_ScopeClose ||
            token->kind == TokenBaseKind_ParentheticalOpen){
            result->is_closed = true;
            result->close = Ii64(token->pos);
            break;
        }

        if (token->kind == TokenBaseKind_StatementClose){
            result->is_closed = true;
            result->close = Ii64(token);
            generic_parse_inc(state);
            break;
        }

        generic_parse_inc(state);
    }

    state->in_statement = false;

    return(result);
}

static Code_Index_Nest*
generic_parse_preprocessor(Code_Index_File *index, Generic_Parse_State *state){
    Token *token = token_it_read(&state->it);
    Code_Index_Nest *result = ((Code_Index_Nest*)linalloc_wrap_zero(linalloc_push((state->arena), sizeof(Code_Index_Nest)*(1), SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_code_index.cpp" ":" "472" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_code_index.cpp" ":" "472" ":") - 1)))));
    result->kind = CodeIndexNest_Preprocessor;
    result->open = Ii64(token->pos);
    result->close = Ii64(max_i64);
    result->file = index;

    state->in_preprocessor = true;

    b32 potential_macro = false;
    if (state->do_cpp_parse){
        if (token->sub_kind == TokenCppKind_PPDefine){
            potential_macro = true;
        }
    }

    generic_parse_inc(state);
    for (;;){
        generic_parse_skip_soft_tokens(index, state);
        token = token_it_read(&state->it);
        if (token == 0 || state->finished){
            break;
        }

        if (!(((token->flags)&(TokenBaseFlag_PreprocessorBody))!=0) ||
            token->kind == TokenBaseKind_Preprocessor){
            result->is_closed = true;
            result->close = Ii64(token->pos);
            break;
        }

        if (state->do_cpp_parse && potential_macro){
            if (token->sub_kind == TokenCppKind_Identifier){
                index_new_note(index, state, Ii64(token), CodeIndexNote_Macro, result);
            }
            potential_macro = false;
        }

        if (token->kind == TokenBaseKind_ScopeOpen){
            Code_Index_Nest *nest = generic_parse_scope(index, state);
            nest->parent = result;
            code_index_push_nest(&result->nest_list, nest);
            continue;
        }

        if (token->kind == TokenBaseKind_ParentheticalOpen){
            Code_Index_Nest *nest = generic_parse_paren(index, state);
            nest->parent = result;
            code_index_push_nest(&result->nest_list, nest);
            continue;
        }

        generic_parse_inc(state);
    }

    result->nest_array = code_index_nest_ptr_array_from_list(state->arena, &result->nest_list);

    state->in_preprocessor = false;

    return(result);
}

static Code_Index_Nest*
generic_parse_scope(Code_Index_File *index, Generic_Parse_State *state){
    Token *token = token_it_read(&state->it);
    Code_Index_Nest *result = ((Code_Index_Nest*)linalloc_wrap_zero(linalloc_push((state->arena), sizeof(Code_Index_Nest)*(1), SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_code_index.cpp" ":" "536" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_code_index.cpp" ":" "536" ":") - 1)))));
    result->kind = CodeIndexNest_Scope;
    result->open = Ii64(token);
    result->close = Ii64(max_i64);
    result->file = index;

    state->scope_counter += 1;

    generic_parse_inc(state);
    for (;;){
        generic_parse_skip_soft_tokens(index, state);
        token = token_it_read(&state->it);
        if (token == 0 || state->finished){
            break;
        }

        if (state->in_preprocessor){
            if (!(((token->flags)&(TokenBaseFlag_PreprocessorBody))!=0) ||
                token->kind == TokenBaseKind_Preprocessor){
                break;
            }
        }
        else{
            if (token->kind == TokenBaseKind_Preprocessor){
                Code_Index_Nest *nest = generic_parse_preprocessor(index, state);
                code_index_push_nest(&index->nest_list, nest);
                continue;
            }
        }

        if (token->kind == TokenBaseKind_ScopeClose){
            result->is_closed = true;
            result->close = Ii64(token);
            generic_parse_inc(state);
            break;
        }

        if (token->kind == TokenBaseKind_ScopeOpen){
            Code_Index_Nest *nest = generic_parse_scope(index, state);
            nest->parent = result;
            code_index_push_nest(&result->nest_list, nest);
            continue;
        }

        if (token->kind == TokenBaseKind_ParentheticalClose){
            generic_parse_inc(state);
            continue;
        }

        if (token->kind == TokenBaseKind_ParentheticalOpen){
            Code_Index_Nest *nest = generic_parse_paren(index, state);
            nest->parent = result;
            code_index_push_nest(&result->nest_list, nest);



            nest = generic_parse_statement(index, state);
            nest->parent = result;
            code_index_push_nest(&result->nest_list, nest);

            continue;
        }

        {
            Code_Index_Nest *nest = generic_parse_statement(index, state);
            nest->parent = result;
            code_index_push_nest(&result->nest_list, nest);
        }
    }

    result->nest_array = code_index_nest_ptr_array_from_list(state->arena, &result->nest_list);

    state->scope_counter -= 1;

    return(result);
}

static Code_Index_Nest*
generic_parse_paren(Code_Index_File *index, Generic_Parse_State *state){
    Token *token = token_it_read(&state->it);
    Code_Index_Nest *result = ((Code_Index_Nest*)linalloc_wrap_zero(linalloc_push((state->arena), sizeof(Code_Index_Nest)*(1), SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_code_index.cpp" ":" "616" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_code_index.cpp" ":" "616" ":") - 1)))));
    result->kind = CodeIndexNest_Paren;
    result->open = Ii64(token);
    result->close = Ii64(max_i64);
    result->file = index;

    i64 manifested_characters_on_line = 0;
    {
        u8 *ptr = state->prev_line_start;
        u8 *end_ptr = state->contents.str + token->pos;

        for (;ptr < end_ptr; ptr += 1){
            if (!character_is_whitespace(*ptr)){
                break;
            }
        }

        manifested_characters_on_line = (i64)(end_ptr - ptr) + token->size;
    }

    state->paren_counter += 1;

    generic_parse_inc(state);
    for (;;){
        generic_parse_skip_soft_tokens(index, state);
        token = token_it_read(&state->it);
        if (token == 0 || state->finished){
            break;
        }

        if (state->in_preprocessor){
            if (!(((token->flags)&(TokenBaseFlag_PreprocessorBody))!=0) ||
                token->kind == TokenBaseKind_Preprocessor){
                break;
            }
        }
        else{
            if (token->kind == TokenBaseKind_Preprocessor){
                Code_Index_Nest *nest = generic_parse_preprocessor(index, state);
                code_index_push_nest(&index->nest_list, nest);
                continue;
            }
        }

        if (token->kind == TokenBaseKind_ParentheticalClose){
            result->is_closed = true;
            result->close = Ii64(token);
            generic_parse_inc(state);
            break;
        }

        if (token->kind == TokenBaseKind_ScopeClose){
            break;
        }

        if (token->kind == TokenBaseKind_ScopeOpen){
            Code_Index_Nest *nest = generic_parse_scope(index, state);
            nest->parent = result;
            code_index_push_nest(&result->nest_list, nest);
            continue;
        }

        if (token->kind == TokenBaseKind_ParentheticalOpen){
            Code_Index_Nest *nest = generic_parse_paren(index, state);
            nest->parent = result;
            code_index_push_nest(&result->nest_list, nest);
            continue;
        }

        generic_parse_inc(state);
    }

    result->nest_array = code_index_nest_ptr_array_from_list(state->arena, &result->nest_list);

    state->paren_counter -= 1;

    return(result);
}

static b32
generic_parse_full_input_breaks(Code_Index_File *index, Generic_Parse_State *state, i32 limit){
    b32 result = false;

    i64 first_index = token_it_index(&state->it);
    i64 one_past_last_index = first_index + limit;
    for (;;){
        generic_parse_skip_soft_tokens(index, state);
        Token *token = token_it_read(&state->it);

        if (token == 0 || state->finished){
            result = true;
            break;
        }

        if (token->kind == TokenBaseKind_Preprocessor){
            Code_Index_Nest *nest = generic_parse_preprocessor(index, state);
            code_index_push_nest(&index->nest_list, nest);
        }
        else if (token->kind == TokenBaseKind_ScopeOpen){
            Code_Index_Nest *nest = generic_parse_scope(index, state);
            code_index_push_nest(&index->nest_list, nest);
        }
        else if (token->kind == TokenBaseKind_ParentheticalOpen){
            Code_Index_Nest *nest = generic_parse_paren(index, state);
            code_index_push_nest(&index->nest_list, nest);
        }
        else if (state->do_cpp_parse){
            if (token->sub_kind == TokenCppKind_Struct ||
                token->sub_kind == TokenCppKind_Union ||
                token->sub_kind == TokenCppKind_Enum){
                cpp_parse_type_structure(index, state, 0);
            }
            else if (token->sub_kind == TokenCppKind_Typedef){
                cpp_parse_type_def(index, state, 0);
            }
            else if (token->sub_kind == TokenCppKind_Identifier){
                cpp_parse_function(index, state, 0);
            }
            else{
                generic_parse_inc(state);
            }
        }
        else{
            generic_parse_inc(state);
        }

        i64 index = token_it_index(&state->it);
        if (index >= one_past_last_index){
            token = token_it_read(&state->it);
            if (token == 0){
                result = true;
            }
            break;
        }
    }

    if (result){
        index->nest_array = code_index_nest_ptr_array_from_list(state->arena, &index->nest_list);
        index->note_array = code_index_note_ptr_array_from_list(state->arena, &index->note_list);
    }

    return(result);
}



static void
default_comment_index(Application_Links *app, Arena *arena, Code_Index_File *index, Token *token, String_Const_u8 contents){

}

static void
generic_parse_init(Application_Links *app, Arena *arena, String_Const_u8 contents, Token_Array *tokens, Generic_Parse_State *state){
    generic_parse_init(app, arena, contents, tokens, default_comment_index, state);
}



static Token_Pair
layout_token_pair(Token_Array *tokens, i64 pos){
    Token_Pair result = {};
    Token_Iterator_Array it = token_iterator_pos(0, tokens, pos);
    Token *b = token_it_read(&it);
    if (b != 0){
        if (b->kind == TokenBaseKind_Whitespace){
            token_it_inc_non_whitespace(&it);
            b = token_it_read(&it);
        }
    }
    token_it_dec_non_whitespace(&it);
    Token *a = token_it_read(&it);
    if (a != 0){
        result.a = *a;
    }
    if (b != 0){
        result.b = *b;
    }
    return(result);
}

static f32
layout_index_x_shift(Application_Links *app, Layout_Reflex *reflex, Code_Index_Nest *nest, i64 pos, f32 regular_indent, b32 *unresolved_dependence){
    f32 result = 0.f;
    if (nest != 0){
        switch (nest->kind){
            case CodeIndexNest_Scope:
            case CodeIndexNest_Preprocessor:
            {
                result = layout_index_x_shift(app, reflex, nest->parent, pos, regular_indent, unresolved_dependence);
                if (nest->open.min < pos && nest->open.max <= pos &&
                    (!nest->is_closed || pos < nest->close.min)){
                    result += regular_indent;
                }
            }break;

            case CodeIndexNest_Statement:
            {
                result = layout_index_x_shift(app, reflex, nest->parent, pos, regular_indent, unresolved_dependence);
                if (nest->open.min < pos && nest->open.max <= pos &&
                    (!nest->is_closed || pos < nest->close.min)){
                    result += regular_indent;
                }
            }break;

            case CodeIndexNest_Paren:
            {
                Rect_f32 box = layout_reflex_get_rect(app, reflex, nest->open.max - 1, unresolved_dependence);
                result = box.x1;
            }break;
        }
    }
    return(result);
}

static f32
layout_index_x_shift(Application_Links *app, Layout_Reflex *reflex, Code_Index_Nest *nest, i64 pos, f32 regular_indent){
    b32 ignore;
    return(layout_index_x_shift(app, reflex, nest, pos, regular_indent, &ignore));
}

static f32
layout_index_x_shift(Application_Links *app, Layout_Reflex *reflex, Code_Index_File *file, i64 pos, f32 regular_indent, b32 *unresolved_dependence){
    f32 indent = 0;
    Code_Index_Nest *nest = code_index_get_nest(file, pos);
    if (nest != 0){
        indent = layout_index_x_shift(app, reflex, nest, pos, regular_indent, unresolved_dependence);
    }
    return(indent);
}

static f32
layout_index_x_shift(Application_Links *app, Layout_Reflex *reflex, Code_Index_File *file, i64 pos, f32 regular_indent){
    b32 ignore;
    return(layout_index_x_shift(app, reflex, file, pos, regular_indent, &ignore));
}

static void
layout_index__emit_chunk(LefRig_TopBot_Layout_Vars *pos_vars, Face_ID face, Arena *arena, u8 *text_str, i64 range_first, u8 *ptr, u8 *end, Layout_Item_List *list){
    for (;ptr < end;){
        Character_Consume_Result consume = utf8_consume(ptr, (u64)(end - ptr));
        if (consume.codepoint != '\r'){
            i64 index = layout_index_from_ptr(ptr, text_str, range_first);
            if (consume.codepoint != max_u32){
                lr_tb_write(pos_vars, face, arena, list, index, consume.codepoint);
            }
            else{
                lr_tb_write_byte(pos_vars, face, arena, list, index, *ptr);
            }
        }
        ptr += consume.inc;
    }
}

static i32
layout_token_score_wrap_token(Token_Pair *pair, Token_Cpp_Kind kind){
    i32 result = 0;
    if (pair->a.sub_kind != kind && pair->b.sub_kind == kind){
        result -= 1;
    }
    else if (pair->a.sub_kind == kind && pair->b.sub_kind != kind){
        result += 1;
    }
    return(result);
}

static Layout_Item_List
layout_index__inner(Application_Links *app, Arena *arena, Buffer_ID buffer, Range_i64 range, Face_ID face, f32 width, Code_Index_File *file, Layout_Wrap_Kind kind){
    Scratch_Block scratch(app, arena);

    Token_Array tokens = get_token_array_from_buffer(app, buffer);
    Token_Array *tokens_ptr = &tokens;

    Layout_Item_List list = get_empty_item_list(range);
    String_Const_u8 text = push_buffer_range(app, scratch, buffer, range);

    Face_Advance_Map advance_map = get_face_advance_map(app, face);
    Face_Metrics metrics = get_face_metrics(app, face);
    LefRig_TopBot_Layout_Vars pos_vars = get_lr_tb_layout_vars(&advance_map, &metrics, width);

    f32 regular_indent = metrics.space_advance*global_config.virtual_whitespace_regular_indent;
    f32 wrap_align_x = width - metrics.normal_advance;

    Layout_Reflex reflex = get_layout_reflex(&list, buffer, width, face);

    if (text.size == 0){
        lr_tb_write_blank(&pos_vars, face, arena, &list, range.start);
    }
    else{
        b32 first_of_the_line = true;
        Newline_Layout_Vars newline_vars = get_newline_layout_vars();

        u8 *ptr = text.str;
        u8 *end_ptr = ptr + text.size;
        u8 *word_ptr = ptr;

        u8 *pending_wrap_ptr = ptr;
        f32 pending_wrap_x = 0.f;
        i32 pending_wrap_paren_nest_count = 0;
        i32 pending_wrap_token_score = 0;
        f32 pending_wrap_accumulated_w = 0.f;

        start:
        if (ptr == end_ptr){
            i64 index = layout_index_from_ptr(ptr, text.str, range.first);
            f32 shift = layout_index_x_shift(app, &reflex, file, index, regular_indent);
            lr_tb_advance_x_without_item(&pos_vars, shift);
            goto finish;
        }

        if (!character_is_whitespace(*ptr)){
            i64 index = layout_index_from_ptr(ptr, text.str, range.first);
            f32 shift = layout_index_x_shift(app, &reflex, file, index, regular_indent);
            lr_tb_advance_x_without_item(&pos_vars, shift);
            goto consuming_non_whitespace;
        }

        {
            for (;ptr < end_ptr; ptr += 1){
                if (!character_is_whitespace(*ptr)){
                    pending_wrap_ptr = ptr;
                    word_ptr = ptr;
                    i64 index = layout_index_from_ptr(ptr, text.str, range.first);
                    f32 shift = layout_index_x_shift(app, &reflex, file, index, regular_indent);
                    lr_tb_advance_x_without_item(&pos_vars, shift);
                    goto consuming_non_whitespace;
                }
                if (*ptr == '\r'){
                    i64 index = layout_index_from_ptr(ptr, text.str, range.first);
                    newline_layout_consume_CR(&newline_vars, index);
                }
                else if (*ptr == '\n'){
                    pending_wrap_ptr = ptr;
                    i64 index = layout_index_from_ptr(ptr, text.str, range.first);
                    f32 shift = layout_index_x_shift(app, &reflex, file, index, regular_indent);
                    lr_tb_advance_x_without_item(&pos_vars, shift);
                    goto consuming_normal_whitespace;
                }
            }

            if (ptr == end_ptr){
                pending_wrap_ptr = ptr;
                i64 index = layout_index_from_ptr(ptr - 1, text.str, range.first);
                f32 shift = layout_index_x_shift(app, &reflex, file, index, regular_indent);
                lr_tb_advance_x_without_item(&pos_vars, shift);
                goto finish;
            }
        }

        consuming_non_whitespace:
        {
            for (;ptr <= end_ptr; ptr += 1){
                if (ptr == end_ptr || character_is_whitespace(*ptr)){
                    break;
                }
            }


            newline_layout_consume_default(&newline_vars);
            String_Const_u8 word = SCu8(word_ptr, ptr);
            u8 *word_end = ptr;
            {
                f32 word_advance = 0.f;
                ptr = word.str;
                for (;ptr < word_end;){
                    Character_Consume_Result consume = utf8_consume(ptr, (u64)(word_end - ptr));
                    if (consume.codepoint != max_u32){
                        word_advance += lr_tb_advance(&pos_vars, face, consume.codepoint);
                    }
                    else{
                        word_advance += lr_tb_advance_byte(&pos_vars);
                    }
                    ptr += consume.inc;
                }
                pending_wrap_accumulated_w += word_advance;
            }

            if (!first_of_the_line && (kind == Layout_Wrapped) && lr_tb_crosses_width(&pos_vars, pending_wrap_accumulated_w)){
                i64 index = layout_index_from_ptr(pending_wrap_ptr, text.str, range.first);
                lr_tb_align_rightward(&pos_vars, wrap_align_x);
                lr_tb_write_ghost(&pos_vars, face, arena, &list, index, '\\');

                lr_tb_next_line(&pos_vars);





                ptr = pending_wrap_ptr;
                pending_wrap_accumulated_w = 0.f;
                first_of_the_line = true;
                goto start;
            }
        }

        consuming_normal_whitespace:
        for (; ptr < end_ptr; ptr += 1){
            if (!character_is_whitespace(*ptr)){
                u8 *new_wrap_ptr = ptr;

                i64 index = layout_index_from_ptr(new_wrap_ptr, text.str, range.first);
                Code_Index_Nest *new_wrap_nest = code_index_get_nest(file, index);
                b32 invalid_wrap_x = false;
                f32 new_wrap_x = layout_index_x_shift(app, &reflex, new_wrap_nest, index, regular_indent, &invalid_wrap_x);
                if (invalid_wrap_x){
                    new_wrap_x = max_f32;
                }

                i32 new_wrap_paren_nest_count = 0;
                for (Code_Index_Nest *nest = new_wrap_nest;
                     nest != 0;
                     nest = nest->parent){
                    if (nest->kind == CodeIndexNest_Paren){
                        new_wrap_paren_nest_count += 1;
                    }
                }

                Token_Pair new_wrap_token_pair = layout_token_pair(tokens_ptr, index);



                i32 token_score = 0;
                if (new_wrap_token_pair.a.kind == TokenBaseKind_Keyword){
                    if (new_wrap_token_pair.b.kind == TokenBaseKind_ParentheticalOpen ||
                        new_wrap_token_pair.b.kind == TokenBaseKind_Keyword){
                        token_score -= 2;
                    }
                }
                token_score += layout_token_score_wrap_token(&new_wrap_token_pair, TokenCppKind_Eq);
                token_score += layout_token_score_wrap_token(&new_wrap_token_pair, TokenCppKind_PlusEq);
                token_score += layout_token_score_wrap_token(&new_wrap_token_pair, TokenCppKind_MinusEq);
                token_score += layout_token_score_wrap_token(&new_wrap_token_pair, TokenCppKind_StarEq);
                token_score += layout_token_score_wrap_token(&new_wrap_token_pair, TokenCppKind_DivEq);
                token_score += layout_token_score_wrap_token(&new_wrap_token_pair, TokenCppKind_ModEq);
                token_score += layout_token_score_wrap_token(&new_wrap_token_pair, TokenCppKind_LeftLeftEq);
                token_score += layout_token_score_wrap_token(&new_wrap_token_pair, TokenCppKind_RightRightEq);
                token_score += layout_token_score_wrap_token(&new_wrap_token_pair, TokenCppKind_Comma);
                token_score += layout_token_score_wrap_token(&new_wrap_token_pair, TokenCppKind_AndAnd);
                token_score += layout_token_score_wrap_token(&new_wrap_token_pair, TokenCppKind_OrOr);
                token_score += layout_token_score_wrap_token(&new_wrap_token_pair, TokenCppKind_Ternary);
                token_score += layout_token_score_wrap_token(&new_wrap_token_pair, TokenCppKind_Colon);
                token_score += layout_token_score_wrap_token(&new_wrap_token_pair, TokenCppKind_Semicolon);

                i32 new_wrap_token_score = token_score;

                b32 new_wrap_ptr_is_better = false;
                if (first_of_the_line){
                    new_wrap_ptr_is_better = true;
                }
                else{
                    if (new_wrap_token_score > pending_wrap_token_score){
                        new_wrap_ptr_is_better = true;
                    }
                    else if (new_wrap_token_score == pending_wrap_token_score){
                        f32 new_score = new_wrap_paren_nest_count*10.f + new_wrap_x;
                        f32 old_score = pending_wrap_paren_nest_count*10.f + pending_wrap_x + metrics.normal_advance*4.f + pending_wrap_accumulated_w*0.5f;

                        if (new_score < old_score){
                            new_wrap_ptr_is_better = true;
                        }
                    }
                }

                if (new_wrap_ptr_is_better){
                    layout_index__emit_chunk(&pos_vars, face, arena, text.str, range.first, pending_wrap_ptr, new_wrap_ptr, &list);
                    first_of_the_line = false;

                    pending_wrap_ptr = new_wrap_ptr;
                    pending_wrap_paren_nest_count = new_wrap_paren_nest_count;
                    pending_wrap_x = layout_index_x_shift(app, &reflex, new_wrap_nest, index, regular_indent);
                    pending_wrap_paren_nest_count = new_wrap_paren_nest_count;
                    pending_wrap_token_score = new_wrap_token_score;
                    pending_wrap_accumulated_w = 0.f;
                }

                word_ptr = ptr;
                goto consuming_non_whitespace;
            }

            i64 index = layout_index_from_ptr(ptr, text.str, range.first);
            switch (*ptr){
                default:
                {
                    newline_layout_consume_default(&newline_vars);
                    pending_wrap_accumulated_w += lr_tb_advance(&pos_vars, face, *ptr);
                }break;

                case '\r':
                {
                    newline_layout_consume_CR(&newline_vars, index);
                }break;

                case '\n':
                {
                    layout_index__emit_chunk(&pos_vars, face, arena, text.str, range.first, pending_wrap_ptr, ptr, &list);
                    pending_wrap_ptr = ptr + 1;
                    pending_wrap_accumulated_w = 0.f;

                    u64 newline_index = newline_layout_consume_LF(&newline_vars, index);
                    lr_tb_write_blank(&pos_vars, face, arena, &list, newline_index);
                    lr_tb_next_line(&pos_vars);
                    first_of_the_line = true;
                    ptr += 1;
                    goto start;
                }break;
            }
        }

        finish:
        if (newline_layout_consume_finish(&newline_vars)){
            layout_index__emit_chunk(&pos_vars, face, arena, text.str, range.first, pending_wrap_ptr, ptr, &list);
            i64 index = layout_index_from_ptr(ptr, text.str, range.first);
            lr_tb_write_blank(&pos_vars, face, arena, &list, index);
        }
    }

    layout_item_list_finish(&list, -pos_vars.line_to_text_shift);

    return(list);
}

static Layout_Item_List
layout_virt_indent_index(Application_Links *app, Arena *arena, Buffer_ID buffer, Range_i64 range, Face_ID face, f32 width, Layout_Wrap_Kind kind){
    Layout_Item_List result = {};

    if (global_config.enable_virtual_whitespace){
        code_index_lock();
        Code_Index_File *file = code_index_get_file(buffer);
        if (file != 0){
            result = layout_index__inner(app, arena, buffer, range, face, width, file, kind);
        }
        code_index_unlock();
        if (file == 0){
            result = layout_virt_indent_literal(app, arena, buffer, range, face, width, kind);
        }
    }
    else{
        result = layout_basic(app, arena, buffer, range, face, width, kind);
    }

    return(result);
}

static Layout_Item_List
layout_virt_indent_index_unwrapped(Application_Links *app, Arena *arena, Buffer_ID buffer, Range_i64 range, Face_ID face, f32 width){
    return(layout_virt_indent_index(app, arena, buffer, range, face, width, Layout_Unwrapped));
}

static Layout_Item_List
layout_virt_indent_index_wrapped(Application_Links *app, Arena *arena, Buffer_ID buffer, Range_i64 range, Face_ID face, f32 width){
    return(layout_virt_indent_index(app, arena, buffer, range, face, width, Layout_Wrapped));
}

static Layout_Item_List
layout_virt_indent_index_generic(Application_Links *app, Arena *arena, Buffer_ID buffer, Range_i64 range, Face_ID face, f32 width){
    Managed_Scope scope = buffer_get_managed_scope(app, buffer);
    b32 *wrap_lines_ptr = ((b32*)managed_scope_get_attachment((app), (scope), (buffer_wrap_lines), sizeof(b32)));
    b32 wrap_lines = (wrap_lines_ptr != 0 && *wrap_lines_ptr);
    return(layout_virt_indent_index(app, arena, buffer, range, face, width, wrap_lines?Layout_Wrapped:Layout_Unwrapped));
}

CUSTOM_COMMAND(toggle_virtual_whitespace, "/home/sam/.bin/4coder/custom/4coder_code_index.cpp", 1176, Normal)
CUSTOM_DOC("Toggles virtual whitespace for all files.")
{
    global_config.enable_virtual_whitespace = !global_config.enable_virtual_whitespace;

    for (Buffer_ID buffer = get_buffer_next(app, 0, Access_Always);
         buffer != 0;
         buffer = get_buffer_next(app, buffer, Access_Always)){
        buffer_clear_layout_cache(app, buffer);
    }
}
# 98 "/home/sam/.bin/4coder/custom/4coder_default_include.cpp" 2
# 1 "/home/sam/.bin/4coder/custom/4coder_fancy.cpp" 1






static FColor
fcolor_argb(ARGB_Color color){
    FColor result = {};
    result.argb = color;
    if (result.a_byte == 0){
        result.argb = 0;
    }
    return(result);
}
static FColor
fcolor_argb(Vec4_f32 color){
    return(fcolor_argb(pack_color(color)));
}
static FColor
fcolor_argb(f32 r, f32 g, f32 b, f32 a){
    return(fcolor_argb(pack_color(V4f32(r, g, b, a))));
}

static FColor
fcolor_id(Managed_ID id){
    FColor result = {};
    result.id = (ID_Color)id;
    return(result);
}

static FColor
fcolor_id(Managed_ID id, u32 sub_index){
    FColor result = {};
    result.id = (ID_Color)id;
    result.sub_index = (u8)sub_index;
    return(result);
}

static ARGB_Color
argb_color_blend(ARGB_Color a, f32 at, ARGB_Color b, f32 bt){
    Vec4_f32 av = unpack_color(a);
    Vec4_f32 bv = unpack_color(b);
    Vec4_f32 value = at*av + bt*bv;
    return(pack_color(value));
}
static ARGB_Color
argb_color_blend(ARGB_Color a, f32 t, ARGB_Color b){
    return(argb_color_blend(a, 1.f - t, b, t));
}

static ARGB_Color
fcolor_resolve(FColor color){
    ARGB_Color result = 0;
    if (color.a_byte == 0){
        if (color.id != 0){
            result = finalize_color(color.id, color.sub_index);
        }
    }
    else{
        result = color.argb;
    }
    return(result);
}

static FColor
fcolor_change_alpha(FColor color, f32 alpha){
    Vec4_f32 v = unpack_color(fcolor_resolve(color));
    v.a = alpha;
    return(fcolor_argb(pack_color(v)));
}
static FColor
fcolor_blend(FColor a, f32 at, FColor b, f32 bt){
    ARGB_Color a_argb = fcolor_resolve(a);
    ARGB_Color b_argb = fcolor_resolve(b);
    return(fcolor_argb(argb_color_blend(a_argb, at, b_argb, bt)));
}
static FColor
fcolor_blend(FColor a, f32 t, FColor b){
    return(fcolor_blend(a, 1.f - t, b, t));
}

static FColor
fcolor_zero(void){
    FColor result = {};
    return(result);
}

static b32
fcolor_is_valid(FColor color){
    return(color.argb != 0);
}



static void
push_fancy_string(Fancy_Line *line, Fancy_String *string){
    do{ if((string)){if((line->first)){(line->last)->next=(string);}else{(line->first)=(string);}(line->last)=(string);(line->last)->next=0;} }while(0);
}

static void
push_fancy_line(Fancy_Block *block, Fancy_Line *line){
    do{ if((line)){if((block->first)){(block->last)->next=(line);}else{(block->first)=(line);}(block->last)=(line);(block->last)->next=0;} }while(0);
    block->line_count += 1;
}



static Fancy_String*
fill_fancy_string(Fancy_String *ptr, Face_ID face, FColor fore, f32 pre_margin, f32 post_margin,
                  String_Const_u8 value){
    ptr->value = value;
    ptr->face = face;
    ptr->fore = fore;
    ptr->pre_margin = pre_margin;
    ptr->post_margin = post_margin;
    return(ptr);
}

static Fancy_String*
push_fancy_string(Arena *arena, Fancy_Line *line, Face_ID face, FColor fore,
                  f32 pre_margin, f32 post_margin, String_Const_u8 value){
    Fancy_String *result = ((Fancy_String*)linalloc_wrap_zero(linalloc_push((arena), sizeof(Fancy_String)*(1), SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_fancy.cpp" ":" "123" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_fancy.cpp" ":" "123" ":") - 1)))));
    fill_fancy_string(result, face, fore, pre_margin, post_margin, value);
    if (line != 0){
        push_fancy_string(line, result);
    }
    return(result);
}

static Fancy_String*
push_fancy_string(Arena *arena, Fancy_Line *line, Face_ID face, FColor fore,
                  String_Const_u8 value){
    return(push_fancy_string(arena, line, face, fore, 0, 0, value));
}
static Fancy_String*
push_fancy_string(Arena *arena, Fancy_Line *line, Face_ID face,
                  f32 pre_margin, f32 post_margin, String_Const_u8 value){
    return(push_fancy_string(arena, line, face, fcolor_zero(),
                             pre_margin, post_margin, value));
}
static Fancy_String*
push_fancy_string(Arena *arena, Fancy_Line *line, FColor fore,
                  f32 pre_margin, f32 post_margin, String_Const_u8 value){
    return(push_fancy_string(arena, line, 0, fore, pre_margin, post_margin, value));
}
static Fancy_String*
push_fancy_string(Arena *arena, Fancy_Line *line, Face_ID face, String_Const_u8 value){
    return(push_fancy_string(arena, line, face, fcolor_zero(), 0, 0, value));
}
static Fancy_String*
push_fancy_string(Arena *arena, Fancy_Line *line, FColor color, String_Const_u8 value){
    return(push_fancy_string(arena, line, 0, color, 0, 0, value));
}
static Fancy_String*
push_fancy_string(Arena *arena, Fancy_Line *line, f32 pre_margin, f32 post_margin,
                  String_Const_u8 value){
    return(push_fancy_string(arena, line, 0, fcolor_zero(), pre_margin, post_margin,
                             value));
}
static Fancy_String*
push_fancy_string(Arena *arena, Fancy_Line *line, String_Const_u8 value){
    return(push_fancy_string(arena, line, 0, fcolor_zero(), 0, 0, value));
}



static Fancy_String*
push_fancy_stringfv(Arena *arena, Fancy_Line *line, Face_ID face, FColor fore,
                    f32 pre_margin, f32 post_margin,
                    char *format, va_list args){
    return(push_fancy_string(arena, line, face, fore, pre_margin, post_margin,
                             push_u8_stringfv(arena, format, args)));
}
static Fancy_String*
push_fancy_stringfv(Arena *arena, Fancy_Line *line, Face_ID face, FColor fore,
                    char *format, va_list args){
    return(push_fancy_stringfv(arena, line, face, fore, 0, 0, format, args));
}
static Fancy_String*
push_fancy_stringfv(Arena *arena, Fancy_Line *line, Face_ID face,
                    f32 pre_margin, f32 post_margin,
                    char *format, va_list args){
    return(push_fancy_stringfv(arena, line, face, fcolor_zero(),
                               pre_margin, post_margin, format, args));
}
static Fancy_String*
push_fancy_stringfv(Arena *arena, Fancy_Line *line, FColor fore,
                    f32 pre_margin, f32 post_margin,
                    char *format, va_list args){
    return(push_fancy_stringfv(arena, line, 0, fore, pre_margin, post_margin,
                               format, args));
}
static Fancy_String*
push_fancy_stringfv(Arena *arena, Fancy_Line *line, Face_ID face,
                    char *format, va_list args){
    return(push_fancy_stringfv(arena, line, face, fcolor_zero(), 0, 0,
                               format, args));
}
static Fancy_String*
push_fancy_stringfv(Arena *arena, Fancy_Line *line, FColor color,
                    char *format, va_list args){
    return(push_fancy_stringfv(arena, line, 0, color, 0, 0, format, args));
}
static Fancy_String*
push_fancy_stringfv(Arena *arena, Fancy_Line *line, f32 pre_margin, f32 post_margin,
                    char *format, va_list args){
    return(push_fancy_stringfv(arena, line, 0, fcolor_zero(), pre_margin, post_margin,
                               format, args));
}
static Fancy_String*
push_fancy_stringfv(Arena *arena, Fancy_Line *line,
                    char *format, va_list args){
    return(push_fancy_stringfv(arena, line, 0, fcolor_zero(), 0, 0, format, args));
}





static Fancy_String*
push_fancy_stringf(Arena *arena, Fancy_Line *line, Face_ID face, FColor fore,
                   f32 pre_margin, f32 post_margin,
                   char *format, ...){
    va_list args; 
# 225 "/home/sam/.bin/4coder/custom/4coder_fancy.cpp" 3 4
   __builtin_va_start(
# 225 "/home/sam/.bin/4coder/custom/4coder_fancy.cpp"
   args
# 225 "/home/sam/.bin/4coder/custom/4coder_fancy.cpp" 3 4
   ,
# 225 "/home/sam/.bin/4coder/custom/4coder_fancy.cpp"
   format
# 225 "/home/sam/.bin/4coder/custom/4coder_fancy.cpp" 3 4
   )
# 225 "/home/sam/.bin/4coder/custom/4coder_fancy.cpp"
                 ;
    Fancy_String *result = push_fancy_string(arena, line, face, fore, pre_margin, post_margin, push_u8_stringfv(arena, format, args))
                                                                         ;
    
# 228 "/home/sam/.bin/4coder/custom/4coder_fancy.cpp" 3 4
   __builtin_va_end(
# 228 "/home/sam/.bin/4coder/custom/4coder_fancy.cpp"
   args
# 228 "/home/sam/.bin/4coder/custom/4coder_fancy.cpp" 3 4
   )
# 228 "/home/sam/.bin/4coder/custom/4coder_fancy.cpp"
   ; return(result);
}
static Fancy_String*
push_fancy_stringf(Arena *arena, Fancy_Line *line, Face_ID face, FColor fore,
                   char *format, ...){
    va_list args; 
# 233 "/home/sam/.bin/4coder/custom/4coder_fancy.cpp" 3 4
   __builtin_va_start(
# 233 "/home/sam/.bin/4coder/custom/4coder_fancy.cpp"
   args
# 233 "/home/sam/.bin/4coder/custom/4coder_fancy.cpp" 3 4
   ,
# 233 "/home/sam/.bin/4coder/custom/4coder_fancy.cpp"
   format
# 233 "/home/sam/.bin/4coder/custom/4coder_fancy.cpp" 3 4
   )
# 233 "/home/sam/.bin/4coder/custom/4coder_fancy.cpp"
                 ;
    Fancy_String *result = push_fancy_stringfv(arena, line, face, fore, 0, 0, format, args);
    
# 235 "/home/sam/.bin/4coder/custom/4coder_fancy.cpp" 3 4
   __builtin_va_end(
# 235 "/home/sam/.bin/4coder/custom/4coder_fancy.cpp"
   args
# 235 "/home/sam/.bin/4coder/custom/4coder_fancy.cpp" 3 4
   )
# 235 "/home/sam/.bin/4coder/custom/4coder_fancy.cpp"
   ; return(result);
}
static Fancy_String*
push_fancy_stringf(Arena *arena, Fancy_Line *line, Face_ID face,
                   f32 pre_margin, f32 post_margin,
                   char *format, ...){
    va_list args; 
# 241 "/home/sam/.bin/4coder/custom/4coder_fancy.cpp" 3 4
   __builtin_va_start(
# 241 "/home/sam/.bin/4coder/custom/4coder_fancy.cpp"
   args
# 241 "/home/sam/.bin/4coder/custom/4coder_fancy.cpp" 3 4
   ,
# 241 "/home/sam/.bin/4coder/custom/4coder_fancy.cpp"
   format
# 241 "/home/sam/.bin/4coder/custom/4coder_fancy.cpp" 3 4
   )
# 241 "/home/sam/.bin/4coder/custom/4coder_fancy.cpp"
                 ;
    Fancy_String *result = push_fancy_stringfv(arena, line, face, fcolor_zero(), pre_margin, post_margin, format, args)
                                                                           ;
    
# 244 "/home/sam/.bin/4coder/custom/4coder_fancy.cpp" 3 4
   __builtin_va_end(
# 244 "/home/sam/.bin/4coder/custom/4coder_fancy.cpp"
   args
# 244 "/home/sam/.bin/4coder/custom/4coder_fancy.cpp" 3 4
   )
# 244 "/home/sam/.bin/4coder/custom/4coder_fancy.cpp"
   ; return(result);
}
static Fancy_String*
push_fancy_stringf(Arena *arena, Fancy_Line *line, FColor fore,
                   f32 pre_margin, f32 post_margin,
                   char *format, ...){
    va_list args; 
# 250 "/home/sam/.bin/4coder/custom/4coder_fancy.cpp" 3 4
   __builtin_va_start(
# 250 "/home/sam/.bin/4coder/custom/4coder_fancy.cpp"
   args
# 250 "/home/sam/.bin/4coder/custom/4coder_fancy.cpp" 3 4
   ,
# 250 "/home/sam/.bin/4coder/custom/4coder_fancy.cpp"
   format
# 250 "/home/sam/.bin/4coder/custom/4coder_fancy.cpp" 3 4
   )
# 250 "/home/sam/.bin/4coder/custom/4coder_fancy.cpp"
                 ;
    Fancy_String *result = push_fancy_stringfv(arena, line, 0, fore, pre_margin, post_margin, format, args)
                                                  ;
    
# 253 "/home/sam/.bin/4coder/custom/4coder_fancy.cpp" 3 4
   __builtin_va_end(
# 253 "/home/sam/.bin/4coder/custom/4coder_fancy.cpp"
   args
# 253 "/home/sam/.bin/4coder/custom/4coder_fancy.cpp" 3 4
   )
# 253 "/home/sam/.bin/4coder/custom/4coder_fancy.cpp"
   ; return(result);
}
static Fancy_String*
push_fancy_stringf(Arena *arena, Fancy_Line *line, Face_ID face,
                   char *format, ...){
    va_list args; 
# 258 "/home/sam/.bin/4coder/custom/4coder_fancy.cpp" 3 4
   __builtin_va_start(
# 258 "/home/sam/.bin/4coder/custom/4coder_fancy.cpp"
   args
# 258 "/home/sam/.bin/4coder/custom/4coder_fancy.cpp" 3 4
   ,
# 258 "/home/sam/.bin/4coder/custom/4coder_fancy.cpp"
   format
# 258 "/home/sam/.bin/4coder/custom/4coder_fancy.cpp" 3 4
   )
# 258 "/home/sam/.bin/4coder/custom/4coder_fancy.cpp"
                 ;
    Fancy_String *result = push_fancy_stringfv(arena, line, face, fcolor_zero(), 0, 0, format, args)
                                                  ;
    
# 261 "/home/sam/.bin/4coder/custom/4coder_fancy.cpp" 3 4
   __builtin_va_end(
# 261 "/home/sam/.bin/4coder/custom/4coder_fancy.cpp"
   args
# 261 "/home/sam/.bin/4coder/custom/4coder_fancy.cpp" 3 4
   )
# 261 "/home/sam/.bin/4coder/custom/4coder_fancy.cpp"
   ; return(result);
}
static Fancy_String*
push_fancy_stringf(Arena *arena, Fancy_Line *line, FColor color,
                   char *format, ...){
    va_list args; 
# 266 "/home/sam/.bin/4coder/custom/4coder_fancy.cpp" 3 4
   __builtin_va_start(
# 266 "/home/sam/.bin/4coder/custom/4coder_fancy.cpp"
   args
# 266 "/home/sam/.bin/4coder/custom/4coder_fancy.cpp" 3 4
   ,
# 266 "/home/sam/.bin/4coder/custom/4coder_fancy.cpp"
   format
# 266 "/home/sam/.bin/4coder/custom/4coder_fancy.cpp" 3 4
   )
# 266 "/home/sam/.bin/4coder/custom/4coder_fancy.cpp"
                 ;
    Fancy_String *result = push_fancy_stringfv(arena, line, 0, color, 0, 0, format, args);
    
# 268 "/home/sam/.bin/4coder/custom/4coder_fancy.cpp" 3 4
   __builtin_va_end(
# 268 "/home/sam/.bin/4coder/custom/4coder_fancy.cpp"
   args
# 268 "/home/sam/.bin/4coder/custom/4coder_fancy.cpp" 3 4
   )
# 268 "/home/sam/.bin/4coder/custom/4coder_fancy.cpp"
   ; return(result);
}
static Fancy_String*
push_fancy_stringf(Arena *arena, Fancy_Line *line, f32 pre_margin, f32 post_margin,
                   char *format, ...){
    va_list args; 
# 273 "/home/sam/.bin/4coder/custom/4coder_fancy.cpp" 3 4
   __builtin_va_start(
# 273 "/home/sam/.bin/4coder/custom/4coder_fancy.cpp"
   args
# 273 "/home/sam/.bin/4coder/custom/4coder_fancy.cpp" 3 4
   ,
# 273 "/home/sam/.bin/4coder/custom/4coder_fancy.cpp"
   format
# 273 "/home/sam/.bin/4coder/custom/4coder_fancy.cpp" 3 4
   )
# 273 "/home/sam/.bin/4coder/custom/4coder_fancy.cpp"
                 ;
    Fancy_String *result = push_fancy_stringfv(arena, line, 0, fcolor_zero(), pre_margin, post_margin, format, args)
                                                                           ;
    
# 276 "/home/sam/.bin/4coder/custom/4coder_fancy.cpp" 3 4
   __builtin_va_end(
# 276 "/home/sam/.bin/4coder/custom/4coder_fancy.cpp"
   args
# 276 "/home/sam/.bin/4coder/custom/4coder_fancy.cpp" 3 4
   )
# 276 "/home/sam/.bin/4coder/custom/4coder_fancy.cpp"
   ; return(result);
}
static Fancy_String*
push_fancy_stringf(Arena *arena, Fancy_Line *line,
                   char *format, ...){
    va_list args; 
# 281 "/home/sam/.bin/4coder/custom/4coder_fancy.cpp" 3 4
   __builtin_va_start(
# 281 "/home/sam/.bin/4coder/custom/4coder_fancy.cpp"
   args
# 281 "/home/sam/.bin/4coder/custom/4coder_fancy.cpp" 3 4
   ,
# 281 "/home/sam/.bin/4coder/custom/4coder_fancy.cpp"
   format
# 281 "/home/sam/.bin/4coder/custom/4coder_fancy.cpp" 3 4
   )
# 281 "/home/sam/.bin/4coder/custom/4coder_fancy.cpp"
                 ;
    Fancy_String *result = push_fancy_stringfv(arena, line, 0, fcolor_zero(), 0, 0, format, args);
    
# 283 "/home/sam/.bin/4coder/custom/4coder_fancy.cpp" 3 4
   __builtin_va_end(
# 283 "/home/sam/.bin/4coder/custom/4coder_fancy.cpp"
   args
# 283 "/home/sam/.bin/4coder/custom/4coder_fancy.cpp" 3 4
   )
# 283 "/home/sam/.bin/4coder/custom/4coder_fancy.cpp"
   ; return(result);
}



static Fancy_String*
push_fancy_string_fixed(Arena *arena, Fancy_Line *line, Face_ID face, FColor fore,
                        f32 pre_margin, f32 post_margin,
                        String_Const_u8 value, i32 max){
    if (value.size <= max){
        return(push_fancy_stringf(arena, line, face, fore, pre_margin, post_margin,
                                  "%-*.*s", max, (i32)(value).size, (char*)(value).str));
    }
    else{
        return(push_fancy_stringf(arena, line, face, fore, pre_margin, post_margin,
                                  "%-*.*s...", max - 3, (i32)(value).size, (char*)(value).str));
    }
}
static Fancy_String*
push_fancy_string_fixed(Arena *arena, Fancy_Line *line, Face_ID face, FColor fore,
                        String_Const_u8 value, i32 max){
    if (value.size <= max){
        return(push_fancy_stringf(arena, line, face, fore, 0.f, 0.f,
                                  "%-*.*s", max, (i32)(value).size, (char*)(value).str));
    }
    else{
        return(push_fancy_stringf(arena, line, face, fore, 0.f, 0.f,
                                  "%-*.*s...", max - 3, (i32)(value).size, (char*)(value).str));
    }
}
static Fancy_String*
push_fancy_string_fixed(Arena *arena, Fancy_Line *line, Face_ID face,
                        f32 pre_margin, f32 post_margin, String_Const_u8 value,
                        i32 max){
    if (value.size <= max){
        return(push_fancy_stringf(arena, line, face, fcolor_zero(),
                                  pre_margin, post_margin,
                                  "%-*.*s", max, (i32)(value).size, (char*)(value).str));
    }
    else{
        return(push_fancy_stringf(arena, line, face, fcolor_zero(),
                                  pre_margin, post_margin,
                                  "%-*.*s...", max - 3, (i32)(value).size, (char*)(value).str));
    }
}
static Fancy_String*
push_fancy_string_fixed(Arena *arena, Fancy_Line *line, FColor fore,
                        f32 pre_margin, f32 post_margin, String_Const_u8 value,
                        i32 max){
    if (value.size <= max){
        return(push_fancy_stringf(arena, line, 0, fore, pre_margin, post_margin,
                                  "%-*.*s", max, (i32)(value).size, (char*)(value).str));
    }
    else{
        return(push_fancy_stringf(arena, line, 0, fore, pre_margin, post_margin,
                                  "%-*.*s...", max - 3, (i32)(value).size, (char*)(value).str));
    }
}
static Fancy_String*
push_fancy_string_fixed(Arena *arena, Fancy_Line *line, Face_ID face,
                        String_Const_u8 value, i32 max){
    if (value.size <= max){
        return(push_fancy_stringf(arena, line, face, fcolor_zero(), 0.f, 0.f,
                                  "%-*.*s", max, (i32)(value).size, (char*)(value).str));
    }
    else{
        return(push_fancy_stringf(arena, line, face, fcolor_zero(), 0.f, 0.f,
                                  "%-*.*s...", max - 3, (i32)(value).size, (char*)(value).str));
    }
}
static Fancy_String*
push_fancy_string_fixed(Arena *arena, Fancy_Line *line, FColor fore,
                        String_Const_u8 value, i32 max){
    if (value.size <= max){
        return(push_fancy_stringf(arena, line, (Face_ID)0, fore, 0.f, 0.f,
                                  "%-*.*s", max, (i32)(value).size, (char*)(value).str));
    }
    else{
        return(push_fancy_stringf(arena, line, (Face_ID)0, fore, 0.f, 0.f,
                                  "%-*.*s...", max - 3, (i32)(value).size, (char*)(value).str));
    }
}
static Fancy_String*
push_fancy_string_fixed(Arena *arena, Fancy_Line *line,
                        f32 pre_margin, f32 post_margin, String_Const_u8 value,
                        i32 max){
    if (value.size <= max){
        return(push_fancy_stringf(arena, line, (Face_ID)0, fcolor_zero(),
                                  pre_margin, post_margin,
                                  "%-*.*s", max, (i32)(value).size, (char*)(value).str));
    }
    else{
        return(push_fancy_stringf(arena, line, (Face_ID)0, fcolor_zero(),
                                  pre_margin, post_margin,
                                  "%-*.*s...", max - 3, (i32)(value).size, (char*)(value).str));
    }
}
static Fancy_String*
push_fancy_string_fixed(Arena *arena, Fancy_Line *line, String_Const_u8 value,
                        i32 max){
    if (value.size <= max){
        return(push_fancy_stringf(arena, line, (Face_ID)0, fcolor_zero(), 0.f, 0.f,
                                  "%-*.*s", max, (i32)(value).size, (char*)(value).str));
    }
    else{
        return(push_fancy_stringf(arena, line, (Face_ID)0, fcolor_zero(), 0.f, 0.f,
                                  "%-*.*s...", max - 3, (i32)(value).size, (char*)(value).str));
    }
}

static Fancy_String*
push_fancy_string_trunc(Arena *arena, Fancy_Line *line, Face_ID face, FColor fore,
                        f32 pre_margin, f32 post_margin,
                        String_Const_u8 value, i32 max){
    if (value.size <= max){
        return(push_fancy_stringf(arena, line, face, fore, pre_margin, post_margin,
                                  "%.*s", (i32)(value).size, (char*)(value).str));
    }
    else{
        return(push_fancy_stringf(arena, line, face, fore, pre_margin, post_margin,
                                  "%.*s...", max - 3, value.str));
    }
}
static Fancy_String*
push_fancy_string_trunc(Arena *arena, Fancy_Line *line, Face_ID face, FColor fore,
                        String_Const_u8 value, i32 max){
    if (value.size <= max){
        return(push_fancy_stringf(arena, line, face, fore, 0.f, 0.f,
                                  "%.*s", (i32)(value).size, (char*)(value).str));
    }
    else{
        return(push_fancy_stringf(arena, line, face, fore, 0.f, 0.f,
                                  "%.*s...", max - 3, value.str));
    }
}
static Fancy_String*
push_fancy_string_trunc(Arena *arena, Fancy_Line *line, Face_ID face,
                        f32 pre_margin, f32 post_margin, String_Const_u8 value,
                        i32 max){
    if (value.size <= max){
        return(push_fancy_stringf(arena, line, face, fcolor_zero(),
                                  pre_margin, post_margin,
                                  "%.*s", (i32)(value).size, (char*)(value).str));
    }
    else{
        return(push_fancy_stringf(arena, line, face, fcolor_zero(),
                                  pre_margin, post_margin,
                                  "%.*s...", max - 3, value.str));
    }
}
static Fancy_String*
push_fancy_string_trunc(Arena *arena, Fancy_Line *line, FColor fore,
                        f32 pre_margin, f32 post_margin, String_Const_u8 value,
                        i32 max){
    if (value.size <= max){
        return(push_fancy_stringf(arena, line, 0, fore, pre_margin, post_margin,
                                  "%.*s", (i32)(value).size, (char*)(value).str));
    }
    else{
        return(push_fancy_stringf(arena, line, 0, fore, pre_margin, post_margin,
                                  "%.*s...", max - 3, value.str));
    }
}
static Fancy_String*
push_fancy_string_trunc(Arena *arena, Fancy_Line *line, Face_ID face,
                        String_Const_u8 value, i32 max){
    if (value.size <= max){
        return(push_fancy_stringf(arena, line, face, fcolor_zero(), 0.f, 0.f,
                                  "%.*s", (i32)(value).size, (char*)(value).str));
    }
    else{
        return(push_fancy_stringf(arena, line, face, fcolor_zero(), 0.f, 0.f,
                                  "%.*s...", max - 3, value.str));
    }
}
static Fancy_String*
push_fancy_string_trunc(Arena *arena, Fancy_Line *line, FColor fore,
                        String_Const_u8 value, i32 max){
    if (value.size <= max){
        return(push_fancy_stringf(arena, line, (Face_ID)0, fore, 0.f, 0.f,
                                  "%.*s", (i32)(value).size, (char*)(value).str));
    }
    else{
        return(push_fancy_stringf(arena, line, (Face_ID)0, fore, 0.f, 0.f,
                                  "%.*s...", max - 3, value.str));
    }
}
static Fancy_String*
push_fancy_string_trunc(Arena *arena, Fancy_Line *line,
                        f32 pre_margin, f32 post_margin, String_Const_u8 value,
                        i32 max){
    if (value.size <= max){
        return(push_fancy_stringf(arena, line, (Face_ID)0, fcolor_zero(),
                                  pre_margin, post_margin,
                                  "%.*s", (i32)(value).size, (char*)(value).str));
    }
    else{
        return(push_fancy_stringf(arena, line, (Face_ID)0, fcolor_zero(),
                                  pre_margin, post_margin,
                                  "%.*s...", max - 3, value.str));
    }
}
static Fancy_String*
push_fancy_string_trunc(Arena *arena, Fancy_Line *line, String_Const_u8 value,
                        i32 max){
    if (value.size <= max){
        return(push_fancy_stringf(arena, line, (Face_ID)0, fcolor_zero(), 0.f, 0.f,
                                  "%.*s", (i32)(value).size, (char*)(value).str));
    }
    else{
        return(push_fancy_stringf(arena, line, (Face_ID)0, fcolor_zero(), 0.f, 0.f,
                                  "%.*s...", max - 3, value.str));
    }
}



static Fancy_Line*
push_fancy_line(Arena *arena, Fancy_Block *block, Face_ID face, FColor fore,
                String_Const_u8 text){
    Fancy_Line *line = ((Fancy_Line*)linalloc_wrap_zero(linalloc_push((arena), sizeof(Fancy_Line)*(1), SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_fancy.cpp" ":" "503" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_fancy.cpp" ":" "503" ":") - 1)))));
    line->face = face;
    line->fore = fore;
    if (text.size != 0){
        push_fancy_string(arena, line, text);
    }
    if (block != 0){
        push_fancy_line(block, line);
    }
    return(line);
}
static Fancy_Line*
push_fancy_line(Arena *arena, Fancy_Block *block, Face_ID face, FColor fcolor){
    return(push_fancy_line(arena, block, face, fcolor, SCu8()));
}
static Fancy_Line*
push_fancy_line(Arena *arena, Fancy_Block *block, Face_ID face, String_Const_u8 val){
    return(push_fancy_line(arena, block, face, fcolor_zero(), val));
}
static Fancy_Line*
push_fancy_line(Arena *arena, Fancy_Block *block, FColor color, String_Const_u8 val){
    return(push_fancy_line(arena, block, 0, color, val));
}
static Fancy_Line*
push_fancy_line(Arena *arena, Fancy_Block *block, Face_ID face){
    return(push_fancy_line(arena, block, face, fcolor_zero(), SCu8()));
}
static Fancy_Line*
push_fancy_line(Arena *arena, Fancy_Block *block, FColor color){
    return(push_fancy_line(arena, block, 0, color, SCu8()));
}
static Fancy_Line*
push_fancy_line(Arena *arena, Fancy_Block *block, String_Const_u8 val){
    return(push_fancy_line(arena, block, 0, fcolor_zero(), val));
}
static Fancy_Line*
push_fancy_line(Arena *arena, Fancy_Block *block){
    return(push_fancy_line(arena, block, 0, fcolor_zero(), SCu8()));
}



static f32
get_fancy_string_width__inner(Application_Links *app, Face_ID face,
                              Fancy_String *string){
    f32 result = 0.f;
    for (;string != 0;
         string = string->next){
        Face_ID use_face = face;
        if (string->face != 0){
            use_face = string->face;
        }
        if (use_face != 0){
            result += get_string_advance(app, use_face, string->value);
            Face_Metrics metrics = get_face_metrics(app, use_face);
            f32 normal_advance = metrics.normal_advance;
            result += (string->pre_margin + string->post_margin)*normal_advance;
        }
    }
    return(result);
}

static f32
get_fancy_string_height__inner(Application_Links *app, Face_ID face, Fancy_String *string){
    f32 result = 0.f;
    if (face != 0){
        Face_Metrics metrics = get_face_metrics(app, face);
        result = metrics.line_height;
    }
    for (;string != 0;
         string = string->next){
        if (string->face != 0){
            Face_ID use_face = string->face;
            Face_Metrics metrics = get_face_metrics(app, use_face);
            result = (((result)>(metrics.line_height))?(result):(metrics.line_height));
        }
    }
    return(result);
}

static f32
get_fancy_string_text_height__inner(Application_Links *app, Face_ID face, Fancy_String *string){
    f32 result = 0.f;
    if (face != 0){
        Face_Metrics metrics = get_face_metrics(app, face);
        result = metrics.text_height;
    }
    for (;string != 0;
         string = string->next){
        if (string->face != 0){
            Face_ID use_face = string->face;
            Face_Metrics metrics = get_face_metrics(app, use_face);
            result = (((result)>(metrics.text_height))?(result):(metrics.text_height));
        }
    }
    return(result);
}

static Vec2_f32
draw_fancy_string__inner(Application_Links *app, Face_ID face, FColor fore, Fancy_String *first_string, Vec2_f32 p, u32 flags, Vec2_f32 delta){
    f32 base_line = 0.f;
    for (Fancy_String *string = first_string;
         string != 0;
         string = string->next){
        Face_ID use_face = face;
        if (string->face != 0){
            use_face = string->face;
        }
        if (use_face != 0){
            Face_Metrics metrics = get_face_metrics(app, use_face);
            base_line = (((base_line)>(metrics.ascent))?(base_line):(metrics.ascent));
        }
    }

    Vec2_f32 down_delta = V2f32(-delta.y, delta.x);
    for (Fancy_String *string = first_string;
         string != 0;
         string = string->next){
        Face_ID use_face = face;
        if (string->face != 0){
            use_face = string->face;
        }
        FColor use_fore = fore;
        if (fcolor_is_valid(string->fore)){
            use_fore = string->fore;
        }
        if (use_face != 0){
            ARGB_Color use_argb = fcolor_resolve(use_fore);
            Face_Metrics metrics = get_face_metrics(app, use_face);
            f32 down_shift = (base_line - metrics.ascent);
            down_shift = (((0.f)>(down_shift))?(0.f):(down_shift));
            Vec2_f32 p_shift = down_shift*down_delta;
            Vec2_f32 p_shifted = p + p_shift;

            if (fcolor_is_valid(use_fore)){
                Vec2_f32 margin_delta = delta*metrics.normal_advance;
                p_shifted += margin_delta*string->pre_margin;
                p_shifted = draw_string_oriented(app, use_face, use_argb, string->value, p_shifted, flags, delta);
                p_shifted += margin_delta*string->post_margin;
            }
            else{
                f32 adv =
                    (string->pre_margin + string->post_margin)*metrics.normal_advance;
                adv += get_string_advance(app, use_face, string->value);
                p_shifted += adv*delta;
            }

            p = p_shifted - p_shift;
        }
    }
    return(p);
}

static f32
get_fancy_string_width(Application_Links *app, Face_ID face,
                       Fancy_String *string){
    Fancy_String *next = string->next;
    string->next = 0;
    f32 result = get_fancy_string_width__inner(app, face, string);
    string->next = next;
    return(result);
}

static f32
get_fancy_string_height(Application_Links *app, Face_ID face,
                        Fancy_String *string){
    Fancy_String *next = string->next;
    string->next = 0;
    f32 result = get_fancy_string_height__inner(app, face, string);
    string->next = next;
    return(result);
}

static f32
get_fancy_string_text_height(Application_Links *app, Face_ID face,
                             Fancy_String *string){
    Fancy_String *next = string->next;
    string->next = 0;
    f32 result = get_fancy_string_text_height__inner(app, face, string);
    string->next = next;
    return(result);
}

static Vec2_f32
get_fancy_string_dim(Application_Links *app, Face_ID face, Fancy_String *string){
    Fancy_String *next = string->next;
    string->next = 0;
    Vec2_f32 result = V2f32(get_fancy_string_width__inner(app, face, string),
                            get_fancy_string_height__inner(app, face, string));
    string->next = next;
    return(result);
}

static Vec2_f32
draw_fancy_string(Application_Links *app, Face_ID face, FColor fore,
                  Fancy_String *string, Vec2_f32 p, u32 flags, Vec2_f32 delta){
    Fancy_String *next = string->next;
    string->next = 0;
    Vec2_f32 result = draw_fancy_string__inner(app, face, fore, string, p, flags, delta);
    string->next = next;
    return(result);
}

static f32
get_fancy_line_width(Application_Links *app, Face_ID face, Fancy_Line *line){
    f32 result = 0.f;
    if (line != 0){
        if (line->face != 0){
            face = line->face;
        }
        result = get_fancy_string_width__inner(app, face, line->first);
    }
    return(result);
}

static f32
get_fancy_line_height(Application_Links *app, Face_ID face, Fancy_Line *line){
    f32 result = 0.f;
    if (line != 0){
        if (line->face != 0){
            face = line->face;
        }
        result = get_fancy_string_height__inner(app, face, line->first);
    }
    return(result);
}

static f32
get_fancy_line_text_height(Application_Links *app, Face_ID face, Fancy_Line *line){
    f32 result = 0.f;
    if (line != 0){
        if (line->face != 0){
            face = line->face;
        }
        result = get_fancy_string_text_height__inner(app, face, line->first);
    }
    return(result);
}

static Vec2_f32
get_fancy_line_dim(Application_Links *app, Face_ID face, Fancy_Line *line){
    Vec2_f32 result = {};
    if (line != 0){
        if (line->face != 0){
            face = line->face;
        }
        result = V2f32(get_fancy_string_width__inner(app, face, line->first), get_fancy_string_height__inner(app, face, line->first));
    }
    return(result);
}

static Vec2_f32
draw_fancy_line(Application_Links *app, Face_ID face, FColor fore,
                Fancy_Line *line, Vec2_f32 p, u32 flags, Vec2_f32 delta){
    Vec2_f32 result = {};
    if (line != 0){
        if (line->face != 0){
            face = line->face;
        }
        if (fcolor_is_valid(line->fore)){
            fore = line->fore;
        }
        result = draw_fancy_string__inner(app, face, fore, line->first, p, flags, delta);
    }
    return(result);
}

static f32
get_fancy_block_width(Application_Links *app, Face_ID face, Fancy_Block *block){
    f32 width = 0.f;
    for (Fancy_Line *node = block->first;
         node != 0;
         node = node->next){
        f32 w = get_fancy_line_width(app, face, node);
        width = (((width)>(w))?(width):(w));
    }
    return(width);
}

static f32
get_fancy_block_height(Application_Links *app, Face_ID face, Fancy_Block *block){
    f32 height = 0.f;
    for (Fancy_Line *node = block->first;
         node != 0;
         node = node->next){
        height += get_fancy_line_height(app, face, node);
    }
    return(height);
}

static Vec2_f32
get_fancy_block_dim(Application_Links *app, Face_ID face, Fancy_Block *block){
    Vec2_f32 result = {};
    result.x = get_fancy_block_width(app, face, block);
    result.y = get_fancy_block_height(app, face, block);
    return(result);
}

static void
draw_fancy_block(Application_Links *app, Face_ID face, FColor fore,
                 Fancy_Block *block, Vec2_f32 p, u32 flags, Vec2_f32 delta){
    for (Fancy_Line *node = block->first;
         node != 0;
         node = node->next){
        draw_fancy_line(app, face, fore, node, p, flags, delta);
        p.y += get_fancy_line_height(app, face, node);
    }
}

static Vec2_f32
draw_fancy_string(Application_Links *app, Face_ID face, FColor fore,
                  Fancy_String *string, Vec2_f32 p){
    return(draw_fancy_string(app, face, fore, string, p, 0, V2f32(1.f, 0.f)));
}

static Vec2_f32
draw_fancy_string(Application_Links *app, Fancy_String *string, Vec2_f32 p){
    return(draw_fancy_string(app, 0, fcolor_zero(), string, p, 0, V2f32(1.f, 0.f)));
}

static Vec2_f32
draw_fancy_line(Application_Links *app, Face_ID face, FColor fore,
                Fancy_Line *line, Vec2_f32 p){
    return(draw_fancy_line(app, face, fore, line, p, 0, V2f32(1.f, 0.f)));
}

static void
draw_fancy_block(Application_Links *app, Face_ID face, FColor fore,
                 Fancy_Block *block, Vec2_f32 p){
    draw_fancy_block(app, face, fore, block, p, 0, V2f32(1.f, 0.f));
}




static FColor f_white = fcolor_argb(1.0f, 1.0f, 1.0f, 1.0f);
static FColor f_light_gray = fcolor_argb(0.7f, 0.7f, 0.7f, 1.0f);
static FColor f_gray = fcolor_argb(0.5f, 0.5f, 0.5f, 1.0f);
static FColor f_dark_gray = fcolor_argb(0.3f, 0.3f, 0.3f, 1.0f);
static FColor f_black = fcolor_argb(0.0f, 0.0f, 0.0f, 1.0f);
static FColor f_red = fcolor_argb(1.0f, 0.0f, 0.0f, 1.0f);
static FColor f_green = fcolor_argb(0.0f, 1.0f, 0.0f, 1.0f);
static FColor f_blue = fcolor_argb(0.0f, 0.0f, 1.0f, 1.0f);
static FColor f_yellow = fcolor_argb(1.0f, 1.0f, 0.0f, 1.0f);
static FColor f_pink = fcolor_argb(1.0f, 0.0f, 1.0f, 1.0f);
static FColor f_cyan = fcolor_argb(0.0f, 1.0f, 1.0f, 1.0f);
# 99 "/home/sam/.bin/4coder/custom/4coder_default_include.cpp" 2
# 1 "/home/sam/.bin/4coder/custom/4coder_draw.cpp" 1






static void
draw_text_layout_default(Application_Links *app, Text_Layout_ID layout_id){
    ARGB_Color special_color = finalize_color(defcolor_special_character, 0);
    ARGB_Color ghost_color = finalize_color(defcolor_ghost_character, 0);
    draw_text_layout(app, layout_id, special_color, ghost_color);
}

static FColor
get_item_margin_color(i32 level, i32 sub_id){
    FColor margin = fcolor_zero();
    switch (level){
        default:
        case UIHighlight_None:
        {
            margin = fcolor_id(defcolor_list_item, sub_id);
        }break;
        case UIHighlight_Hover:
        {
            margin = fcolor_id(defcolor_list_item_hover, sub_id);
        }break;
        case UIHighlight_Active:
        {
            margin = fcolor_id(defcolor_list_item_active, sub_id);
        }break;
    }
    return(margin);
}
static FColor
get_item_margin_color(i32 level){
    return(get_item_margin_color(level, 0));
}
static FColor
get_panel_margin_color(i32 level){
    FColor margin = fcolor_zero();
    switch (level){
        default:
        case UIHighlight_None:
        {
            margin = fcolor_id(defcolor_margin);
        }break;
        case UIHighlight_Hover:
        {
            margin = fcolor_id(defcolor_margin_hover);
        }break;
        case UIHighlight_Active:
        {
            margin = fcolor_id(defcolor_margin_active);
        }break;
    }
    return(margin);
}

static Vec2_f32
draw_string(Application_Links *app, Face_ID font_id, String_Const_u8 string, Vec2_f32 p, ARGB_Color color){
    return(draw_string_oriented(app, font_id, color, string, p, 0, V2f32(1.f, 0.f)));
}

static Vec2_f32
draw_string(Application_Links *app, Face_ID font_id, String_Const_u8 string, Vec2_f32 p, FColor color){
    ARGB_Color argb = fcolor_resolve(color);
    return(draw_string(app, font_id, string, p, argb));
}

static void
draw_rectangle_fcolor(Application_Links *app, Rect_f32 rect, f32 roundness, FColor color){
    ARGB_Color argb = fcolor_resolve(color);
    draw_rectangle(app, rect, roundness, argb);
}

static void
draw_rectangle_outline_fcolor(Application_Links *app, Rect_f32 rect, f32 roundness, f32 thickness, FColor color){
    ARGB_Color argb = fcolor_resolve(color);
    draw_rectangle_outline(app, rect, roundness, thickness, argb);
}

static void
draw_margin(Application_Links *app, Rect_f32 outer, Rect_f32 inner, ARGB_Color color){
    draw_rectangle(app, Rf32(outer.x0, outer.y0, outer.x1, inner.y0), 0.f, color);
    draw_rectangle(app, Rf32(outer.x0, inner.y1, outer.x1, outer.y1), 0.f, color);
    draw_rectangle(app, Rf32(outer.x0, inner.y0, inner.x0, inner.y1), 0.f, color);
    draw_rectangle(app, Rf32(inner.x1, inner.y0, outer.x1, inner.y1), 0.f, color);
}

static void
draw_margin(Application_Links *app, Rect_f32 outer, Rect_f32 inner, FColor color){
    ARGB_Color argb = fcolor_resolve(color);
    draw_margin(app, outer, inner, argb);
}

static void
draw_character_block(Application_Links *app, Text_Layout_ID layout, i64 pos, f32 roundness, ARGB_Color color){
    Rect_f32 rect = text_layout_character_on_screen(app, layout, pos);
    draw_rectangle(app, rect, roundness, color);
}

static void
draw_character_block(Application_Links *app, Text_Layout_ID layout, i64 pos, f32 roundness, FColor color){
    ARGB_Color argb = fcolor_resolve(color);
    draw_character_block(app, layout, pos, roundness, argb);
}

static void
draw_character_block(Application_Links *app, Text_Layout_ID layout, Range_i64 range, f32 roundness, ARGB_Color color){
    if (range.first < range.one_past_last){
        i64 i = range.first;
        Rect_f32 first_rect = text_layout_character_on_screen(app, layout, i);
        i += 1;
        Range_f32 y = rect_range_y(first_rect);
        Range_f32 x = rect_range_x(first_rect);
        for (;i < range.one_past_last; i += 1){
            Rect_f32 rect = text_layout_character_on_screen(app, layout, i);
            if (rect.x0 < rect.x1 && rect.y0 < rect.y1){
                Range_f32 new_y = rect_range_y(rect);
                Range_f32 new_x = rect_range_x(rect);
                b32 joinable = false;
                if (new_y == y && (range_overlap(x, new_x) || x.max == new_x.min || new_x.max == x.min)){
                    joinable = true;
                }

                if (!joinable){
                    draw_rectangle(app, Rf32(x, y), roundness, color);
                    y = new_y;
                    x = new_x;
                }
                else{
                    x = range_union(x, new_x);
                }
            }
        }
        draw_rectangle(app, Rf32(x, y), roundness, color);
    }
}

static void
draw_character_block(Application_Links *app, Text_Layout_ID layout, Range_i64 range, f32 roundness, FColor color){
    ARGB_Color argb = fcolor_resolve(color);
    draw_character_block(app, layout, range, roundness, argb);
}

static void
draw_character_wire_frame(Application_Links *app, Text_Layout_ID layout, i64 pos, f32 roundness, f32 thickness, ARGB_Color color){
    Rect_f32 rect = text_layout_character_on_screen(app, layout, pos);
    draw_rectangle_outline(app, rect, roundness, thickness, color);
}

static void
draw_character_wire_frame(Application_Links *app, Text_Layout_ID layout, i64 pos, f32 roundness, f32 thickness, FColor color){
    ARGB_Color argb = fcolor_resolve(color);
    draw_character_wire_frame(app, layout, pos, roundness, thickness, argb);
}

static void
draw_character_wire_frame(Application_Links *app, Text_Layout_ID layout, Range_i64 range, f32 roundness, f32 thickness, FColor color){
    for (i64 i = range.first; i < range.one_past_last; i += 1){
        draw_character_wire_frame(app, layout, i, roundness, thickness, color);
    }
}

static void
draw_character_i_bar(Application_Links *app, Text_Layout_ID layout, i64 pos, ARGB_Color color){
    Rect_f32 rect = text_layout_character_on_screen(app, layout, pos);
    rect.x1 = rect.x0 + 1.f;
    draw_rectangle(app, rect, 0.f, color);
}

static void
draw_character_i_bar(Application_Links *app, Text_Layout_ID layout, i64 pos, FColor color){
    ARGB_Color argb = fcolor_resolve(color);
    draw_character_i_bar(app, layout, pos, argb);
}

static void
draw_line_highlight(Application_Links *app, Text_Layout_ID layout, Range_i64 line_range, ARGB_Color color){
    Range_f32 y1 = text_layout_line_on_screen(app, layout, line_range.min);
    Range_f32 y2 = text_layout_line_on_screen(app, layout, line_range.max);
    Range_f32 y = range_union(y1, y2);
    if (range_size(y) > 0.f){
        Rect_f32 region = text_layout_region(app, layout);
        draw_rectangle(app, Rf32(rect_range_x(region), y), 0.f, color);
    }
}

static void
draw_line_highlight(Application_Links *app, Text_Layout_ID layout, Range_i64 line_range, FColor color){
    ARGB_Color argb = fcolor_resolve(color);
    draw_line_highlight(app, layout, line_range, argb);
}

static void
draw_line_highlight(Application_Links *app, Text_Layout_ID layout, i64 line, ARGB_Color color){
    draw_line_highlight(app, layout, Ii64(line), color);
}

static void
draw_line_highlight(Application_Links *app, Text_Layout_ID layout, i64 line, FColor color){
    draw_line_highlight(app, layout, Ii64(line), color);
}

static void
paint_text_color_fcolor(Application_Links *app, Text_Layout_ID layout, Range_i64 pos, FColor color){
    ARGB_Color argb = fcolor_resolve(color);
    paint_text_color(app, layout, pos, argb);
}

static void
paint_text_color_pos(Application_Links *app, Text_Layout_ID layout, i64 pos, ARGB_Color color){
    paint_text_color(app, layout, Ii64(pos, pos + 1), color);
}

static void
paint_text_color_pos(Application_Links *app, Text_Layout_ID layout, i64 pos, FColor color){
    ARGB_Color argb = fcolor_resolve(color);
    paint_text_color_pos(app, layout, pos, argb);
}



static Rect_f32_Pair
layout_file_bar_on_top(Rect_f32 rect, f32 line_height){
    return(rect_split_top_bottom(rect, line_height + 2.f));
}

static Rect_f32_Pair
layout_file_bar_on_bot(Rect_f32 rect, f32 line_height){
    return(rect_split_top_bottom_neg(rect, line_height + 2.f));
}

static Rect_f32_Pair
layout_query_bar_on_top(Rect_f32 rect, f32 line_height, i32 bar_count){
    return(rect_split_top_bottom(rect, (line_height + 2.f)*bar_count));
}

static Rect_f32_Pair
layout_query_bar_on_bot(Rect_f32 rect, f32 line_height, i32 bar_count){
    return(rect_split_top_bottom_neg(rect, (line_height + 2.f)*bar_count));
}

static Rect_f32_Pair
layout_line_number_margin(Rect_f32 rect, f32 digit_advance, i64 digit_count){
    f32 margin_width = (f32)digit_count*digit_advance + 2.f;
    return(rect_split_left_right(rect, margin_width));
}

static Rect_f32_Pair
layout_line_number_margin(Application_Links *app, Buffer_ID buffer, Rect_f32 rect, f32 digit_advance){
    i64 line_count = buffer_get_line_count(app, buffer);
    i64 line_count_digit_count = digit_count_from_integer(line_count, 10);
    return(layout_line_number_margin(rect, digit_advance, line_count_digit_count));
}

static const i32 fps_history_depth = 10;
static Rect_f32_Pair
layout_fps_hud_on_bottom(Rect_f32 rect, f32 line_height){
    return(rect_split_top_bottom_neg(rect, line_height*fps_history_depth));
}

static Rect_f32
draw_background_and_margin(Application_Links *app, View_ID view, ARGB_Color margin, ARGB_Color back, f32 width){
    Rect_f32 view_rect = view_get_screen_rect(app, view);
    Rect_f32 inner = rect_inner(view_rect, width);
    draw_rectangle(app, inner, 0.f, back);
    if (width > 0.f){
        draw_margin(app, view_rect, inner, margin);
    }
    return(inner);
}

static Rect_f32
draw_background_and_margin(Application_Links *app, View_ID view, ARGB_Color margin, ARGB_Color back){
    return(draw_background_and_margin(app, view, margin, back, 3.f));
}

static Rect_f32
draw_background_and_margin(Application_Links *app, View_ID view, FColor margin, FColor back, f32 width){
    ARGB_Color margin_argb = fcolor_resolve(margin);
    ARGB_Color back_argb = fcolor_resolve(back);
    return(draw_background_and_margin(app, view, margin_argb, back_argb, width));
}

static Rect_f32
draw_background_and_margin(Application_Links *app, View_ID view, FColor margin, FColor back){
    ARGB_Color margin_argb = fcolor_resolve(margin);
    ARGB_Color back_argb = fcolor_resolve(back);
    return(draw_background_and_margin(app, view, margin_argb, back_argb, 3.f));
}

static Rect_f32
draw_background_and_margin(Application_Links *app, View_ID view, b32 is_active_view, f32 width){
    FColor margin_color = get_panel_margin_color(is_active_view?UIHighlight_Active:UIHighlight_None);
    return(draw_background_and_margin(app, view, margin_color, fcolor_id(defcolor_back), width));
}

static Rect_f32
draw_background_and_margin(Application_Links *app, View_ID view, b32 is_active_view){
    FColor margin_color = get_panel_margin_color(is_active_view?UIHighlight_Active:UIHighlight_None);
    return(draw_background_and_margin(app, view, margin_color, fcolor_id(defcolor_back), 3.f));
}

static Rect_f32
draw_background_and_margin(Application_Links *app, View_ID view){
    View_ID active_view = get_active_view(app, Access_Always);
    b32 is_active_view = (active_view == view);
    return(draw_background_and_margin(app, view, is_active_view));
}

static void
draw_file_bar(Application_Links *app, View_ID view_id, Buffer_ID buffer, Face_ID face_id, Rect_f32 bar){
    Scratch_Block scratch(app);

    draw_rectangle_fcolor(app, bar, 0.f, fcolor_id(defcolor_bar));

    FColor base_color = fcolor_id(defcolor_base);
    FColor pop2_color = fcolor_id(defcolor_pop2);

    i64 cursor_position = view_get_cursor_pos(app, view_id);
    Buffer_Cursor cursor = view_compute_cursor(app, view_id, seek_pos(cursor_position));

    Fancy_Line list = {};
    String_Const_u8 unique_name = push_buffer_unique_name(app, scratch, buffer);
    push_fancy_string(scratch, &list, base_color, unique_name);
    push_fancy_stringf(scratch, &list, base_color, " - Row: %3.lld Col: %3.lld -", cursor.line, cursor.col);

    Managed_Scope scope = buffer_get_managed_scope(app, buffer);
    Line_Ending_Kind *eol_setting = ((Line_Ending_Kind*)managed_scope_get_attachment((app), (scope), (buffer_eol_setting), sizeof(Line_Ending_Kind)))
                                                                      ;
    switch (*eol_setting){
        case LineEndingKind_Binary:
        {
            push_fancy_string(scratch, &list, base_color, SCu8((u8*)(" bin"), (u64)(sizeof(" bin") - 1)));
        }break;

        case LineEndingKind_LF:
        {
            push_fancy_string(scratch, &list, base_color, SCu8((u8*)(" lf"), (u64)(sizeof(" lf") - 1)));
        }break;

        case LineEndingKind_CRLF:
        {
            push_fancy_string(scratch, &list, base_color, SCu8((u8*)(" crlf"), (u64)(sizeof(" crlf") - 1)));
        }break;
    }

    u8 space[3];
    {
        Dirty_State dirty = buffer_get_dirty_state(app, buffer);
        String_u8 str = Su8(space, 0, 3);
        if (dirty != 0){
            string_append(&str, SCu8((u8*)(" "), (u64)(sizeof(" ") - 1)));
        }
        if ((((dirty)&(DirtyState_UnsavedChanges))!=0)){
            string_append(&str, SCu8((u8*)("*"), (u64)(sizeof("*") - 1)));
        }
        if ((((dirty)&(DirtyState_UnloadedChanges))!=0)){
            string_append(&str, SCu8((u8*)("!"), (u64)(sizeof("!") - 1)));
        }
        push_fancy_string(scratch, &list, pop2_color, str.string);
    }

    Vec2_f32 p = bar.p0 + V2f32(2.f, 2.f);
    draw_fancy_line(app, face_id, fcolor_zero(), &list, p);
}

static void
draw_query_bar(Application_Links *app, Query_Bar *query_bar, Face_ID face_id, Rect_f32 bar){
    Scratch_Block scratch(app);
    Fancy_Line list = {};
    push_fancy_string(scratch, &list, fcolor_id(defcolor_pop1) , query_bar->prompt);
    push_fancy_string(scratch, &list, fcolor_id(defcolor_text_default), query_bar->string);
    Vec2_f32 p = bar.p0 + V2f32(2.f, 2.f);
    draw_fancy_line(app, face_id, fcolor_zero(), &list, p);
}

static void
draw_line_number_margin(Application_Links *app, View_ID view_id, Buffer_ID buffer, Face_ID face_id, Text_Layout_ID text_layout_id, Rect_f32 margin){
    Profile_Scope_Block profile_block_381 ((app), SCu8((u8*)("draw line number margin"), (u64)(sizeof("draw line number margin") - 1)), SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_draw.cpp" ":" "381" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_draw.cpp" ":" "381" ":") - 1)));

    Scratch_Block scratch(app);
    FColor line_color = fcolor_id(defcolor_line_numbers_text);

    Rect_f32 prev_clip = draw_set_clip(app, margin);
    draw_rectangle_fcolor(app, margin, 0.f, fcolor_id(defcolor_line_numbers_back));

    Range_i64 visible_range = text_layout_get_visible_range(app, text_layout_id);
    i64 line_count = buffer_get_line_count(app, buffer);
    i64 line_count_digit_count = digit_count_from_integer(line_count, 10);

    Fancy_String fstring = {};
    u8 *digit_buffer = ((u8*)linalloc_wrap_unintialized(linalloc_push((scratch), sizeof(u8)*(line_count_digit_count), SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_draw.cpp" ":" "394" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_draw.cpp" ":" "394" ":") - 1)))));
    String_Const_u8 digit_string = SCu8(digit_buffer, line_count_digit_count);
    for (i32 i = 0; i < line_count_digit_count; i += 1){
        digit_buffer[i] = ' ';
    }

    Buffer_Cursor cursor = view_compute_cursor(app, view_id, seek_pos(visible_range.first));
    i64 line_number = cursor.line;

    Buffer_Cursor cursor_opl = view_compute_cursor(app, view_id, seek_pos(visible_range.one_past_last));
    i64 one_past_last_line_number = cursor_opl.line + 1;

    u8 *small_digit = digit_buffer + line_count_digit_count - 1;
    {
        u8 *ptr = small_digit;
        if (line_number == 0){
            *ptr = '0';
        }
        else{
            for (u64 X = line_number; X > 0; X /= 10){
                *ptr = '0' + (X%10);
                ptr -= 1;
            }
        }
    }

    for (;line_number < one_past_last_line_number &&
         line_number < line_count;){
        Range_f32 line_y = text_layout_line_on_screen(app, text_layout_id, line_number);
        Vec2_f32 p = V2f32(margin.x0, line_y.min);

        fill_fancy_string(&fstring, 0, line_color, 0, 0, digit_string);
        draw_fancy_string(app, face_id, fcolor_zero(), &fstring, p);

        line_number += 1;
        {
            u8 *ptr = small_digit;
            for (;;){
                if (ptr < digit_buffer){
                    break;
                }
                if (*ptr == ' '){
                    *ptr = '0';
                }
                if (*ptr == '9'){
                    *ptr = '0';
                    ptr -= 1;
                }
                else{
                    *ptr += 1;
                    break;
                }
            }
        }
    }

    draw_set_clip(app, prev_clip);
}

static void
draw_fps_hud(Application_Links *app, Frame_Info frame_info, Face_ID face_id, Rect_f32 rect){
    Face_Metrics face_metrics = get_face_metrics(app, face_id);
    f32 line_height = face_metrics.line_height;

    static f32 history_literal_dt[fps_history_depth] = {};
    static f32 history_animation_dt[fps_history_depth] = {};
    static i32 history_frame_index[fps_history_depth] = {};

    i32 wrapped_index = frame_info.index%fps_history_depth;
    history_literal_dt[wrapped_index] = frame_info.literal_dt;
    history_animation_dt[wrapped_index] = frame_info.animation_dt;
    history_frame_index[wrapped_index] = frame_info.index;

    draw_rectangle_fcolor(app, rect, 0.f, f_black);
    draw_rectangle_outline_fcolor(app, rect, 0.f, 1.f, f_white);

    Vec2_f32 p = rect.p0;

    Scratch_Block scratch(app);

    Range_i32 ranges[2] = {};
    ranges[0].first = wrapped_index;
    ranges[0].one_past_last = -1;
    ranges[1].first = fps_history_depth - 1;
    ranges[1].one_past_last = wrapped_index;
    for (i32 i = 0; i < 2; i += 1){
        Range_i32 r = ranges[i];
        for (i32 j = r.first; j > r.one_past_last; j -= 1, p.y += line_height){
            f32 dts[2];
            dts[0] = history_literal_dt[j];
            dts[1] = history_animation_dt[j];
            i32 frame_index = history_frame_index[j];

            Fancy_Line list = {};
            push_fancy_stringf(scratch, &list, f_pink , "FPS: ");
            push_fancy_stringf(scratch, &list, f_green, "[");
            push_fancy_stringf(scratch, &list, f_white, "%5d", frame_index);
            push_fancy_stringf(scratch, &list, f_green, "]: ");

            for (i32 k = 0; k < 2; k += 1){
                f32 dt = dts[k];
                if (dt == 0.f){
                    push_fancy_stringf(scratch, &list, f_white, "----------");
                }
                else{
                    push_fancy_stringf(scratch, &list, f_white, "%10.6f", dt);
                }
                push_fancy_stringf(scratch, &list, f_green, " | ");
            }

            draw_fancy_line(app, face_id, fcolor_zero(), &list, p);
        }
    }
}

static FColor
get_token_color_cpp(Token token){
    Managed_ID color = defcolor_text_default;
    switch (token.kind){
        case TokenBaseKind_Preprocessor:
        {
            color = defcolor_preproc;
        }break;
        case TokenBaseKind_Keyword:
        {
            color = defcolor_keyword;
        }break;
        case TokenBaseKind_Comment:
        {
            color = defcolor_comment;
        }break;
        case TokenBaseKind_LiteralString:
        {
            color = defcolor_str_constant;
        }break;
        case TokenBaseKind_LiteralInteger:
        {
            color = defcolor_int_constant;
        }break;
        case TokenBaseKind_LiteralFloat:
        {
            color = defcolor_float_constant;
        }break;
    }

    switch (token.sub_kind){
        case TokenCppKind_LiteralTrue:
        case TokenCppKind_LiteralFalse:
        {
            color = defcolor_bool_constant;
        }break;
        case TokenCppKind_LiteralCharacter:
        case TokenCppKind_LiteralCharacterWide:
        case TokenCppKind_LiteralCharacterUTF8:
        case TokenCppKind_LiteralCharacterUTF16:
        case TokenCppKind_LiteralCharacterUTF32:
        {
            color = defcolor_char_constant;
        }break;
        case TokenCppKind_PPIncludeFile:
        {
            color = defcolor_include;
        }break;
    }
    FColor result = fcolor_id(color);
    return(result);
}

static void
draw_cpp_token_colors(Application_Links *app, Text_Layout_ID text_layout_id, Token_Array *array){
    Range_i64 visible_range = text_layout_get_visible_range(app, text_layout_id);
    i64 first_index = token_index_from_pos(array, visible_range.first);
    Token_Iterator_Array it = token_iterator_index(0, array, first_index);
    for (;;){
        Token *token = token_it_read(&it);
        if (token->pos >= visible_range.one_past_last){
            break;
        }
        FColor color = get_token_color_cpp(*token);
        ARGB_Color argb = fcolor_resolve(color);
        paint_text_color(app, text_layout_id, Ii64_size(token->pos, token->size), argb);
        if (!token_it_inc_all(&it)){
            break;
        }
    }
}

static void
draw_whitespace_highlight(Application_Links *app, Text_Layout_ID text_layout_id, Token_Array *array, f32 roundness){
    Range_i64 visible_range = text_layout_get_visible_range(app, text_layout_id);
    i64 first_index = token_index_from_pos(array, visible_range.first);
    Token_Iterator_Array it = token_iterator_index(0, array, first_index);
    for (;;){
        Token *token = token_it_read(&it);
        if (token->pos >= visible_range.one_past_last){
            break;
        }
        if (token->kind == TokenBaseKind_Whitespace){
            Range_i64 range = Ii64(token);
            draw_character_block(app, text_layout_id, range, roundness,
                                 fcolor_id(defcolor_highlight_white));
        }
        if (!token_it_inc_all(&it)){
            break;
        }
    }
}

static void
draw_whitespace_highlight(Application_Links *app, Buffer_ID buffer, Text_Layout_ID text_layout_id, f32 roundness){
    Range_i64 visible_range = text_layout_get_visible_range(app, text_layout_id);
    for (i64 i = visible_range.first; i < visible_range.one_past_last;){
        u8 c = buffer_get_char(app, buffer, i);
        if (character_is_whitespace(c)){
            i64 s = i;
            i += 1;
            for (; i < visible_range.one_past_last; i += 1){
                c = buffer_get_char(app, buffer, i);
                if (!character_is_whitespace(c)){
                    break;
                }
            }
            Range_i64 range = Ii64(s, i);
            draw_character_block(app, text_layout_id, range, roundness,
                                 fcolor_id(defcolor_highlight_white));
        }
        else{
            i += 1;
        }
    }
}

static void
draw_comment_highlights(Application_Links *app, Buffer_ID buffer, Text_Layout_ID text_layout_id,
                        Token_Array *array, Comment_Highlight_Pair *pairs, i32 pair_count){
    Scratch_Block scratch(app);
    Range_i64 visible_range = text_layout_get_visible_range(app, text_layout_id);
    i64 first_index = token_index_from_pos(array, visible_range.first);
    Token_Iterator_Array it = token_iterator_index(buffer, array, first_index);
    for (;;){
        Temp_Memory_Block temp(scratch);
        Token *token = token_it_read(&it);
        if (token->pos >= visible_range.one_past_last){
            break;
        }
        String_Const_u8 tail = {};
        if (token_it_check_and_get_lexeme(app, scratch, &it, TokenBaseKind_Comment, &tail)){
            for (i64 index = token->pos;
                 tail.size > 0;
                 tail = string_skip(tail, 1), index += 1){
                Comment_Highlight_Pair *pair = pairs;
                for (i32 i = 0; i < pair_count; i += 1, pair += 1){
                    u64 needle_size = pair->needle.size;
                    if (needle_size == 0){
                        continue;
                    }
                    String_Const_u8 prefix = string_prefix(tail, needle_size);
                    if (string_match(prefix, pair->needle)){
                        Range_i64 range = Ii64_size(index, needle_size);
                        paint_text_color(app, text_layout_id, range, pair->color);
                        tail = string_skip(tail, needle_size - 1);
                        index += needle_size - 1;
                        break;
                    }
                }
            }
        }
        if (!token_it_inc_non_whitespace(&it)){
            break;
        }
    }
}

static Range_i64_Array
get_enclosure_ranges(Application_Links *app, Arena *arena, Buffer_ID buffer, i64 pos, u32 flags){
    Range_i64_Array array = {};
    i32 max = 100;
    array.ranges = ((Range_i64*)linalloc_wrap_unintialized(linalloc_push((arena), sizeof(Range_i64)*(max), SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_draw.cpp" ":" "671" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_draw.cpp" ":" "671" ":") - 1)))));
    for (;;){
        Range_i64 range = {};
        if (find_surrounding_nest(app, buffer, pos, flags, &range)){
            array.ranges[array.count] = range;
            array.count += 1;
            pos = range.first;
            if (array.count >= max){
                break;
            }
        }
        else{
            break;
        }
    }
    return(array);
}

static void
draw_enclosures(Application_Links *app, Text_Layout_ID text_layout_id, Buffer_ID buffer,
                i64 pos, u32 flags, Range_Highlight_Kind kind,
                ARGB_Color *back_colors, i32 back_count,
                ARGB_Color *fore_colors, i32 fore_count){
    Scratch_Block scratch(app);
    Range_i64_Array ranges = get_enclosure_ranges(app, scratch, buffer, pos, flags);

    i32 color_index = 0;
    for (i32 i = ranges.count - 1; i >= 0; i -= 1){
        Range_i64 range = ranges.ranges[i];
        if (kind == RangeHighlightKind_LineHighlight){
            Range_i64 r[2] = {};
            if (i > 0){
                Range_i64 inner_range = ranges.ranges[i - 1];
                Range_i64 lines = get_line_range_from_pos_range(app, buffer, range);
                Range_i64 inner_lines = get_line_range_from_pos_range(app, buffer, inner_range);
                inner_lines.min = (((lines.min)>(inner_lines.min))?(lines.min):(inner_lines.min));
                inner_lines.max = (((inner_lines.max)<(lines.max))?(inner_lines.max):(lines.max));
                inner_lines.min -= 1;
                inner_lines.max += 1;
                if (lines.min <= inner_lines.min){
                    r[0] = Ii64(lines.min, inner_lines.min);
                }
                if (inner_lines.max <= lines.max){
                    r[1] = Ii64(inner_lines.max, lines.max);
                }
            }
            else{
                r[0] = get_line_range_from_pos_range(app, buffer, range);
            }
            for (i32 j = 0; j < 2; j += 1){
                if (r[j].min == 0){
                    continue;
                }
                Range_i64 line_range = r[j];
                if (back_colors != 0){
                    i32 back_index = color_index%back_count;
                    draw_line_highlight(app, text_layout_id, line_range, back_colors[back_index]);
                }
                if (fore_colors != 0){
                    i32 fore_index = color_index%fore_count;
                    Range_i64 pos_range = get_pos_range_from_line_range(app, buffer, line_range);
                    paint_text_color(app, text_layout_id, pos_range, fore_colors[fore_index]);
                }
            }
        }
        else{
            if (back_colors != 0){
                i32 back_index = color_index%back_count;
                draw_character_block(app, text_layout_id, range.min, 0.f, back_colors[back_index]);
                draw_character_block(app, text_layout_id, range.max - 1, 0.f, back_colors[back_index]);
            }
            if (fore_colors != 0){
                i32 fore_index = color_index%fore_count;
                paint_text_color_pos(app, text_layout_id, range.min, fore_colors[fore_index]);
                paint_text_color_pos(app, text_layout_id, range.max - 1, fore_colors[fore_index]);
            }
        }
        color_index += 1;
    }
}

static void
draw_scope_highlight(Application_Links *app, Buffer_ID buffer, Text_Layout_ID text_layout_id,
                     i64 pos, ARGB_Color *colors, i32 color_count){
    draw_enclosures(app, text_layout_id, buffer,
                    pos, FindNest_Scope, RangeHighlightKind_LineHighlight,
                    colors, color_count, 0, 0);
}

static void
draw_paren_highlight(Application_Links *app, Buffer_ID buffer, Text_Layout_ID text_layout_id,
                     i64 pos, ARGB_Color *colors, i32 color_count){
    Token_Array token_array = get_token_array_from_buffer(app, buffer);
    if (token_array.tokens != 0){
        Token_Iterator_Array it = token_iterator_pos(0, &token_array, pos);
        Token *token = token_it_read(&it);
        if (token != 0 && token->kind == TokenBaseKind_ParentheticalOpen){
            pos = token->pos + token->size;
        }
        else{
            if (token_it_dec_all(&it)){
                token = token_it_read(&it);
                if (token->kind == TokenBaseKind_ParentheticalClose &&
                    pos == token->pos + token->size){
                    pos = token->pos;
                }
            }
        }
    }
    draw_enclosures(app, text_layout_id, buffer,
                    pos, FindNest_Paren, RangeHighlightKind_CharacterHighlight,
                    0, 0, colors, color_count);
}

static void
draw_jump_highlights(Application_Links *app, Buffer_ID buffer, Text_Layout_ID text_layout_id,
                     Buffer_ID jump_buffer, FColor line_color){
    Scratch_Block scratch(app);
    if (jump_buffer != 0){
        Managed_Scope scopes[2];
        scopes[0] = buffer_get_managed_scope(app, jump_buffer);
        scopes[1] = buffer_get_managed_scope(app, buffer);
        Managed_Scope comp_scope = get_managed_scope_with_multiple_dependencies(app, scopes, ((sizeof(scopes))/(sizeof(*scopes))));
        Managed_Object *markers_object = ((Managed_Object*)managed_scope_get_attachment((app), (comp_scope), (sticky_jump_marker_handle), sizeof(Managed_Object)));

        i32 count = managed_object_get_item_count(app, *markers_object);
        Marker *markers = ((Marker*)linalloc_wrap_unintialized(linalloc_push((scratch), sizeof(Marker)*(count), SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_draw.cpp" ":" "797" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_draw.cpp" ":" "797" ":") - 1)))));
        managed_object_load_data(app, *markers_object, 0, count, markers);
        for (i32 i = 0; i < count; i += 1){
            i64 line_number = get_line_number_from_pos(app, buffer, markers[i].pos);
            draw_line_highlight(app, text_layout_id, line_number, line_color);
        }
    }
}

static b32
draw_highlight_range(Application_Links *app, View_ID view_id,
                     Buffer_ID buffer, Text_Layout_ID text_layout_id,
                     f32 roundness){
    b32 has_highlight_range = false;
    Managed_Scope scope = view_get_managed_scope(app, view_id);
    Buffer_ID *highlight_buffer = ((Buffer_ID*)managed_scope_get_attachment((app), (scope), (view_highlight_buffer), sizeof(Buffer_ID)));
    if (*highlight_buffer != 0){
        if (*highlight_buffer != buffer){
            view_disable_highlight_range(app, view_id);
        }
        else{
            has_highlight_range = true;
            Managed_Object *highlight = ((Managed_Object*)managed_scope_get_attachment((app), (scope), (view_highlight_range), sizeof(Managed_Object)));
            Marker marker_range[2];
            if (managed_object_load_data(app, *highlight, 0, 2, marker_range)){
                Range_i64 range = Ii64(marker_range[0].pos, marker_range[1].pos);
                draw_character_block(app, text_layout_id, range, roundness,
                                     fcolor_id(defcolor_highlight));
                paint_text_color_fcolor(app, text_layout_id, range,
                                        fcolor_id(defcolor_at_highlight));
            }
        }
    }
    return(has_highlight_range);
}

static i32
default_cursor_sub_id(void){
    i32 result = 0;
    if (global_keyboard_macro_is_recording){
        result = 1;
    }
    return(result);
}

static void
draw_original_4coder_style_cursor_mark_highlight(Application_Links *app, View_ID view_id, b32 is_active_view,
                                                 Buffer_ID buffer, Text_Layout_ID text_layout_id,
                                                 f32 roundness, f32 outline_thickness){
    b32 has_highlight_range = draw_highlight_range(app, view_id, buffer, text_layout_id, roundness);
    if (!has_highlight_range){
        i32 cursor_sub_id = default_cursor_sub_id();

        i64 cursor_pos = view_get_cursor_pos(app, view_id);
        i64 mark_pos = view_get_mark_pos(app, view_id);
        if (is_active_view){
            draw_character_block(app, text_layout_id, cursor_pos, roundness,
                                 fcolor_id(defcolor_cursor, cursor_sub_id));
            paint_text_color_pos(app, text_layout_id, cursor_pos,
                                 fcolor_id(defcolor_at_cursor));
            draw_character_wire_frame(app, text_layout_id, mark_pos,
                                      roundness, outline_thickness,
                                      fcolor_id(defcolor_mark));
        }
        else{
            draw_character_wire_frame(app, text_layout_id, mark_pos,
                                      roundness, outline_thickness,
                                      fcolor_id(defcolor_mark));
            draw_character_wire_frame(app, text_layout_id, cursor_pos,
                                      roundness, outline_thickness,
                                      fcolor_id(defcolor_cursor, cursor_sub_id));
        }
    }
}

static void
draw_notepad_style_cursor_highlight(Application_Links *app, View_ID view_id,
                                    Buffer_ID buffer, Text_Layout_ID text_layout_id,
                                    f32 roundness){
    b32 has_highlight_range = draw_highlight_range(app, view_id, buffer, text_layout_id, roundness);
    if (!has_highlight_range){
        i32 cursor_sub_id = default_cursor_sub_id();
        i64 cursor_pos = view_get_cursor_pos(app, view_id);
        i64 mark_pos = view_get_mark_pos(app, view_id);
        if (cursor_pos != mark_pos){
            Range_i64 range = Ii64(cursor_pos, mark_pos);
            draw_character_block(app, text_layout_id, range, roundness, fcolor_id(defcolor_highlight));
            paint_text_color_fcolor(app, text_layout_id, range, fcolor_id(defcolor_at_highlight));
        }
        draw_character_i_bar(app, text_layout_id, cursor_pos, fcolor_id(defcolor_cursor, cursor_sub_id));
    }
}



static Rect_f32
get_contained_box_near_point(Rect_f32 container, Vec2_f32 p, Vec2_f32 box_dims){
    Vec2_f32 container_dims = rect_dim(container);
    box_dims.x = (((box_dims.x)<(container_dims.x))?(box_dims.x):(container_dims.x));
    box_dims.y = (((box_dims.y)<(container_dims.y))?(box_dims.y):(container_dims.y));
    Vec2_f32 q = p + V2f32(-20.f, 22.f);
    if (q.x + box_dims.x > container.x1){
        q.x = container.x1 - box_dims.x;
    }
    if (q.y + box_dims.y > container.y1){
        q.y = p.y - box_dims.y - 2.f;
        if (q.y < container.y0){
            q.y = (container.y0 + container.y1 - box_dims.y)*0.5f;
        }
    }
    return(Rf32_xy_wh(q, box_dims));
}

static Rect_f32
draw_tool_tip(Application_Links *app, Face_ID face, Fancy_Block *block,
              Vec2_f32 p, Rect_f32 region, f32 x_padding, f32 x_half_padding,
              FColor back_color){
    Rect_f32 box = Rf32(p, p);
    if (block->line_count > 0){
        Vec2_f32 dims = get_fancy_block_dim(app, face, block);
        dims += V2f32(x_padding, 2.f);
        box = get_contained_box_near_point(region, p, dims);
        box.x0 = f32_round32(box.x0);
        box.y0 = f32_round32(box.y0);
        box.x1 = f32_round32(box.x1);
        box.y1 = f32_round32(box.y1);
        Rect_f32 prev_clip = draw_set_clip(app, box);
        draw_rectangle_fcolor(app, box, 6.f, back_color);
        draw_fancy_block(app, face, fcolor_zero(), block,
                         box.p0 + V2f32(x_half_padding, 1.f));
        draw_set_clip(app, prev_clip);
    }
    return(box);
}

static Rect_f32
draw_drop_down(Application_Links *app, Face_ID face, Fancy_Block *block,
               Vec2_f32 p, Rect_f32 region, f32 x_padding, f32 x_half_padding,
               FColor outline_color, FColor back_color){
    Rect_f32 box = Rf32(p, p);
    if (block->line_count > 0){
        Vec2_f32 dims = get_fancy_block_dim(app, face, block);
        dims += V2f32(x_padding, 4.f);
        box = get_contained_box_near_point(region, p, dims);
        box.x0 = f32_round32(box.x0);
        box.y0 = f32_round32(box.y0);
        box.x1 = f32_round32(box.x1);
        box.y1 = f32_round32(box.y1);
        Rect_f32 prev_clip = draw_set_clip(app, box);
        draw_rectangle_fcolor(app, box, 0.f, back_color);
        draw_margin(app, box, rect_inner(box, 1.f), outline_color);
        draw_fancy_block(app, face, fcolor_zero(), block,
                         box.p0 + V2f32(x_half_padding, 2.f));
        draw_set_clip(app, prev_clip);
    }
    return(box);
}

static b32
draw_button(Application_Links *app, Rect_f32 rect, Vec2_f32 mouse_p, Face_ID face, String_Const_u8 text){
    b32 hovered = false;
    if (rect_contains_point(rect, mouse_p)){
        hovered = true;
    }

    UI_Highlight_Level highlight = hovered?UIHighlight_Active:UIHighlight_None;
    draw_rectangle_fcolor(app, rect, 3.f, get_item_margin_color(highlight));
    rect = rect_inner(rect, 3.f);
    draw_rectangle_fcolor(app, rect, 3.f, get_item_margin_color(highlight, 1));

    Scratch_Block scratch(app);
    Fancy_String *fancy = push_fancy_string(scratch, 0, face, fcolor_id(defcolor_text_default), text);
    Vec2_f32 dim = get_fancy_string_dim(app, 0, fancy);
    Vec2_f32 p = (rect.p0 + rect.p1 - dim)*0.5f;
    draw_fancy_string(app, fancy, p);

    return(hovered);
}
# 100 "/home/sam/.bin/4coder/custom/4coder_default_include.cpp" 2
# 1 "/home/sam/.bin/4coder/custom/4coder_font_helper.cpp" 1






static Face_Description
get_buffer_face_description(Application_Links *app, Buffer_ID buffer){
    Face_ID current_id = get_face_id(app, buffer);
    Face_Description description = {};
    if (current_id != 0){
        description = get_face_description(app, current_id);
    }
    return(description);
}

static Face_Description
get_global_face_description(Application_Links *app){
    return(get_buffer_face_description(app, 0));
}

static b32
font_load_location_match(Font_Load_Location *a, Font_Load_Location *b){
    return(string_match(a->file_name, b->file_name));
}

static b32
face_load_parameters_match(Face_Load_Parameters *a, Face_Load_Parameters *b){
    return(block_compare(a, b, sizeof(*a)) == 0);
}

static b32
face_description_match(Face_Description *a, Face_Description *b){
    b32 result = false;
    if (font_load_location_match(&a->font, &b->font) &&
        face_load_parameters_match(&a->parameters, &b->parameters)){
        result = true;
    }
    return(result);
}

static Face_ID
face_id_from_font_load_target(Application_Links *app, Font_Load_Location *font){
    Face_ID largest_id = get_largest_face_id(app);
    Face_ID result = 0;
    for (Face_ID id = 1; id <= largest_id; ++id){
        Face_Description compare = get_face_description(app, id);
        if (font_load_location_match(&compare.font, font)){
            result = id;
            break;
        }
    }
    return(result);
}

static Face_ID
face_id_from_face_load_parameters(Application_Links *app, Face_Load_Parameters *parameters){
    Face_ID largest_id = get_largest_face_id(app);
    Face_ID result = 0;
    for (Face_ID id = 1; id <= largest_id; ++id){
        Face_Description compare = get_face_description(app, id);
        if (face_load_parameters_match(&compare.parameters, parameters)){
            result = id;
            break;
        }
    }
    return(result);
}

static Face_ID
face_id_from_description(Application_Links *app, Face_Description *description){
    Face_ID largest_id = get_largest_face_id(app);
    Face_ID result = 0;
    for (Face_ID id = 1; id <= largest_id; ++id){
        Face_Description compare = get_face_description(app, id);
        if (face_description_match(&compare, description)){
            result = id;
            break;
        }
    }
    return(result);
}

static b32
modify_global_face_by_description(Application_Links *app, Face_Description description){
    Face_ID face_id = get_face_id(app, 0);
    return(try_modify_face(app, face_id, &description));
}

static void
set_buffer_face_by_description(Application_Links *app, Buffer_ID buffer, Face_Description *description){
    Face_ID id = face_id_from_description(app, description);
    if (id == 0){
        id = try_create_new_face(app, description);
    }
    if (id != 0){
        buffer_set_face(app, buffer, id);
    }
}

static void
set_buffer_face_by_font_load_location(Application_Links *app, Buffer_ID buffer, Font_Load_Location *font){
    Face_Description description = get_buffer_face_description(app, buffer);
    description.font = *font;
    set_buffer_face_by_description(app, buffer, &description);
}

static void
set_buffer_face_by_face_load_parameters(Application_Links *app, Buffer_ID buffer, Face_Load_Parameters *parameters){
    Face_Description description = get_buffer_face_description(app, buffer);
    description.parameters = *parameters;
    set_buffer_face_by_description(app, buffer, &description);
}
# 101 "/home/sam/.bin/4coder/custom/4coder_default_include.cpp" 2
# 1 "/home/sam/.bin/4coder/custom/4coder_config.cpp" 1






static String_Const_u8_Array
parse_extension_line_to_extension_list(Application_Links *app,
                                       Arena *arena, String_Const_u8 str){
    Profile_Scope_Block profile_block_10 ((app), SCu8((u8*)("parse extension line to extension list"), (u64)(sizeof("parse extension line to extension list") - 1)), SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_config.cpp" ":" "10" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_config.cpp" ":" "10" ":") - 1)));
    i32 count = 0;
    for (u64 i = 0; i < str.size; i += 1){
        if (str.str[i] == '.'){
            count += 1;
        }
    }

    String_Const_u8_Array array = {};
    array.count = count;
    array.strings = ((String_Const_u8*)linalloc_wrap_unintialized(linalloc_push((arena), sizeof(String_Const_u8)*(count), SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_config.cpp" ":" "20" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_config.cpp" ":" "20" ":") - 1)))));

    (linalloc_align((arena), (1)));
    str = string_skip(str, string_find_first(str, '.') + 1);
    for (i32 i = 0; i < count; i += 1){
        u64 next_period = string_find_first(str, '.');
        String_Const_u8 extension = string_prefix(str, next_period);
        str = string_skip(str, next_period + 1);
        array.strings[i] = push_string_copy(arena, extension);
    }
    (linalloc_align((arena), (8)));

    return(array);
}



static void
setup_built_in_mapping(Application_Links *app, String_Const_u8 name, Mapping *mapping, i64 global_id, i64 file_id, i64 code_id){
    Thread_Context *tctx = get_thread_context(app);
    if (string_match(name, SCu8((u8*)("default"), (u64)(sizeof("default") - 1)))){
        mapping_release(tctx, mapping);
        mapping_init(tctx, mapping);
        setup_default_mapping(mapping, global_id, file_id, code_id);
    }
    else if (string_match(name, SCu8((u8*)("mac-default"), (u64)(sizeof("mac-default") - 1)))){
        mapping_release(tctx, mapping);
        mapping_init(tctx, mapping);
        setup_mac_mapping(mapping, global_id, file_id, code_id);
    }
    else if (string_match(name, SCu8((u8*)("choose"), (u64)(sizeof("choose") - 1)))){
        mapping_release(tctx, mapping);
        mapping_init(tctx, mapping);



        setup_default_mapping(mapping, global_id, file_id, code_id);

    }
}



static Error_Location
get_error_location(Application_Links *app, u8 *base, u8 *pos){
    Profile_Scope_Block profile_block_65 ((app), SCu8((u8*)("get error location"), (u64)(sizeof("get error location") - 1)), SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_config.cpp" ":" "65" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_config.cpp" ":" "65" ":") - 1)));
    Error_Location location = {};
    location.line_number = 1;
    location.column_number = 1;
    for (u8 *ptr = base;
         ptr < pos;
         ptr += 1){
        if (*ptr == '\n'){
            location.line_number += 1;
            location.column_number = 1;
        }
        else{
            location.column_number += 1;
        }
    }
    return(location);
}

static String_Const_u8
config_stringize_errors(Application_Links *app, Arena *arena, Config *parsed){
    Profile_Scope_Block profile_block_85 ((app), SCu8((u8*)("stringize errors"), (u64)(sizeof("stringize errors") - 1)), SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_config.cpp" ":" "85" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_config.cpp" ":" "85" ":") - 1)));
    String_Const_u8 result = {};
    if (parsed->errors.first != 0){
        List_String_Const_u8 list = {};
        for (Config_Error *error = parsed->errors.first;
             error != 0;
             error = error->next){
            Error_Location location = get_error_location(app, parsed->data.str, error->pos);
            string_list_pushf(arena, &list, "%.*s:%d:%d: %.*s\n",
                              (i32)(error->file_name).size, (char*)(error->file_name).str, location.line_number, location.column_number, (i32)(error->text).size, (char*)(error->text).str);
        }
        result = string_list_flatten(arena, list);
    }
    return(result);
}



static void
config_parser__advance_to_next(Config_Parser *ctx){
    Token *t = ctx->token;
    Token *e = ctx->end;
    for (t += 1;
         t < e && (t->kind == TokenBaseKind_Comment ||
                   t->kind == TokenBaseKind_Whitespace);
         t += 1);
    ctx->token = t;
}

static Config_Parser
make_config_parser(Arena *arena, String_Const_u8 file_name, String_Const_u8 data, Token_Array array){
    Config_Parser ctx = {};
    ctx.start = array.tokens;
    ctx.token = ctx.start - 1;
    ctx.end = ctx.start + array.count;
    ctx.file_name = file_name;
    ctx.data = data;
    ctx.arena = arena;
    config_parser__advance_to_next(&ctx);
    return(ctx);
}

static b32
config_parser__recognize_base_token(Config_Parser *ctx, Token_Base_Kind kind){
    b32 result = false;
    if (ctx->start <= ctx->token && ctx->token < ctx->end){
        result = (ctx->token->kind == kind);
    }
    else if (kind == TokenBaseKind_EOF){
        result = true;
    }
    return(result);
}

static b32
config_parser__recognize_token(Config_Parser *ctx, Token_Cpp_Kind kind){
    b32 result = false;
    if (ctx->start <= ctx->token && ctx->token < ctx->end){
        result = (ctx->token->sub_kind == kind);
    }
    else if (kind == TokenCppKind_EOF){
        result = true;
    }
    return(result);
}

static b32
config_parser__recognize_boolean(Config_Parser *ctx){
    b32 result = false;
    Token *token = ctx->token;
    if (ctx->start <= ctx->token && ctx->token < ctx->end){
        result = (token->sub_kind == TokenCppKind_LiteralTrue ||
                  token->sub_kind == TokenCppKind_LiteralFalse);
    }
    return(result);
}

static String_Const_u8
config_parser__get_lexeme(Config_Parser *ctx){
    String_Const_u8 lexeme = {};
    Token *token = ctx->token;
    if (ctx->start <= token && token < ctx->end){
        lexeme = SCu8(ctx->data.str + token->pos, token->size);
    }
    return(lexeme);
}

static Config_Integer
config_parser__get_int(Config_Parser *ctx){
    Config_Integer config_integer = {};
    String_Const_u8 str = config_parser__get_lexeme(ctx);
    if (string_match(string_prefix(str, 2), SCu8((u8*)("0x"), (u64)(sizeof("0x") - 1)))){
        config_integer.is_signed = false;
        config_integer.uinteger = (u32)(string_to_integer(string_skip(str, 2), 16));
    }
    else{
        b32 is_negative = (string_get_character(str, 0) == '-');
        if (is_negative){
            str = string_skip(str, 1);
        }
        config_integer.is_signed = true;
        config_integer.integer = (i32)(string_to_integer(str, 10));
        if (is_negative){
            config_integer.integer *= -1;
        }
    }
    return(config_integer);
}

static b32
config_parser__get_boolean(Config_Parser *ctx){
    String_Const_u8 str = config_parser__get_lexeme(ctx);
    return(string_match(str, SCu8((u8*)("true"), (u64)(sizeof("true") - 1))));
}

static b32
config_parser__recognize_text(Config_Parser *ctx, String_Const_u8 text){
    String_Const_u8 lexeme = config_parser__get_lexeme(ctx);
    return(lexeme.str != 0 && string_match(lexeme, text));
}

static b32
config_parser__match_token(Config_Parser *ctx, Token_Cpp_Kind kind){
    b32 result = config_parser__recognize_token(ctx, kind);
    if (result){
        config_parser__advance_to_next(ctx);
    }
    return(result);
}

static b32
config_parser__match_text(Config_Parser *ctx, String_Const_u8 text){
    b32 result = config_parser__recognize_text(ctx, text);
    if (result){
        config_parser__advance_to_next(ctx);
    }
    return(result);
}



static Config *config_parser__config (Config_Parser *ctx);
static i32 *config_parser__version (Config_Parser *ctx);
static Config_Assignment *config_parser__assignment(Config_Parser *ctx);
static Config_LValue *config_parser__lvalue (Config_Parser *ctx);
static Config_RValue *config_parser__rvalue (Config_Parser *ctx);
static Config_Compound *config_parser__compound (Config_Parser *ctx);
static Config_Compound_Element *config_parser__element (Config_Parser *ctx);

static Config*
config_parse(Application_Links *app, Arena *arena, String_Const_u8 file_name,
             String_Const_u8 data, Token_Array array){
    Profile_Scope_Block profile_block_237 ((app), SCu8((u8*)("config parse"), (u64)(sizeof("config parse") - 1)), SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_config.cpp" ":" "237" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_config.cpp" ":" "237" ":") - 1)));
    Temp_Memory restore_point = begin_temp(arena);
    Config_Parser ctx = make_config_parser(arena, file_name, data, array);
    Config *config = config_parser__config(&ctx);
    if (config == 0){
        end_temp(restore_point);
    }
    return(config);
}


static Config_Error*
config_error_push(Arena *arena, Config_Error_List *list, String_Const_u8 file_name,
                  u8 *pos, char *error_text){
    Config_Error *error = ((Config_Error*)linalloc_wrap_unintialized(linalloc_push((arena), sizeof(Config_Error)*(1), SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_config.cpp" ":" "251" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_config.cpp" ":" "251" ":") - 1)))));
    (((list->first)==0)?((error)->next=(error)->prev=0,(list->first)=(list->last)=(error)):((error)->prev=(list->last),(error)->next=0,(list->last)->next=(error),(list->last)=(error)));
    list->count += 1;
    error->file_name = file_name;
    error->pos = pos;
    error->text = push_string_copy(arena, SCu8(error_text));
    return(error);
}

static u8*
config_parser__get_pos(Config_Parser *ctx){
    return(ctx->data.str + ctx->token->pos);
}

static void
config_parser__log_error_pos(Config_Parser *ctx, u8 *pos, char *error_text){
    config_error_push(ctx->arena, &ctx->errors, ctx->file_name, pos, error_text);
}

static void
config_parser__log_error(Config_Parser *ctx, char *error_text){
    config_parser__log_error_pos(ctx, config_parser__get_pos(ctx), error_text);
}

static Config*
config_parser__config(Config_Parser *ctx){
    i32 *version = config_parser__version(ctx);

    Config_Assignment *first = 0;
    Config_Assignment *last = 0;
    i32 count = 0;
    for (;!config_parser__recognize_token(ctx, TokenCppKind_EOF);){
        Config_Assignment *assignment = config_parser__assignment(ctx);
        if (assignment != 0){
            (((first)==0)?((assignment)->next=(assignment)->prev=0,(first)=(last)=(assignment)):((assignment)->prev=(last),(assignment)->next=0,(last)->next=(assignment),(last)=(assignment)));
            count += 1;
        }
    }

    Config *config = ((Config*)linalloc_wrap_unintialized(linalloc_push((ctx->arena), sizeof(Config)*(1), SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_config.cpp" ":" "290" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_config.cpp" ":" "290" ":") - 1)))));
    block_zero((config), sizeof(*(config)));
    config->version = version;
    config->first = first;
    config->last = last;
    config->count = count;
    config->errors = ctx->errors;
    config->file_name = ctx->file_name;
    config->data = ctx->data;
    return(config);
}

static void
config_parser__recover_parse(Config_Parser *ctx){
    for (;;){
        if (config_parser__match_token(ctx, TokenCppKind_Semicolon)){
            break;
        }
        if (config_parser__recognize_token(ctx, TokenCppKind_EOF)){
            break;
        }
        config_parser__advance_to_next(ctx);
    }
}

static i32*
config_parser__version(Config_Parser *ctx){
    do{ if (!(config_parser__match_text((ctx), SCu8((u8*)("version"), (u64)(sizeof("version") - 1))))){ return(0); } }while(0);

    if (!config_parser__match_token(ctx, TokenCppKind_ParenOp)){
        config_parser__log_error(ctx, "expected token '(' for version specifier: 'version(#)'");
        config_parser__recover_parse(ctx);
        return(0);
    }

    if (!config_parser__recognize_base_token(ctx, TokenBaseKind_LiteralInteger)){
        config_parser__log_error(ctx, "expected an integer constant for version specifier: 'version(#)'");
        config_parser__recover_parse(ctx);
        return(0);
    }

    Config_Integer value = config_parser__get_int(ctx);
    config_parser__advance_to_next(ctx);

    if (!config_parser__match_token(ctx, TokenCppKind_ParenCl)){
        config_parser__log_error(ctx, "expected token ')' for version specifier: 'version(#)'");
        config_parser__recover_parse(ctx);
        return(0);
    }

    if (!config_parser__match_token(ctx, TokenCppKind_Semicolon)){
        config_parser__log_error(ctx, "expected token ';' for version specifier: 'version(#)'");
        config_parser__recover_parse(ctx);
        return(0);
    }

    i32 *ptr = ((i32*)linalloc_wrap_unintialized(linalloc_push((ctx->arena), sizeof(i32)*(1), SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_config.cpp" ":" "346" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_config.cpp" ":" "346" ":") - 1)))));
    *ptr = value.integer;
    return(ptr);
}

static Config_Assignment*
config_parser__assignment(Config_Parser *ctx){
    u8 *pos = config_parser__get_pos(ctx);

    Config_LValue *l = config_parser__lvalue(ctx);
    if (l == 0){
        config_parser__log_error(ctx, "expected an l-value; l-value formats: 'identifier', 'identifier[#]'");
        config_parser__recover_parse(ctx);
        return(0);
    }

    if (!config_parser__match_token(ctx, TokenCppKind_Eq)){
        config_parser__log_error(ctx, "expected token '=' for assignment: 'l-value = r-value;'");
        config_parser__recover_parse(ctx);
        return(0);
    }

    Config_RValue *r = config_parser__rvalue(ctx);
    if (r == 0){
        config_parser__log_error(ctx, "expected an r-value; r-value formats:\n"
                                 "\tconstants (true, false, integers, hexadecimal integers, strings, characters)\n"
                                 "\tany l-value that is set in the file\n"
                                 "\tcompound: '{ compound-element, compound-element, compound-element ...}'\n"
                                 "\ta compound-element is an r-value, and can have a layout specifier\n"
                                 "\tcompound-element with layout specifier: .name = r-value, .integer = r-value");
        config_parser__recover_parse(ctx);
        return(0);
    }

    if (!config_parser__match_token(ctx, TokenCppKind_Semicolon)){
        config_parser__log_error(ctx, "expected token ';' for assignment: 'l-value = r-value;'");
        config_parser__recover_parse(ctx);
        return(0);
    }

    Config_Assignment *assignment = ((Config_Assignment*)linalloc_wrap_zero(linalloc_push((ctx->arena), sizeof(Config_Assignment)*(1), SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_config.cpp" ":" "386" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_config.cpp" ":" "386" ":") - 1)))));
    assignment->pos = pos;
    assignment->l = l;
    assignment->r = r;
    return(assignment);
}

static Config_LValue*
config_parser__lvalue(Config_Parser *ctx){
    do{ if (!(config_parser__recognize_token(ctx, TokenCppKind_Identifier))){ return(0); } }while(0);
    String_Const_u8 identifier = config_parser__get_lexeme(ctx);
    config_parser__advance_to_next(ctx);

    i32 index = 0;
    if (config_parser__match_token(ctx, TokenCppKind_BrackOp)){
        do{ if (!(config_parser__recognize_base_token(ctx, TokenBaseKind_LiteralInteger))){ return(0); } }while(0);
        Config_Integer value = config_parser__get_int(ctx);
        index = value.integer;
        config_parser__advance_to_next(ctx);
        do{ if (!(config_parser__match_token(ctx, TokenCppKind_BrackCl))){ return(0); } }while(0);
    }

    Config_LValue *lvalue = ((Config_LValue*)linalloc_wrap_zero(linalloc_push((ctx->arena), sizeof(Config_LValue)*(1), SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_config.cpp" ":" "408" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_config.cpp" ":" "408" ":") - 1)))));
    lvalue->identifier = identifier;
    lvalue->index = index;
    return(lvalue);
}

static Config_RValue*
config_parser__rvalue(Config_Parser *ctx){
    Config_RValue *rvalue = 0;
    if (config_parser__recognize_token(ctx, TokenCppKind_Identifier)){
        Config_LValue *l = config_parser__lvalue(ctx);
        do{ if (!(l != 0)){ return(0); } }while(0);
        rvalue = ((Config_RValue*)linalloc_wrap_zero(linalloc_push((ctx->arena), sizeof(Config_RValue)*(1), SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_config.cpp" ":" "420" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_config.cpp" ":" "420" ":") - 1)))));
        rvalue->type = ConfigRValueType_LValue;
        rvalue->lvalue = l;
    }
    else if (config_parser__recognize_token(ctx, TokenCppKind_BraceOp)){
        config_parser__advance_to_next(ctx);
        Config_Compound *compound = config_parser__compound(ctx);
        do{ if (!(compound != 0)){ return(0); } }while(0);
        rvalue = ((Config_RValue*)linalloc_wrap_zero(linalloc_push((ctx->arena), sizeof(Config_RValue)*(1), SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_config.cpp" ":" "428" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_config.cpp" ":" "428" ":") - 1)))));
        rvalue->type = ConfigRValueType_Compound;
        rvalue->compound = compound;
    }
    else if (config_parser__recognize_boolean(ctx)){
        b32 b = config_parser__get_boolean(ctx);
        config_parser__advance_to_next(ctx);
        rvalue = ((Config_RValue*)linalloc_wrap_zero(linalloc_push((ctx->arena), sizeof(Config_RValue)*(1), SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_config.cpp" ":" "435" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_config.cpp" ":" "435" ":") - 1)))));
        rvalue->type = ConfigRValueType_Boolean;
        rvalue->boolean = b;
    }
    else if (config_parser__recognize_base_token(ctx, TokenBaseKind_LiteralInteger)){
        Config_Integer value = config_parser__get_int(ctx);
        config_parser__advance_to_next(ctx);
        rvalue = ((Config_RValue*)linalloc_wrap_zero(linalloc_push((ctx->arena), sizeof(Config_RValue)*(1), SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_config.cpp" ":" "442" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_config.cpp" ":" "442" ":") - 1)))));
        rvalue->type = ConfigRValueType_Integer;
        if (value.is_signed){
            rvalue->integer = value.integer;
        }
        else{
            rvalue->uinteger = value.uinteger;
        }
    }
    else if (config_parser__recognize_token(ctx, TokenCppKind_LiteralString)){
        String_Const_u8 s = config_parser__get_lexeme(ctx);
        config_parser__advance_to_next(ctx);
        s = string_chop(string_skip(s, 1), 1);
        String_Const_u8 interpreted = string_interpret_escapes(ctx->arena, s);
        rvalue = ((Config_RValue*)linalloc_wrap_zero(linalloc_push((ctx->arena), sizeof(Config_RValue)*(1), SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_config.cpp" ":" "456" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_config.cpp" ":" "456" ":") - 1)))));
        rvalue->type = ConfigRValueType_String;
        rvalue->string = interpreted;
    }
    else if (config_parser__recognize_token(ctx, TokenCppKind_LiteralCharacter)){
        String_Const_u8 s = config_parser__get_lexeme(ctx);
        config_parser__advance_to_next(ctx);
        s = string_chop(string_skip(s, 1), 1);
        String_Const_u8 interpreted = string_interpret_escapes(ctx->arena, s);
        rvalue = ((Config_RValue*)linalloc_wrap_zero(linalloc_push((ctx->arena), sizeof(Config_RValue)*(1), SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_config.cpp" ":" "465" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_config.cpp" ":" "465" ":") - 1)))));
        rvalue->type = ConfigRValueType_Character;
        rvalue->character = string_get_character(interpreted, 0);
    }
    return(rvalue);
}

static void
config_parser__compound__check(Config_Parser *ctx, Config_Compound *compound){
    b32 implicit_index_allowed = true;
    for (Config_Compound_Element *node = compound->first;
         node != 0;
         node = node->next){
        if (node->l.type != ConfigLayoutType_Unset){
            implicit_index_allowed = false;
        }
        else if (!implicit_index_allowed){
            config_parser__log_error_pos(ctx, node->l.pos,
                                         "encountered unlabeled member after one or more labeled members");
        }
    }
}

static Config_Compound*
config_parser__compound(Config_Parser *ctx){
    Config_Compound_Element *first = 0;
    Config_Compound_Element *last = 0;
    i32 count = 0;

    Config_Compound_Element *element = config_parser__element(ctx);
    do{ if (!(element != 0)){ return(0); } }while(0);
    (((first)==0)?((element)->next=(element)->prev=0,(first)=(last)=(element)):((element)->prev=(last),(element)->next=0,(last)->next=(element),(last)=(element)));
    count += 1;

    for (;config_parser__match_token(ctx, TokenCppKind_Comma);){
        if (config_parser__recognize_token(ctx, TokenCppKind_BraceCl)){
            break;
        }
        element = config_parser__element(ctx);
        do{ if (!(element != 0)){ return(0); } }while(0);
        (((first)==0)?((element)->next=(element)->prev=0,(first)=(last)=(element)):((element)->prev=(last),(element)->next=0,(last)->next=(element),(last)=(element)));
        count += 1;
    }

    do{ if (!(config_parser__match_token(ctx, TokenCppKind_BraceCl))){ return(0); } }while(0);

    Config_Compound *compound = ((Config_Compound*)linalloc_wrap_unintialized(linalloc_push((ctx->arena), sizeof(Config_Compound)*(1), SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_config.cpp" ":" "511" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_config.cpp" ":" "511" ":") - 1)))));
    block_zero((compound), sizeof(*(compound)));
    compound->first = first;
    compound->last = last;
    compound->count = count;
    config_parser__compound__check(ctx, compound);
    return(compound);
}

static Config_Compound_Element*
config_parser__element(Config_Parser *ctx){
    Config_Layout layout = {};
    layout.pos = config_parser__get_pos(ctx);
    if (config_parser__match_token(ctx, TokenCppKind_Dot)){
        if (config_parser__recognize_token(ctx, TokenCppKind_Identifier)){
            layout.type = ConfigLayoutType_Identifier;
            layout.identifier = config_parser__get_lexeme(ctx);
            config_parser__advance_to_next(ctx);
        }
        else if (config_parser__recognize_base_token(ctx, TokenBaseKind_LiteralInteger)){
            layout.type = ConfigLayoutType_Integer;
            Config_Integer value = config_parser__get_int(ctx);
            layout.integer = value.integer;
            config_parser__advance_to_next(ctx);
        }
        else{
            return(0);
        }
        do{ if (!(config_parser__match_token(ctx, TokenCppKind_Eq))){ return(0); } }while(0);
    }
    Config_RValue *rvalue = config_parser__rvalue(ctx);
    do{ if (!(rvalue != 0)){ return(0); } }while(0);
    Config_Compound_Element *element = ((Config_Compound_Element*)linalloc_wrap_unintialized(linalloc_push((ctx->arena), sizeof(Config_Compound_Element)*(1), SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_config.cpp" ":" "543" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_config.cpp" ":" "543" ":") - 1)))));
    block_zero((element), sizeof(*(element)));
    element->l = layout;
    element->r = rvalue;
    return(element);
}



static Config_Error*
config_add_error(Arena *arena, Config *config, u8 *pos, char *error_text){
    return(config_error_push(arena, &config->errors, config->file_name, pos,
                             error_text));
}



static Config_Assignment*
config_lookup_assignment(Config *config, String_Const_u8 var_name, i32 subscript){
    Config_Assignment *assignment = 0;
    for (assignment = config->first;
         assignment != 0;
         assignment = assignment->next){
        Config_LValue *l = assignment->l;
        if (l != 0 && string_match(l->identifier, var_name) && l->index == subscript){
            break;
        }
    }
    return(assignment);
}

static Config_Get_Result
config_var(Config *config, String_Const_u8 var_name, i32 subscript);

static Config_Get_Result
config_evaluate_rvalue(Config *config, Config_Assignment *assignment, Config_RValue *r){
    Config_Get_Result result = {};
    if (r != 0 && !assignment->visited){
        if (r->type == ConfigRValueType_LValue){
            assignment->visited = true;
            Config_LValue *l = r->lvalue;
            result = config_var(config, l->identifier, l->index);
            assignment->visited = false;
        }
        else{
            result.success = true;
            result.pos = assignment->pos;
            result.type = r->type;
            switch (r->type){
                case ConfigRValueType_Boolean:
                {
                    result.boolean = r->boolean;
                }break;

                case ConfigRValueType_Integer:
                {
                    result.integer = r->integer;
                }break;

                case ConfigRValueType_String:
                {
                    result.string = r->string;
                }break;

                case ConfigRValueType_Character:
                {
                    result.character = r->character;
                }break;

                case ConfigRValueType_Compound:
                {
                    result.compound = r->compound;
                }break;
            }
        }
    }
    return(result);
}

static Config_Get_Result
config_var(Config *config, String_Const_u8 var_name, i32 subscript){
    Config_Get_Result result = {};
    Config_Assignment *assignment = config_lookup_assignment(config, var_name, subscript);
    if (assignment != 0){
        result = config_evaluate_rvalue(config, assignment, assignment->r);
    }
    return(result);
}

static Config_Get_Result
config_compound_member(Config *config, Config_Compound *compound, String_Const_u8 var_name, i32 index){
    Config_Get_Result result = {};
    i32 implicit_index = 0;
    b32 implicit_index_is_valid = true;
    for (Config_Compound_Element *element = compound->first;
         element != 0;
         element = element->next, implicit_index += 1){
        b32 element_matches_query = false;
        switch (element->l.type){
            case ConfigLayoutType_Unset:
            {
                if (implicit_index_is_valid && index == implicit_index){
                    element_matches_query = true;
                }
            }break;

            case ConfigLayoutType_Identifier:
            {
                implicit_index_is_valid = false;
                if (string_match(element->l.identifier, var_name)){
                    element_matches_query = true;
                }
            }break;

            case ConfigLayoutType_Integer:
            {
                implicit_index_is_valid = false;
                if (element->l.integer == index){
                    element_matches_query = true;
                }
            }break;
        }
        if (element_matches_query){
            Config_Assignment dummy_assignment = {};
            dummy_assignment.pos = element->l.pos;
            result = config_evaluate_rvalue(config, &dummy_assignment, element->r);
            break;
        }
    }
    return(result);
}

static Config_Iteration_Step_Result
typed_array_iteration_step(Config *parsed, Config_Compound *compound, Config_RValue_Type type, i32 index);

static i32
typed_array_get_count(Config *parsed, Config_Compound *compound, Config_RValue_Type type);

static Config_Get_Result_List
typed_array_reference_list(Arena *arena, Config *parsed, Config_Compound *compound, Config_RValue_Type type);





static b32
config_has_var(Config *config, String_Const_u8 var_name, i32 subscript){
    Config_Get_Result result = config_var(config, var_name, subscript);
    return(result.success && result.type == ConfigRValueType_NoType);
}

static b32
config_has_var(Config *config, char *var_name, i32 subscript){
    return(config_has_var(config, SCu8(var_name), subscript));
}

static b32
config_bool_var(Config *config, String_Const_u8 var_name, i32 subscript, b32* var_out){
    Config_Get_Result result = config_var(config, var_name, subscript);
    b32 success = (result.success && result.type == ConfigRValueType_Boolean);
    if (success){
        *var_out = result.boolean;
    }
    return(success);
}
static b32
config_bool_var(Config *config, String_Const_u8 var_name, i32 subscript, b8 *var_out){
    b32 temp = false;
    b32 success = config_bool_var(config, var_name, subscript, &temp);
    if (success){
        *var_out = (temp != false);
    }
    return(success);
}
static b32
config_bool_var(Config *config, char *var_name, i32 subscript, b32* var_out){
    return(config_bool_var(config, SCu8(var_name), subscript, var_out));
}
static b32
config_bool_var(Config *config, char* var_name, i32 subscript, b8 *var_out){
    b32 temp = false;
    b32 success = config_bool_var(config, SCu8(var_name), subscript, &temp);
    if (success){
        *var_out = (temp != false);
    }
    return(success);
}

static b32
config_int_var(Config *config, String_Const_u8 var_name, i32 subscript, i32* var_out){
    Config_Get_Result result = config_var(config, var_name, subscript);
    b32 success = result.success && result.type == ConfigRValueType_Integer;
    if (success){
        *var_out = result.integer;
    }
    return(success);
}

static b32
config_int_var(Config *config, char *var_name, i32 subscript, i32* var_out){
    return(config_int_var(config, SCu8(var_name), subscript, var_out));
}

static b32
config_uint_var(Config *config, String_Const_u8 var_name, i32 subscript, u32* var_out){
    Config_Get_Result result = config_var(config, var_name, subscript);
    b32 success = result.success && result.type == ConfigRValueType_Integer;
    if (success){
        *var_out = result.uinteger;
    }
    return(success);
}

static b32
config_uint_var(Config *config, char *var_name, i32 subscript, u32* var_out){
    return(config_uint_var(config, SCu8(var_name), subscript, var_out));
}

static b32
config_string_var(Config *config, String_Const_u8 var_name, i32 subscript, String_Const_u8* var_out){
    Config_Get_Result result = config_var(config, var_name, subscript);
    b32 success = result.success && result.type == ConfigRValueType_String;
    if (success){
        *var_out = result.string;
    }
    return(success);
}

static b32
config_string_var(Config *config, char *var_name, i32 subscript, String_Const_u8* var_out){
    return(config_string_var(config, SCu8(var_name), subscript, var_out));
}

static b32
config_placed_string_var(Config *config, String_Const_u8 var_name, i32 subscript, String_Const_u8* var_out, u8 *space, u64 space_size){
    Config_Get_Result result = config_var(config, var_name, subscript);
    b32 success = (result.success && result.type == ConfigRValueType_String);
    if (success){
        u64 size = result.string.size;
        size = (((size)<(space_size))?(size):(space_size));
        block_copy(space, result.string.str, size);
        *var_out = SCu8(space, size);
    }
    return(success);
}

static b32
config_placed_string_var(Config *config, char *var_name, i32 subscript, String_Const_u8* var_out, u8 *space, u64 space_size){
    return(config_placed_string_var(config, SCu8(var_name), subscript, var_out, space, space_size));
}

static b32
config_char_var(Config *config, String_Const_u8 var_name, i32 subscript, char* var_out){
    Config_Get_Result result = config_var(config, var_name, subscript);
    b32 success = result.success && result.type == ConfigRValueType_Character;
    if (success){
        *var_out = result.character;
    }
    return(success);
}

static b32
config_char_var(Config *config, char *var_name, i32 subscript, char* var_out){
    return(config_char_var(config, SCu8(var_name), subscript, var_out));
}

static b32
config_compound_var(Config *config, String_Const_u8 var_name, i32 subscript, Config_Compound** var_out){
    Config_Get_Result result = config_var(config, var_name, subscript);
    b32 success = (result.success && result.type == ConfigRValueType_Compound);
    if (success){
        *var_out = result.compound;
    }
    return(success);
}

static b32
config_compound_var(Config *config, char *var_name, i32 subscript, Config_Compound** var_out){
    return(config_compound_var(config, SCu8(var_name), subscript, var_out));
}

static b32
config_compound_has_member(Config *config, Config_Compound *compound,
                           String_Const_u8 var_name, i32 index){
    Config_Get_Result result = config_compound_member(config, compound, var_name, index);
    b32 success = result.success && result.type == ConfigRValueType_NoType;
    return(success);
}

static b32
config_compound_has_member(Config *config, Config_Compound *compound,
                           char *var_name, i32 index){
    return(config_compound_has_member(config, compound, SCu8(var_name), index));
}

static b32
config_compound_bool_member(Config *config, Config_Compound *compound,
                            String_Const_u8 var_name, i32 index, b32* var_out){
    Config_Get_Result result = config_compound_member(config, compound, var_name, index);
    b32 success = result.success && result.type == ConfigRValueType_Boolean;
    if (success){
        *var_out = result.boolean;
    }
    return(success);
}

static b32
config_compound_bool_member(Config *config, Config_Compound *compound,
                            char *var_name, i32 index, b32* var_out){
    return(config_compound_bool_member(config, compound, SCu8(var_name), index, var_out));
}

static b32
config_compound_int_member(Config *config, Config_Compound *compound,
                           String_Const_u8 var_name, i32 index, i32* var_out){
    Config_Get_Result result = config_compound_member(config, compound, var_name, index);
    b32 success = result.success && result.type == ConfigRValueType_Integer;
    if (success){
        *var_out = result.integer;
    }
    return(success);
}

static b32
config_compound_int_member(Config *config, Config_Compound *compound,
                           char *var_name, i32 index, i32* var_out){
    return(config_compound_int_member(config, compound, SCu8(var_name), index, var_out));
}

static b32
config_compound_uint_member(Config *config, Config_Compound *compound,
                            String_Const_u8 var_name, i32 index, u32* var_out){
    Config_Get_Result result = config_compound_member(config, compound, var_name, index);
    b32 success = result.success && result.type == ConfigRValueType_Integer;
    if (success){
        *var_out = result.uinteger;
    }
    return(success);
}

static b32
config_compound_uint_member(Config *config, Config_Compound *compound,
                            char *var_name, i32 index, u32* var_out){
    return(config_compound_uint_member(config, compound, SCu8(var_name), index, var_out));
}

static b32
config_compound_string_member(Config *config, Config_Compound *compound,
                              String_Const_u8 var_name, i32 index, String_Const_u8* var_out){
    Config_Get_Result result = config_compound_member(config, compound, var_name, index);
    b32 success = (result.success && result.type == ConfigRValueType_String);
    if (success){
        *var_out = result.string;
    }
    return(success);
}

static b32
config_compound_string_member(Config *config, Config_Compound *compound,
                              char *var_name, i32 index, String_Const_u8* var_out){
    return(config_compound_string_member(config, compound, SCu8(var_name), index, var_out));
}

static b32
config_compound_placed_string_member(Config *config, Config_Compound *compound,
                                     String_Const_u8 var_name, i32 index, String_Const_u8* var_out, u8 *space, u64 space_size){
    Config_Get_Result result = config_compound_member(config, compound, var_name, index);
    b32 success = (result.success && result.type == ConfigRValueType_String);
    if (success){
        u64 size = result.string.size;
        size = (((size)<(space_size))?(size):(space_size));
        block_copy(space, result.string.str, size);
        *var_out = SCu8(space, size);
    }
    return(success);
}

static b32
config_compound_placed_string_member(Config *config, Config_Compound *compound,
                                     char *var_name, i32 index, String_Const_u8* var_out, u8 *space, u64 space_size){
    return(config_compound_placed_string_member(config, compound, SCu8(var_name), index, var_out, space, space_size));
}

static b32
config_compound_char_member(Config *config, Config_Compound *compound,
                            String_Const_u8 var_name, i32 index, char* var_out){
    Config_Get_Result result = config_compound_member(config, compound, var_name, index);
    b32 success = result.success && result.type == ConfigRValueType_Character;
    if (success){
        *var_out = result.character;
    }
    return(success);
}

static b32
config_compound_char_member(Config *config, Config_Compound *compound,
                            char *var_name, i32 index, char* var_out){
    return(config_compound_char_member(config, compound, SCu8(var_name), index, var_out));
}

static b32
config_compound_compound_member(Config *config, Config_Compound *compound,
                                String_Const_u8 var_name, i32 index, Config_Compound** var_out){
    Config_Get_Result result = config_compound_member(config, compound, var_name, index);
    b32 success = (result.success && result.type == ConfigRValueType_Compound);
    if (success){
        *var_out = result.compound;
    }
    return(success);
}

static b32
config_compound_compound_member(Config *config, Config_Compound *compound,
                                char *var_name, i32 index, Config_Compound** var_out){
    return(config_compound_compound_member(config, compound, SCu8(var_name), index, var_out));
}

static Iteration_Step_Result
typed_has_array_iteration_step(Config *config, Config_Compound *compound, i32 index){
    Config_Iteration_Step_Result result = typed_array_iteration_step(config, compound, ConfigRValueType_NoType, index);
    return(result.step);
}

static Iteration_Step_Result
typed_bool_array_iteration_step(Config *config, Config_Compound *compound, i32 index, b32* var_out){
    Config_Iteration_Step_Result result = typed_array_iteration_step(config, compound, ConfigRValueType_Boolean, index);
    b32 success = (result.step == Iteration_Good);
    if (success){
        *var_out = result.get.boolean;
    }
    return(result.step);
}

static Iteration_Step_Result
typed_int_array_iteration_step(Config *config, Config_Compound *compound, i32 index, i32* var_out){
    Config_Iteration_Step_Result result = typed_array_iteration_step(config, compound, ConfigRValueType_Integer, index);
    b32 success = (result.step == Iteration_Good);
    if (success){
        *var_out = result.get.integer;
    }
    return(result.step);
}

static Iteration_Step_Result
typed_uint_array_iteration_step(Config *config, Config_Compound *compound, i32 index, u32* var_out){
    Config_Iteration_Step_Result result = typed_array_iteration_step(config, compound, ConfigRValueType_Integer, index);
    b32 success = (result.step == Iteration_Good);
    if (success){
        *var_out = result.get.uinteger;
    }
    return(result.step);
}

static Iteration_Step_Result
typed_string_array_iteration_step(Config *config, Config_Compound *compound, i32 index, String_Const_u8* var_out){
    Config_Iteration_Step_Result result = typed_array_iteration_step(config, compound, ConfigRValueType_String, index);
    b32 success = (result.step == Iteration_Good);
    if (success){
        *var_out = result.get.string;
    }
    return(result.step);
}

static Iteration_Step_Result
typed_placed_string_array_iteration_step(Config *config, Config_Compound *compound, i32 index, String_Const_u8* var_out, u8 *space, u64 space_size){
    Config_Iteration_Step_Result result = typed_array_iteration_step(config, compound, ConfigRValueType_String, index);
    b32 success = (result.step == Iteration_Good);
    if (success){
        u64 size = result.get.string.size;
        size = (((size)<(space_size))?(size):(space_size));
        block_copy(space, result.get.string.str, size);
        *var_out = SCu8(space, size);
    }
    return(result.step);
}

static Iteration_Step_Result
typed_char_array_iteration_step(Config *config, Config_Compound *compound, i32 index, char* var_out){
    Config_Iteration_Step_Result result = typed_array_iteration_step(config, compound, ConfigRValueType_Character, index);
    b32 success = (result.step == Iteration_Good);
    if (success){
        *var_out = result.get.character;
    }
    return(result.step);
}

static Iteration_Step_Result
typed_compound_array_iteration_step(Config *config, Config_Compound *compound, i32 index, Config_Compound** var_out){
    Config_Iteration_Step_Result result = typed_array_iteration_step(config, compound, ConfigRValueType_Compound, index);
    b32 success = (result.step == Iteration_Good);
    if (success){
        *var_out = result.get.compound;
    }
    return(result.step);
}

static i32
typed_bool_array_get_count(Config *config, Config_Compound *compound){
    i32 count = typed_array_get_count(config, compound, ConfigRValueType_Boolean);
    return(count);
}

static i32
typed_int_array_get_count(Config *config, Config_Compound *compound){
    i32 count = typed_array_get_count(config, compound, ConfigRValueType_Integer);
    return(count);
}

static i32
typed_float_array_get_count(Config *config, Config_Compound *compound){
    i32 count = typed_array_get_count(config, compound, ConfigRValueType_Float);
    return(count);
}

static i32
typed_string_array_get_count(Config *config, Config_Compound *compound){
    i32 count = typed_array_get_count(config, compound, ConfigRValueType_String);
    return(count);
}

static i32
typed_character_array_get_count(Config *config, Config_Compound *compound){
    i32 count = typed_array_get_count(config, compound, ConfigRValueType_Character);
    return(count);
}

static i32
typed_compound_array_get_count(Config *config, Config_Compound *compound){
    i32 count = typed_array_get_count(config, compound, ConfigRValueType_Compound);
    return(count);
}

static i32
typed_no_type_array_get_count(Config *config, Config_Compound *compound){
    i32 count = typed_array_get_count(config, compound, ConfigRValueType_NoType);
    return(count);
}

static Config_Get_Result_List
typed_bool_array_reference_list(Arena *arena, Config *config, Config_Compound *compound){
    Config_Get_Result_List list = typed_array_reference_list(arena, config, compound, ConfigRValueType_Boolean);
    return(list);
}

static Config_Get_Result_List
typed_int_array_reference_list(Arena *arena, Config *config, Config_Compound *compound){
    Config_Get_Result_List list = typed_array_reference_list(arena, config, compound, ConfigRValueType_Integer);
    return(list);
}

static Config_Get_Result_List
typed_float_array_reference_list(Arena *arena, Config *config, Config_Compound *compound){
    Config_Get_Result_List list = typed_array_reference_list(arena, config, compound, ConfigRValueType_Float);
    return(list);
}

static Config_Get_Result_List
typed_string_array_reference_list(Arena *arena, Config *config, Config_Compound *compound){
    Config_Get_Result_List list = typed_array_reference_list(arena, config, compound, ConfigRValueType_String);
    return(list);
}

static Config_Get_Result_List
typed_character_array_reference_list(Arena *arena, Config *config, Config_Compound *compound){
    Config_Get_Result_List list = typed_array_reference_list(arena, config, compound, ConfigRValueType_Character);
    return(list);
}

static Config_Get_Result_List
typed_compound_array_reference_list(Arena *arena, Config *config, Config_Compound *compound){
    Config_Get_Result_List list = typed_array_reference_list(arena, config, compound, ConfigRValueType_Compound);
    return(list);
}

static Config_Get_Result_List
typed_no_type_array_reference_list(Arena *arena, Config *config, Config_Compound *compound){
    Config_Get_Result_List list = typed_array_reference_list(arena, config, compound, ConfigRValueType_NoType);
    return(list);
}



static Config_Iteration_Step_Result
typed_array_iteration_step(Config *parsed, Config_Compound *compound, Config_RValue_Type type, i32 index){
    Config_Iteration_Step_Result result = {};
    result.step = Iteration_Quit;
    Config_Get_Result get_result = config_compound_member(parsed, compound, SCu8((u8*)("~"), (u64)(sizeof("~") - 1)), index);
    if (get_result.success){
        if (get_result.type == type || type == ConfigRValueType_NoType){
            result.step = Iteration_Good;
            result.get = get_result;
        }
        else{
            result.step = Iteration_Skip;
        }
    }
    return(result);
}

static i32
typed_array_get_count(Config *parsed, Config_Compound *compound, Config_RValue_Type type){
    i32 count = 0;
    for (i32 i = 0;; ++i){
        Config_Iteration_Step_Result result = typed_array_iteration_step(parsed, compound, type, i);
        if (result.step == Iteration_Skip){
            continue;
        }
        else if (result.step == Iteration_Quit){
            break;
        }
        count += 1;
    }
    return(count);
}

static Config_Get_Result_List
typed_array_reference_list(Arena *arena, Config *parsed, Config_Compound *compound, Config_RValue_Type type){
    Config_Get_Result_List list = {};
    for (i32 i = 0;; ++i){
        Config_Iteration_Step_Result result = typed_array_iteration_step(parsed, compound, type, i);
        if (result.step == Iteration_Skip){
            continue;
        }
        else if (result.step == Iteration_Quit){
            break;
        }
        Config_Get_Result_Node *node = ((Config_Get_Result_Node*)linalloc_wrap_unintialized(linalloc_push((arena), sizeof(Config_Get_Result_Node)*(1), SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_config.cpp" ":" "1169" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_config.cpp" ":" "1169" ":") - 1)))));
        node->result = result.get;
        (((list.first)==0)?((node)->next=(node)->prev=0,(list.first)=(list.last)=(node)):((node)->prev=(list.last),(node)->next=0,(list.last)->next=(node),(list.last)=(node)));
        list.count += 1;
    }
    return(list);
}



static void
change_mode(Application_Links *app, String_Const_u8 mode){
    fcoder_mode = FCoderMode_Original;
    if (string_match(mode, SCu8((u8*)("4coder"), (u64)(sizeof("4coder") - 1)))){
        fcoder_mode = FCoderMode_Original;
    }
    else if (string_match(mode, SCu8((u8*)("notepad-like"), (u64)(sizeof("notepad-like") - 1)))){
        begin_notepad_mode(app);
    }
    else{
        print_message(app, SCu8((u8*)("Unknown mode.\n"), (u64)(sizeof("Unknown mode.\n") - 1)));
    }
}



static Token_Array
token_array_from_text(Application_Links *app, Arena *arena, String_Const_u8 data){
    Profile_Scope_Block profile_block_1197 ((app), SCu8((u8*)("token array from text"), (u64)(sizeof("token array from text") - 1)), SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_config.cpp" ":" "1197" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_config.cpp" ":" "1197" ":") - 1)));
    Token_List list = lex_full_input_cpp(arena, data);
    return(token_array_from_list(arena, &list));
}

static Config*
config_from_text(Application_Links *app, Arena *arena, String_Const_u8 file_name,
                 String_Const_u8 data){
    Config *parsed = 0;
    Temp_Memory restore_point = begin_temp(arena);
    Token_Array array = token_array_from_text(app, arena, data);
    if (array.tokens != 0){
        parsed = config_parse(app, arena, file_name, data, array);
        if (parsed == 0){
            end_temp(restore_point);
        }
    }
    return(parsed);
}



static void
config_init_default(Config_Data *config){
    config->user_name = SCu8(config->user_name_space, (u64)0);

    block_zero((&config->code_exts), sizeof(*(&config->code_exts)));

    config->mapping = SCu8(config->mapping_space, (u64)0);
    config->mode = SCu8(config->mode_space, (u64)0);

    config->bind_by_physical_key = false;
    config->use_scroll_bars = false;
    config->use_file_bars = true;
    config->hide_file_bar_in_ui = true;
    config->use_error_highlight = true;
    config->use_jump_highlight = true;
    config->use_scope_highlight = true;
    config->use_paren_helper = true;
    config->use_comment_keyword = true;
    config->lister_whole_word_backspace_when_modified = false;
    config->show_line_number_margins = false;
    config->enable_output_wrapping = false;
    config->enable_undo_fade_out = true;

    config->enable_virtual_whitespace = true;
    config->enable_code_wrapping = true;
    config->automatically_indent_text_on_save = true;
    config->automatically_save_changes_on_build = true;
    config->automatically_load_project = false;

    config->cursor_roundness = .45f;
    config->mark_thickness = 2.f;
    config->lister_roundness = .20f;

    config->virtual_whitespace_regular_indent = 4;

    config->indent_with_tabs = false;
    config->indent_width = 4;
    config->default_tab_width = 4;

    config->default_theme_name = SCu8(config->default_theme_name_space, sizeof("4coder") - 1);
    block_copy(config->default_theme_name.str, "4coder", config->default_theme_name.size);
    config->highlight_line_at_cursor = true;

    config->default_font_name = SCu8(config->default_font_name_space, (u64)0);
    config->default_font_size = 16;
    config->default_font_hinting = false;

    config->default_compiler_bat = SCu8(config->default_compiler_bat_space, 2);
    block_copy(config->default_compiler_bat.str, "cl", 2);

    config->default_flags_bat = SCu8(config->default_flags_bat_space, (u64)0);

    config->default_compiler_sh = SCu8(config->default_compiler_sh_space, 3);
    block_copy(config->default_compiler_sh.str, "g++", 3);

    config->default_flags_sh = SCu8(config->default_flags_sh_space, (u64)0);

    config->lalt_lctrl_is_altgr = false;
}

static Config*
config_parse__data(Application_Links *app, Arena *arena, String_Const_u8 file_name,
                   String_Const_u8 data, Config_Data *config){
    config_init_default(config);

    b32 success = false;

    Config *parsed = config_from_text(app, arena, file_name, data);
    if (parsed != 0){
        success = true;

        config_placed_string_var((parsed),("user_name"),(0),(&config->user_name),(config->user_name_space),sizeof(config->user_name_space))
                                                                            ;

        String_Const_u8 str = {};
        if (config_string_var(parsed, "treat_as_code", 0, &str)){
            config->code_exts =
                parse_extension_line_to_extension_list(app, arena, str);
        }

        config_placed_string_var((parsed),("mapping"),(0),(&config->mapping),(config->mapping_space),sizeof(config->mapping_space));
        config_placed_string_var((parsed),("mode"),(0),(&config->mode),(config->mode_space),sizeof(config->mode_space));

        config_bool_var(parsed, "bind_by_physical_key", 0, &config->bind_by_physical_key);
        config_bool_var(parsed, "use_scroll_bars", 0, &config->use_scroll_bars);
        config_bool_var(parsed, "use_file_bars", 0, &config->use_file_bars);
        config_bool_var(parsed, "hide_file_bar_in_ui", 0, &config->hide_file_bar_in_ui);
        config_bool_var(parsed, "use_error_highlight", 0, &config->use_error_highlight);
        config_bool_var(parsed, "use_jump_highlight", 0, &config->use_jump_highlight);
        config_bool_var(parsed, "use_scope_highlight", 0, &config->use_scope_highlight);
        config_bool_var(parsed, "use_paren_helper", 0, &config->use_paren_helper);
        config_bool_var(parsed, "use_comment_keyword", 0, &config->use_comment_keyword);
        config_bool_var(parsed, "lister_whole_word_backspace_when_modified", 0, &config->lister_whole_word_backspace_when_modified);
        config_bool_var(parsed, "show_line_number_margins", 0, &config->show_line_number_margins);
        config_bool_var(parsed, "enable_output_wrapping", 0, &config->enable_output_wrapping);
        config_bool_var(parsed, "enable_undo_fade_out", 0, &config->enable_undo_fade_out);


        config_bool_var(parsed, "enable_virtual_whitespace", 0, &config->enable_virtual_whitespace);
        config_bool_var(parsed, "enable_code_wrapping", 0, &config->enable_code_wrapping);
        config_bool_var(parsed, "automatically_indent_text_on_save", 0, &config->automatically_indent_text_on_save);
        config_bool_var(parsed, "automatically_save_changes_on_build", 0, &config->automatically_save_changes_on_build);
        config_bool_var(parsed, "automatically_load_project", 0, &config->automatically_load_project);

        {
            i32 x = 0;
            if (config_int_var(parsed, "cursor_roundness", 0, &x)){
                config->cursor_roundness = ((f32)x)*0.01f;
            }
            if (config_int_var(parsed, "mark_thickness", 0, &x)){
                config->mark_thickness = (f32)x;
            }
            if (config_int_var(parsed, "lister_roundness", 0, &x)){
                config->lister_roundness = ((f32)x)*0.01f;
            }
        }

        config_int_var(parsed, "virtual_whitespace_regular_indent", 0, &config->virtual_whitespace_regular_indent);

        config_bool_var(parsed, "indent_with_tabs", 0, &config->indent_with_tabs);
        config_int_var(parsed, "indent_width", 0, &config->indent_width);
        config_int_var(parsed, "default_tab_width", 0, &config->default_tab_width);

        config_placed_string_var((parsed),("default_theme_name"),(0),(&config->default_theme_name),(config->default_theme_name_space),sizeof(config->default_theme_name_space))
                                                                                              ;
        config_bool_var(parsed, "highlight_line_at_cursor", 0, &config->highlight_line_at_cursor);

        config_placed_string_var((parsed),("default_font_name"),(0),(&config->default_font_name),(config->default_font_name_space),sizeof(config->default_font_name_space))
                                                                                            ;
        config_int_var(parsed, "default_font_size", 0, &config->default_font_size);
        config_bool_var(parsed, "default_font_hinting", 0, &config->default_font_hinting);

        config_placed_string_var((parsed),("default_compiler_bat"),(0),(&config->default_compiler_bat),(config->default_compiler_bat_space),sizeof(config->default_compiler_bat_space))
                                                                                                  ;
        config_placed_string_var((parsed),("default_flags_bat"),(0),(&config->default_flags_bat),(config->default_flags_bat_space),sizeof(config->default_flags_bat_space))
                                                                                            ;
        config_placed_string_var((parsed),("default_compiler_sh"),(0),(&config->default_compiler_sh),(config->default_compiler_sh_space),sizeof(config->default_compiler_sh_space))
                                                                                                ;
        config_placed_string_var((parsed),("default_flags_sh"),(0),(&config->default_flags_sh),(config->default_flags_sh_space),sizeof(config->default_flags_sh_space))
                                                                                          ;

        config_bool_var(parsed, "lalt_lctrl_is_altgr", 0, &config->lalt_lctrl_is_altgr);
    }

    if (!success){
        config_init_default(config);
    }

    return(parsed);
}

static Config*
config_parse__file_handle(Application_Links *app, Arena *arena,
                          String_Const_u8 file_name, FILE *file, Config_Data *config){
    Config *parsed = 0;
    Data data = dump_file_handle(arena, file);
    if (data.data != 0){
        parsed = config_parse__data(app, arena, file_name, SCu8(data), config);
    }
    else{
        config_init_default(config);
    }
    return(parsed);
}

static Config*
config_parse__file_name(Application_Links *app, Arena *arena, char *file_name, Config_Data *config){
    Config *parsed = 0;
    b32 success = false;
    FILE *file = open_file_try_current_path_then_binary_path(app, file_name);
    if (file != 0){
        Data data = dump_file_handle(arena, file);
        fclose(file);
        if (data.data != 0){
            parsed = config_parse__data(app, arena, SCu8(file_name), SCu8(data),
                                        config);
            success = true;
        }
    }
    if (!success){
        config_init_default(config);
    }
    return(parsed);
}

static Config*
theme_parse__data(Application_Links *app, Arena *arena, String_Const_u8 file_name, String_Const_u8 data, Arena *color_arena, Color_Table *color_table){
    Config *parsed = config_from_text(app, arena, file_name, data);
    if (parsed != 0){
        for (Config_Assignment *node = parsed->first;
             node != 0;
             node = node->next){
            Scratch_Block scratch(app, arena);
            Config_LValue *l = node->l;
            String_Const_u8 l_name = push_string_copy(scratch, l->identifier);
            Managed_ID id = managed_id_get(app, SCu8((u8*)("colors"), (u64)(sizeof("colors") - 1)), l_name);
            if (id != 0){
                u32 color = 0;
                if (config_uint_var(parsed, l_name, 0, &color)){
                    color_table->arrays[id%color_table->count] = make_colors(color_arena, color);
                }
                else{
                    Config_Compound *compound = 0;
                    if (config_compound_var(parsed, l_name, 0, &compound)){
                        static u32 color_array[256];
                        i32 counter = 0;
                        for (i32 i = 0;; i += 1){
                            Config_Iteration_Step_Result result = typed_array_iteration_step(parsed, compound, ConfigRValueType_Integer, i);
                            if (result.step == Iteration_Skip){
                                continue;
                            }
                            else if (result.step == Iteration_Quit){
                                break;
                            }

                            color_array[counter] = result.get.uinteger;
                            counter += 1;
                            if (counter == 256){
                                break;
                            }
                        }

                        color_table->arrays[id%color_table->count] = make_colors(color_arena, color_array, counter);
                    }
                }
            }

        }
    }
    return(parsed);
}

static Config*
theme_parse__buffer(Application_Links *app, Arena *arena, Buffer_ID buffer, Arena *color_arena, Color_Table *color_table){
    String_Const_u8 contents = push_whole_buffer(app, arena, buffer);
    Config *parsed = 0;
    if (contents.str != 0){
        String_Const_u8 file_name = push_buffer_file_name(app, arena, buffer);
        parsed = theme_parse__data(app, arena, file_name, contents, color_arena, color_table);
    }
    return(parsed);
}

static Config*
theme_parse__file_handle(Application_Links *app, Arena *arena, String_Const_u8 file_name, FILE *file, Arena *color_arena, Color_Table *color_table){
    Data data = dump_file_handle(arena, file);
    Config *parsed = 0;
    if (data.data != 0){
        parsed = theme_parse__data(app, arena, file_name, SCu8(data), color_arena, color_table);
    }
    return(parsed);
}

static Config*
theme_parse__file_name(Application_Links *app, Arena *arena, char *file_name, Arena *color_arena, Color_Table *color_table){
    Config *parsed = 0;
    FILE *file = open_file_try_current_path_then_binary_path(app, file_name);
    if (file != 0){
        Data data = dump_file_handle(arena, file);
        fclose(file);
        parsed = theme_parse__data(app, arena, SCu8(file_name), SCu8(data), color_arena, color_table);
    }
    if (parsed == 0){
        Scratch_Block scratch(app, arena);
        String_Const_u8 str = push_u8_stringf(scratch, "Did not find %s, theme not loaded", file_name);
        print_message(app, str);
    }
    return(parsed);
}



static void
config_feedback_bool(Arena *arena, List_String_Const_u8 *list, char *name, b32 val){
    string_list_pushf(arena, list, "%s = %s;\n", name, (char*)(val?"true":"false"));
}

static void
config_feedback_string(Arena *arena, List_String_Const_u8 *list, char *name, String_Const_u8 val){
    val.size = (((0)>(val.size))?(0):(val.size));
    string_list_pushf(arena, list, "%s = \"%.*s\";\n", name, (i32)(val).size, (char*)(val).str);
}

static void
config_feedback_string(Arena *arena, List_String_Const_u8 *list, char *name, char *val){
    string_list_pushf(arena, list, "%s = \"%s\";\n", name, val);
}

static void
config_feedback_extension_list(Arena *arena, List_String_Const_u8 *list, char *name, String_Const_u8_Array *extensions){
    string_list_pushf(arena, list, "%s = \"", name);
    for (i32 i = 0; i < extensions->count; ++i){
        String_Const_u8 ext = extensions->strings[i];
        string_list_pushf(arena, list, ".%.*s", (i32)(ext).size, (char*)(ext).str);
    }
    string_list_push((arena), (list), SCu8((u8*)("\";\n"), (u64)(sizeof("\";\n") - 1)));
}

static void
config_feedback_int(Arena *arena, List_String_Const_u8 *list, char *name, i32 val){
    string_list_pushf(arena, list, "%s = %d;\n", name, val);
}



static void
load_config_and_apply(Application_Links *app, Arena *out_arena, Config_Data *config,
                      i32 override_font_size, b32 override_hinting){
    Scratch_Block scratch(app, out_arena);

    linalloc_clear(out_arena);
    Config *parsed = config_parse__file_name(app, out_arena, "config.4coder", config);

    if (parsed != 0){

        print_message(app, SCu8((u8*)("Loaded config file:\n"), (u64)(sizeof("Loaded config file:\n") - 1)));


        String_Const_u8 error_text = config_stringize_errors(app, scratch, parsed);
        if (error_text.str != 0){
            print_message(app, error_text);
        }
    }
    else{
        print_message(app, SCu8((u8*)("Using default config:\n"), (u64)(sizeof("Using default config:\n") - 1)));
        Face_Description description = get_face_description(app, 0);
        if (description.font.file_name.str != 0){
            u64 size = (((description.font.file_name.size)<(sizeof(config->default_font_name_space)))?(description.font.file_name.size):(sizeof(config->default_font_name_space)));
            block_copy(config->default_font_name_space, description.font.file_name.str, size);
            config->default_font_name.size = size;
        }
    }

    if (config->default_font_name.size == 0){

        block_copy(config->default_font_name_space, "liberation-mono.ttf", sizeof("liberation-mono.ttf") - 1);
        config->default_font_name.size = sizeof("liberation-mono.ttf") - 1;

    }

    {

        Temp_Memory temp2 = begin_temp(scratch);
        List_String_Const_u8 list = {};

        config_feedback_string(scratch, &list, "user_name", config->user_name);
        config_feedback_extension_list(scratch, &list, "treat_as_code", &config->code_exts);

        config_feedback_string(scratch, &list, "mapping", config->mapping);
        config_feedback_string(scratch, &list, "mode", config->mode);

        config_feedback_bool(scratch, &list, "bind_by_physical_key", config->bind_by_physical_key);
        config_feedback_bool(scratch, &list, "use_scroll_bars", config->use_scroll_bars);
        config_feedback_bool(scratch, &list, "use_file_bars", config->use_file_bars);
        config_feedback_bool(scratch, &list, "hide_file_bar_in_ui", config->hide_file_bar_in_ui);
        config_feedback_bool(scratch, &list, "use_error_highlight", config->use_error_highlight);
        config_feedback_bool(scratch, &list, "use_jump_highlight", config->use_jump_highlight);
        config_feedback_bool(scratch, &list, "use_scope_highlight", config->use_scope_highlight);
        config_feedback_bool(scratch, &list, "use_paren_helper", config->use_paren_helper);
        config_feedback_bool(scratch, &list, "use_comment_keyword", config->use_comment_keyword);
        config_feedback_bool(scratch, &list, "lister_whole_word_backspace_when_modified", config->lister_whole_word_backspace_when_modified);
        config_feedback_bool(scratch, &list, "show_line_number_margins", config->show_line_number_margins);
        config_feedback_bool(scratch, &list, "enable_output_wrapping", config->enable_output_wrapping);
        config_feedback_bool(scratch, &list, "enable_undo_fade_out", config->enable_undo_fade_out);

        config_feedback_int(scratch, &list, "cursor_roundness", (i32)(config->cursor_roundness*100.f));
        config_feedback_int(scratch, &list, "mark_thickness", (i32)(config->mark_thickness));
        config_feedback_int(scratch, &list, "lister_roundness", (i32)(config->lister_roundness*100.f));

        config_feedback_bool(scratch, &list, "enable_virtual_whitespace", config->enable_virtual_whitespace);
        config_feedback_int(scratch, &list, "virtual_whitespace_regular_indent", config->virtual_whitespace_regular_indent);
        config_feedback_bool(scratch, &list, "enable_code_wrapping", config->enable_code_wrapping);
        config_feedback_bool(scratch, &list, "automatically_indent_text_on_save", config->automatically_indent_text_on_save);
        config_feedback_bool(scratch, &list, "automatically_save_changes_on_build", config->automatically_save_changes_on_build);
        config_feedback_bool(scratch, &list, "automatically_load_project", config->automatically_load_project);

        config_feedback_bool(scratch, &list, "indent_with_tabs", config->indent_with_tabs);
        config_feedback_int(scratch, &list, "indent_width", config->indent_width);
        config_feedback_int(scratch, &list, "default_tab_width", config->default_tab_width);

        config_feedback_string(scratch, &list, "default_theme_name", config->default_theme_name);
        config_feedback_bool(scratch, &list, "highlight_line_at_cursor", config->highlight_line_at_cursor);

        config_feedback_string(scratch, &list, "default_font_name", config->default_font_name);
        config_feedback_int(scratch, &list, "default_font_size", config->default_font_size);
        config_feedback_bool(scratch, &list, "default_font_hinting", config->default_font_hinting);

        config_feedback_string(scratch, &list, "default_compiler_bat", config->default_compiler_bat);
        config_feedback_string(scratch, &list, "default_flags_bat", config->default_flags_bat);
        config_feedback_string(scratch, &list, "default_compiler_sh", config->default_compiler_sh);
        config_feedback_string(scratch, &list, "default_flags_sh", config->default_flags_sh);

        config_feedback_bool(scratch, &list, "lalt_lctrl_is_altgr", config->lalt_lctrl_is_altgr);

        string_list_push((scratch), (&list), SCu8((u8*)("\n"), (u64)(sizeof("\n") - 1)));
        String_Const_u8 message = string_list_flatten(scratch, list);
        print_message(app, message);
        end_temp(temp2);
    }


    setup_built_in_mapping(app, config->mapping, &framework_mapping, mapid_global, mapid_file, mapid_code);
    change_mode(app, config->mode);
    global_set_setting(app, GlobalSetting_LAltLCtrlIsAltGr, config->lalt_lctrl_is_altgr);

    Color_Table *colors = get_color_table_by_name(config->default_theme_name);
    set_active_color(colors);

    Face_Description description = {};
    if (override_font_size != 0){
        description.parameters.pt_size = override_font_size;
    }
    else{
        description.parameters.pt_size = config->default_font_size;
    }
    description.parameters.hinting = config->default_font_hinting || override_hinting;

    description.font.file_name = config->default_font_name;
    if (!modify_global_face_by_description(app, description)){
        description.font.file_name = get_file_path_in_fonts_folder(scratch, config->default_font_name);
        modify_global_face_by_description(app, description);
    }

    if (config->bind_by_physical_key){
        system_set_key_mode(KeyMode_Physical);
    }
    else{
        system_set_key_mode(KeyMode_LanguageArranged);
    }
}

static void
load_theme_file_into_live_set(Application_Links *app, char *file_name){
    Arena *arena = &global_theme_arena;
    Color_Table color_table = make_color_table(app, arena);
    Scratch_Block scratch(app, arena);
    Config *config = theme_parse__file_name(app, scratch, file_name, arena, &color_table);
    String_Const_u8 error_text = config_stringize_errors(app, scratch, config);
    print_message(app, error_text);

    String_Const_u8 name = SCu8(file_name);
    name = string_front_of_path(name);
    if (string_match(string_postfix(name, 7), SCu8((u8*)(".4coder"), (u64)(sizeof(".4coder") - 1)))){
        name = string_chop(name, 7);
    }
    save_theme(color_table, name);
}

CUSTOM_COMMAND(load_theme_current_buffer, "/home/sam/.bin/4coder/custom/4coder_config.cpp", 1667, Normal)
CUSTOM_DOC("Parse the current buffer as a theme file and add the theme to the theme list. If the buffer has a .4coder postfix in it's name, it is removed when the name is saved.")
{
    View_ID view = get_active_view(app, Access_ReadVisible);
    Buffer_ID buffer = view_get_buffer(app, view, Access_ReadVisible);

    Scratch_Block scratch(app);
    String_Const_u8 file_name = push_buffer_file_name(app, scratch, buffer);
    if (file_name.size > 0){
        Arena *arena = &global_theme_arena;
        Color_Table color_table = make_color_table(app, arena);
        Config *config = theme_parse__buffer(app, scratch, buffer, arena, &color_table);
        String_Const_u8 error_text = config_stringize_errors(app, scratch, config);
        print_message(app, error_text);

        u64 problem_score = 0;
        if (color_table.count < defcolor_line_numbers_text){
            problem_score = defcolor_line_numbers_text - color_table.count;
        }
        for (i32 i = 0; i < color_table.count; i += 1){
            if (color_table.arrays[i].count == 0){
                problem_score += 1;
            }
        }

        if (error_text.size > 0 || problem_score >= 10){
            String_Const_u8 string = push_u8_stringf(scratch, "There appears to be a problem parsing %.*s; no theme change applied\n", (i32)(file_name).size, (char*)(file_name).str);
            print_message(app, string);
        }
        else{
            String_Const_u8 name = string_front_of_path(file_name);
            if (string_match(string_postfix(name, 7), SCu8((u8*)(".4coder"), (u64)(sizeof(".4coder") - 1)))){
                name = string_chop(name, 7);
            }
            save_theme(color_table, name);

            Color_Table_Node *node = global_theme_list.last;
            if (node != 0 && string_match(node->name, name)){
                active_color_table = node->table;
            }
        }
    }
}

static void
load_folder_of_themes_into_live_set(Application_Links *app, String_Const_u8 path){
    Scratch_Block scratch(app);

    File_List list = system_get_file_list(scratch, path);
    for (File_Info **ptr = list.infos, **end = list.infos + list.count;
         ptr < end;
         ptr += 1){
        File_Info *info = *ptr;
        if (!(((info->attributes.flags)&(FileAttribute_IsDirectory))!=0)){
            String_Const_u8 name = info->file_name;
            Temp_Memory_Block temp(scratch);
            String_Const_u8 full_name = push_u8_stringf(scratch, "%.*s/%.*s",
                                                        (i32)(path).size, (char*)(path).str,
                                                        (i32)(name).size, (char*)(name).str);
            load_theme_file_into_live_set(app, (char*)full_name.str);
        }
    }
}
# 102 "/home/sam/.bin/4coder/custom/4coder_default_include.cpp" 2
# 1 "/home/sam/.bin/4coder/custom/4coder_default_framework.cpp" 1






static void
point_stack_push(Application_Links *app, Buffer_ID buffer, i64 pos){
    Managed_Object object = alloc_buffer_markers_on_buffer(app, buffer, 1, 0);
    Marker *marker = (Marker*)managed_object_get_pointer(app, object);
    marker->pos = pos;
    marker->lean_right = false;

    i32 next_top = (point_stack.top + 1)%((sizeof(point_stack.markers))/(sizeof(*point_stack.markers)));
    if (next_top == point_stack.bot){
        Point_Stack_Slot *slot = &point_stack.markers[point_stack.bot];
        managed_object_free(app, slot->object);
        block_zero((slot), sizeof(*(slot)));
        point_stack.bot = (point_stack.bot + 1)%((sizeof(point_stack.markers))/(sizeof(*point_stack.markers)));
    }

    Point_Stack_Slot *slot = &point_stack.markers[point_stack.top];
    slot->buffer = buffer;
    slot->object = object;
    point_stack.top = next_top;
}

static void
point_stack_push_view_cursor(Application_Links *app, View_ID view){
    Buffer_ID buffer = view_get_buffer(app, view, Access_Always);
    i64 pos = view_get_cursor_pos(app, view);
    point_stack_push(app, buffer, pos);
}

static b32
point_stack_pop(Application_Links *app){
    b32 result = false;
    if (point_stack.top != point_stack.bot){
        result = true;
        if (point_stack.top > 0){
            point_stack.top -= 1;
        }
        else{
            point_stack.top = ((sizeof(point_stack.markers))/(sizeof(*point_stack.markers))) - 1;
        }
        Point_Stack_Slot *slot = &point_stack.markers[point_stack.top];
        managed_object_free(app, slot->object);
        block_zero((slot), sizeof(*(slot)));
    }
    return(result);
}

static b32
point_stack_read_top(Application_Links *app, Buffer_ID *buffer_out, i64 *pos_out){
    b32 result = false;
    if (point_stack.top != point_stack.bot){
        result = true;
        i32 prev_top = point_stack.top;
        if (prev_top > 0){
            prev_top -= 1;
        }
        else{
            prev_top = ((sizeof(point_stack.markers))/(sizeof(*point_stack.markers))) - 1;
        }
        Point_Stack_Slot *slot = &point_stack.markers[prev_top];
        Managed_Object object = slot->object;
        Marker *marker = (Marker*)managed_object_get_pointer(app, object);
        if (marker != 0){
            *buffer_out = slot->buffer;
            *pos_out = marker->pos;
        }
        else{
            *buffer_out = 0;
            *pos_out = 0;
        }
    }
    return(result);
}



static void
unlock_jump_buffer(void){
    locked_buffer.size = 0;
}

static void
lock_jump_buffer(Application_Links *app, String_Const_u8 name){
    if (name.size < sizeof(locked_buffer_space)){
        block_copy(locked_buffer_space, name.str, name.size);
        locked_buffer = SCu8(locked_buffer_space, name.size);
        Scratch_Block scratch(app);
        String_Const_u8 escaped = string_escape(scratch, name);
        do{ Temp_Memory temp_LOG_F = begin_temp(scratch); String_Const_u8 E = push_u8_stringf(scratch, "lock jump buffer [name=\"%.*s\"]", (i32)(escaped).size, (char*)(escaped).str); do{ Temp_Memory temp_LOG = begin_temp(scratch); String_Const_u8 M = log_event(scratch, E, SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_default_framework.cpp"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_default_framework.cpp") - 1)), 94, (0), (0), (system_thread_get_id())); log_string(app, M); end_temp(temp_LOG); }while(0); end_temp(temp_LOG_F); }while(0)
                                                                             ;
    }
}

static void
lock_jump_buffer(Application_Links *app, char *name, i32 size){
    lock_jump_buffer(app, SCu8(name, size));
}

static void
lock_jump_buffer(Application_Links *app, Buffer_ID buffer_id){
    Scratch_Block scratch(app);
    String_Const_u8 buffer_name = push_buffer_unique_name(app, scratch, buffer_id);
    lock_jump_buffer(app, buffer_name);
}

static Buffer_ID
get_locked_jump_buffer(Application_Links *app){
    Buffer_ID result = 0;
    if (locked_buffer.size > 0){
        result = get_buffer_by_name(app, locked_buffer, Access_Always);
    }
    if (result == 0){
        unlock_jump_buffer();
    }
    return(result);
}

static View_ID
get_view_for_locked_jump_buffer(Application_Links *app){
    View_ID result = 0;
    Buffer_ID buffer = get_locked_jump_buffer(app);
    if (buffer != 0){
        result = get_first_view_with_buffer(app, buffer);
    }
    return(result);
}



static void
new_view_settings(Application_Links *app, View_ID view){
    if (!global_config.use_scroll_bars){
        view_set_setting(app, view, ViewSetting_ShowScrollbar, false);
    }
    if (!global_config.use_file_bars){
        view_set_setting(app, view, ViewSetting_ShowFileBar, false);
    }
}




static void
view_set_passive(Application_Links *app, View_ID view_id, b32 value){
    Managed_Scope scope = view_get_managed_scope(app, view_id);
    b32 *is_passive = ((b32*)managed_scope_get_attachment((app), (scope), (view_is_passive_loc), sizeof(b32)));
    if (is_passive != 0){
        *is_passive = value;
    }
}

static b32
view_get_is_passive(Application_Links *app, View_ID view_id){
    Managed_Scope scope = view_get_managed_scope(app, view_id);
    b32 *is_passive = ((b32*)managed_scope_get_attachment((app), (scope), (view_is_passive_loc), sizeof(b32)));
    b32 result = false;
    if (is_passive != 0){
        result = *is_passive;
    }
    return(result);
}

static View_ID
open_footer_panel(Application_Links *app, View_ID view){
    View_ID special_view = open_view(app, view, ViewSplit_Bottom);
    new_view_settings(app, special_view);
    Buffer_ID buffer = view_get_buffer(app, special_view, Access_Always);
    Face_ID face_id = get_face_id(app, buffer);
    Face_Metrics metrics = get_face_metrics(app, face_id);
    view_set_split_pixel_size(app, special_view, (i32)(metrics.line_height*14.f));
    view_set_passive(app, special_view, true);
    return(special_view);
}

static void
close_build_footer_panel(Application_Links *app){
    if (view_exists(app, build_footer_panel_view_id)){
        view_close(app, build_footer_panel_view_id);
    }
    build_footer_panel_view_id = 0;
}

static View_ID
open_build_footer_panel(Application_Links *app){
    if (!view_exists(app, build_footer_panel_view_id)){
        View_ID view = get_active_view(app, Access_Always);
        build_footer_panel_view_id = open_footer_panel(app, view);
        view_set_active(app, view);
    }
    return(build_footer_panel_view_id);
}

static View_ID
get_next_view_looped_primary_panels(Application_Links *app, View_ID start_view_id, Access_Flag access){
    View_ID view_id = start_view_id;
    do{
        view_id = get_next_view_looped_all_panels(app, view_id, access);
        if (!view_get_is_passive(app, view_id)){
            break;
        }
    }while(view_id != start_view_id);
    return(view_id);
}

static View_ID
get_prev_view_looped_primary_panels(Application_Links *app, View_ID start_view_id, Access_Flag access){
    View_ID view_id = start_view_id;
    do{
        view_id = get_prev_view_looped_all_panels(app, view_id, access);
        if (!view_get_is_passive(app, view_id)){
            break;
        }
    }while(view_id != start_view_id);
    return(view_id);
}

static View_ID
get_next_view_after_active(Application_Links *app, Access_Flag access){
    View_ID view = get_active_view(app, access);
    if (view != 0){
        view = get_next_view_looped_primary_panels(app, view, access);
    }
    return(view);
}



static void
call_after_ctx_shutdown(Application_Links *app, View_ID view, Custom_Command_Function *func){
    view_enqueue_command_function(app, view, func);
}

static Fallback_Dispatch_Result
fallback_command_dispatch(Application_Links *app, Mapping *mapping, Command_Map *map,
                          User_Input *in){
    Fallback_Dispatch_Result result = {};
    if (mapping != 0 && map != 0){
        Command_Binding binding = map_get_binding_recursive(mapping, map, &in->event);
        if (binding.custom != 0){
            Command_Metadata *metadata = get_command_metadata(binding.custom);
            if (metadata != 0){
                if (metadata->is_ui){
                    result.code = FallbackDispatch_DelayedUICall;
                    result.func = binding.custom;
                }
                else{
                    binding.custom(app);
                    result.code = FallbackDispatch_DidCall;
                }
            }
            else{
                binding.custom(app);
                result.code = FallbackDispatch_DidCall;
            }
        }
    }
    return(result);
}

static b32
ui_fallback_command_dispatch(Application_Links *app, View_ID view,
                             Mapping *mapping, Command_Map *map, User_Input *in){
    b32 result = false;
    Fallback_Dispatch_Result disp_result =
        fallback_command_dispatch(app, mapping, map, in);
    if (disp_result.code == FallbackDispatch_DelayedUICall){
        call_after_ctx_shutdown(app, view, disp_result.func);
        result = true;
    }
    if (disp_result.code == FallbackDispatch_Unhandled){
        leave_current_input_unhandled(app);
    }
    return(result);
}

static b32
ui_fallback_command_dispatch(Application_Links *app, View_ID view, User_Input *in){
    b32 result = false;
    View_Context ctx = view_current_context(app, view);
    if (ctx.mapping != 0){
        Command_Map *map = mapping_get_map(ctx.mapping, ctx.map_id);
        result = ui_fallback_command_dispatch(app, view, ctx.mapping, map, in);
    }
    else{
        leave_current_input_unhandled(app);
    }
    return(result);
}



static void
view_buffer_set(Application_Links *app, Buffer_ID *buffers, i64 *positions, i32 count){
    if (count > 0){
        Scratch_Block scratch(app);

        struct View_Node{
            View_Node *next;
            View_ID view_id;
        };

        View_ID active_view_id = get_active_view(app, Access_Always);
        View_ID first_view_id = active_view_id;
        if (view_get_is_passive(app, active_view_id)){
            first_view_id = get_next_view_looped_primary_panels(app, active_view_id, Access_Always);
        }

        View_ID view_id = first_view_id;

        View_Node *primary_view_first = 0;
        View_Node *primary_view_last = 0;
        i32 available_view_count = 0;

        primary_view_first = primary_view_last = ((View_Node*)linalloc_wrap_unintialized(linalloc_push((scratch), sizeof(View_Node)*(1), SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_default_framework.cpp" ":" "319" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_default_framework.cpp" ":" "319" ":") - 1)))));
        primary_view_last->next = 0;
        primary_view_last->view_id = view_id;
        available_view_count += 1;
        for (;;){
            view_id = get_next_view_looped_primary_panels(app, view_id, Access_Always);
            if (view_id == first_view_id){
                break;
            }
            View_Node *node = ((View_Node*)linalloc_wrap_unintialized(linalloc_push((scratch), sizeof(View_Node)*(1), SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_default_framework.cpp" ":" "328" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_default_framework.cpp" ":" "328" ":") - 1)))));
            primary_view_last->next = node;
            node->next = 0;
            node->view_id = view_id;
            primary_view_last = node;
            available_view_count += 1;
        }

        i32 buffer_set_count = (((count)<(available_view_count))?(count):(available_view_count));
        View_Node *node = primary_view_first;
        for (i32 i = 0; i < buffer_set_count; i += 1, node = node->next){
            if (view_set_buffer(app, node->view_id, buffers[i], 0)){
                view_set_cursor_and_preferred_x(app, node->view_id, seek_pos(positions[i]));
            }
        }
    }
}



static void
change_active_panel_send_command(Application_Links *app, Custom_Command_Function *custom_func){
    View_ID view = get_active_view(app, Access_Always);
    view = get_next_view_looped_primary_panels(app, view, Access_Always);
    if (view != 0){
        view_set_active(app, view);
    }
    if (custom_func != 0){
        view_enqueue_command_function(app, view, custom_func);
    }
}

CUSTOM_COMMAND(change_active_panel, "/home/sam/.bin/4coder/custom/4coder_default_framework.cpp", 360, Normal)
CUSTOM_DOC("Change the currently active panel, moving to the panel with the next highest view_id.")
{
    change_active_panel_send_command(app, 0);
}

CUSTOM_COMMAND(change_active_panel_backwards, "/home/sam/.bin/4coder/custom/4coder_default_framework.cpp", 366, Normal)
CUSTOM_DOC("Change the currently active panel, moving to the panel with the next lowest view_id.")
{
    View_ID view = get_active_view(app, Access_Always);
    view = get_prev_view_looped_primary_panels(app, view, Access_Always);
    if (view != 0){
        view_set_active(app, view);
    }
}

CUSTOM_COMMAND(open_panel_vsplit, "/home/sam/.bin/4coder/custom/4coder_default_framework.cpp", 376, Normal)
CUSTOM_DOC("Create a new panel by vertically splitting the active panel.")
{
    View_ID view = get_active_view(app, Access_Always);
    View_ID new_view = open_view(app, view, ViewSplit_Right);
    new_view_settings(app, new_view);
    Buffer_ID buffer = view_get_buffer(app, view, Access_Always);
    view_set_buffer(app, new_view, buffer, 0);
}

CUSTOM_COMMAND(open_panel_hsplit, "/home/sam/.bin/4coder/custom/4coder_default_framework.cpp", 386, Normal)
CUSTOM_DOC("Create a new panel by horizontally splitting the active panel.")
{
    View_ID view = get_active_view(app, Access_Always);
    View_ID new_view = open_view(app, view, ViewSplit_Bottom);
    new_view_settings(app, new_view);
    Buffer_ID buffer = view_get_buffer(app, view, Access_Always);
    view_set_buffer(app, new_view, buffer, 0);
}





static Buffer_ID
create_or_switch_to_buffer_and_clear_by_name(Application_Links *app, String_Const_u8 name_string, View_ID default_target_view){
    Buffer_ID search_buffer = get_buffer_by_name(app, name_string, Access_Always);
    if (search_buffer != 0){
        buffer_set_setting(app, search_buffer, BufferSetting_ReadOnly, true);

        View_ID target_view = default_target_view;

        View_ID view_with_buffer_already_open = get_first_view_with_buffer(app, search_buffer);
        if (view_with_buffer_already_open != 0){
            target_view = view_with_buffer_already_open;



        }
        else{
            view_set_buffer(app, target_view, search_buffer, 0);
        }
        view_set_active(app, target_view);

        clear_buffer(app, search_buffer);
        buffer_send_end_signal(app, search_buffer);
    }
    else{
        search_buffer = create_buffer(app, name_string, BufferCreate_AlwaysNew);
        buffer_set_setting(app, search_buffer, BufferSetting_Unimportant, true);
        buffer_set_setting(app, search_buffer, BufferSetting_ReadOnly, true);



        view_set_buffer(app, default_target_view, search_buffer, 0);
        view_set_active(app, default_target_view);
    }

    return(search_buffer);
}



static void
save_all_dirty_buffers_with_postfix(Application_Links *app, String_Const_u8 postfix){
    Profile_Scope_Block profile_block_441 ((app), SCu8((u8*)("save all dirty buffers"), (u64)(sizeof("save all dirty buffers") - 1)), SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_default_framework.cpp" ":" "441" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_default_framework.cpp" ":" "441" ":") - 1)));
    Scratch_Block scratch(app);
    for (Buffer_ID buffer = get_buffer_next(app, 0, Access_ReadWriteVisible);
         buffer != 0;
         buffer = get_buffer_next(app, buffer, Access_ReadWriteVisible)){
        Dirty_State dirty = buffer_get_dirty_state(app, buffer);
        if (dirty == DirtyState_UnsavedChanges){
            Temp_Memory temp = begin_temp(scratch);
            String_Const_u8 file_name = push_buffer_file_name(app, scratch, buffer);
            if (string_match(string_postfix(file_name, postfix.size), postfix)){
                buffer_save(app, buffer, file_name, 0);
            }
            end_temp(temp);
        }
    }
}

CUSTOM_COMMAND(save_all_dirty_buffers, "/home/sam/.bin/4coder/custom/4coder_default_framework.cpp", 458, Normal)
CUSTOM_DOC("Saves all buffers marked dirty (showing the '*' indicator).")
{
    String_Const_u8 empty = {};
    save_all_dirty_buffers_with_postfix(app, empty);
}



static void
set_mouse_suppression(b32 suppress){
    if (suppress){
        suppressing_mouse = true;
        system_show_mouse_cursor(MouseCursorShow_Never);
    }
    else{
        suppressing_mouse = false;
        system_show_mouse_cursor(MouseCursorShow_Always);
    }
}

CUSTOM_COMMAND(suppress_mouse, "/home/sam/.bin/4coder/custom/4coder_default_framework.cpp", 479, Normal)
CUSTOM_DOC("Hides the mouse and causes all mosue input (clicks, position, wheel) to be ignored.")
{
    set_mouse_suppression(true);
}

CUSTOM_COMMAND(allow_mouse, "/home/sam/.bin/4coder/custom/4coder_default_framework.cpp", 485, Normal)
CUSTOM_DOC("Shows the mouse and causes all mouse input to be processed normally.")
{
    set_mouse_suppression(false);
}

CUSTOM_COMMAND(toggle_mouse, "/home/sam/.bin/4coder/custom/4coder_default_framework.cpp", 491, Normal)
CUSTOM_DOC("Toggles the mouse suppression mode, see suppress_mouse and allow_mouse.")
{
    set_mouse_suppression(!suppressing_mouse);
}

CUSTOM_COMMAND(set_mode_to_original, "/home/sam/.bin/4coder/custom/4coder_default_framework.cpp", 497, Normal)
CUSTOM_DOC("Sets the edit mode to 4coder original.")
{
    fcoder_mode = FCoderMode_Original;
}

CUSTOM_COMMAND(set_mode_to_notepad_like, "/home/sam/.bin/4coder/custom/4coder_default_framework.cpp", 503, Normal)
CUSTOM_DOC("Sets the edit mode to Notepad like.")
{
    begin_notepad_mode(app);
}

CUSTOM_COMMAND(toggle_highlight_line_at_cursor, "/home/sam/.bin/4coder/custom/4coder_default_framework.cpp", 509, Normal)
CUSTOM_DOC("Toggles the line highlight at the cursor.")
{
    global_config.highlight_line_at_cursor = !global_config.highlight_line_at_cursor;
}

CUSTOM_COMMAND(toggle_highlight_enclosing_scopes, "/home/sam/.bin/4coder/custom/4coder_default_framework.cpp", 515, Normal)
CUSTOM_DOC("In code files scopes surrounding the cursor are highlighted with distinguishing colors.")
{
    global_config.use_scope_highlight = !global_config.use_scope_highlight;
}

CUSTOM_COMMAND(toggle_paren_matching_helper, "/home/sam/.bin/4coder/custom/4coder_default_framework.cpp", 521, Normal)
CUSTOM_DOC("In code files matching parentheses pairs are colored with distinguishing colors.")
{
    global_config.use_paren_helper = !global_config.use_paren_helper;
}

CUSTOM_COMMAND(toggle_fullscreen, "/home/sam/.bin/4coder/custom/4coder_default_framework.cpp", 527, Normal)
CUSTOM_DOC("Toggle fullscreen mode on or off.  The change(s) do not take effect until the next frame.")
{
    system_set_fullscreen(!system_is_fullscreen());
}

CUSTOM_COMMAND(load_themes_default_folder, "/home/sam/.bin/4coder/custom/4coder_default_framework.cpp", 533, Normal)
CUSTOM_DOC("Loads all the theme files in the default theme folder.")
{
    String_Const_u8 fcoder_extension = SCu8((u8*)(".4coder"), (u64)(sizeof(".4coder") - 1));
    save_all_dirty_buffers_with_postfix(app, fcoder_extension);

    Scratch_Block scratch(app);
    String_Const_u8 bin_path = system_get_path(scratch, SystemPath_Binary);
    String_Const_u8 path = push_u8_stringf(scratch, "%.*sthemes", (i32)(bin_path).size, (char*)(bin_path).str);
    load_folder_of_themes_into_live_set(app, path);
}

CUSTOM_COMMAND(load_themes_hot_directory, "/home/sam/.bin/4coder/custom/4coder_default_framework.cpp", 545, Normal)
CUSTOM_DOC("Loads all the theme files in the current hot directory.")
{
    String_Const_u8 fcoder_extension = SCu8((u8*)(".4coder"), (u64)(sizeof(".4coder") - 1));
    save_all_dirty_buffers_with_postfix(app, fcoder_extension);

    Scratch_Block scratch(app);
    String_Const_u8 path = push_hot_directory(app, scratch);
    load_folder_of_themes_into_live_set(app, path);
}

CUSTOM_COMMAND(clear_all_themes, "/home/sam/.bin/4coder/custom/4coder_default_framework.cpp", 556, Normal)
CUSTOM_DOC("Clear the theme list")
{
    if (global_theme_arena.base_allocator == 0){
        global_theme_arena = make_arena_system();
    }
    else{
        linalloc_clear(&global_theme_arena);
    }

    block_zero((&global_theme_list), sizeof(*(&global_theme_list)));
    set_default_color_scheme(app);
}



static void
default_4coder_initialize(Application_Links *app, String_Const_u8_Array file_names,
                          i32 override_font_size, b32 override_hinting){
# 587 "/home/sam/.bin/4coder/custom/4coder_default_framework.cpp"
    print_message(app, SCu8((u8*)("Welcome to " "beta " "4" "." "1" "." "6" "\n" "If you're new to 4coder there is a built in tutorial\n" "Use the key combination [ X Alt ] (on mac [ X Control ])\n" "Type in 'hms_demo_tutorial' and press enter\n" "\n" "Direct bug reports and feature requests to https://github.com/4coder-editor/4coder/issues\n" "\n" "Other questions and discussion can be directed to editor@4coder.net or 4coder.handmade.network\n" "\n" "The change log can be found in CHANGES.txt\n" "\n"), (u64)(sizeof("Welcome to " "beta " "4" "." "1" "." "6" "\n" "If you're new to 4coder there is a built in tutorial\n" "Use the key combination [ X Alt ] (on mac [ X Control ])\n" "Type in 'hms_demo_tutorial' and press enter\n" "\n" "Direct bug reports and feature requests to https://github.com/4coder-editor/4coder/issues\n" "\n" "Other questions and discussion can be directed to editor@4coder.net or 4coder.handmade.network\n" "\n" "The change log can be found in CHANGES.txt\n" "\n") - 1)));


    load_config_and_apply(app, &global_config_arena, &global_config, override_font_size, override_hinting);


    Scratch_Block scratch(app);
    String_Const_u8 hot_directory = push_hot_directory(app, scratch);
    for (i32 i = 0; i < file_names.count; i += 1){
        Temp_Memory_Block temp(scratch);
        String_Const_u8 input_name = file_names.vals[i];
        String_Const_u8 full_name = push_u8_stringf(scratch, "%.*s/%.*s",
                                                    (i32)(hot_directory).size, (char*)(hot_directory).str,
                                                    (i32)(input_name).size, (char*)(input_name).str);
        Buffer_ID new_buffer = create_buffer(app, full_name, BufferCreate_NeverNew|BufferCreate_MustAttachToFile);
        if (new_buffer == 0){
            create_buffer(app, input_name, 0);
        }
    }
}

static void
default_4coder_initialize(Application_Links *app,
                          i32 override_font_size, b32 override_hinting){
    String_Const_u8_Array file_names = {};
    default_4coder_initialize(app, file_names, override_font_size, override_hinting);
}

static void
default_4coder_initialize(Application_Links *app, String_Const_u8_Array file_names){
    Face_Description description = get_face_description(app, 0);
    default_4coder_initialize(app, file_names,
                              description.parameters.pt_size,
                              description.parameters.hinting);
}

static void
default_4coder_initialize(Application_Links *app){
    Face_Description command_line_description = get_face_description(app, 0);
    String_Const_u8_Array file_names = {};
    default_4coder_initialize(app, file_names, command_line_description.parameters.pt_size, command_line_description.parameters.hinting);
}

static void
default_4coder_side_by_side_panels(Application_Links *app,
                                   Buffer_Identifier left, Buffer_Identifier right){
    Buffer_ID left_id = buffer_identifier_to_id(app, left);
    Buffer_ID right_id = buffer_identifier_to_id(app, right);


    View_ID view = get_active_view(app, Access_Always);
    new_view_settings(app, view);
    view_set_buffer(app, view, left_id, 0);


    open_panel_vsplit(app);
    View_ID right_view = get_active_view(app, Access_Always);
    view_set_buffer(app, right_view, right_id, 0);


    view_set_active(app, view);
}

static void
default_4coder_side_by_side_panels(Application_Links *app,
                                   Buffer_Identifier left, Buffer_Identifier right,
                                   String_Const_u8_Array file_names){
    if (file_names.count > 0){
        left = buffer_identifier(file_names.vals[0]);
        if (file_names.count > 1){
            right = buffer_identifier(file_names.vals[1]);
        }
    }
    default_4coder_side_by_side_panels(app, left, right);
}

static void
default_4coder_side_by_side_panels(Application_Links *app, String_Const_u8_Array file_names){
    Buffer_Identifier left = buffer_identifier(SCu8((u8*)("*scratch*"), (u64)(sizeof("*scratch*") - 1)));
    Buffer_Identifier right = buffer_identifier(SCu8((u8*)("*messages*"), (u64)(sizeof("*messages*") - 1)));
    default_4coder_side_by_side_panels(app, left, right, file_names);
}

static void
default_4coder_side_by_side_panels(Application_Links *app){
    String_Const_u8_Array file_names = {};
    default_4coder_side_by_side_panels(app, file_names);
}

static void
default_4coder_one_panel(Application_Links *app, Buffer_Identifier buffer){
    Buffer_ID id = buffer_identifier_to_id(app, buffer);
    View_ID view = get_active_view(app, Access_Always);
    new_view_settings(app, view);
    view_set_buffer(app, view, id, 0);
}

static void
default_4coder_one_panel(Application_Links *app, String_Const_u8_Array file_names){
    Buffer_Identifier buffer = buffer_identifier(SCu8((u8*)("*messages*"), (u64)(sizeof("*messages*") - 1)));
    if (file_names.count > 0){
        buffer = buffer_identifier(file_names.vals[0]);
    }
    default_4coder_one_panel(app, buffer);
}

static void
default_4coder_one_panel(Application_Links *app){
    String_Const_u8_Array file_names = {};
    default_4coder_one_panel(app, file_names);
}



static void
buffer_modified_set_init(void){
    Buffer_Modified_Set *set = &global_buffer_modified_set;

    block_zero((set), sizeof(*(set)));
    Base_Allocator *allocator = get_base_allocator_system();
    set->arena = make_arena(allocator);
    set->id_to_node = make_table_u64_u64__inner((allocator),(100),SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_default_framework.cpp" ":" "708" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_default_framework.cpp" ":" "708" ":") - 1)));
}

static Buffer_Modified_Node*
buffer_modified_set__alloc_node(Buffer_Modified_Set *set){
    Buffer_Modified_Node *result = set->free;
    if (result == 0){
        result = ((Buffer_Modified_Node*)linalloc_wrap_unintialized(linalloc_push((&set->arena), sizeof(Buffer_Modified_Node)*(1), SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_default_framework.cpp" ":" "715" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_default_framework.cpp" ":" "715" ":") - 1)))));
    }
    else{
        ((set->free)=(set->free)=(set->free)->next);
    }
    return(result);
}

static void
buffer_mark_as_modified(Buffer_ID buffer){
    Buffer_Modified_Set *set = &global_buffer_modified_set;

    Table_Lookup lookup = table_lookup(&set->id_to_node, (u64)buffer);
    if (!lookup.found_match){
        Buffer_Modified_Node *node = buffer_modified_set__alloc_node(set);
        (((set->first)==0)?((node)->next=(node)->prev=0,(set->first)=(set->last)=(node)):((node)->prev=(set->last),(node)->next=0,(set->last)->next=(node),(set->last)=(node)));
        node->buffer = buffer;
        table_insert(&set->id_to_node, (u64)buffer, (u64)((u8*)(node) - (u8*)(0)));
    }
}

static void
buffer_unmark_as_modified(Buffer_ID buffer){
    Buffer_Modified_Set *set = &global_buffer_modified_set;

    Table_Lookup lookup = table_lookup(&set->id_to_node, (u64)buffer);
    if (lookup.found_match){
        u64 val = 0;
        table_read(&set->id_to_node, (u64)buffer, &val);
        Buffer_Modified_Node *node = (Buffer_Modified_Node*)(void*)(((u8*)0) + val);
        (((set->last)==(node))?((((set->first)==(set->last))?((set->first)=(set->last)=0):((set->last)->prev->next=0,(set->last)=(set->last)->prev))) :((set->first)==(node))?((((set->last)==(set->first))?((set->last)=(set->first)=0):((set->first)->next->prev=0,(set->first)=(set->first)->next))) : ((node)->next->prev=(node)->prev,(node)->prev->next=(node)->next,(node)->next=(node)->prev=0));
        table_erase(&set->id_to_node, lookup);
        ((node)->next=(set->free),(set->free)=(node));
    }
}

static void
buffer_modified_set_clear(void){
    Buffer_Modified_Set *set = &global_buffer_modified_set;

    table_clear(&set->id_to_node);
    if (set->last != 0){
        set->last->next = set->free;
        set->free = set->first;
        set->first = 0;
        set->last = 0;
    }
}



static Fade_Range*
alloc_fade_range(void){
    Fade_Range *result = free_fade_ranges;
    if (result == 0){
        result = ((Fade_Range*)linalloc_wrap_unintialized(linalloc_push((&fade_range_arena), sizeof(Fade_Range)*(1), SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_default_framework.cpp" ":" "770" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_default_framework.cpp" ":" "770" ":") - 1)))));
    }
    else{
        ((free_fade_ranges)=(free_fade_ranges)=(free_fade_ranges)->next);
    }
    block_zero((result), sizeof(*(result)));
    return(result);
}

static void
free_fade_range(Fade_Range *range){
    ((range)->next=(free_fade_ranges),(free_fade_ranges)=(range));
}

static Fade_Range*
buffer_post_fade(Application_Links *app, Buffer_ID buffer_id, f32 seconds, Range_i64 range, ARGB_Color color){
    Fade_Range *fade_range = alloc_fade_range();
    do{ if((fade_range)){if((buffer_fade_ranges.first)){(buffer_fade_ranges.last)->next=(fade_range);}else{(buffer_fade_ranges.first)=(fade_range);}(buffer_fade_ranges.last)=(fade_range);(buffer_fade_ranges.last)->next=0;} }while(0);
    buffer_fade_ranges.count += 1;
    fade_range->buffer_id = buffer_id;
    fade_range->t = seconds;
    fade_range->full_t = seconds;
    fade_range->range = range;
    fade_range->color = color;
    return(fade_range);
}

static void
buffer_shift_fade_ranges(Buffer_ID buffer_id, i64 shift_after_p, i64 shift_amount){
    for (Fade_Range *node = buffer_fade_ranges.first;
         node != 0;
         node = node->next){
        if (node->buffer_id == buffer_id){
            if (node->range.min >= shift_after_p){
                node->range.min += shift_amount;
                node->range.max += shift_amount;
            }
            else if (node->range.max >= shift_after_p){
                node->range.max += shift_amount;
            }
        }
    }
}

static b32
tick_all_fade_ranges(Application_Links *app, f32 t){
    Fade_Range **prev_next = &buffer_fade_ranges.first;
    for (Fade_Range *node = buffer_fade_ranges.first, *next = 0;
         node != 0;
         node = next){
        next = node->next;
        node->t -= t;
        if (node->t <= 0.f){
            if (node->finish_call != 0){
                node->finish_call(app, node);
            }
            *prev_next = next;
            free_fade_range(node);
            buffer_fade_ranges.count -= 1;
        }
        else{
            prev_next = &node->next;
            buffer_fade_ranges.last = node;
        }
    }
    return(buffer_fade_ranges.count > 0);
}

static void
paint_fade_ranges(Application_Links *app, Text_Layout_ID layout, Buffer_ID buffer){
    for (Fade_Range *node = buffer_fade_ranges.first;
         node != 0;
         node = node->next){
        if (node->buffer_id == buffer){
            f32 blend = node->t/node->full_t;
            if (node->negate_fade_direction){
                blend = 1.f - blend;
            }
            paint_text_color_blend(app, layout, node->range, node->color, blend);
        }
    }
}



static void
clipboard_init_empty(Clipboard *clipboard, u32 history_depth){
    history_depth = (((1)>(history_depth))?(1):(history_depth));
    heap_init(&clipboard->heap, &clipboard->arena);
    clipboard->clip_index = 0;
    clipboard->clip_capacity = history_depth;
    clipboard->clips = ((String_Const_u8*)linalloc_wrap_zero(linalloc_push((&clipboard->arena), sizeof(String_Const_u8)*(history_depth), SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_default_framework.cpp" ":" "861" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_default_framework.cpp" ":" "861" ":") - 1)))));
}

static void
clipboard_init(Base_Allocator *allocator, u32 history_depth, Clipboard *clipboard_out){
    u64 memsize = sizeof(String_Const_u8)*history_depth;
    memsize = round_up_u64(memsize, ((4) << 10));
    clipboard_out->arena = make_arena(allocator, memsize, 8);
    clipboard_init_empty(clipboard_out, history_depth);
}

static void
clipboard_clear(Clipboard *clipboard){
    linalloc_clear(&clipboard->arena);
    clipboard_init_empty(clipboard, clipboard->clip_capacity);
}

static String_Const_u8
clipboard_post_internal_only(Clipboard *clipboard, String_Const_u8 string){
    u32 rolled_index = clipboard->clip_index%clipboard->clip_capacity;
    clipboard->clip_index += 1;
    String_Const_u8 *slot = &clipboard->clips[rolled_index];
    if (slot->str != 0){
        if (slot->size < string.size ||
            (slot->size - string.size) > ((1) << 10)){
            heap_free(&clipboard->heap, slot->str);
            goto alloc_new;
        }
    }
    else{
        alloc_new:;
        u8 *new_buf = (u8*)heap_allocate(&clipboard->heap, string.size);
        slot->str = new_buf;
    }
    block_copy(slot->str, string.str, string.size);
    slot->size = string.size;
    return(*slot);
}

static u32
clipboard_count(Clipboard *clipboard){
    u32 result = clipboard->clip_index;
    result = (((result)<(clipboard->clip_capacity))?(result):(clipboard->clip_capacity));
    return(result);
}

static String_Const_u8
get_clipboard_index(Clipboard *clipboard, u32 item_index){
    String_Const_u8 result = {};
    u32 top = (((clipboard->clip_index)<(clipboard->clip_capacity))?(clipboard->clip_index):(clipboard->clip_capacity));
    if (top > 0){
        item_index = item_index%top;
        i32 array_index = ((clipboard->clip_index - 1) - item_index)%top;
        result = clipboard->clips[array_index];
    }
    return(result);
}

static String_Const_u8
push_clipboard_index(Arena *arena, Clipboard *clipboard, i32 item_index){
    String_Const_u8 result = get_clipboard_index(clipboard, item_index);
    result = push_string_copy(arena, result);
    return(result);
}



static void
clipboard_clear(i32 clipboard_id){
    clipboard_clear(&clipboard0);
}

static String_Const_u8
clipboard_post_internal_only(i32 clipboard_id, String_Const_u8 string){
    return(clipboard_post_internal_only(&clipboard0, string));
}

static b32
clipboard_post(i32 clipboard_id, String_Const_u8 string){
    clipboard_post_internal_only(clipboard_id, string);
    system_post_clipboard(string, clipboard_id);
    return(true);
}

static i32
clipboard_count(i32 clipboard_id){
    return(clipboard_count(&clipboard0));
}

static String_Const_u8
push_clipboard_index(Arena *arena, i32 clipboard_id, i32 item_index){
    return(push_clipboard_index(arena, &clipboard0, item_index));
}



static void
initialize_managed_id_metadata(Application_Links *app);

static void
default_framework_init(Application_Links *app){
    Thread_Context *tctx = get_thread_context(app);
    async_task_handler_init(app, &global_async_system);
    clipboard_init(get_base_allocator_system(), 64, &clipboard0);
    code_index_init();
    buffer_modified_set_init();
    Profile_Global_List *list = get_core_profile_list(app);
    profile_thread_set_name((tctx), (list), (SCu8((u8*)("main"), (u64)(sizeof("main") - 1))));
    initialize_managed_id_metadata(app);
    set_default_color_scheme(app);
    heap_init(&global_heap, tctx->allocator);
    global_config_arena = make_arena_system();
    fade_range_arena = make_arena_system(((8) << 10));
}



static void
default_input_handler_init(Application_Links *app, Arena *arena){
    Thread_Context *tctx = get_thread_context(app);

    View_ID view = get_this_ctx_view(app, Access_Always);
    String_Const_u8 name = push_u8_stringf(arena, "view %d", view);

    Profile_Global_List *list = get_core_profile_list(app);
    profile_thread_set_name((tctx), (list), (name));

    View_Context ctx = view_current_context(app, view);
    ctx.mapping = &framework_mapping;
    ctx.map_id = mapid_global;
    view_alter_context(app, view, &ctx);
}

static Command_Map_ID
default_get_map_id(Application_Links *app, View_ID view){
    Command_Map_ID result = 0;
    Buffer_ID buffer = view_get_buffer(app, view, Access_Always);
    Managed_Scope buffer_scope = buffer_get_managed_scope(app, buffer);
    Command_Map_ID *result_ptr = ((Command_Map_ID*)managed_scope_get_attachment((app), (buffer_scope), (buffer_map_id), sizeof(Command_Map_ID)));
    if (result_ptr != 0){
        if (*result_ptr == 0){
            *result_ptr = mapid_file;
        }
        result = *result_ptr;
    }
    else{
        result = mapid_global;
    }
    return(result);
}

static void
set_next_rewrite(Application_Links *app, View_ID view, Rewrite_Type rewrite){
    Managed_Scope scope = view_get_managed_scope(app, view);
    Rewrite_Type *next_rewrite = ((Rewrite_Type*)managed_scope_get_attachment((app), (scope), (view_next_rewrite_loc), sizeof(Rewrite_Type)));
    *next_rewrite = rewrite;
}

static void
default_pre_command(Application_Links *app, Managed_Scope scope){
    Rewrite_Type *next_rewrite =
        ((Rewrite_Type*)managed_scope_get_attachment((app), (scope), (view_next_rewrite_loc), sizeof(Rewrite_Type)));
    *next_rewrite = Rewrite_None;
    if (fcoder_mode == FCoderMode_NotepadLike){
        for (View_ID view_it = get_view_next(app, 0, Access_Always);
             view_it != 0;
             view_it = get_view_next(app, view_it, Access_Always)){
            Managed_Scope scope_it = view_get_managed_scope(app, view_it);
            b32 *snap_mark_to_cursor =
                ((b32*)managed_scope_get_attachment((app), (scope_it), (view_snap_mark_to_cursor), sizeof(b32)))
                                     ;
            *snap_mark_to_cursor = true;
        }
    }
}

static void
default_post_command(Application_Links *app, Managed_Scope scope){
    Rewrite_Type *next_rewrite = ((Rewrite_Type*)managed_scope_get_attachment((app), (scope), (view_next_rewrite_loc), sizeof(Rewrite_Type)));
    if (next_rewrite != 0){
        if (*next_rewrite != Rewrite_NoChange){
            Rewrite_Type *rewrite =
                ((Rewrite_Type*)managed_scope_get_attachment((app), (scope), (view_rewrite_loc), sizeof(Rewrite_Type)));
            *rewrite = *next_rewrite;
        }
    }
    if (fcoder_mode == FCoderMode_NotepadLike){
        for (View_ID view_it = get_view_next(app, 0, Access_Always);
             view_it != 0;
             view_it = get_view_next(app, view_it, Access_Always)){
            Managed_Scope scope_it = view_get_managed_scope(app, view_it);
            b32 *snap_mark_to_cursor =
                ((b32*)managed_scope_get_attachment((app), (scope_it), (view_snap_mark_to_cursor), sizeof(b32)));
            if (*snap_mark_to_cursor){
                i64 pos = view_get_cursor_pos(app, view_it);
                view_set_mark(app, view_it, seek_pos(pos));
            }
        }
    }
}
# 103 "/home/sam/.bin/4coder/custom/4coder_default_include.cpp" 2
# 1 "/home/sam/.bin/4coder/custom/4coder_clipboard.cpp" 1






CUSTOM_COMMAND(clipboard_record_clip, "/home/sam/.bin/4coder/custom/4coder_clipboard.cpp", 7, Normal)
CUSTOM_DOC("In response to a new clipboard contents events, saves the new clip onto the clipboard history")
{
    User_Input in = get_current_input(app);
    if (in.event.kind == InputEventKind_Core &&
        in.event.core.code == CoreCode_NewClipboardContents){
        clipboard_post_internal_only(0, in.event.core.string);
    }
}



static b32
clipboard_post_buffer_range(Application_Links *app, i32 clipboard_index, Buffer_ID buffer, Range_i64 range){
    b32 success = false;
    Scratch_Block scratch(app);
    String_Const_u8 string = push_buffer_range(app, scratch, buffer, range);
    if (string.size > 0){
        clipboard_post(clipboard_index, string);
        success = true;
    }
    return(success);
}

static b32
clipboard_update_history_from_system(Application_Links *app, i32 clipboard_id){
    Scratch_Block scratch(app);
    b32 result = false;
    String_Const_u8 string = system_get_clipboard(scratch, clipboard_id);
    if (string.str != 0){
        clipboard_post_internal_only(clipboard_id, string);
        result = true;
    }
    return(result);
}

static List_String_Const_u8 clipboard_collection_list = {};

static void
clipboard_collection_render(Application_Links *app, Frame_Info frame_info, View_ID view){
    Scratch_Block scratch(app);
    Rect_f32 region = draw_background_and_margin(app, view);
    Vec2_f32 mid_p = (region.p1 + region.p0)*0.5f;

    Fancy_Block message = {};
    Fancy_Line *line = push_fancy_line(scratch, &message);
    push_fancy_string(scratch, line, fcolor_id(defcolor_pop2),
                      SCu8((u8*)("Collecting all clipboard events "), (u64)(sizeof("Collecting all clipboard events ") - 1)));
    push_fancy_string(scratch, line, fcolor_id(defcolor_pop1),
                      SCu8((u8*)("press [escape] to stop"), (u64)(sizeof("press [escape] to stop") - 1)));

    for (Node_String_Const_u8 *node = clipboard_collection_list.first;
         node != 0;
         node = node->next){
        line = push_fancy_line(scratch, &message);
        push_fancy_string(scratch, line, fcolor_id(defcolor_text_default), node->string);
    }

    Face_ID face_id = get_face_id(app, 0);
    Vec2_f32 dim = get_fancy_block_dim(app, face_id, &message);
    Vec2_f32 half_dim = dim*0.5f;
    draw_fancy_block(app, face_id, fcolor_zero(), &message, mid_p - half_dim);
}

CUSTOM_COMMAND(begin_clipboard_collection_mode, "/home/sam/.bin/4coder/custom/4coder_clipboard.cpp", 71, UI)
CUSTOM_DOC("Allows the user to copy multiple strings from other applications before switching to 4coder and pasting them all.")
{
    static b32 in_clipboard_collection_mode = false;
    if (!in_clipboard_collection_mode){
        in_clipboard_collection_mode = true;
        system_set_clipboard_catch_all(true);

        Scratch_Block scratch(app);
        block_zero((&clipboard_collection_list), sizeof(*(&clipboard_collection_list)));

        View_ID view = get_this_ctx_view(app, Access_Always);
        View_Context ctx = view_current_context(app, view);
        ctx.render_caller = clipboard_collection_render;
        ctx.hides_buffer = true;
        View_Context_Block ctx_block(app, view, &ctx);

        for (;;){
            User_Input in = get_next_input(app, EventPropertyGroup_Any, EventProperty_Escape);
            if (in.abort){
                break;
            }
            if (in.event.kind == InputEventKind_KeyStroke && in.event.key.code == KeyCode_Escape){
                break;
            }
            if (in.event.kind == InputEventKind_Core &&
                in.event.core.code == CoreCode_NewClipboardContents){
                String_Const_u8 stable_clip = clipboard_post_internal_only(0, in.event.core.string);
                string_list_push(scratch, &clipboard_collection_list, stable_clip);
            }
        }

        block_zero((&clipboard_collection_list), sizeof(*(&clipboard_collection_list)));

        system_set_clipboard_catch_all(false);
        in_clipboard_collection_mode = false;
    }
}

CUSTOM_COMMAND(copy, "/home/sam/.bin/4coder/custom/4coder_clipboard.cpp", 110, Normal)
CUSTOM_DOC("Copy the text in the range from the cursor to the mark onto the clipboard.")
{
    View_ID view = get_active_view(app, Access_ReadVisible);
    Buffer_ID buffer = view_get_buffer(app, view, Access_ReadVisible);
    Range_i64 range = get_view_range(app, view);
    clipboard_post_buffer_range(app, 0, buffer, range);
}

CUSTOM_COMMAND(cut, "/home/sam/.bin/4coder/custom/4coder_clipboard.cpp", 119, Normal)
CUSTOM_DOC("Cut the text in the range from the cursor to the mark onto the clipboard.")
{
    View_ID view = get_active_view(app, Access_ReadWriteVisible);
    Buffer_ID buffer = view_get_buffer(app, view, Access_ReadWriteVisible);
    Range_i64 range = get_view_range(app, view);
    if (clipboard_post_buffer_range(app, 0, buffer, range)){
        buffer_replace_range(app, buffer, range, string_u8_empty);
    }
}

CUSTOM_COMMAND(paste, "/home/sam/.bin/4coder/custom/4coder_clipboard.cpp", 130, Normal)
CUSTOM_DOC("At the cursor, insert the text at the top of the clipboard.")
{
    clipboard_update_history_from_system(app, 0);
    i32 count = clipboard_count(0);
    if (count > 0){
        View_ID view = get_active_view(app, Access_ReadWriteVisible);
        if_view_has_highlighted_range_delete_range(app, view);

        set_next_rewrite(app, view, Rewrite_Paste);

        Managed_Scope scope = view_get_managed_scope(app, view);
        i32 *paste_index = ((i32*)managed_scope_get_attachment((app), (scope), (view_paste_index_loc), sizeof(i32)));
        if (paste_index != 0){
            *paste_index = 0;

            Scratch_Block scratch(app);

            String_Const_u8 string = push_clipboard_index(scratch, 0, *paste_index);
            if (string.size > 0){
                Buffer_ID buffer = view_get_buffer(app, view, Access_ReadWriteVisible);

                i64 pos = view_get_cursor_pos(app, view);
                buffer_replace_range(app, buffer, Ii64(pos), string);
                view_set_mark(app, view, seek_pos(pos));
                view_set_cursor_and_preferred_x(app, view, seek_pos(pos + (i32)string.size));

                ARGB_Color argb = fcolor_resolve(fcolor_id(defcolor_paste));
                buffer_post_fade(app, buffer, 0.667f, Ii64_size(pos, string.size), argb);
            }
        }
    }
}

CUSTOM_COMMAND(paste_next, "/home/sam/.bin/4coder/custom/4coder_clipboard.cpp", 164, Normal)
CUSTOM_DOC("If the previous command was paste or paste_next, replaces the paste range with the next text down on the clipboard, otherwise operates as the paste command.")
{
    Scratch_Block scratch(app);

    b32 new_clip = clipboard_update_history_from_system(app, 0);

    i32 count = clipboard_count(0);
    if (count > 0){
        View_ID view = get_active_view(app, Access_ReadWriteVisible);
        Managed_Scope scope = view_get_managed_scope(app, view);

        Rewrite_Type *rewrite = ((Rewrite_Type*)managed_scope_get_attachment((app), (scope), (view_rewrite_loc), sizeof(Rewrite_Type)));
        if (rewrite != 0){
            if (*rewrite == Rewrite_Paste && !new_clip){
                no_mark_snap_to_cursor(app, scope);

                set_next_rewrite(app, view, Rewrite_Paste);

                i32 *paste_index_ptr = ((i32*)managed_scope_get_attachment((app), (scope), (view_paste_index_loc), sizeof(i32)));
                i32 paste_index = (*paste_index_ptr) + 1;
                *paste_index_ptr = paste_index;

                String_Const_u8 string = push_clipboard_index(scratch, 0, paste_index);

                Buffer_ID buffer = view_get_buffer(app, view, Access_ReadWriteVisible);

                Range_i64 range = get_view_range(app, view);
                i64 pos = range.min;

                buffer_replace_range(app, buffer, range, string);
                view_set_cursor_and_preferred_x(app, view, seek_pos(pos + string.size));

                ARGB_Color argb = fcolor_resolve(fcolor_id(defcolor_paste));
                buffer_post_fade(app, buffer, 0.667f, Ii64_size(pos, string.size), argb);
            }
            else{
                paste(app);
            }
        }
    }
}

CUSTOM_COMMAND(paste_and_indent, "/home/sam/.bin/4coder/custom/4coder_clipboard.cpp", 207, Normal)
CUSTOM_DOC("Paste from the top of clipboard and run auto-indent on the newly pasted text.")
{
    paste(app);
    auto_indent_range(app);
}

CUSTOM_COMMAND(paste_next_and_indent, "/home/sam/.bin/4coder/custom/4coder_clipboard.cpp", 214, Normal)
CUSTOM_DOC("Paste the next item on the clipboard and run auto-indent on the newly pasted text.")
{
    paste_next(app);
    auto_indent_range(app);
}

CUSTOM_COMMAND(clear_clipboard, "/home/sam/.bin/4coder/custom/4coder_clipboard.cpp", 221, Normal)
CUSTOM_DOC("Clears the history of the clipboard")
{
    clipboard_clear(0);
}



CUSTOM_COMMAND(multi_paste, "/home/sam/.bin/4coder/custom/4coder_clipboard.cpp", 229, Normal)
CUSTOM_DOC("Paste multiple entries from the clipboard at once")
{
    Scratch_Block scratch(app);

    i32 count = clipboard_count(0);
    if (count > 0){
        View_ID view = get_active_view(app, Access_ReadWriteVisible);
        Managed_Scope scope = view_get_managed_scope(app, view);

        Rewrite_Type *rewrite = ((Rewrite_Type*)managed_scope_get_attachment((app), (scope), (view_rewrite_loc), sizeof(Rewrite_Type)));
        if (rewrite != 0){
            if (*rewrite == Rewrite_Paste){
                Rewrite_Type *next_rewrite = ((Rewrite_Type*)managed_scope_get_attachment((app), (scope), (view_next_rewrite_loc), sizeof(Rewrite_Type)));
                *next_rewrite = Rewrite_Paste;
                i32 *paste_index_ptr = ((i32*)managed_scope_get_attachment((app), (scope), (view_paste_index_loc), sizeof(i32)));
                i32 paste_index = (*paste_index_ptr) + 1;
                *paste_index_ptr = paste_index;

                String_Const_u8 string = push_clipboard_index(scratch, 0, paste_index);

                String_Const_u8 insert_string = push_u8_stringf(scratch, "\n%.*s", (i32)(string).size, (char*)(string).str);

                Buffer_ID buffer = view_get_buffer(app, view, Access_ReadWriteVisible);
                Range_i64 range = get_view_range(app, view);
                buffer_replace_range(app, buffer, Ii64(range.max), insert_string);
                view_set_mark(app, view, seek_pos(range.max + 1));
                view_set_cursor_and_preferred_x(app, view, seek_pos(range.max + insert_string.size));

                ARGB_Color argb = fcolor_resolve(fcolor_id(defcolor_paste));
                buffer_post_fade(app, buffer, 0.667f, Ii64(range.max + 1, range.max + insert_string.size), argb);
            }
            else{
                paste(app);
            }
        }
    }
}

static Range_i64
multi_paste_range(Application_Links *app, View_ID view, Range_i64 range, i32 paste_count, b32 old_to_new){
    Scratch_Block scratch(app);

    Range_i64 finish_range = range;
    if (paste_count >= 1){
        Buffer_ID buffer = view_get_buffer(app, view, Access_ReadWriteVisible);
        if (buffer != 0){
            i64 total_size = 0;
            for (i32 paste_index = 0; paste_index < paste_count; ++paste_index){
                Temp_Memory temp = begin_temp(scratch);
                String_Const_u8 string = push_clipboard_index(scratch, 0, paste_index);
                total_size += string.size + 1;
                end_temp(temp);
            }
            total_size -= 1;

            i32 first = paste_count - 1;
            i32 one_past_last = -1;
            i32 step = -1;
            if (!old_to_new){
                first = 0;
                one_past_last = paste_count;
                step = 1;
            }

            List_String_Const_u8 list = {};

            for (i32 paste_index = first; paste_index != one_past_last; paste_index += step){
                if (paste_index != first){
                    string_list_push(scratch, &list, SCu8("\n", 1));
                }
                String_Const_u8 string = push_clipboard_index(scratch, 0, paste_index);
                if (string.size > 0){
                    string_list_push(scratch, &list, string);
                }
            }

            String_Const_u8 flattened = string_list_flatten(scratch, list);

            buffer_replace_range(app, buffer, range, flattened);
            i64 pos = range.min;
            finish_range.min = pos;
            finish_range.max = pos + total_size;
            view_set_mark(app, view, seek_pos(finish_range.min));
            view_set_cursor_and_preferred_x(app, view, seek_pos(finish_range.max));

            ARGB_Color argb = fcolor_resolve(fcolor_id(defcolor_paste));
            buffer_post_fade(app, buffer, 0.667f, finish_range, argb);
        }
    }
    return(finish_range);
}

static void
multi_paste_interactive_up_down(Application_Links *app, i32 paste_count, i32 clip_count){
    View_ID view = get_active_view(app, Access_ReadWriteVisible);
    i64 pos = view_get_cursor_pos(app, view);
    b32 old_to_new = true;
    Range_i64 range = multi_paste_range(app, view, Ii64(pos), paste_count, old_to_new);

    Query_Bar_Group group(app);
    Query_Bar bar = {};
    bar.prompt = SCu8((u8*)("Up and Down to condense and expand paste stages; R to reverse order; Return to finish; Escape to abort."), (u64)(sizeof("Up and Down to condense and expand paste stages; R to reverse order; Return to finish; Escape to abort.") - 1));
    if (start_query_bar(app, &bar, 0) == 0) return;

    User_Input in = {};
    for (;;){
        in = get_next_input(app, EventProperty_AnyKey, EventProperty_Escape);
        if (in.abort) break;

        b32 did_modify = false;
        if (match_key_code(&in, KeyCode_Up)){
            if (paste_count > 1){
                --paste_count;
                did_modify = true;
            }
        }
        else if (match_key_code(&in, KeyCode_Down)){
            if (paste_count < clip_count){
                ++paste_count;
                did_modify = true;
            }
        }
        else if (match_key_code(&in, KeyCode_R)){
            old_to_new = !old_to_new;
            did_modify = true;
        }
        else if (match_key_code(&in, KeyCode_Return)){
            break;
        }

        if (did_modify){
            range = multi_paste_range(app, view, range, paste_count, old_to_new);
        }
    }

    if (in.abort){
        Buffer_ID buffer = view_get_buffer(app, view, Access_ReadWriteVisible);
        buffer_replace_range(app, buffer, range, SCu8(""));
    }
}

CUSTOM_COMMAND(multi_paste_interactive, "/home/sam/.bin/4coder/custom/4coder_clipboard.cpp", 371, Normal)
CUSTOM_DOC("Paste multiple lines from the clipboard history, controlled with arrow keys")
{
    i32 clip_count = clipboard_count(0);
    if (clip_count > 0){
        multi_paste_interactive_up_down(app, 1, clip_count);
    }
}

CUSTOM_COMMAND(multi_paste_interactive_quick, "/home/sam/.bin/4coder/custom/4coder_clipboard.cpp", 380, Normal)
CUSTOM_DOC("Paste multiple lines from the clipboard history, controlled by inputing the number of lines to paste")
{
    i32 clip_count = clipboard_count(0);
    if (clip_count > 0){
        u8 string_space[256];
        Query_Bar_Group group(app);
        Query_Bar bar = {};
        bar.prompt = SCu8((u8*)("How Many Slots To Paste: "), (u64)(sizeof("How Many Slots To Paste: ") - 1));
        bar.string = SCu8(string_space, (u64)0);
        bar.string_capacity = sizeof(string_space);
        query_user_number(app, &bar);

        i32 initial_paste_count = (i32)string_to_integer(bar.string, 10);
        initial_paste_count = (((1)>(initial_paste_count))?(1):(((clip_count)<(initial_paste_count))?(clip_count):(initial_paste_count)));
        end_query_bar(app, &bar, 0);

        multi_paste_interactive_up_down(app, initial_paste_count, clip_count);
    }
}




static void
clipboard_clear(Application_Links *app, i32 clipboard_id){
    clipboard_clear(clipboard_id);
}
static b32
clipboard_post(Application_Links *app, i32 clipboard_id, String_Const_u8 string){
    return(clipboard_post(clipboard_id, string));
}
static i32
clipboard_count(Application_Links *app, i32 clipboard_id){
    return(clipboard_count(clipboard_id));
}
static String_Const_u8
push_clipboard_index(Application_Links *app, Arena *arena, i32 clipboard_id, i32 item_index){
    return(push_clipboard_index(arena, clipboard_id, item_index));
}
# 104 "/home/sam/.bin/4coder/custom/4coder_default_include.cpp" 2
# 1 "/home/sam/.bin/4coder/custom/4coder_lister_base.cpp" 1






static Vec2_f32
panel_space_from_screen_space(Vec2_f32 p, Vec2_f32 file_region_p0){
    return(p - file_region_p0);
}

static Vec2_f32
get_mouse_position_in_panel_space(Mouse_State mouse, Vec2_f32 file_region_p0){
    return(panel_space_from_screen_space(V2f32(mouse.p), file_region_p0));
}

static Vec2_f32
get_mouse_position_in_panel_space(Application_Links *app, Vec2_f32 file_region_p0){
    return(get_mouse_position_in_panel_space(get_mouse_state(app), file_region_p0));
}



static f32
lister_get_text_field_height(f32 line_height){
    return(line_height);
}

static f32
lister_get_block_height(f32 line_height){
    return(line_height*2);
}

static Rect_f32_Pair
lister_get_top_level_layout(Rect_f32 rect, f32 text_field_height){
    return(rect_split_top_bottom(rect, text_field_height));
}



static Lister*
view_get_lister(Application_Links *app, View_ID view){
    Managed_Scope scope = view_get_managed_scope(app, view);
    Lister **ptr = ((Lister**)managed_scope_get_attachment((app), (scope), (view_lister_loc), sizeof(Lister*)));
    Lister *result = 0;
    if (ptr != 0){
        result = *ptr;
    }
    return(result);
}

static Lister*
view_set_lister(Application_Links *app, View_ID view, Lister *lister){
    Managed_Scope scope = view_get_managed_scope(app, view);
    Lister **ptr = ((Lister**)managed_scope_get_attachment((app), (scope), (view_lister_loc), sizeof(Lister*)));
    Lister *result = 0;
    if (ptr != 0){
        result = *ptr;
        *ptr = lister;
    }
    return(result);
}

static void
lister_set_map(Lister *lister, Mapping *mapping, Command_Map *map){
    lister->mapping = mapping;
    lister->map = map;
}

static void
lister_set_map(Lister *lister, Mapping *mapping, Command_Map_ID map){
    lister->mapping = mapping;
    lister->map = mapping_get_map(mapping, map);
}

static Lister_Prev_Current
begin_lister(Application_Links *app, Arena *arena){
    Lister_Prev_Current result = {};
    Lister *lister = ((Lister*)linalloc_wrap_zero(linalloc_push((arena), sizeof(Lister)*(1), SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_lister_base.cpp" ":" "79" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_lister_base.cpp" ":" "79" ":") - 1)))));
    lister->arena = arena;
    lister->query = Su8(lister->query_space, 0, sizeof(lister->query_space));
    lister->text_field = Su8(lister->text_field_space, 0, sizeof(lister->text_field_space));
    lister->key_string = Su8(lister->key_string_space, 0, sizeof(lister->key_string_space));
    View_ID view = get_this_ctx_view(app, Access_Always);
    result.prev = view_set_lister(app, view, lister);
    result.current = lister;
    lister->restore_all_point = begin_temp(lister->arena);
    View_Context ctx = view_current_context(app, view);
    lister_set_map(lister, ctx.mapping, ctx.map_id);
    return(result);
}

Lister_Block::Lister_Block(Application_Links *a, Arena *arena){
    Lister_Prev_Current new_lister = begin_lister(a, arena);
    this->app = a;
    this->lister = new_lister;
}

Lister_Block::~Lister_Block(){
    View_ID view = get_this_ctx_view(app, Access_Always);
    view_set_lister(this->app, view, this->lister.prev);
}

Lister_Block::operator Lister *(){
    return(this->lister.current);
}

static void
lister_set_string(String_Const_u8 string, String_u8 *target){
    target->size = 0;
    string_append(target, string);
}
static void
lister_append_string(String_Const_u8 string, String_u8 *target){
    string_append(target, string);
}

static void
lister_set_query(Lister *lister, String_Const_u8 string){
    lister_set_string(string, &lister->query);
}
static void
lister_set_query(Lister *lister, char *string){
    lister_set_string(SCu8(string), &lister->query);
}
static void
lister_set_text_field(Lister *lister, String_Const_u8 string){
    lister_set_string(string, &lister->text_field);
}
static void
lister_set_text_field(Lister *lister, char *string){
    lister_set_string(SCu8(string), &lister->text_field);
}
static void
lister_set_key(Lister *lister, String_Const_u8 string){
    lister_set_string(string, &lister->key_string);
}
static void
lister_set_key(Lister *lister, char *string){
    lister_set_string(SCu8(string), &lister->key_string);
}

static void
lister_append_query(Lister *lister, String_Const_u8 string){
    lister_append_string(string, &lister->query);
}
static void
lister_append_query(Lister *lister, char *string){
    lister_append_string(SCu8(string), &lister->query);
}
static void
lister_append_text_field(Lister *lister, String_Const_u8 string){
    lister_append_string(string, &lister->text_field);
}
static void
lister_append_text_field(Lister *lister, char *string){
    lister_append_string(SCu8(string), &lister->text_field);
}
static void
lister_append_key(Lister *lister, String_Const_u8 string){
    lister_append_string(string, &lister->key_string);
}
static void
lister_append_key(Lister *lister, char *string){
    lister_append_string(SCu8(string), &lister->key_string);
}

static void
lister_set_handlers(Lister *lister, Lister_Handlers *handlers){
    block_copy((&lister->handlers), (handlers), sizeof(*(&lister->handlers)));
}

static void
lister_zero_scroll(Lister *lister){
    block_zero((&lister->scroll), sizeof(*(&lister->scroll)));
}

static void
lister_render(Application_Links *app, Frame_Info frame_info, View_ID view){
    Scratch_Block scratch(app);

    Lister *lister = view_get_lister(app, view);
    if (lister == 0){
        return;
    }

    Rect_f32 region = draw_background_and_margin(app, view);
    Rect_f32 prev_clip = draw_set_clip(app, region);

    Face_ID face_id = get_face_id(app, 0);
    Face_Metrics metrics = get_face_metrics(app, face_id);
    f32 line_height = metrics.line_height;
    f32 block_height = lister_get_block_height(line_height);
    f32 text_field_height = lister_get_text_field_height(line_height);


    b64 showing_file_bar = false;
    if (view_get_setting(app, view, ViewSetting_ShowFileBar, &showing_file_bar) &&
        showing_file_bar &&
        !global_config.hide_file_bar_in_ui){
        Rect_f32_Pair pair = layout_file_bar_on_top(region, line_height);
        Buffer_ID buffer = view_get_buffer(app, view, Access_Always);
        draw_file_bar(app, view, buffer, face_id, pair.min);
        region = pair.max;
    }

    Mouse_State mouse = get_mouse_state(app);
    Vec2_f32 m_p = V2f32(mouse.p);

    lister->visible_count = (i32)((rect_height(region)/block_height)) - 3;
    lister->visible_count = (((1)>(lister->visible_count))?(1):(lister->visible_count));

    Rect_f32 text_field_rect = {};
    Rect_f32 list_rect = {};
    {
        Rect_f32_Pair pair = lister_get_top_level_layout(region, text_field_height);
        text_field_rect = pair.min;
        list_rect = pair.max;
    }

    {
        Vec2_f32 p = V2f32(text_field_rect.x0 + 3.f, text_field_rect.y0);
        Fancy_Line text_field = {};
        push_fancy_string(scratch, &text_field, fcolor_id(defcolor_pop1),
                          lister->query.string);
        push_fancy_stringf(scratch, &text_field, " ");
        p = draw_fancy_line(app, face_id, fcolor_zero(), &text_field, p);




        block_zero((&text_field), sizeof(*(&text_field)));
        push_fancy_string(scratch, &text_field, fcolor_id(defcolor_text_default),
                          lister->text_field.string);
        f32 width = get_fancy_line_width(app, face_id, &text_field);
        f32 cap_width = text_field_rect.x1 - p.x - 6.f;
        if (cap_width < width){
            Rect_f32 prect = draw_set_clip(app, Rf32(p.x, text_field_rect.y0, p.x + cap_width, text_field_rect.y1));
            p.x += cap_width - width;
            draw_fancy_line(app, face_id, fcolor_zero(), &text_field, p);
            draw_set_clip(app, prect);
        }
        else{
            draw_fancy_line(app, face_id, fcolor_zero(), &text_field, p);
        }
    }


    Range_f32 x = rect_range_x(list_rect);
    draw_set_clip(app, list_rect);


    f32 scroll_y = lister->scroll.position.y;

    if (lister->set_vertical_focus_to_item){
        lister->set_vertical_focus_to_item = false;
        Range_f32 item_y = If32_size(lister->item_index*block_height, block_height);
        f32 view_h = rect_height(list_rect);
        Range_f32 view_y = If32_size(scroll_y, view_h);
        if (view_y.min > item_y.min || item_y.max > view_y.max){
            f32 item_center = (item_y.min + item_y.max)*0.5f;
            f32 view_center = (view_y.min + view_y.max)*0.5f;
            f32 margin = view_h*.3f;
            margin = (((margin)<(block_height*3.f))?(margin):(block_height*3.f));
            if (item_center < view_center){
                lister->scroll.target.y = item_y.min - margin;
            }
            else{
                f32 target_bot = item_y.max + margin;
                lister->scroll.target.y = target_bot - view_h;
            }
        }
    }


    i32 count = lister->filtered.count;
    Range_f32 scroll_range = If32(0.f, (((0.f)>(count*block_height - block_height))?(0.f):(count*block_height - block_height)));
    lister->scroll.target.y = clamp_range(scroll_range, lister->scroll.target.y);
    lister->scroll.target.x = 0.f;

    Vec2_f32_Delta_Result delta = delta_apply(app, view,
                                              frame_info.animation_dt, lister->scroll);
    lister->scroll.position = delta.p;
    if (delta.still_animating){
        animate_in_n_milliseconds(app, 0);
    }

    lister->scroll.position.y = clamp_range(scroll_range, lister->scroll.position.y);
    lister->scroll.position.x = 0.f;

    scroll_y = lister->scroll.position.y;
    f32 y_pos = list_rect.y0 - scroll_y;

    i32 first_index = (i32)(scroll_y/block_height);
    y_pos += first_index*block_height;

    for (i32 i = first_index; i < count; i += 1){
        Lister_Node *node = lister->filtered.node_ptrs[i];

        Range_f32 y = If32(y_pos, y_pos + block_height);
        y_pos = y.max;

        Rect_f32 item_rect = Rf32(x, y);
        Rect_f32 item_inner = rect_inner(item_rect, 3.f);

        b32 hovered = rect_contains_point(item_rect, m_p);
        UI_Highlight_Level highlight = UIHighlight_None;
        if (node == lister->highlighted_node){
            highlight = UIHighlight_Active;
        }
        else if (node->user_data == lister->hot_user_data){
            if (hovered){
                highlight = UIHighlight_Active;
            }
            else{
                highlight = UIHighlight_Hover;
            }
        }
        else if (hovered){
            highlight = UIHighlight_Hover;
        }

        f32 roundness = block_height*global_config.lister_roundness;
        draw_rectangle_fcolor(app, item_rect, roundness, get_item_margin_color(highlight));
        draw_rectangle_fcolor(app, item_inner, roundness, get_item_margin_color(highlight, 1));

        Fancy_Line line = {};
        push_fancy_string(scratch, &line, fcolor_id(defcolor_text_default), node->string);
        push_fancy_stringf(scratch, &line, " ");
        push_fancy_string(scratch, &line, fcolor_id(defcolor_pop2), node->status);

        Vec2_f32 p = item_inner.p0 + V2f32(3.f, (block_height - line_height)*0.5f);
        draw_fancy_line(app, face_id, fcolor_zero(), &line, p);
    }

    draw_set_clip(app, prev_clip);
}

static void*
lister_get_user_data(Lister *lister, i32 index){
    void *result = 0;
    if (0 <= index && index < lister->options.count){
        i32 counter = 0;
        for (Lister_Node *node = lister->options.first;
             node != 0;
             node = node->next, counter += 1){
            if (counter == index){
                result = node->user_data;
                break;
            }
        }
    }
    return(result);
}

static Lister_Filtered
lister_get_filtered(Arena *arena, Lister *lister){
    i32 node_count = lister->options.count;

    Lister_Filtered filtered = {};
    filtered.exact_matches.node_ptrs = ((Lister_Node**)linalloc_wrap_unintialized(linalloc_push((arena), sizeof(Lister_Node*)*(1), SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_lister_base.cpp" ":" "361" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_lister_base.cpp" ":" "361" ":") - 1)))));
    filtered.before_extension_matches.node_ptrs = ((Lister_Node**)linalloc_wrap_unintialized(linalloc_push((arena), sizeof(Lister_Node*)*(node_count), SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_lister_base.cpp" ":" "362" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_lister_base.cpp" ":" "362" ":") - 1)))));
    filtered.substring_matches.node_ptrs = ((Lister_Node**)linalloc_wrap_unintialized(linalloc_push((arena), sizeof(Lister_Node*)*(node_count), SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_lister_base.cpp" ":" "363" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_lister_base.cpp" ":" "363" ":") - 1)))));

    Temp_Memory_Block temp(arena);

    String_Const_u8 key = lister->key_string.string;
    key = push_string_copy(arena, key);
    string_mod_replace_character(key, '_', '*');
    string_mod_replace_character(key, ' ', '*');

    List_String_Const_u8 absolutes = {};
    string_list_push(arena, &absolutes, SCu8((u8*)(""), (u64)(sizeof("") - 1)));
    List_String_Const_u8 splits = string_split(arena, key, (u8*)"*", 1);
    b32 has_wildcard = (splits.node_count > 1);
    string_list_push(&absolutes, &splits);
    string_list_push(arena, &absolutes, SCu8((u8*)(""), (u64)(sizeof("") - 1)));

    for (Lister_Node *node = lister->options.first;
         node != 0;
         node = node->next){
        String_Const_u8 node_string = node->string;
        if (key.size == 0 || string_wildcard_match_insensitive(absolutes, node_string)){
            if (string_match_insensitive(node_string, key) && filtered.exact_matches.count == 0){
                filtered.exact_matches.node_ptrs[filtered.exact_matches.count++] = node;
            }
            else if (key.size > 0 &&
                     !has_wildcard &&
                     string_match_insensitive(string_prefix(node_string, key.size), key) &&
                     node->string.size > key.size &&
                     node->string.str[key.size] == '.'){
                filtered.before_extension_matches.node_ptrs[filtered.before_extension_matches.count++] = node;
            }
            else{
                filtered.substring_matches.node_ptrs[filtered.substring_matches.count++] = node;
            }
        }
    }

    return(filtered);
}

static void
lister_update_selection_values(Lister *lister){
    lister->raw_item_index = -1;
    lister->highlighted_node = 0;
    i32 count = lister->filtered.count;
    for (i32 i = 0; i < count; i += 1){
        Lister_Node *node = lister->filtered.node_ptrs[i];
        if (lister->item_index == i){
            lister->highlighted_node = node;
            lister->raw_item_index = node->raw_index;
        }
    }
}

static void
lister_update_filtered_list(Application_Links *app, Lister *lister){
    Arena *arena = lister->arena;
    Scratch_Block scratch(app, arena);

    Lister_Filtered filtered = lister_get_filtered(scratch, lister);

    Lister_Node_Ptr_Array node_ptr_arrays[] = {
        filtered.exact_matches,
        filtered.before_extension_matches,
        filtered.substring_matches,
    };

    end_temp(lister->filter_restore_point);

    i32 total_count = 0;
    for (i32 array_index = 0; array_index < ((sizeof(node_ptr_arrays))/(sizeof(*node_ptr_arrays))); array_index += 1){
        Lister_Node_Ptr_Array node_ptr_array = node_ptr_arrays[array_index];
        total_count += node_ptr_array.count;
    }

    Lister_Node **node_ptrs = ((Lister_Node**)linalloc_wrap_unintialized(linalloc_push((arena), sizeof(Lister_Node*)*(total_count), SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_lister_base.cpp" ":" "438" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_lister_base.cpp" ":" "438" ":") - 1)))));
    lister->filtered.node_ptrs = node_ptrs;
    lister->filtered.count = total_count;
    i32 counter = 0;
    for (i32 array_index = 0; array_index < ((sizeof(node_ptr_arrays))/(sizeof(*node_ptr_arrays))); array_index += 1){
        Lister_Node_Ptr_Array node_ptr_array = node_ptr_arrays[array_index];
        for (i32 node_index = 0; node_index < node_ptr_array.count; node_index += 1){
            Lister_Node *node = node_ptr_array.node_ptrs[node_index];
            node_ptrs[counter] = node;
            counter += 1;
        }
    }

    lister_update_selection_values(lister);
}

static void
lister_call_refresh_handler(Application_Links *app, Lister *lister){
    if (lister->handlers.refresh != 0){
        lister->handlers.refresh(app, lister);
        lister->filter_restore_point = begin_temp(lister->arena);
        lister_update_filtered_list(app, lister);
    }
}

static void
lister_activate(Application_Links *app, Lister *lister, void *user_data, b32 mouse){
    lister->out.activated_by_click = mouse;
    lister->out.text_field = lister->text_field.string;
    lister->out.user_data = user_data;
}

static void*
lister_user_data_at_p(Application_Links *app, View_ID view, Lister *lister, Vec2_f32 m_p){
    Rect_f32 region = view_get_screen_rect(app, view);

    region = rect_inner(region, 3.f);

    Face_ID face_id = get_face_id(app, 0);
    Face_Metrics metrics = get_face_metrics(app, face_id);
    f32 line_height = metrics.line_height;
    f32 block_height = lister_get_block_height(line_height);
    f32 text_field_height = lister_get_text_field_height(line_height);

    b64 showing_file_bar = false;
    if (view_get_setting(app, view, ViewSetting_ShowFileBar, &showing_file_bar) &&
        showing_file_bar &&
        !global_config.hide_file_bar_in_ui){
        Rect_f32_Pair pair = layout_file_bar_on_top(region, line_height);
        region = pair.max;
    }

    Rect_f32_Pair pair = lister_get_top_level_layout(region, text_field_height);
    Rect_f32 list_rect = pair.max;

    void *result = 0;
    if (rect_contains_point(list_rect, m_p)){
        f32 y = m_p.y - list_rect.y0 + lister->scroll.position.y;
        i32 index = (i32)(y/block_height);
        if (0 <= index && index < lister->filtered.count){
            Lister_Node *node = lister->filtered.node_ptrs[index];
            result = node->user_data;
        }
    }

    return(result);
}

static Lister_Result
run_lister(Application_Links *app, Lister *lister){
    lister->filter_restore_point = begin_temp(lister->arena);
    lister_update_filtered_list(app, lister);

    View_ID view = get_this_ctx_view(app, Access_Always);
    View_Context ctx = view_current_context(app, view);
    ctx.render_caller = lister_render;
    ctx.hides_buffer = true;
    View_Context_Block ctx_block(app, view, &ctx);

    for (;;){
        User_Input in = get_next_input(app, EventPropertyGroup_Any, EventProperty_Escape);
        if (in.abort){
            block_zero((&lister->out), sizeof(*(&lister->out)));
            lister->out.canceled = true;
            break;
        }

        Lister_Activation_Code result = ListerActivation_Continue;
        b32 handled = true;
        switch (in.event.kind){
            case InputEventKind_TextInsert:
            {
                if (lister->handlers.write_character != 0){
                    result = lister->handlers.write_character(app);
                }
            }break;

            case InputEventKind_KeyStroke:
            {
                switch (in.event.key.code){
                    case KeyCode_Return:
                    case KeyCode_Tab:
                    {
                        void *user_data = 0;
                        if (0 <= lister->raw_item_index &&
                            lister->raw_item_index < lister->options.count){
                            user_data = lister_get_user_data(lister, lister->raw_item_index);
                        }
                        lister_activate(app, lister, user_data, false);
                        result = ListerActivation_Finished;
                    }break;

                    case KeyCode_Backspace:
                    {
                        if (lister->handlers.backspace != 0){
                            lister->handlers.backspace(app);
                        }
                        else if (lister->handlers.key_stroke != 0){
                            result = lister->handlers.key_stroke(app);
                        }
                        else{
                            handled = false;
                        }
                    }break;

                    case KeyCode_Up:
                    {
                        if (lister->handlers.navigate != 0){
                            lister->handlers.navigate(app, view, lister, -1);
                        }
                        else if (lister->handlers.key_stroke != 0){
                            result = lister->handlers.key_stroke(app);
                        }
                        else{
                            handled = false;
                        }
                    }break;

                    case KeyCode_Down:
                    {
                        if (lister->handlers.navigate != 0){
                            lister->handlers.navigate(app, view, lister, 1);
                        }
                        else if (lister->handlers.key_stroke != 0){
                            result = lister->handlers.key_stroke(app);
                        }
                        else{
                            handled = false;
                        }
                    }break;

                    case KeyCode_PageUp:
                    {
                        if (lister->handlers.navigate != 0){
                            lister->handlers.navigate(app, view, lister,
                                                      -lister->visible_count);
                        }
                        else if (lister->handlers.key_stroke != 0){
                            result = lister->handlers.key_stroke(app);
                        }
                        else{
                            handled = false;
                        }
                    }break;

                    case KeyCode_PageDown:
                    {
                        if (lister->handlers.navigate != 0){
                            lister->handlers.navigate(app, view, lister,
                                                      lister->visible_count);
                        }
                        else if (lister->handlers.key_stroke != 0){
                            result = lister->handlers.key_stroke(app);
                        }
                        else{
                            handled = false;
                        }
                    }break;

                    default:
                    {
                        if (lister->handlers.key_stroke != 0){
                            result = lister->handlers.key_stroke(app);
                        }
                        else{
                            handled = false;
                        }
                    }break;
                }
            }break;

            case InputEventKind_MouseButton:
            {
                switch (in.event.mouse.code){
                    case MouseCode_Left:
                    {
                        Vec2_f32 p = V2f32(in.event.mouse.p);
                        void *clicked = lister_user_data_at_p(app, view, lister, p);
                        lister->hot_user_data = clicked;
                    }break;

                    default:
                    {
                        handled = false;
                    }break;
                }
            }break;

            case InputEventKind_MouseButtonRelease:
            {
                switch (in.event.mouse.code){
                    case MouseCode_Left:
                    {
                        if (lister->hot_user_data != 0){
                            Vec2_f32 p = V2f32(in.event.mouse.p);
                            void *clicked = lister_user_data_at_p(app, view, lister, p);
                            if (lister->hot_user_data == clicked){
                                lister_activate(app, lister, clicked, true);
                                result = ListerActivation_Finished;
                            }
                        }
                        lister->hot_user_data = 0;
                    }break;

                    default:
                    {
                        handled = false;
                    }break;
                }
            }break;

            case InputEventKind_MouseWheel:
            {
                Mouse_State mouse = get_mouse_state(app);
                lister->scroll.target.y += mouse.wheel;
                lister_update_filtered_list(app, lister);
            }break;

            case InputEventKind_MouseMove:
            {
                lister_update_filtered_list(app, lister);
            }break;

            case InputEventKind_Core:
            {
                switch (in.event.core.code){
                    case CoreCode_Animate:
                    {
                        lister_update_filtered_list(app, lister);
                    }break;

                    default:
                    {
                        handled = false;
                    }break;
                }
            }break;

            default:
            {
                handled = false;
            }break;
        }

        if (result == ListerActivation_Finished){
            break;
        }

        if (!handled){
            Mapping *mapping = lister->mapping;
            Command_Map *map = lister->map;

            Fallback_Dispatch_Result disp_result =
                fallback_command_dispatch(app, mapping, map, &in);
            if (disp_result.code == FallbackDispatch_DelayedUICall){
                call_after_ctx_shutdown(app, view, disp_result.func);
                break;
            }
            if (disp_result.code == FallbackDispatch_Unhandled){
                leave_current_input_unhandled(app);
            }
            else{
                lister_call_refresh_handler(app, lister);
            }
        }
    }

    return(lister->out);
}

static Lister_Prealloced_String
lister_prealloced(String_Const_u8 string){
    Lister_Prealloced_String result = {};
    result.string = string;
    return(result);
}

static void
lister_begin_new_item_set(Application_Links *app, Lister *lister){
    end_temp(lister->restore_all_point);
    block_zero((&lister->options), sizeof(*(&lister->options)));
    block_zero((&lister->filtered), sizeof(*(&lister->filtered)));
}

static void*
lister_add_item(Lister *lister, Lister_Prealloced_String string, Lister_Prealloced_String status, void *user_data, u64 extra_space){
    void *base_memory = ((u8*)linalloc_wrap_unintialized(linalloc_push((lister->arena), sizeof(u8)*(sizeof(Lister_Node) + extra_space), SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_lister_base.cpp" ":" "744" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_lister_base.cpp" ":" "744" ":") - 1)))));
    Lister_Node *node = (Lister_Node*)base_memory;
    node->string = string.string;
    node->status = status.string;
    node->user_data = user_data;
    node->raw_index = lister->options.count;
    (((lister->options.first)==0)?((node)->next=(node)->prev=0,(lister->options.first)=(lister->options.last)=(node)):((node)->prev=(lister->options.last),(node)->next=0,(lister->options.last)->next=(node),(lister->options.last)=(node)));
    lister->options.count += 1;
    void *result = (node + 1);
    return(result);
}

static void*
lister_add_item(Lister *lister, Lister_Prealloced_String string, String_Const_u8 status,
                void *user_data, u64 extra_space){
    return(lister_add_item(lister, string, lister_prealloced(push_string_copy(lister->arena, status)), user_data, extra_space));
}

static void*
lister_add_item(Lister *lister, String_Const_u8 string, Lister_Prealloced_String status, void *user_data, u64 extra_space){
    return(lister_add_item(lister, lister_prealloced(push_string_copy(lister->arena, string)), status, user_data, extra_space));
}

static void*
lister_add_item(Lister *lister, String_Const_u8 string, String_Const_u8 status, void *user_data, u64 extra_space){
    return(lister_add_item(lister,
                           lister_prealloced(push_string_copy(lister->arena, string)),
                           lister_prealloced(push_string_copy(lister->arena, status)),
                           user_data, extra_space));
}

static Lister_Activation_Code
lister__write_string__default(Application_Links *app){
    Lister_Activation_Code result = ListerActivation_Continue;
    View_ID view = get_active_view(app, Access_Always);
    Lister *lister = view_get_lister(app, view);
    if (lister != 0){
        User_Input in = get_current_input(app);
        String_Const_u8 string = to_writable(&in);
        if (string.str != 0 && string.size > 0){
            lister_append_text_field(lister, string);
            lister_append_key(lister, string);
            lister->item_index = 0;
            lister_zero_scroll(lister);
            lister_update_filtered_list(app, lister);
        }
    }
    return(result);
}

static void
lister__backspace_text_field__default(Application_Links *app){
    View_ID view = get_active_view(app, Access_Always);
    Lister *lister = view_get_lister(app, view);
    if (lister != 0){
        lister->text_field.string = backspace_utf8(lister->text_field.string);
        lister->key_string.string = backspace_utf8(lister->key_string.string);
        lister->item_index = 0;
        lister_zero_scroll(lister);
        lister_update_filtered_list(app, lister);
    }
}

static void
lister__navigate__default(Application_Links *app, View_ID view, Lister *lister, i32 delta){
    i32 new_index = lister->item_index + delta;
    if (new_index < 0 && lister->item_index == 0){
        lister->item_index = lister->filtered.count - 1;
    }
    else if (new_index >= lister->filtered.count &&
             lister->item_index == lister->filtered.count - 1){
        lister->item_index = 0;
    }
    else{
        lister->item_index = (((0)>(new_index))?(0):(((lister->filtered.count - 1)<(new_index))?(lister->filtered.count - 1):(new_index)));
    }
    lister->set_vertical_focus_to_item = true;
    lister_update_selection_values(lister);
}

static Lister_Handlers
lister_get_default_handlers(void){
    Lister_Handlers handlers = {};
    handlers.write_character = lister__write_string__default;
    handlers.backspace = lister__backspace_text_field__default;
    handlers.navigate = lister__navigate__default;
    return(handlers);
}

static void
lister_set_default_handlers(Lister *lister){
    Lister_Handlers handlers = lister_get_default_handlers();
    lister_set_handlers(lister, &handlers);
}



static Lister_Result
run_lister_with_refresh_handler(Application_Links *app, Arena *arena, String_Const_u8 query, Lister_Handlers handlers){
    Lister_Result result = {};
    if (handlers.refresh != 0){
        Lister_Block lister(app, arena);
        lister_set_query(lister, query);
        lister_set_handlers(lister, &handlers);
        handlers.refresh(app, lister);
        result = run_lister(app, lister);
    }
    else{

        String_Const_u8 str = push_u8_stringf(arena, "ERROR: No refresh handler specified for lister (query_string = \"%.*s\")\n", (i32)(query).size, (char*)(query).str);

        print_message(app, str);
        result.canceled = true;
    }
    return(result);
}

static Lister_Result
run_lister_with_refresh_handler(Application_Links *app, String_Const_u8 query, Lister_Handlers handlers){
    Scratch_Block scratch(app);
    return(run_lister_with_refresh_handler(app, scratch, query, handlers));
}

static Lister_Result
run_lister_with_refresh_handler(Application_Links *app, Arena *arena, char *query, Lister_Handlers handlers){
    return(run_lister_with_refresh_handler(app, arena, SCu8(query), handlers));
}

static Lister_Result
run_lister_with_refresh_handler(Application_Links *app, char *query, Lister_Handlers handlers){
    return(run_lister_with_refresh_handler(app, SCu8(query), handlers));
}



static void
lister_choice(Arena *arena, Lister_Choice_List *list, String_Const_u8 string, String_Const_u8 status, Key_Code code, u64 user_data){
    Lister_Choice *choice = ((Lister_Choice*)linalloc_wrap_unintialized(linalloc_push((arena), sizeof(Lister_Choice)*(1), SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_lister_base.cpp" ":" "881" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_lister_base.cpp" ":" "881" ":") - 1)))));
    do{ if((choice)){if((list->first)){(list->last)->next=(choice);}else{(list->first)=(choice);}(list->last)=(choice);(list->last)->next=0;} }while(0);
    choice->string = string;
    choice->status = status;
    choice->key_code = code;
    choice->user_data = user_data;
}

static void
lister_choice(Arena *arena, Lister_Choice_List *list, char *string, String_Const_u8 status, Key_Code code, u64 user_data){
    lister_choice(arena, list, SCu8(string), status, code, (u64)((u8*)(user_data) - (u8*)(0)));
}

static void
lister_choice(Arena *arena, Lister_Choice_List *list, String_Const_u8 string, char *status, Key_Code code, u64 user_data){
    lister_choice(arena, list, string, SCu8(status), code, (u64)((u8*)(user_data) - (u8*)(0)));
}

static void
lister_choice(Arena *arena, Lister_Choice_List *list, char *string, char *status, Key_Code code, u64 user_data){
    lister_choice(arena, list, SCu8(string), SCu8(status), code,
                  (u64)((u8*)(user_data) - (u8*)(0)));
}

static void
lister_choice(Arena *arena, Lister_Choice_List *list, String_Const_u8 string, String_Const_u8 status, Key_Code code, void *user_data){
    lister_choice(arena, list, string, status, code, (u64)((u8*)(user_data) - (u8*)(0)));
}

static void
lister_choice(Arena *arena, Lister_Choice_List *list, char *string, String_Const_u8 status, Key_Code code, void *user_data){
    lister_choice(arena, list, string, status, code, (u64)((u8*)(user_data) - (u8*)(0)));
}

static void
lister_choice(Arena *arena, Lister_Choice_List *list, String_Const_u8 string, char *status, Key_Code code, void *user_data){
    lister_choice(arena, list, string, status, code, (u64)((u8*)(user_data) - (u8*)(0)));
}

static void
lister_choice(Arena *arena, Lister_Choice_List *list, char *string, char *status, Key_Code code, void *user_data){
    lister_choice(arena, list, string, status, code, (u64)((u8*)(user_data) - (u8*)(0)));
}

static Lister_Activation_Code
lister__key_stroke__choice_list(Application_Links *app){
    Lister_Activation_Code result = ListerActivation_Continue;
    View_ID view = get_active_view(app, Access_Always);
    Lister *lister = view_get_lister(app, view);
    if (lister != 0){
        User_Input in = get_current_input(app);
        if (in.event.kind == InputEventKind_KeyStroke){
            void *user_data = 0;
            b32 did_shortcut_key = false;
            for (Lister_Node *node = lister->options.first;
                 node != 0;
                 node = node->next){
                Key_Code *key_code = (Key_Code*)(node + 1);
                if (*key_code == in.event.key.code){
                    user_data = node->user_data;
                    did_shortcut_key = true;
                    break;
                }
            }
            if (did_shortcut_key){
                lister_activate(app, lister, user_data, false);
                result = ListerActivation_Finished;
            }
        }
    }
    return(result);
}

static Lister_Choice*
get_choice_from_user(Application_Links *app, String_Const_u8 query,
                     Lister_Choice_List list){
    Scratch_Block scratch(app);
    Lister_Block lister(app, scratch);
    for (Lister_Choice *choice = list.first;
         choice != 0;
         choice = choice->next){
        u64 code_size = sizeof(choice->key_code);
        void *extra = lister_add_item(lister, choice->string, choice->status,
                                      choice, code_size);
        block_copy(extra, &choice->key_code, code_size);
    }
    lister_set_query(lister, query);
    Lister_Handlers handlers = {};
    handlers.navigate = lister__navigate__default;
    handlers.key_stroke = lister__key_stroke__choice_list;
    lister_set_handlers(lister, &handlers);

    Lister_Result l_result = run_lister(app, lister);
    Lister_Choice *result = 0;
    if (!l_result.canceled){
        result = (Lister_Choice*)l_result.user_data;
    }
    return(result);
}

static Lister_Choice*
get_choice_from_user(Application_Links *app, char *query, Lister_Choice_List list){
    return(get_choice_from_user(app, SCu8(query), list));
}
# 105 "/home/sam/.bin/4coder/custom/4coder_default_include.cpp" 2
# 1 "/home/sam/.bin/4coder/custom/4coder_base_commands.cpp" 1







static void
write_text(Application_Links *app, String_Const_u8 insert){
    Profile_Scope_Block profile_block_10 ((app), SCu8((u8*)("write character"), (u64)(sizeof("write character") - 1)), SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_base_commands.cpp" ":" "10" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_base_commands.cpp" ":" "10" ":") - 1)));
    if (insert.str != 0 && insert.size > 0){
        View_ID view = get_active_view(app, Access_ReadWriteVisible);
        if_view_has_highlighted_range_delete_range(app, view);

        i64 pos = view_get_cursor_pos(app, view);
        pos = view_get_character_legal_pos_from_pos(app, view, pos);

        Buffer_ID buffer = view_get_buffer(app, view, Access_ReadWriteVisible);


        History_Record_Index first_index = buffer_history_get_current_state_index(app, buffer);
        b32 do_merge = false;
        if (insert.str[0] != '\n'){
            Record_Info record = get_single_record(app, buffer, first_index);
            if (record.error == RecordError_NoError && record.kind == RecordKind_Single){
                String_Const_u8 string = record.single_string_forward;
                i32 last_end = (i32)(record.single_first + string.size);
                if (last_end == pos && string.size > 0){
                    char c = string.str[string.size - 1];
                    if (c != '\n'){
                        if (character_is_whitespace(insert.str[0]) &&
                            character_is_whitespace(c)){
                            do_merge = true;
                        }
                        else if (character_is_alpha_numeric(insert.str[0]) && character_is_alpha_numeric(c)){
                            do_merge = true;
                        }
                    }
                }
            }
        }


        b32 edit_success = buffer_replace_range(app, buffer, Ii64(pos), insert);


        if (do_merge){
            History_Record_Index last_index = buffer_history_get_current_state_index(app, buffer);
            buffer_history_merge_record_range(app, buffer, first_index, last_index, RecordMergeFlag_StateInRange_MoveStateForward);
        }


        if (edit_success){
            view_set_cursor_and_preferred_x(app, view, seek_pos(pos + insert.size));
        }
    }
}

CUSTOM_COMMAND(write_text_input, "/home/sam/.bin/4coder/custom/4coder_base_commands.cpp", 59, Normal)
CUSTOM_DOC("Inserts whatever text was used to trigger this command.")
{
    User_Input in = get_current_input(app);
    String_Const_u8 insert = to_writable(&in);
    write_text(app, insert);
}

CUSTOM_COMMAND(write_space, "/home/sam/.bin/4coder/custom/4coder_base_commands.cpp", 67, Normal)
CUSTOM_DOC("Inserts a space.")
{
    write_text(app, SCu8((u8*)(" "), (u64)(sizeof(" ") - 1)));
}

CUSTOM_COMMAND(write_underscore, "/home/sam/.bin/4coder/custom/4coder_base_commands.cpp", 73, Normal)
CUSTOM_DOC("Inserts an underscore.")
{
    write_text(app, SCu8((u8*)("_"), (u64)(sizeof("_") - 1)));
}

CUSTOM_COMMAND(delete_char, "/home/sam/.bin/4coder/custom/4coder_base_commands.cpp", 79, Normal)
CUSTOM_DOC("Deletes the character to the right of the cursor.")
{
    View_ID view = get_active_view(app, Access_ReadWriteVisible);
    if (!if_view_has_highlighted_range_delete_range(app, view)){
        Buffer_ID buffer = view_get_buffer(app, view, Access_ReadWriteVisible);
        i64 start = view_get_cursor_pos(app, view);
        i64 buffer_size = buffer_get_size(app, buffer);
        if (0 <= start && start < buffer_size){
            Buffer_Cursor cursor = view_compute_cursor(app, view, seek_pos(start));
            i64 character = view_relative_character_from_pos(app, view, cursor.line, cursor.pos);
            i64 end = view_pos_from_relative_character(app, view, cursor.line, character + 1);
            buffer_replace_range(app, buffer, Ii64(start, end), string_u8_empty);
        }
    }
}

CUSTOM_COMMAND(backspace_char, "/home/sam/.bin/4coder/custom/4coder_base_commands.cpp", 96, Normal)
CUSTOM_DOC("Deletes the character to the left of the cursor.")
{
    View_ID view = get_active_view(app, Access_ReadWriteVisible);
    if (!if_view_has_highlighted_range_delete_range(app, view)){
        Buffer_ID buffer = view_get_buffer(app, view, Access_ReadWriteVisible);
        i64 end = view_get_cursor_pos(app, view);
        i64 buffer_size = buffer_get_size(app, buffer);
        if (0 < end && end <= buffer_size){
            Buffer_Cursor cursor = view_compute_cursor(app, view, seek_pos(end));
            i64 character = view_relative_character_from_pos(app, view, cursor.line, cursor.pos);
            i64 start = view_pos_from_relative_character(app, view, cursor.line, character - 1);
            if (buffer_replace_range(app, buffer, Ii64(start, end), string_u8_empty)){
                view_set_cursor_and_preferred_x(app, view, seek_pos(start));
            }
        }
    }
}

CUSTOM_COMMAND(set_mark, "/home/sam/.bin/4coder/custom/4coder_base_commands.cpp", 115, Normal)
CUSTOM_DOC("Sets the mark to the current position of the cursor.")
{
    View_ID view = get_active_view(app, Access_ReadVisible);
    i64 pos = view_get_cursor_pos(app, view);
    view_set_mark(app, view, seek_pos(pos));
    view_set_cursor_and_preferred_x(app, view, seek_pos(pos));
}

CUSTOM_COMMAND(cursor_mark_swap, "/home/sam/.bin/4coder/custom/4coder_base_commands.cpp", 124, Normal)
CUSTOM_DOC("Swaps the position of the cursor and the mark.")
{
    View_ID view = get_active_view(app, Access_ReadVisible);
    i64 cursor = view_get_cursor_pos(app, view);
    i64 mark = view_get_mark_pos(app, view);
    view_set_cursor_and_preferred_x(app, view, seek_pos(mark));
    view_set_mark(app, view, seek_pos(cursor));
}

CUSTOM_COMMAND(delete_range, "/home/sam/.bin/4coder/custom/4coder_base_commands.cpp", 134, Normal)
CUSTOM_DOC("Deletes the text in the range between the cursor and the mark.")
{
    View_ID view = get_active_view(app, Access_ReadWriteVisible);
    Buffer_ID buffer = view_get_buffer(app, view, Access_ReadWriteVisible);
    Range_i64 range = get_view_range(app, view);
    buffer_replace_range(app, buffer, range, string_u8_empty);
}

static void
current_view_boundary_delete(Application_Links *app, Scan_Direction direction, Boundary_Function_List funcs){
    View_ID view = get_active_view(app, Access_ReadWriteVisible);
    Buffer_ID buffer = view_get_buffer(app, view, Access_ReadWriteVisible);
    Range_i64 range = {};
    range.first = view_get_cursor_pos(app, view);
    range.one_past_last = scan(app, funcs, buffer, direction, range.first);
    range = rectify(range);
    buffer_replace_range(app, buffer, range, string_u8_empty);
}

CUSTOM_COMMAND(backspace_alpha_numeric_boundary, "/home/sam/.bin/4coder/custom/4coder_base_commands.cpp", 154, Normal)
CUSTOM_DOC("Delete characters between the cursor position and the first alphanumeric boundary to the left.")
{
    Scratch_Block scratch(app);
    current_view_boundary_delete(app, Scan_Backward, push_boundary_list__inner((scratch), boundary_alpha_numeric, 0));
}

CUSTOM_COMMAND(delete_alpha_numeric_boundary, "/home/sam/.bin/4coder/custom/4coder_base_commands.cpp", 161, Normal)
CUSTOM_DOC("Delete characters between the cursor position and the first alphanumeric boundary to the right.")
{
    Scratch_Block scratch(app);
    current_view_boundary_delete(app, Scan_Forward, push_boundary_list__inner((scratch), boundary_alpha_numeric, 0));
}

static void
current_view_snipe_delete(Application_Links *app, Scan_Direction direction, Boundary_Function_List funcs){
    View_ID view = get_active_view(app, Access_ReadWriteVisible);
    Buffer_ID buffer = view_get_buffer(app, view, Access_ReadWriteVisible);
    i64 pos = view_get_cursor_pos(app, view);
    Range_i64 range = get_snipe_range(app, funcs, buffer, pos, direction);
    buffer_replace_range(app, buffer, range, SCu8((u8*)(""), (u64)(sizeof("") - 1)));
}

CUSTOM_COMMAND(snipe_backward_whitespace_or_token_boundary, "/home/sam/.bin/4coder/custom/4coder_base_commands.cpp", 177, Normal)
CUSTOM_DOC("Delete a single, whole token on or to the left of the cursor and post it to the clipboard.")
{
    Scratch_Block scratch(app);
    current_view_snipe_delete(app, Scan_Backward,
                              push_boundary_list__inner((scratch), boundary_token, boundary_non_whitespace, 0));
}

CUSTOM_COMMAND(snipe_forward_whitespace_or_token_boundary, "/home/sam/.bin/4coder/custom/4coder_base_commands.cpp", 185, Normal)
CUSTOM_DOC("Delete a single, whole token on or to the right of the cursor and post it to the clipboard.")
{
    Scratch_Block scratch(app);
    current_view_snipe_delete(app, Scan_Forward,
                              push_boundary_list__inner((scratch), boundary_token, boundary_non_whitespace, 0));
}



CUSTOM_COMMAND(center_view, "/home/sam/.bin/4coder/custom/4coder_base_commands.cpp", 195, Normal)
CUSTOM_DOC("Centers the view vertically on the line on which the cursor sits.")
{
    View_ID view = get_active_view(app, Access_ReadVisible);
    Rect_f32 region = view_get_buffer_region(app, view);
    i64 pos = view_get_cursor_pos(app, view);
    Buffer_Cursor cursor = view_compute_cursor(app, view, seek_pos(pos));
    f32 view_height = rect_height(region);
    Buffer_Scroll scroll = view_get_buffer_scroll(app, view);
    scroll.target.line_number = cursor.line;
    scroll.target.pixel_shift.y = -view_height*0.5f;
    view_set_buffer_scroll(app, view, scroll, SetBufferScroll_SnapCursorIntoView);
    no_mark_snap_to_cursor(app, view);
}

CUSTOM_COMMAND(left_adjust_view, "/home/sam/.bin/4coder/custom/4coder_base_commands.cpp", 210, Normal)
CUSTOM_DOC("Sets the left size of the view near the x position of the cursor.")
{
    View_ID view = get_active_view(app, Access_ReadVisible);
    i64 pos = view_get_cursor_pos(app, view);
    Buffer_Cursor cursor = view_compute_cursor(app, view, seek_pos(pos));
    Vec2_f32 p = view_relative_xy_of_pos(app, view, cursor.line, pos);
    Buffer_Scroll scroll = view_get_buffer_scroll(app, view);
    scroll.target.pixel_shift.x = (((0.f)>(p.x - 30.f))?(0.f):(p.x - 30.f));
    view_set_buffer_scroll(app, view, scroll, SetBufferScroll_SnapCursorIntoView);
    no_mark_snap_to_cursor(app, view);
}

CUSTOM_COMMAND(click_set_cursor_and_mark, "/home/sam/.bin/4coder/custom/4coder_base_commands.cpp", 223, Normal)
CUSTOM_DOC("Sets the cursor position and mark to the mouse position.")
{
    View_ID view = get_active_view(app, Access_ReadVisible);
    Mouse_State mouse = get_mouse_state(app);
    i64 pos = view_pos_from_xy(app, view, V2f32(mouse.p));
    view_set_cursor_and_preferred_x(app, view, seek_pos(pos));
    view_set_mark(app, view, seek_pos(pos));
}

CUSTOM_COMMAND(click_set_cursor, "/home/sam/.bin/4coder/custom/4coder_base_commands.cpp", 233, Normal)
CUSTOM_DOC("Sets the cursor position to the mouse position.")
{
    View_ID view = get_active_view(app, Access_ReadVisible);
    Mouse_State mouse = get_mouse_state(app);
    i64 pos = view_pos_from_xy(app, view, V2f32(mouse.p));
    view_set_cursor_and_preferred_x(app, view, seek_pos(pos));
    no_mark_snap_to_cursor(app, view);
}

CUSTOM_COMMAND(click_set_cursor_if_lbutton, "/home/sam/.bin/4coder/custom/4coder_base_commands.cpp", 243, Normal)
CUSTOM_DOC("If the mouse left button is pressed, sets the cursor position to the mouse position.")
{
    View_ID view = get_active_view(app, Access_ReadVisible);
    Mouse_State mouse = get_mouse_state(app);
    if (mouse.l){
        i64 pos = view_pos_from_xy(app, view, V2f32(mouse.p));
        view_set_cursor_and_preferred_x(app, view, seek_pos(pos));
    }
    no_mark_snap_to_cursor(app, view);
    set_next_rewrite(app, view, Rewrite_NoChange);
}

CUSTOM_COMMAND(click_set_mark, "/home/sam/.bin/4coder/custom/4coder_base_commands.cpp", 256, Normal)
CUSTOM_DOC("Sets the mark position to the mouse position.")
{
    View_ID view = get_active_view(app, Access_ReadVisible);
    Mouse_State mouse = get_mouse_state(app);
    i64 pos = view_pos_from_xy(app, view, V2f32(mouse.p));
    view_set_mark(app, view, seek_pos(pos));
    no_mark_snap_to_cursor(app, view);
}

CUSTOM_COMMAND(mouse_wheel_scroll, "/home/sam/.bin/4coder/custom/4coder_base_commands.cpp", 266, Normal)
CUSTOM_DOC("Reads the scroll wheel value from the mouse state and scrolls accordingly.")
{
    View_ID view = get_active_view(app, Access_ReadVisible);
    Mouse_State mouse = get_mouse_state(app);
    if (mouse.wheel != 0){
        Buffer_Scroll scroll = view_get_buffer_scroll(app, view);
        scroll.target = view_move_buffer_point(app, view, scroll.target, V2f32(0.f, (f32)mouse.wheel));
        view_set_buffer_scroll(app, view, scroll, SetBufferScroll_SnapCursorIntoView);
    }
    if (mouse.l){
        no_mark_snap_to_cursor(app, view);
    }
}



static void
move_vertical_pixels(Application_Links *app, View_ID view, f32 pixels){
    Profile_Scope_Block profile_block_285 ((app), SCu8((u8*)("move vertical pixels"), (u64)(sizeof("move vertical pixels") - 1)), SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_base_commands.cpp" ":" "285" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_base_commands.cpp" ":" "285" ":") - 1)));
    i64 pos = view_get_cursor_pos(app, view);
    Buffer_Cursor cursor = view_compute_cursor(app, view, seek_pos(pos));
    Rect_f32 r = view_padded_box_of_pos(app, view, cursor.line, pos);
    Vec2_f32 p = {};
    p.x = view_get_preferred_x(app, view);
    if (pixels > 0.f){
        p.y = r.y1 + pixels;
    }
    else{
        p.y = r.y0 + pixels;
    }
    i64 new_pos = view_pos_at_relative_xy(app, view, cursor.line, p);
    view_set_cursor(app, view, seek_pos(new_pos));
    no_mark_snap_to_cursor_if_shift(app, view);
}

static void
move_vertical_pixels(Application_Links *app, f32 pixels){
    View_ID view = get_active_view(app, Access_ReadVisible);
    move_vertical_pixels(app, view, pixels);
}

static void
move_vertical_lines(Application_Links *app, View_ID view, i64 lines){
    if (lines > 0){
        for (i64 i = 0; i < lines; i += 1){
            move_vertical_pixels(app, 1.f);
        }
    }
    else{
        for (i64 i = 0; i > lines; i -= 1){
            move_vertical_pixels(app, -1.f);
        }
    }
}

static void
move_vertical_lines(Application_Links *app, i64 lines){
    View_ID view = get_active_view(app, Access_ReadVisible);
    move_vertical_lines(app, view, lines);
}

static f32
get_page_jump(Application_Links *app, View_ID view){
    Rect_f32 region = view_get_buffer_region(app, view);
    return(rect_height(region)*.9f);
}

CUSTOM_COMMAND(move_up, "/home/sam/.bin/4coder/custom/4coder_base_commands.cpp", 334, Normal)
CUSTOM_DOC("Moves the cursor up one line.")
{
    move_vertical_lines(app, -1);
}

CUSTOM_COMMAND(move_down, "/home/sam/.bin/4coder/custom/4coder_base_commands.cpp", 340, Normal)
CUSTOM_DOC("Moves the cursor down one line.")
{
    move_vertical_lines(app, 1);
}

CUSTOM_COMMAND(move_up_10, "/home/sam/.bin/4coder/custom/4coder_base_commands.cpp", 346, Normal)
CUSTOM_DOC("Moves the cursor up ten lines.")
{
    move_vertical_lines(app, -10);
}

CUSTOM_COMMAND(move_down_10, "/home/sam/.bin/4coder/custom/4coder_base_commands.cpp", 352, Normal)
CUSTOM_DOC("Moves the cursor down ten lines.")
{
    move_vertical_lines(app, 10);
}

CUSTOM_COMMAND(move_down_textual, "/home/sam/.bin/4coder/custom/4coder_base_commands.cpp", 358, Normal)
CUSTOM_DOC("Moves down to the next line of actual text, regardless of line wrapping.")
{
    View_ID view = get_active_view(app, Access_ReadWriteVisible);
    i64 pos = view_get_cursor_pos(app, view);
    Buffer_Cursor cursor = view_compute_cursor(app, view, seek_pos(pos));
    i64 next_line = cursor.line + 1;
    view_set_cursor_and_preferred_x(app, view, seek_line_col(next_line, 1));
}

CUSTOM_COMMAND(page_up, "/home/sam/.bin/4coder/custom/4coder_base_commands.cpp", 368, Normal)
CUSTOM_DOC("Scrolls the view up one view height and moves the cursor up one view height.")
{
    View_ID view = get_active_view(app, Access_ReadVisible);
    f32 page_jump = get_page_jump(app, view);
    move_vertical_pixels(app, -page_jump);
}

CUSTOM_COMMAND(page_down, "/home/sam/.bin/4coder/custom/4coder_base_commands.cpp", 376, Normal)
CUSTOM_DOC("Scrolls the view down one view height and moves the cursor down one view height.")
{
    View_ID view = get_active_view(app, Access_ReadVisible);
    f32 page_jump = get_page_jump(app, view);
    move_vertical_pixels(app, page_jump);
}

static void
seek_blank_line(Application_Links *app, Scan_Direction direction, Position_Within_Line position){
    View_ID view = get_active_view(app, Access_ReadVisible);
    Buffer_ID buffer = view_get_buffer(app, view, Access_ReadVisible);
    i64 pos = view_get_cursor_pos(app, view);
    i64 new_pos = get_pos_of_blank_line_grouped(app, buffer, direction, pos);
    switch (position){
        case PositionWithinLine_SkipLeadingWhitespace:
        {
            new_pos = get_pos_past_lead_whitespace(app, buffer, new_pos);
        }break;
        case PositionWithinLine_End:
        {
            new_pos = get_line_side_pos_from_pos(app, buffer, new_pos, Side_Max);
        }break;
    }
    new_pos = view_get_character_legal_pos_from_pos(app, view, new_pos);
    view_set_cursor_and_preferred_x(app, view, seek_pos(new_pos));
    no_mark_snap_to_cursor_if_shift(app, view);
}

CUSTOM_COMMAND(move_up_to_blank_line, "/home/sam/.bin/4coder/custom/4coder_base_commands.cpp", 405, Normal)
CUSTOM_DOC("Seeks the cursor up to the next blank line.")
{
    seek_blank_line(app, Scan_Backward, PositionWithinLine_Start);
}

CUSTOM_COMMAND(move_down_to_blank_line, "/home/sam/.bin/4coder/custom/4coder_base_commands.cpp", 411, Normal)
CUSTOM_DOC("Seeks the cursor down to the next blank line.")
{
    seek_blank_line(app, Scan_Forward, PositionWithinLine_Start);
}

CUSTOM_COMMAND(move_up_to_blank_line_skip_whitespace, "/home/sam/.bin/4coder/custom/4coder_base_commands.cpp", 417, Normal)
CUSTOM_DOC("Seeks the cursor up to the next blank line and places it at the end of the line.")
{
    seek_blank_line(app, Scan_Backward, PositionWithinLine_SkipLeadingWhitespace);
}

CUSTOM_COMMAND(move_down_to_blank_line_skip_whitespace, "/home/sam/.bin/4coder/custom/4coder_base_commands.cpp", 423, Normal)
CUSTOM_DOC("Seeks the cursor down to the next blank line and places it at the end of the line.")
{
    seek_blank_line(app, Scan_Forward, PositionWithinLine_SkipLeadingWhitespace);
}

CUSTOM_COMMAND(move_up_to_blank_line_end, "/home/sam/.bin/4coder/custom/4coder_base_commands.cpp", 429, Normal)
CUSTOM_DOC("Seeks the cursor up to the next blank line and places it at the end of the line.")
{
    seek_blank_line(app, Scan_Backward, PositionWithinLine_End);
}

CUSTOM_COMMAND(move_down_to_blank_line_end, "/home/sam/.bin/4coder/custom/4coder_base_commands.cpp", 435, Normal)
CUSTOM_DOC("Seeks the cursor down to the next blank line and places it at the end of the line.")
{
    seek_blank_line(app, Scan_Forward, PositionWithinLine_End);
}

CUSTOM_COMMAND(move_left, "/home/sam/.bin/4coder/custom/4coder_base_commands.cpp", 441, Normal)
CUSTOM_DOC("Moves the cursor one character to the left.")
{
    View_ID view = get_active_view(app, Access_ReadVisible);
    view_set_cursor_by_character_delta(app, view, -1);
    no_mark_snap_to_cursor_if_shift(app, view);
}

CUSTOM_COMMAND(move_right, "/home/sam/.bin/4coder/custom/4coder_base_commands.cpp", 449, Normal)
CUSTOM_DOC("Moves the cursor one character to the right.")
{
    View_ID view = get_active_view(app, Access_ReadVisible);
    view_set_cursor_by_character_delta(app, view, 1);
    no_mark_snap_to_cursor_if_shift(app, view);
}

static void
current_view_scan_move(Application_Links *app, Scan_Direction direction, Boundary_Function_List funcs){
    View_ID view = get_active_view(app, Access_ReadVisible);
    Buffer_ID buffer = view_get_buffer(app, view, Access_ReadVisible);
    i64 cursor_pos = view_get_cursor_pos(app, view);
    i64 pos = scan(app, funcs, buffer, direction, cursor_pos);
    view_set_cursor_and_preferred_x(app, view, seek_pos(pos));
    no_mark_snap_to_cursor_if_shift(app, view);
}

CUSTOM_COMMAND(move_right_whitespace_boundary, "/home/sam/.bin/4coder/custom/4coder_base_commands.cpp", 467, Normal)
CUSTOM_DOC("Seek right for the next boundary between whitespace and non-whitespace.")
{
    Scratch_Block scratch(app);
    current_view_scan_move(app, Scan_Forward,
                           push_boundary_list__inner((scratch), boundary_non_whitespace, 0));
}

CUSTOM_COMMAND(move_left_whitespace_boundary, "/home/sam/.bin/4coder/custom/4coder_base_commands.cpp", 475, Normal)
CUSTOM_DOC("Seek left for the next boundary between whitespace and non-whitespace.")
{
    Scratch_Block scratch(app);
    current_view_scan_move(app, Scan_Backward,
                           push_boundary_list__inner((scratch), boundary_non_whitespace, 0));
}

CUSTOM_COMMAND(move_right_token_boundary, "/home/sam/.bin/4coder/custom/4coder_base_commands.cpp", 483, Normal)
CUSTOM_DOC("Seek right for the next end of a token.")
{
    Scratch_Block scratch(app);
    current_view_scan_move(app, Scan_Forward, push_boundary_list__inner((scratch), boundary_token, 0));
}

CUSTOM_COMMAND(move_left_token_boundary, "/home/sam/.bin/4coder/custom/4coder_base_commands.cpp", 490, Normal)
CUSTOM_DOC("Seek left for the next beginning of a token.")
{
    Scratch_Block scratch(app);
    current_view_scan_move(app, Scan_Backward, push_boundary_list__inner((scratch), boundary_token, 0));
}

CUSTOM_COMMAND(move_right_whitespace_or_token_boundary, "/home/sam/.bin/4coder/custom/4coder_base_commands.cpp", 497, Normal)
CUSTOM_DOC("Seek right for the next end of a token or boundary between whitespace and non-whitespace.")
{
    Scratch_Block scratch(app);
    current_view_scan_move(app, Scan_Forward, push_boundary_list__inner((scratch), boundary_token, boundary_non_whitespace, 0));
}

CUSTOM_COMMAND(move_left_whitespace_or_token_boundary, "/home/sam/.bin/4coder/custom/4coder_base_commands.cpp", 504, Normal)
CUSTOM_DOC("Seek left for the next end of a token or boundary between whitespace and non-whitespace.")
{
    Scratch_Block scratch(app);
    current_view_scan_move(app, Scan_Backward, push_boundary_list__inner((scratch), boundary_token, boundary_non_whitespace, 0));
}

CUSTOM_COMMAND(move_right_alpha_numeric_boundary, "/home/sam/.bin/4coder/custom/4coder_base_commands.cpp", 511, Normal)
CUSTOM_DOC("Seek right for boundary between alphanumeric characters and non-alphanumeric characters.")
{
    Scratch_Block scratch(app);
    current_view_scan_move(app, Scan_Forward, push_boundary_list__inner((scratch), boundary_alpha_numeric, 0));
}

CUSTOM_COMMAND(move_left_alpha_numeric_boundary, "/home/sam/.bin/4coder/custom/4coder_base_commands.cpp", 518, Normal)
CUSTOM_DOC("Seek left for boundary between alphanumeric characters and non-alphanumeric characters.")
{
    Scratch_Block scratch(app);
    current_view_scan_move(app, Scan_Backward, push_boundary_list__inner((scratch), boundary_alpha_numeric, 0));
}

CUSTOM_COMMAND(move_right_alpha_numeric_or_camel_boundary, "/home/sam/.bin/4coder/custom/4coder_base_commands.cpp", 525, Normal)
CUSTOM_DOC("Seek right for boundary between alphanumeric characters or camel case word and non-alphanumeric characters.")
{
    Scratch_Block scratch(app);
    current_view_scan_move(app, Scan_Forward, push_boundary_list__inner((scratch), boundary_alpha_numeric_camel, 0));
}

CUSTOM_COMMAND(move_left_alpha_numeric_or_camel_boundary, "/home/sam/.bin/4coder/custom/4coder_base_commands.cpp", 532, Normal)
CUSTOM_DOC("Seek left for boundary between alphanumeric characters or camel case word and non-alphanumeric characters.")
{
    Scratch_Block scratch(app);
    current_view_scan_move(app, Scan_Backward, push_boundary_list__inner((scratch), boundary_alpha_numeric_camel, 0));
}



CUSTOM_COMMAND(select_all, "/home/sam/.bin/4coder/custom/4coder_base_commands.cpp", 541, Normal)
CUSTOM_DOC("Puts the cursor at the top of the file, and the mark at the bottom of the file.")
{
    View_ID view = get_active_view(app, Access_ReadVisible);
    Buffer_ID buffer = view_get_buffer(app, view, Access_ReadVisible);
    i32 buffer_size = (i32)buffer_get_size(app, buffer);
    view_set_cursor_and_preferred_x(app, view, seek_pos(0));
    view_set_mark(app, view, seek_pos(buffer_size));
    no_mark_snap_to_cursor(app, view);
}



CUSTOM_COMMAND(to_uppercase, "/home/sam/.bin/4coder/custom/4coder_base_commands.cpp", 554, Normal)
CUSTOM_DOC("Converts all ascii text in the range between the cursor and the mark to uppercase.")
{
    View_ID view = get_active_view(app, Access_ReadWriteVisible);
    Buffer_ID buffer = view_get_buffer(app, view, Access_ReadWriteVisible);
    Range_i64 range = get_view_range(app, view);
    Scratch_Block scratch(app);
    String_Const_u8 string = push_buffer_range(app, scratch, buffer, range);
    string = string_mod_upper(string);
    buffer_replace_range(app, buffer, range, string);
    view_set_cursor_and_preferred_x(app, view, seek_pos(range.max));
}

CUSTOM_COMMAND(to_lowercase, "/home/sam/.bin/4coder/custom/4coder_base_commands.cpp", 567, Normal)
CUSTOM_DOC("Converts all ascii text in the range between the cursor and the mark to lowercase.")
{
    View_ID view = get_active_view(app, Access_ReadWriteVisible);
    Buffer_ID buffer = view_get_buffer(app, view, Access_ReadWriteVisible);
    Range_i64 range = get_view_range(app, view);
    Scratch_Block scratch(app);
    String_Const_u8 string = push_buffer_range(app, scratch, buffer, range);
    string = string_mod_lower(string);
    buffer_replace_range(app, buffer, range, string);
    view_set_cursor_and_preferred_x(app, view, seek_pos(range.max));
}

typedef i32 Clean_All_Lines_Mode;
enum{
    CleanAllLinesMode_RemoveBlankLines,
    CleanAllLinesMode_LeaveBlankLines,
};

static void
clean_all_lines_buffer(Application_Links *app, Buffer_ID buffer, Clean_All_Lines_Mode mode){
    Profile_Scope_Block profile_block_588 ((app), SCu8((u8*)("clean all lines"), (u64)(sizeof("clean all lines") - 1)), SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_base_commands.cpp" ":" "588" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_base_commands.cpp" ":" "588" ":") - 1)));
    Scratch_Block scratch(app);
    Batch_Edit *batch_first = 0;
    Batch_Edit *batch_last = 0;

    i64 line_count = buffer_get_line_count(app, buffer);
    for (i64 line_number = 1; line_number <= line_count; line_number += 1){
        i64 line_start = get_line_side_pos(app, buffer, line_number, Side_Min);
        i64 line_end = get_line_side_pos(app, buffer, line_number, Side_Max);
        u8 prev = buffer_get_char(app, buffer, line_end - 1);
        b32 has_cr_character = false;
        b32 has_tail_whitespace = false;
        if (prev == '\r'){
            has_cr_character = true;
            if (line_end - 2 >= line_start){
                prev = buffer_get_char(app, buffer, line_end - 2);
                has_tail_whitespace = character_is_whitespace(prev);
            }
        }
        else{
            has_tail_whitespace = character_is_whitespace(prev);
        }
        if (has_tail_whitespace){
            String_Const_u8 line = push_buffer_range(app, scratch, buffer,
                                                     Ii64(line_start, line_end));
            if (line.size > 0){
                i64 end_offset = line.size;
                i64 i = line.size - 1;
                if (has_cr_character){
                    end_offset -= 1;
                    i -= 1;
                }
                i64 start_offset = 0;
                for (; i >= 0; i -= 1){
                    if (!character_is_whitespace(line.str[i])){
                        start_offset = i + 1;
                        break;
                    }
                }

                if (mode == CleanAllLinesMode_RemoveBlankLines || start_offset > 0){
                    i64 start = start_offset + line_start;
                    i64 end = end_offset + line_start;

                    Batch_Edit *batch = ((Batch_Edit*)linalloc_wrap_unintialized(linalloc_push((scratch), sizeof(Batch_Edit)*(1), SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_base_commands.cpp" ":" "632" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_base_commands.cpp" ":" "632" ":") - 1)))));
                    do{ if((batch)){if((batch_first)){(batch_last)->next=(batch);}else{(batch_first)=(batch);}(batch_last)=(batch);(batch_last)->next=0;} }while(0);
                    batch->edit.text = SCu8();
                    batch->edit.range = Ii64(start, end);
                }
            }
        }
    }

    if (batch_first != 0){
        buffer_batch_edit(app, buffer, batch_first);
    }
}

CUSTOM_COMMAND(clean_all_lines, "/home/sam/.bin/4coder/custom/4coder_base_commands.cpp", 646, Normal)
CUSTOM_DOC("Removes trailing whitespace from all lines and removes all blank lines in the current buffer.")
{
    Profile_Scope_Block profile_block_649 ((app), SCu8((u8*)("clean all lines"), (u64)(sizeof("clean all lines") - 1)), SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_base_commands.cpp" ":" "649" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_base_commands.cpp" ":" "649" ":") - 1)));
    View_ID view = get_active_view(app, Access_ReadWriteVisible);
    Buffer_ID buffer = view_get_buffer(app, view, Access_ReadWriteVisible);
    clean_all_lines_buffer(app, buffer, CleanAllLinesMode_RemoveBlankLines);
}

CUSTOM_COMMAND(clean_trailing_whitespace, "/home/sam/.bin/4coder/custom/4coder_base_commands.cpp", 655, Normal)
CUSTOM_DOC("Removes trailing whitespace from all lines in the current buffer.")
{
    Profile_Scope_Block profile_block_658 ((app), SCu8((u8*)("clean all lines"), (u64)(sizeof("clean all lines") - 1)), SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_base_commands.cpp" ":" "658" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_base_commands.cpp" ":" "658" ":") - 1)));
    View_ID view = get_active_view(app, Access_ReadWriteVisible);
    Buffer_ID buffer = view_get_buffer(app, view, Access_ReadWriteVisible);
    clean_all_lines_buffer(app, buffer, CleanAllLinesMode_LeaveBlankLines);
}



CUSTOM_COMMAND(basic_change_active_panel, "/home/sam/.bin/4coder/custom/4coder_base_commands.cpp", 666, Normal)
CUSTOM_DOC("Change the currently active panel, moving to the panel with the next highest view_id.  Will not skipe the build panel if it is open.")
{
    View_ID view = get_active_view(app, Access_Always);
    get_next_view_looped_all_panels(app, view, Access_Always);
    view_set_active(app, view);
}

CUSTOM_COMMAND(close_panel, "/home/sam/.bin/4coder/custom/4coder_base_commands.cpp", 674, Normal)
CUSTOM_DOC("Closes the currently active panel if it is not the only panel open.")
{
    View_ID view = get_active_view(app, Access_Always);
    view_close(app, view);
}



CUSTOM_COMMAND(show_scrollbar, "/home/sam/.bin/4coder/custom/4coder_base_commands.cpp", 683, Normal)
CUSTOM_DOC("Sets the current view to show it's scrollbar.")
{
    View_ID view = get_active_view(app, Access_Always);
    view_set_setting(app, view, ViewSetting_ShowScrollbar, true);
}

CUSTOM_COMMAND(hide_scrollbar, "/home/sam/.bin/4coder/custom/4coder_base_commands.cpp", 690, Normal)
CUSTOM_DOC("Sets the current view to hide it's scrollbar.")
{
    View_ID view = get_active_view(app, Access_Always);
    view_set_setting(app, view, ViewSetting_ShowScrollbar, false);
}

CUSTOM_COMMAND(show_filebar, "/home/sam/.bin/4coder/custom/4coder_base_commands.cpp", 697, Normal)
CUSTOM_DOC("Sets the current view to show it's filebar.")
{
    View_ID view = get_active_view(app, Access_Always);
    view_set_setting(app, view, ViewSetting_ShowFileBar, true);
}

CUSTOM_COMMAND(hide_filebar, "/home/sam/.bin/4coder/custom/4coder_base_commands.cpp", 704, Normal)
CUSTOM_DOC("Sets the current view to hide it's filebar.")
{
    View_ID view = get_active_view(app, Access_Always);
    view_set_setting(app, view, ViewSetting_ShowFileBar, false);
}

CUSTOM_COMMAND(toggle_filebar, "/home/sam/.bin/4coder/custom/4coder_base_commands.cpp", 711, Normal)
CUSTOM_DOC("Toggles the visibility status of the current view's filebar.")
{
    View_ID view = get_active_view(app, Access_Always);
    b64 value = false;
    view_get_setting(app, view, ViewSetting_ShowFileBar, &value);
    view_set_setting(app, view, ViewSetting_ShowFileBar, !value);
}

CUSTOM_COMMAND(toggle_fps_meter, "/home/sam/.bin/4coder/custom/4coder_base_commands.cpp", 720, Normal)
CUSTOM_DOC("Toggles the visibility of the FPS performance meter")
{
    show_fps_hud = !show_fps_hud;
}

CUSTOM_COMMAND(set_face_size, "/home/sam/.bin/4coder/custom/4coder_base_commands.cpp", 726, Normal)
CUSTOM_DOC("Set face size of the face used by the current buffer.")
{
    View_ID view = get_active_view(app, Access_Always);
    Buffer_ID buffer = view_get_buffer(app, view, Access_Always);
    Face_ID face_id = get_face_id(app, buffer);
    Face_Description description = get_face_description(app, face_id);

    Query_Bar_Group group(app);
    u8 string_space[256];
    Query_Bar bar = {};
    bar.prompt = SCu8((u8*)("Face Size: "), (u64)(sizeof("Face Size: ") - 1));
    bar.string = SCu8(string_space, (u64)0);
    bar.string_capacity = sizeof(string_space);
    if (query_user_number(app, &bar, description.parameters.pt_size)){
        description.parameters.pt_size = (u32)string_to_integer(bar.string, 10);
        try_modify_face(app, face_id, &description);
    }
}

CUSTOM_COMMAND(increase_face_size, "/home/sam/.bin/4coder/custom/4coder_base_commands.cpp", 746, Normal)
CUSTOM_DOC("Increase the size of the face used by the current buffer.")
{
    View_ID view = get_active_view(app, Access_Always);
    Buffer_ID buffer = view_get_buffer(app, view, Access_Always);
    Face_ID face_id = get_face_id(app, buffer);
    Face_Description description = get_face_description(app, face_id);
    ++description.parameters.pt_size;
    try_modify_face(app, face_id, &description);
}

CUSTOM_COMMAND(decrease_face_size, "/home/sam/.bin/4coder/custom/4coder_base_commands.cpp", 757, Normal)
CUSTOM_DOC("Decrease the size of the face used by the current buffer.")
{
    View_ID view = get_active_view(app, Access_Always);
    Buffer_ID buffer = view_get_buffer(app, view, Access_Always);
    Face_ID face_id = get_face_id(app, buffer);
    Face_Description description = get_face_description(app, face_id);
    --description.parameters.pt_size;
    try_modify_face(app, face_id, &description);
}

CUSTOM_COMMAND(set_face_size_this_buffer, "/home/sam/.bin/4coder/custom/4coder_base_commands.cpp", 768, Normal)
CUSTOM_DOC("Set face size of the face used by the current buffer; if any other buffers are using the same face a new face is created so that only this buffer is effected")
{
    View_ID view = get_active_view(app, Access_Always);
    Buffer_ID buffer = view_get_buffer(app, view, Access_Always);
    Face_ID face_id = get_face_id(app, buffer);

    b32 is_shared = false;
    for (Buffer_ID buf_it = get_buffer_next(app, 0, Access_Always);
         buf_it != 0;
         buf_it = get_buffer_next(app, buf_it, Access_Always)){
        if (buf_it == buffer){
            continue;
        }
        Face_ID buf_it_face_id = get_face_id(app, buf_it);
        if (buf_it_face_id == face_id){
            is_shared = true;
        }
    }

    if (is_shared){
        Face_Description description = get_face_description(app, face_id);
        face_id = try_create_new_face(app, &description);
        if (face_id != 0){
            buffer_set_face(app, buffer, face_id);
        }
    }

    set_face_size(app);
}

CUSTOM_COMMAND(mouse_wheel_change_face_size, "/home/sam/.bin/4coder/custom/4coder_base_commands.cpp", 799, Normal)
CUSTOM_DOC("Reads the state of the mouse wheel and uses it to either increase or decrease the face size.")
{
    static u64 next_resize_time = 0;
    u64 now = system_now_time();
    if (now >= next_resize_time){
        next_resize_time = now + 50*1000;
        Mouse_State mouse = get_mouse_state(app);
        if (mouse.wheel > 0){
            decrease_face_size(app);
        }
        else if (mouse.wheel < 0){
            increase_face_size(app);
        }
    }
}

CUSTOM_COMMAND(toggle_show_whitespace, "/home/sam/.bin/4coder/custom/4coder_base_commands.cpp", 816, Normal)
CUSTOM_DOC("Toggles the current buffer's whitespace visibility status.")
{
    View_ID view = get_active_view(app, Access_ReadVisible);
    b64 show_whitespace = false;
    view_get_setting(app, view, ViewSetting_ShowWhitespace, &show_whitespace);
    view_set_setting(app, view, ViewSetting_ShowWhitespace, !show_whitespace);
}

CUSTOM_COMMAND(toggle_line_numbers, "/home/sam/.bin/4coder/custom/4coder_base_commands.cpp", 825, Normal)
CUSTOM_DOC("Toggles the left margin line numbers.")
{
    global_config.show_line_number_margins = !global_config.show_line_number_margins;
}

CUSTOM_COMMAND(toggle_line_wrap, "/home/sam/.bin/4coder/custom/4coder_base_commands.cpp", 831, Normal)
CUSTOM_DOC("Toggles the line wrap setting on this buffer.")
{
    View_ID view = get_active_view(app, Access_ReadVisible);
    Buffer_ID buffer = view_get_buffer(app, view, Access_Always);
    Managed_Scope scope = buffer_get_managed_scope(app, buffer);
    b32 *wrap_lines_ptr = ((b32*)managed_scope_get_attachment((app), (scope), (buffer_wrap_lines), sizeof(b32)));
    if (wrap_lines_ptr != 0){
        *wrap_lines_ptr = !(*wrap_lines_ptr);
        buffer_clear_layout_cache(app, buffer);
    }
}

CUSTOM_COMMAND(exit_4coder, "/home/sam/.bin/4coder/custom/4coder_base_commands.cpp", 844, Normal)
CUSTOM_DOC("Attempts to close 4coder.")
{
    send_exit_signal(app);
}



CUSTOM_COMMAND(goto_line, "/home/sam/.bin/4coder/custom/4coder_base_commands.cpp", 852, Normal)
CUSTOM_DOC("Queries the user for a number, and jumps the cursor to the corresponding line.")
{
    Query_Bar_Group group(app);
    u8 string_space[256];
    Query_Bar bar = {};
    bar.prompt = SCu8((u8*)("Goto Line: "), (u64)(sizeof("Goto Line: ") - 1));
    bar.string = SCu8(string_space, (u64)0);
    bar.string_capacity = sizeof(string_space);
    if (query_user_number(app, &bar)){
        i32 line_number = (i32)string_to_integer(bar.string, 10);
        View_ID view = get_active_view(app, Access_ReadVisible);
        view_set_cursor_and_preferred_x(app, view, seek_line_col(line_number, 0));
    }
}

CUSTOM_COMMAND(search, "/home/sam/.bin/4coder/custom/4coder_base_commands.cpp", 868, Normal);
CUSTOM_COMMAND(reverse_search, "/home/sam/.bin/4coder/custom/4coder_base_commands.cpp", 869, Normal);

static void
isearch__update_highlight(Application_Links *app, View_ID view, Range_i64 range){
    view_set_highlight_range(app, view, range);
    view_set_cursor_and_preferred_x(app, view, seek_pos(range.start));
}

static void
isearch(Application_Links *app, Scan_Direction start_scan, i64 first_pos,
        String_Const_u8 query_init){
    View_ID view = get_active_view(app, Access_ReadVisible);
    Buffer_ID buffer = view_get_buffer(app, view, Access_ReadVisible);
    if (!buffer_exists(app, buffer)){
        return;
    }

    i64 buffer_size = buffer_get_size(app, buffer);

    Query_Bar_Group group(app);
    Query_Bar bar = {};
    if (start_query_bar(app, &bar, 0) == 0){
        return;
    }

    Vec2_f32 old_margin = {};
    Vec2_f32 old_push_in = {};
    view_get_camera_bounds(app, view, &old_margin, &old_push_in);

    Vec2_f32 margin = old_margin;
    margin.y = (((200.f)>(margin.y))?(200.f):(margin.y));
    view_set_camera_bounds(app, view, margin, old_push_in);

    Scan_Direction scan = start_scan;
    i64 pos = first_pos;

    u8 bar_string_space[256];
    bar.string = SCu8(bar_string_space, query_init.size);
    block_copy(bar.string.str, query_init.str, query_init.size);

    String_Const_u8 isearch_str = SCu8((u8*)("I-Search: "), (u64)(sizeof("I-Search: ") - 1));
    String_Const_u8 rsearch_str = SCu8((u8*)("Reverse-I-Search: "), (u64)(sizeof("Reverse-I-Search: ") - 1));

    u64 match_size = bar.string.size;

    User_Input in = {};
    for (;;){
        switch (scan){
            case Scan_Forward:
            {
                bar.prompt = isearch_str;
            }break;
            case Scan_Backward:
            {
                bar.prompt = rsearch_str;
            }break;
        }
        isearch__update_highlight(app, view, Ii64_size(pos, match_size));

        in = get_next_input(app, EventPropertyGroup_Any, EventProperty_Escape);
        if (in.abort){
            break;
        }

        String_Const_u8 string = to_writable(&in);

        b32 string_change = false;
        if (match_key_code(&in, KeyCode_Return) ||
            match_key_code(&in, KeyCode_Tab)){
            Input_Modifier_Set *mods = &in.event.key.modifiers;
            if (has_modifier(mods, KeyCode_Control)){
                bar.string.size = cstring_length(previous_isearch_query);
                block_copy(bar.string.str, previous_isearch_query, bar.string.size);
            }
            else{
                u64 size = bar.string.size;
                size = (((size)<(sizeof(previous_isearch_query) - 1))?(size):(sizeof(previous_isearch_query) - 1));
                block_copy(previous_isearch_query, bar.string.str, size);
                previous_isearch_query[size] = 0;
                break;
            }
        }
        else if (string.str != 0 && string.size > 0){
            String_u8 bar_string = Su8(bar.string, sizeof(bar_string_space));
            string_append(&bar_string, string);
            bar.string = bar_string.string;
            string_change = true;
        }
        else if (match_key_code(&in, KeyCode_Backspace)){
            if (is_unmodified_key(&in.event)){
                u64 old_bar_string_size = bar.string.size;
                bar.string = backspace_utf8(bar.string);
                string_change = (bar.string.size < old_bar_string_size);
            }
            else if (has_modifier(&in.event.key.modifiers, KeyCode_Control)){
                if (bar.string.size > 0){
                    string_change = true;
                    bar.string.size = 0;
                }
            }
        }

        b32 do_scan_action = false;
        b32 do_scroll_wheel = false;
        Scan_Direction change_scan = scan;
        if (!string_change){
            if (match_key_code(&in, KeyCode_PageDown) ||
                match_key_code(&in, KeyCode_Down)){
                change_scan = Scan_Forward;
                do_scan_action = true;
            }
            else if (match_key_code(&in, KeyCode_PageUp) ||
                     match_key_code(&in, KeyCode_Up)){
                change_scan = Scan_Backward;
                do_scan_action = true;
            }
            else{

                View_Context ctx = view_current_context(app, view);
                Mapping *mapping = ctx.mapping;
                Command_Map *map = mapping_get_map(mapping, ctx.map_id);
                Command_Binding binding = map_get_binding_recursive(mapping, map, &in.event);
                if (binding.custom != 0){
                    if (binding.custom == search){
                        change_scan = Scan_Forward;
                        do_scan_action = true;
                    }
                    else if (binding.custom == reverse_search){
                        change_scan = Scan_Backward;
                        do_scan_action = true;
                    }
                    else{
                        Command_Metadata *metadata = get_command_metadata(binding.custom);
                        if (metadata != 0){
                            if (metadata->is_ui){
                                view_enqueue_command_function(app, view, binding.custom);
                                break;
                            }
                        }
                        binding.custom(app);
                    }
                }
                else{
                    leave_current_input_unhandled(app);
                }
            }
        }

        if (string_change){
            switch (scan){
                case Scan_Forward:
                {
                    i64 new_pos = 0;
                    seek_string_insensitive_forward(app, buffer, pos - 1, 0, bar.string, &new_pos);
                    if (new_pos < buffer_size){
                        pos = new_pos;
                        match_size = bar.string.size;
                    }
                }break;

                case Scan_Backward:
                {
                    i64 new_pos = 0;
                    seek_string_insensitive_backward(app, buffer, pos + 1, 0, bar.string, &new_pos);
                    if (new_pos >= 0){
                        pos = new_pos;
                        match_size = bar.string.size;
                    }
                }break;
            }
        }
        else if (do_scan_action){
            scan = change_scan;
            switch (scan){
                case Scan_Forward:
                {
                    i64 new_pos = 0;
                    seek_string_insensitive_forward(app, buffer, pos, 0, bar.string, &new_pos);
                    if (new_pos < buffer_size){
                        pos = new_pos;
                        match_size = bar.string.size;
                    }
                }break;

                case Scan_Backward:
                {
                    i64 new_pos = 0;
                    seek_string_insensitive_backward(app, buffer, pos, 0, bar.string, &new_pos);
                    if (new_pos >= 0){
                        pos = new_pos;
                        match_size = bar.string.size;
                    }
                }break;
            }
        }
        else if (do_scroll_wheel){
            mouse_wheel_scroll(app);
        }
    }

    view_disable_highlight_range(app, view);

    if (in.abort){
        u64 size = bar.string.size;
        size = (((size)<(sizeof(previous_isearch_query) - 1))?(size):(sizeof(previous_isearch_query) - 1));
        block_copy(previous_isearch_query, bar.string.str, size);
        previous_isearch_query[size] = 0;
        view_set_cursor_and_preferred_x(app, view, seek_pos(first_pos));
    }

    view_set_camera_bounds(app, view, old_margin, old_push_in);
}

static void
isearch(Application_Links *app, Scan_Direction start_scan, String_Const_u8 query_init){
    View_ID view = get_active_view(app, Access_ReadVisible);
    i64 pos = view_get_cursor_pos(app, view);;
    isearch(app, start_scan, pos, query_init);
}

static void
isearch(Application_Links *app, Scan_Direction start_scan){
    View_ID view = get_active_view(app, Access_ReadVisible);
    i64 pos = view_get_cursor_pos(app, view);;
    isearch(app, start_scan, pos, SCu8());
}

static void
isearch_identifier(Application_Links *app, Scan_Direction scan){
    View_ID view = get_active_view(app, Access_ReadVisible);
    Buffer_ID buffer_id = view_get_buffer(app, view, Access_ReadVisible);
    i64 pos = view_get_cursor_pos(app, view);
    Scratch_Block scratch(app);
    Range_i64 range = enclose_pos_alpha_numeric_underscore(app, buffer_id, pos);
    String_Const_u8 query = push_buffer_range(app, scratch, buffer_id, range);
    isearch(app, scan, range.first, query);
}

CUSTOM_COMMAND(search, "/home/sam/.bin/4coder/custom/4coder_base_commands.cpp", 1107, Normal)
CUSTOM_DOC("Begins an incremental search down through the current buffer for a user specified string.")
{
    isearch(app, Scan_Forward);
}

CUSTOM_COMMAND(reverse_search, "/home/sam/.bin/4coder/custom/4coder_base_commands.cpp", 1113, Normal)
CUSTOM_DOC("Begins an incremental search up through the current buffer for a user specified string.")
{
    isearch(app, Scan_Backward);
}

CUSTOM_COMMAND(search_identifier, "/home/sam/.bin/4coder/custom/4coder_base_commands.cpp", 1119, Normal)
CUSTOM_DOC("Begins an incremental search down through the current buffer for the word or token under the cursor.")
{
    isearch_identifier(app, Scan_Forward);
}

CUSTOM_COMMAND(reverse_search_identifier, "/home/sam/.bin/4coder/custom/4coder_base_commands.cpp", 1125, Normal)
CUSTOM_DOC("Begins an incremental search up through the current buffer for the word or token under the cursor.")
{
    isearch_identifier(app, Scan_Backward);
}

struct String_Pair{
    b32 valid;
    String_Const_u8 a;
    String_Const_u8 b;
};

static String_Pair
query_user_replace_pair(Application_Links *app, Arena *arena){
    Query_Bar *replace = ((Query_Bar*)linalloc_wrap_unintialized(linalloc_push((arena), sizeof(Query_Bar)*(1), SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_base_commands.cpp" ":" "1139" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_base_commands.cpp" ":" "1139" ":") - 1)))));
    u8 *replace_space = ((u8*)linalloc_wrap_unintialized(linalloc_push((arena), sizeof(u8)*(((1) << 10)), SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_base_commands.cpp" ":" "1140" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_base_commands.cpp" ":" "1140" ":") - 1)))));
    replace->prompt = SCu8((u8*)("Replace: "), (u64)(sizeof("Replace: ") - 1));
    replace->string = SCu8(replace_space, (u64)0);
    replace->string_capacity = ((1) << 10);

    Query_Bar *with = ((Query_Bar*)linalloc_wrap_unintialized(linalloc_push((arena), sizeof(Query_Bar)*(1), SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_base_commands.cpp" ":" "1145" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_base_commands.cpp" ":" "1145" ":") - 1)))));
    u8 *with_space = ((u8*)linalloc_wrap_unintialized(linalloc_push((arena), sizeof(u8)*(((1) << 10)), SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_base_commands.cpp" ":" "1146" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_base_commands.cpp" ":" "1146" ":") - 1)))));
    with->prompt = SCu8((u8*)("With: "), (u64)(sizeof("With: ") - 1));
    with->string = SCu8(with_space, (u64)0);
    with->string_capacity = ((1) << 10);

    String_Pair result = {};
    if (query_user_string(app, replace) && replace->string.size != 0 && query_user_string(app, with)){
        result.valid = true;
        result.a = replace->string;
        result.b = with->string;
    }
    return(result);
}



static void
replace_in_range_query_user(Application_Links *app, Buffer_ID buffer, Range_i64 range){
    Scratch_Block scratch(app);
    Query_Bar_Group group(app);
    String_Pair pair = query_user_replace_pair(app, scratch);
    if (pair.valid){
        replace_in_range(app, buffer, range, pair.a, pair.b);
    }
}

CUSTOM_COMMAND(replace_in_range, "/home/sam/.bin/4coder/custom/4coder_base_commands.cpp", 1172, Normal)
CUSTOM_DOC("Queries the user for a needle and string. Replaces all occurences of needle with string in the range between cursor and the mark in the active buffer.")
{
    View_ID view = get_active_view(app, Access_ReadWriteVisible);
    Buffer_ID buffer = view_get_buffer(app, view, Access_ReadWriteVisible);
    Range_i64 range = get_view_range(app, view);
    replace_in_range_query_user(app, buffer, range);
}

CUSTOM_COMMAND(replace_in_buffer, "/home/sam/.bin/4coder/custom/4coder_base_commands.cpp", 1181, Normal)
CUSTOM_DOC("Queries the user for a needle and string. Replaces all occurences of needle with string in the active buffer.")
{
    View_ID view = get_active_view(app, Access_ReadWriteVisible);
    Buffer_ID buffer = view_get_buffer(app, view, Access_ReadWriteVisible);
    Range_i64 range = buffer_range(app, buffer);
    replace_in_range_query_user(app, buffer, range);
}

CUSTOM_COMMAND(replace_in_all_buffers, "/home/sam/.bin/4coder/custom/4coder_base_commands.cpp", 1190, Normal)
CUSTOM_DOC("Queries the user for a needle and string. Replaces all occurences of needle with string in all editable buffers.")
{
    global_history_edit_group_begin(app);

    Scratch_Block scratch(app);
    Query_Bar_Group group(app);
    String_Pair pair = query_user_replace_pair(app, scratch);
    for (Buffer_ID buffer = get_buffer_next(app, 0, Access_ReadWriteVisible);
         buffer != 0;
         buffer = get_buffer_next(app, buffer, Access_ReadWriteVisible)){
        Range_i64 range = buffer_range(app, buffer);
        replace_in_range(app, buffer, range, pair.a, pair.b);
    }

    global_history_edit_group_end(app);
}

static void
query_replace_base(Application_Links *app, View_ID view, Buffer_ID buffer_id, i64 pos, String_Const_u8 r, String_Const_u8 w){
    i64 new_pos = 0;
    seek_string_forward(app, buffer_id, pos - 1, 0, r, &new_pos);

    User_Input in = {};
    for (;;){
        Range_i64 match = Ii64(new_pos, new_pos + r.size);
        isearch__update_highlight(app, view, match);

        in = get_next_input(app, EventProperty_AnyKey, EventProperty_MouseButton);
        if (in.abort || match_key_code(&in, KeyCode_Escape) || !is_unmodified_key(&in.event)){
            break;
        }

        i64 size = buffer_get_size(app, buffer_id);
        if (match.max <= size &&
            (match_key_code(&in, KeyCode_Y) ||
             match_key_code(&in, KeyCode_Return) ||
             match_key_code(&in, KeyCode_Tab))){
            buffer_replace_range(app, buffer_id, match, w);
            pos = match.start + w.size;
        }
        else{
            pos = match.max;
        }

        seek_string_forward(app, buffer_id, pos, 0, r, &new_pos);
    }

    view_disable_highlight_range(app, view);

    if (in.abort){
        return;
    }

    view_set_cursor_and_preferred_x(app, view, seek_pos(pos));
}

static void
query_replace_parameter(Application_Links *app, String_Const_u8 replace_str, i64 start_pos, b32 add_replace_query_bar){
    Query_Bar_Group group(app);
    Query_Bar replace = {};
    replace.prompt = SCu8((u8*)("Replace: "), (u64)(sizeof("Replace: ") - 1));
    replace.string = replace_str;

    if (add_replace_query_bar){
        start_query_bar(app, &replace, 0);
    }

    Query_Bar with = {};
    u8 with_space[1024];
    with.prompt = SCu8((u8*)("With: "), (u64)(sizeof("With: ") - 1));
    with.string = SCu8(with_space, (u64)0);
    with.string_capacity = sizeof(with_space);

    if (query_user_string(app, &with)){
        String_Const_u8 r = replace.string;
        String_Const_u8 w = with.string;

        View_ID view = get_active_view(app, Access_ReadVisible);
        Buffer_ID buffer = view_get_buffer(app, view, Access_ReadVisible);
        i64 pos = start_pos;

        Query_Bar bar = {};
        bar.prompt = SCu8((u8*)("Replace? (y)es, (n)ext, (esc)\n"), (u64)(sizeof("Replace? (y)es, (n)ext, (esc)\n") - 1));
        start_query_bar(app, &bar, 0);

        query_replace_base(app, view, buffer, pos, r, w);
    }
}

CUSTOM_COMMAND(query_replace, "/home/sam/.bin/4coder/custom/4coder_base_commands.cpp", 1280, Normal)
CUSTOM_DOC("Queries the user for two strings, and incrementally replaces every occurence of the first string with the second string.")
{
    View_ID view = get_active_view(app, Access_ReadWriteVisible);
    Buffer_ID buffer = view_get_buffer(app, view, Access_ReadWriteVisible);
    if (buffer != 0){
        Query_Bar_Group group(app);
        Query_Bar replace = {};
        u8 replace_space[1024];
        replace.prompt = SCu8((u8*)("Replace: "), (u64)(sizeof("Replace: ") - 1));
        replace.string = SCu8(replace_space, (u64)0);
        replace.string_capacity = sizeof(replace_space);
        if (query_user_string(app, &replace)){
            if (replace.string.size > 0){
                i64 pos = view_get_cursor_pos(app, view);
                query_replace_parameter(app, replace.string, pos, false);
            }
        }
    }
}

CUSTOM_COMMAND(query_replace_identifier, "/home/sam/.bin/4coder/custom/4coder_base_commands.cpp", 1301, Normal)
CUSTOM_DOC("Queries the user for a string, and incrementally replace every occurence of the word or token found at the cursor with the specified string.")
{
    View_ID view = get_active_view(app, Access_ReadWriteVisible);
    Buffer_ID buffer = view_get_buffer(app, view, Access_ReadWriteVisible);
    if (buffer != 0){
        Scratch_Block scratch(app);
        i64 pos = view_get_cursor_pos(app, view);
        Range_i64 range = enclose_pos_alpha_numeric_underscore(app, buffer, pos);
        String_Const_u8 replace = push_buffer_range(app, scratch, buffer, range);
        if (replace.size != 0){
            query_replace_parameter(app, replace, range.min, true);
        }
    }
}

CUSTOM_COMMAND(query_replace_selection, "/home/sam/.bin/4coder/custom/4coder_base_commands.cpp", 1317, Normal)
CUSTOM_DOC("Queries the user for a string, and incrementally replace every occurence of the string found in the selected range with the specified string.")
{
    View_ID view = get_active_view(app, Access_ReadWriteVisible);
    Buffer_ID buffer = view_get_buffer(app, view, Access_ReadWriteVisible);
    if (buffer != 0){
        Scratch_Block scratch(app);
        Range_i64 range = get_view_range(app, view);
        String_Const_u8 replace = push_buffer_range(app, scratch, buffer, range);
        if (replace.size != 0){
            query_replace_parameter(app, replace, range.min, true);
        }
    }
}



CUSTOM_COMMAND(jump_to_last_point, "/home/sam/.bin/4coder/custom/4coder_base_commands.cpp", 1334, Normal)
CUSTOM_DOC("Read from the top of the point stack and jump there; if already there pop the top and go to the next option")
{
    View_ID view = get_active_view(app, Access_Visible);
    if (view != 0){
        Buffer_ID buffer = view_get_buffer(app, view, Access_Always);
        i64 pos = view_get_cursor_pos(app, view);

        for (;;){
            Buffer_ID stack_buffer = 0;
            i64 stack_pos = 0;
            if (point_stack_read_top(app, &stack_buffer, &stack_pos)){
                if (stack_buffer != 0 &&
                    (stack_buffer != buffer || stack_pos != pos)){
                    view_set_buffer(app, view, stack_buffer, 0);
                    view_set_cursor_and_preferred_x(app, view, seek_pos(stack_pos));
                    break;
                }
                point_stack_pop(app);
            }
            else{
                break;
            }
        }
    }
}



static void
delete_file_base(Application_Links *app, String_Const_u8 file_name, Buffer_ID buffer_id){
    String_Const_u8 path = string_remove_last_folder(file_name);
    Scratch_Block scratch(app);
    List_String_Const_u8 list = {};



    string_list_push((scratch), (&list), SCu8((u8*)("rm "), (u64)(sizeof("rm ") - 1)));



    string_list_pushf(scratch, &list, "\"%.*s\"", (i32)(file_name).size, (char*)(file_name).str);
    String_Const_u8 cmd = string_list_flatten(scratch, list, StringFill_NullTerminate);
    exec_system_command(app, 0, buffer_identifier(0), path, cmd, 0);
    buffer_kill(app, buffer_id, BufferKill_AlwaysKill);
}

CUSTOM_COMMAND(delete_file_query, "/home/sam/.bin/4coder/custom/4coder_base_commands.cpp", 1381, Normal)
CUSTOM_DOC("Deletes the file of the current buffer if 4coder has the appropriate access rights. Will ask the user for confirmation first.")
{
    View_ID view = get_active_view(app, Access_Always);
    Buffer_ID buffer = view_get_buffer(app, view, Access_Always);
    Scratch_Block scratch(app);
    String_Const_u8 file_name = push_buffer_file_name(app, scratch, buffer);
    if (file_name.size > 0){
        Query_Bar_Group group(app);
        Query_Bar bar = {};
        bar.prompt = push_u8_stringf(scratch, "Delete '%.*s' (Y)es, (n)o", (i32)(file_name).size, (char*)(file_name).str);
        if (start_query_bar(app, &bar, 0) != 0){
            b32 cancelled = false;
            for (;!cancelled;){
                User_Input in = get_next_input(app, EventProperty_AnyKey, 0);
                if (in.abort){
                    cancelled = true;
                }
                else{
                    switch (in.event.key.code){
                        case KeyCode_Y:
                        {
                            delete_file_base(app, file_name, buffer);
                            cancelled = true;
                        }break;

                        case KeyCode_Shift:
                        case KeyCode_Control:
                        case KeyCode_Alt:
                        case KeyCode_Command:
                        case KeyCode_CapsLock:
                        {}break;

                        default:
                        {
                            cancelled = true;
                        }break;
                    }
                }
            }
        }
    }
}

CUSTOM_COMMAND(save_to_query, "/home/sam/.bin/4coder/custom/4coder_base_commands.cpp", 1425, Normal)
CUSTOM_DOC("Queries the user for a file name and saves the contents of the current buffer, altering the buffer's name too.")
{
    View_ID view = get_active_view(app, Access_Always);
    Buffer_ID buffer = view_get_buffer(app, view, Access_Always);

    Scratch_Block scratch(app);
    Query_Bar_Group group(app);
    String_Const_u8 buffer_name = push_buffer_unique_name(app, scratch, buffer);


    u8 name_space[4096];
    Query_Bar bar = {};
    bar.prompt = push_u8_stringf(scratch, "Save '%.*s' to: ", (i32)(buffer_name).size, (char*)(buffer_name).str);
    bar.string = SCu8(name_space, (u64)0);
    bar.string_capacity = sizeof(name_space);
    if (query_user_string(app, &bar)){
        if (bar.string.size != 0){
            List_String_Const_u8 new_file_name_list = {};
            string_list_push(scratch, &new_file_name_list, push_hot_directory(app, scratch));
            string_list_push(scratch, &new_file_name_list, bar.string);
            String_Const_u8 new_file_name = string_list_flatten(scratch, new_file_name_list);
            if (buffer_save(app, buffer, new_file_name, BufferSave_IgnoreDirtyFlag)){
                Buffer_ID new_buffer = create_buffer(app, new_file_name, BufferCreate_NeverNew|BufferCreate_JustChangedFile);
                if (new_buffer != 0 && new_buffer != buffer){
                    buffer_kill(app, buffer, BufferKill_AlwaysKill);
                    view_set_buffer(app, view, new_buffer, 0);
                }
            }
        }
    }
}

CUSTOM_COMMAND(rename_file_query, "/home/sam/.bin/4coder/custom/4coder_base_commands.cpp", 1458, Normal)
CUSTOM_DOC("Queries the user for a new name and renames the file of the current buffer, altering the buffer's name too.")
{
    View_ID view = get_active_view(app, Access_Always);
    Buffer_ID buffer = view_get_buffer(app, view, Access_Always);

    Scratch_Block scratch(app);

    String_Const_u8 file_name = push_buffer_file_name(app, scratch, buffer);
    if (file_name.size > 0){

        Query_Bar_Group group(app);
        String_Const_u8 front = string_front_of_path(file_name);
        u8 name_space[4096];
        Query_Bar bar = {};
        bar.prompt = push_u8_stringf(scratch, "Rename '%.*s' to: ", (i32)(front).size, (char*)(front).str);
        bar.string = SCu8(name_space, (u64)0);
        bar.string_capacity = sizeof(name_space);
        if (query_user_string(app, &bar) && bar.string.size != 0){

            List_String_Const_u8 new_file_name_list = {};
            string_list_push(scratch, &new_file_name_list, string_remove_front_of_path(file_name));
            string_list_push(scratch, &new_file_name_list, bar.string);
            String_Const_u8 new_file_name = string_list_flatten(scratch, new_file_name_list, StringFill_NullTerminate);
            if (buffer_save(app, buffer, new_file_name, BufferSave_IgnoreDirtyFlag)){
                Buffer_ID new_buffer = create_buffer(app, new_file_name, BufferCreate_NeverNew|BufferCreate_JustChangedFile);
                if (new_buffer != 0 && new_buffer != buffer){
                    delete_file_base(app, file_name, buffer);
                    view_set_buffer(app, view, new_buffer, 0);
                }
            }
        }
    }
}

CUSTOM_COMMAND(make_directory_query, "/home/sam/.bin/4coder/custom/4coder_base_commands.cpp", 1493, Normal)
CUSTOM_DOC("Queries the user for a name and creates a new directory with the given name.")
{
    Scratch_Block scratch(app);

    String_Const_u8 hot = push_hot_directory(app, scratch);


    Query_Bar_Group group(app);
    u8 name_space[4096];
    Query_Bar bar = {};
    bar.prompt = push_u8_stringf(scratch, "Make directory at '%.*s': ", (i32)(hot).size, (char*)(hot).str);
    bar.string = SCu8(name_space, (u64)0);
    bar.string_capacity = sizeof(name_space);

    if (!query_user_string(app, &bar)) return;
    if (bar.string.size == 0) return;

    String_Const_u8 cmd = push_u8_stringf(scratch, "mkdir %.*s", (i32)(bar.string).size, (char*)(bar.string).str);
    exec_system_command(app, 0, buffer_identifier(0), hot, cmd, 0);
}



static void
current_view_move_line(Application_Links *app, Scan_Direction direction){
    View_ID view = get_active_view(app, Access_ReadWriteVisible);
    Buffer_ID buffer = view_get_buffer(app, view, Access_ReadWriteVisible);
    i64 pos = view_get_cursor_pos(app, view);
    i64 line_number = get_line_number_from_pos(app, buffer, pos);
    pos = move_line(app, buffer, line_number, direction);
    view_set_cursor_and_preferred_x(app, view, seek_pos(pos));
}

CUSTOM_COMMAND(move_line_up, "/home/sam/.bin/4coder/custom/4coder_base_commands.cpp", 1527, Normal)
CUSTOM_DOC("Swaps the line under the cursor with the line above it, and moves the cursor up with it.")
{
    current_view_move_line(app, Scan_Backward);
}

CUSTOM_COMMAND(move_line_down, "/home/sam/.bin/4coder/custom/4coder_base_commands.cpp", 1533, Normal)
CUSTOM_DOC("Swaps the line under the cursor with the line below it, and moves the cursor down with it.")
{
    current_view_move_line(app, Scan_Forward);
}

CUSTOM_COMMAND(duplicate_line, "/home/sam/.bin/4coder/custom/4coder_base_commands.cpp", 1539, Normal)
CUSTOM_DOC("Create a copy of the line on which the cursor sits.")
{
    View_ID view = get_active_view(app, Access_ReadWriteVisible);
    Buffer_ID buffer = view_get_buffer(app, view, Access_ReadWriteVisible);
    i64 pos = view_get_cursor_pos(app, view);
    i64 line = get_line_number_from_pos(app, buffer, pos);
    Scratch_Block scratch(app);
    String_Const_u8 s = push_buffer_line(app, scratch, buffer, line);
    s = push_u8_stringf(scratch, "%.*s\n", (i32)(s).size, (char*)(s).str);
    pos = get_line_side_pos(app, buffer, line, Side_Min);
    buffer_replace_range(app, buffer, Ii64(pos), s);
}

CUSTOM_COMMAND(delete_line, "/home/sam/.bin/4coder/custom/4coder_base_commands.cpp", 1553, Normal)
CUSTOM_DOC("Delete the line the on which the cursor sits.")
{
    View_ID view = get_active_view(app, Access_ReadWriteVisible);
    Buffer_ID buffer = view_get_buffer(app, view, Access_ReadWriteVisible);
    i64 pos = view_get_cursor_pos(app, view);
    i64 line = get_line_number_from_pos(app, buffer, pos);
    Range_i64 range = get_line_pos_range(app, buffer, line);
    range.end += 1;
    i32 size = (i32)buffer_get_size(app, buffer);
    range.end = (((range.end)<(size))?(range.end):(size));
    if (range_size(range) == 0 ||
        buffer_get_char(app, buffer, range.end - 1) != '\n'){
        range.start -= 1;
        range.first = (((0)>(range.first))?(0):(range.first));
    }
    buffer_replace_range(app, buffer, range, SCu8((u8*)(""), (u64)(sizeof("") - 1)));
}



static b32
get_cpp_matching_file(Application_Links *app, Buffer_ID buffer, Buffer_ID *buffer_out){
    b32 result = false;
    Scratch_Block scratch(app);
    String_Const_u8 file_name = push_buffer_file_name(app, scratch, buffer);
    if (file_name.size > 0){
        String_Const_u8 extension = string_file_extension(file_name);
        String_Const_u8 new_extensions[2] = {};
        i32 new_extensions_count = 0;
        if (string_match(extension, SCu8((u8*)("cpp"), (u64)(sizeof("cpp") - 1))) || string_match(extension, SCu8((u8*)("cc"), (u64)(sizeof("cc") - 1)))){
            new_extensions[0] = SCu8((u8*)("h"), (u64)(sizeof("h") - 1));
            new_extensions[1] = SCu8((u8*)("hpp"), (u64)(sizeof("hpp") - 1));
            new_extensions_count = 2;
        }
        else if (string_match(extension, SCu8((u8*)("c"), (u64)(sizeof("c") - 1)))){
            new_extensions[0] = SCu8((u8*)("h"), (u64)(sizeof("h") - 1));
            new_extensions_count = 1;
        }
        else if (string_match(extension, SCu8((u8*)("h"), (u64)(sizeof("h") - 1)))){
            new_extensions[0] = SCu8((u8*)("c"), (u64)(sizeof("c") - 1));
            new_extensions[1] = SCu8((u8*)("cpp"), (u64)(sizeof("cpp") - 1));
            new_extensions_count = 2;
        }
        else if (string_match(extension, SCu8((u8*)("hpp"), (u64)(sizeof("hpp") - 1)))){
            new_extensions[0] = SCu8((u8*)("cpp"), (u64)(sizeof("cpp") - 1));
            new_extensions_count = 1;
        }

        String_Const_u8 file_without_extension = string_file_without_extension(file_name);
        for (i32 i = 0; i < new_extensions_count; i += 1){
            Temp_Memory temp = begin_temp(scratch);
            String_Const_u8 new_extension = new_extensions[i];
            String_Const_u8 new_file_name = push_u8_stringf(scratch, "%.*s.%.*s", (i32)(file_without_extension).size, (char*)(file_without_extension).str, (i32)(new_extension).size, (char*)(new_extension).str);
            if (open_file(app, buffer_out, new_file_name, false, true)){
                result = true;
                break;
            }
            end_temp(temp);
        }
    }

    return(result);
}

CUSTOM_COMMAND(open_file_in_quotes, "/home/sam/.bin/4coder/custom/4coder_base_commands.cpp", 1618, Normal)
CUSTOM_DOC("Reads a filename from surrounding '\"' characters and attempts to open the corresponding file.")
{
    View_ID view = get_active_view(app, Access_ReadVisible);
    Buffer_ID buffer = view_get_buffer(app, view, Access_ReadVisible);
    if (buffer_exists(app, buffer)){
        Scratch_Block scratch(app);

        i64 pos = view_get_cursor_pos(app, view);

        Range_i64 range = enclose_pos_inside_quotes(app, buffer, pos);

        String_Const_u8 quoted_name = push_buffer_range(app, scratch, buffer, range);

        String_Const_u8 file_name = push_buffer_file_name(app, scratch, buffer);
        String_Const_u8 path = string_remove_last_folder(file_name);

        if (character_is_slash(string_get_character(path, path.size - 1))){
            path = string_chop(path, 1);
        }

        String_Const_u8 new_file_name = push_u8_stringf(scratch, "%.*s/%.*s", (i32)(path).size, (char*)(path).str, (i32)(quoted_name).size, (char*)(quoted_name).str);

        view = get_next_view_looped_primary_panels(app, view, Access_Always);
        if (view != 0){
            if (view_open_file(app, view, new_file_name, true)){
                view_set_active(app, view);
            }
        }
    }
}

CUSTOM_COMMAND(open_matching_file_cpp, "/home/sam/.bin/4coder/custom/4coder_base_commands.cpp", 1650, Normal)
CUSTOM_DOC("If the current file is a *.cpp or *.h, attempts to open the corresponding *.h or *.cpp file in the other view.")
{
    View_ID view = get_active_view(app, Access_Always);
    Buffer_ID buffer = view_get_buffer(app, view, Access_Always);
    Buffer_ID new_buffer = 0;
    if (get_cpp_matching_file(app, buffer, &new_buffer)){
        view = get_next_view_looped_primary_panels(app, view, Access_Always);
        view_set_buffer(app, view, new_buffer, 0);
        view_set_active(app, view);
    }
}

CUSTOM_COMMAND(view_buffer_other_panel, "/home/sam/.bin/4coder/custom/4coder_base_commands.cpp", 1663, Normal)
CUSTOM_DOC("Set the other non-active panel to view the buffer that the active panel views, and switch to that panel.")
{
    View_ID view = get_active_view(app, Access_Always);
    Buffer_ID buffer = view_get_buffer(app, view, Access_Always);
    i64 pos = view_get_cursor_pos(app, view);
    change_active_panel(app);
    view = get_active_view(app, Access_Always);
    view_set_buffer(app, view, buffer, 0);
    view_set_cursor_and_preferred_x(app, view, seek_pos(pos));
}

CUSTOM_COMMAND(swap_panels, "/home/sam/.bin/4coder/custom/4coder_base_commands.cpp", 1675, Normal)
CUSTOM_DOC("Swaps the active panel with it's sibling.")
{
    View_ID view = get_active_view(app, Access_Always);
    Panel_ID panel = view_get_panel(app, view);
    Panel_ID parent = panel_get_parent(app, panel);
    for (;parent != 0;){
        Panel_ID child_1 = panel_get_child(app, parent, Side_Min);
        Panel_ID child_2 = panel_get_child(app, parent, Side_Max);

        View_ID view_1 = panel_get_view(app, child_1, Access_Always);
        View_ID view_2 = panel_get_view(app, child_2, Access_Always);

        if (!view_get_is_passive(app, view_1) && !view_get_is_passive(app, view_2)){
            panel_swap_children(app, parent);
            break;
        }

        parent = panel_get_parent(app, parent);
    }
}

CUSTOM_COMMAND(quick_swap_buffer, "/home/sam/.bin/4coder/custom/4coder_base_commands.cpp", 1697, Normal)
CUSTOM_DOC("Change to the most recently used buffer in this view - or to the top of the buffer stack if the most recent doesn't exist anymore")
{
    View_ID view = get_active_view(app, Access_Visible);
    Managed_Scope scope = view_get_managed_scope(app, view);
    Buffer_ID *prev_buffer = ((Buffer_ID*)managed_scope_get_attachment((app), (scope), (view_previous_buffer), sizeof(Buffer_ID)));
    b32 fallback = true;
    if (prev_buffer != 0 && *prev_buffer != 0){
        if (view_set_buffer(app, view, *prev_buffer, 0)){
            fallback = false;
        }
    }
    if (fallback){
        Buffer_ID top_buffer = get_buffer_next(app, 0, Access_Always);
        view_set_buffer(app, view, top_buffer, 0);
    }
}



CUSTOM_COMMAND(kill_buffer, "/home/sam/.bin/4coder/custom/4coder_base_commands.cpp", 1717, Normal)
CUSTOM_DOC("Kills the current buffer.")
{
    View_ID view = get_active_view(app, Access_ReadVisible);
    Buffer_ID buffer = view_get_buffer(app, view, Access_ReadVisible);
    try_buffer_kill(app, buffer, view, 0);
}

CUSTOM_COMMAND(save, "/home/sam/.bin/4coder/custom/4coder_base_commands.cpp", 1725, Normal)
CUSTOM_DOC("Saves the current buffer.")
{
    View_ID view = get_active_view(app, Access_ReadVisible);
    Buffer_ID buffer = view_get_buffer(app, view, Access_ReadVisible);
    Scratch_Block scratch(app);
    String_Const_u8 file_name = push_buffer_file_name(app, scratch, buffer);
    buffer_save(app, buffer, file_name, 0);
}

CUSTOM_COMMAND(reopen, "/home/sam/.bin/4coder/custom/4coder_base_commands.cpp", 1735, Normal)
CUSTOM_DOC("Reopen the current buffer from the hard drive.")
{
    View_ID view = get_active_view(app, Access_ReadVisible);
    Buffer_ID buffer = view_get_buffer(app, view, Access_ReadVisible);
    buffer_reopen(app, buffer, 0);
}



static i64
record_get_new_cursor_position_undo(Application_Links *app, Buffer_ID buffer_id, History_Record_Index index, Record_Info record){
    i64 new_edit_position = record.pos_before_edit;
# 1762 "/home/sam/.bin/4coder/custom/4coder_base_commands.cpp"
    return(new_edit_position);
}

static i64
record_get_new_cursor_position_undo(Application_Links *app, Buffer_ID buffer_id, History_Record_Index index){
    Record_Info record = buffer_history_get_record_info(app, buffer_id, index);
    return(record_get_new_cursor_position_undo(app, buffer_id, index, record));
}

static i64
record_get_new_cursor_position_redo(Application_Links *app, Buffer_ID buffer_id, History_Record_Index index, Record_Info record){
    i64 new_edit_position = 0;
    switch (record.kind){
        default:
        case RecordKind_Single:
        {
            new_edit_position = record.single_first + record.single_string_forward.size;
        }break;
        case RecordKind_Group:
        {
            Record_Info sub_record = buffer_history_get_group_sub_record(app, buffer_id, index, record.group_count - 1);
            new_edit_position = sub_record.single_first + sub_record.single_string_forward.size;
        }break;
    }
    return((i32)(new_edit_position));
}

static i64
record_get_new_cursor_position_redo(Application_Links *app, Buffer_ID buffer_id, History_Record_Index index){
    Record_Info record = buffer_history_get_record_info(app, buffer_id, index);
    return(record_get_new_cursor_position_redo(app, buffer_id, index, record));
}

static void
undo__fade_finish(Application_Links *app, Fade_Range *range){
    Buffer_ID buffer = range->buffer_id;
    History_Record_Index current = buffer_history_get_current_state_index(app, buffer);
    if (current > 0){
        buffer_history_set_current_state_index(app, buffer, current - 1);
    }
}

static void
undo__flush_fades(Application_Links *app, Buffer_ID buffer){
    Fade_Range **prev_next = &buffer_fade_ranges.first;
    for (Fade_Range *node = buffer_fade_ranges.first, *next = 0;
         node != 0;
         node = next){
        next = node->next;
        if (node->buffer_id == buffer &&
            node->finish_call == undo__fade_finish){
            undo__fade_finish(app, node);
            *prev_next = next;
            free_fade_range(node);
            buffer_fade_ranges.count -= 1;
        }
        else{
            prev_next = &node->next;
            buffer_fade_ranges.last = node;
        }
    }
}

CUSTOM_COMMAND(undo, "/home/sam/.bin/4coder/custom/4coder_base_commands.cpp", 1825, Normal)
CUSTOM_DOC("Advances backwards through the undo history of the current buffer.")
{
    View_ID view = get_active_view(app, Access_ReadWriteVisible);
    Buffer_ID buffer = view_get_buffer(app, view, Access_ReadWriteVisible);
    undo__flush_fades(app, buffer);

    History_Record_Index current = buffer_history_get_current_state_index(app, buffer);
    if (current > 0){
        Record_Info record = buffer_history_get_record_info(app, buffer, current);
        i64 new_position = record_get_new_cursor_position_undo(app, buffer, current, record);

        b32 do_immedite_undo = true;
        f32 undo_fade_time = 0.33f;
        if (global_config.enable_undo_fade_out &&
            undo_fade_time > 0.f &&
            record.kind == RecordKind_Single &&
            record.single_string_backward.size == 0){
            b32 has_hard_character = false;
            for (u64 i = 0; i < record.single_string_forward.size; i += 1){
                if (!character_is_whitespace(record.single_string_forward.str[i])){
                    has_hard_character = true;
                    break;
                }
            }
            if (has_hard_character){
                Range_i64 range = Ii64_size(record.single_first, record.single_string_forward.size);
                ARGB_Color color = fcolor_resolve(fcolor_id(defcolor_undo)) & 0xFFFFFF;
                Fade_Range *fade = buffer_post_fade(app, buffer, undo_fade_time, range, color);
                fade->negate_fade_direction = true;
                fade->finish_call = undo__fade_finish;
                do_immedite_undo = false;
                if (new_position > range.max){
                    new_position -= range_size(range);
                }
            }
        }

        if (do_immedite_undo){
            buffer_history_set_current_state_index(app, buffer, current - 1);
            if (record.single_string_backward.size > 0){
                Range_i64 range = Ii64_size(record.single_first, record.single_string_backward.size);
                ARGB_Color color = fcolor_resolve(fcolor_id(defcolor_undo));
                buffer_post_fade(app, buffer, undo_fade_time, range, color);
            }
        }

        view_set_cursor_and_preferred_x(app, view, seek_pos(new_position));
    }
}

CUSTOM_COMMAND(redo, "/home/sam/.bin/4coder/custom/4coder_base_commands.cpp", 1876, Normal)
CUSTOM_DOC("Advances forwards through the undo history of the current buffer.")
{
    View_ID view = get_active_view(app, Access_ReadWriteVisible);
    Buffer_ID buffer = view_get_buffer(app, view, Access_ReadWriteVisible);
    undo__flush_fades(app, buffer);

    History_Record_Index current = buffer_history_get_current_state_index(app, buffer);
    History_Record_Index max_index = buffer_history_get_max_record_index(app, buffer);
    if (current < max_index){
        Record_Info record = buffer_history_get_record_info(app, buffer, current);
        i64 new_position = record_get_new_cursor_position_redo(app, buffer, current + 1, record);

        buffer_history_set_current_state_index(app, buffer, current + 1);

        if (record.single_string_forward.size > 0){
            Range_i64 range = Ii64_size(record.single_first, record.single_string_forward.size);
            ARGB_Color color = fcolor_resolve(fcolor_id(defcolor_undo));
            f32 undo_fade_time = 0.33f;
            buffer_post_fade(app, buffer, undo_fade_time, range, color);
        }

        view_set_cursor_and_preferred_x(app, view, seek_pos(new_position));
    }
}

CUSTOM_COMMAND(undo_all_buffers, "/home/sam/.bin/4coder/custom/4coder_base_commands.cpp", 1902, Normal)
CUSTOM_DOC("Advances backward through the undo history in the buffer containing the most recent regular edit.")
{
    Scratch_Block scratch(app);
    i32 highest_edit_number = -1;
    Buffer_ID first_buffer_match = 0;
    Buffer_ID last_buffer_match = 0;
    i32 match_count = 0;

    {
        for (Buffer_ID buffer = get_buffer_next(app, 0, Access_Always);
             buffer != 0;
             buffer = get_buffer_next(app, buffer, Access_Always)){
            History_Record_Index index = buffer_history_get_current_state_index(app, buffer);
            if (index > 0){
                Record_Info record = buffer_history_get_record_info(app, buffer, index);
                if (record.edit_number > highest_edit_number){
                    highest_edit_number = record.edit_number;
                    first_buffer_match = buffer;
                    last_buffer_match = buffer;
                    match_count = 1;
                }
                else if (record.edit_number == highest_edit_number){
                    last_buffer_match = buffer;
                    match_count += 1;
                }
            }
        }
    }

    Buffer_ID *match_buffers = ((Buffer_ID*)linalloc_wrap_unintialized(linalloc_push((scratch), sizeof(Buffer_ID)*(match_count), SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_base_commands.cpp" ":" "1932" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_base_commands.cpp" ":" "1932" ":") - 1)))));
    i64 *new_positions = ((i64*)linalloc_wrap_unintialized(linalloc_push((scratch), sizeof(i64)*(match_count), SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_base_commands.cpp" ":" "1933" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_base_commands.cpp" ":" "1933" ":") - 1)))));
    match_count = 0;

    if (highest_edit_number != -1){
        for (Buffer_ID buffer = first_buffer_match;
             buffer != 0;
             buffer = get_buffer_next(app, buffer, Access_Always)){
            b32 did_match = false;
            i64 new_edit_position = 0;
            for (;;){
                History_Record_Index index = buffer_history_get_current_state_index(app, buffer);
                if (index > 0){
                    Record_Info record = buffer_history_get_record_info(app, buffer, index);
                    if (record.edit_number == highest_edit_number){
                        did_match = true;
                        new_edit_position = record_get_new_cursor_position_undo(app, buffer, index, record);
                        buffer_history_set_current_state_index(app, buffer, index - 1);
                    }
                    else{
                        break;
                    }
                }
                else{
                    break;
                }
            }
            if (did_match){
                match_buffers[match_count] = buffer;
                new_positions[match_count] = new_edit_position;
                match_count += 1;
            }
            if (buffer == last_buffer_match){
                break;
            }
        }
    }

    view_buffer_set(app, match_buffers, new_positions, match_count);
}

CUSTOM_COMMAND(redo_all_buffers, "/home/sam/.bin/4coder/custom/4coder_base_commands.cpp", 1973, Normal)
CUSTOM_DOC("Advances forward through the undo history in the buffer containing the most recent regular edit.")
{
    Scratch_Block scratch(app);

    i32 lowest_edit_number = 0x7FFFFFFF;
    Buffer_ID first_buffer_match = 0;
    Buffer_ID last_buffer_match = 0;
    i32 match_count = 0;

    {
        for (Buffer_ID buffer = get_buffer_next(app, 0, Access_Always);
             buffer != 0;
             buffer = get_buffer_next(app, buffer, Access_Always)){
            History_Record_Index max_index = buffer_history_get_max_record_index(app, buffer);
            History_Record_Index index = buffer_history_get_current_state_index(app, buffer);
            if (index < max_index){
                Record_Info record = buffer_history_get_record_info(app, buffer, index + 1);
                if (record.edit_number < lowest_edit_number){
                    lowest_edit_number = record.edit_number;
                    first_buffer_match = buffer;
                    last_buffer_match = buffer;
                    match_count = 1;
                }
                else if (record.edit_number == lowest_edit_number){
                    last_buffer_match = buffer;
                    match_count += 1;
                }
            }
        }
    }

    Buffer_ID *match_buffers = ((Buffer_ID*)linalloc_wrap_unintialized(linalloc_push((scratch), sizeof(Buffer_ID)*(match_count), SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_base_commands.cpp" ":" "2005" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_base_commands.cpp" ":" "2005" ":") - 1)))));
    i64 *new_positions = ((i64*)linalloc_wrap_unintialized(linalloc_push((scratch), sizeof(i64)*(match_count), SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_base_commands.cpp" ":" "2006" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_base_commands.cpp" ":" "2006" ":") - 1)))));
    match_count = 0;

    if (lowest_edit_number != -1){
        for (Buffer_ID buffer = first_buffer_match;
             buffer != 0;
             buffer = get_buffer_next(app, buffer, Access_Always)){
            b32 did_match = false;
            i64 new_edit_position = 0;
            History_Record_Index max_index = buffer_history_get_max_record_index(app, buffer);
            for (;;){
                History_Record_Index index = buffer_history_get_current_state_index(app, buffer);
                if (index < max_index){
                    Record_Info record = buffer_history_get_record_info(app, buffer, index + 1);
                    if (record.edit_number == lowest_edit_number){
                        did_match = true;
                        new_edit_position = record_get_new_cursor_position_redo(app, buffer, index + 1, record);
                        buffer_history_set_current_state_index(app, buffer, index + 1);
                    }
                    else{
                        break;
                    }
                }
                else{
                    break;
                }
            }
            if (did_match){
                match_buffers[match_count] = buffer;
                new_positions[match_count] = new_edit_position;
                match_count += 1;
            }
            if (buffer == last_buffer_match){
                break;
            }
        }
    }

    view_buffer_set(app, match_buffers, new_positions, match_count);
}



CUSTOM_COMMAND(open_in_other, "/home/sam/.bin/4coder/custom/4coder_base_commands.cpp", 2049, Normal)
CUSTOM_DOC("Interactively opens a file in the other panel.")
{
    change_active_panel_send_command(app, interactive_open_or_new);
}

CUSTOM_COMMAND(default_file_externally_modified, "/home/sam/.bin/4coder/custom/4coder_base_commands.cpp", 2055, Normal)
CUSTOM_DOC("Notes the external modification of attached files by printing a message.")
{
    User_Input input = get_current_input(app);
    if (match_core_code(&input, CoreCode_FileExternallyModified)){
        Scratch_Block scratch(app);
        Buffer_ID buffer_id = input.event.core.id;
        String_Const_u8 name = push_buffer_unique_name(app, scratch, buffer_id);
        String_Const_u8 str = push_u8_stringf(scratch, "Modified externally: %s\n", name.str);
        print_message(app, str);
    }
}
# 106 "/home/sam/.bin/4coder/custom/4coder_default_include.cpp" 2
# 1 "/home/sam/.bin/4coder/custom/4coder_insertion.cpp" 1






static Buffer_Insertion
begin_buffer_insertion_at(Application_Links *app, Buffer_ID buffer_id, i64 at){
    Buffer_Insertion result = {};
    result.app = app;
    result.buffer = buffer_id;
    result.at = at;
    return(result);
}

static Buffer_Insertion
begin_buffer_insertion_at_buffered(Application_Links *app, Buffer_ID buffer_id, i64 at, Cursor *cursor){
    Buffer_Insertion result = begin_buffer_insertion_at(app, buffer_id, at);
    result.buffering = true;
    result.cursor = cursor;
    result.temp = begin_temp(cursor);
    return(result);
}

static Buffer_Insertion
begin_buffer_insertion_at_buffered(Application_Links *app, Buffer_ID buffer_id, i64 at, Arena *buffer_memory, u64 buffer_memory_size){
    Cursor *cursor = ((Cursor*)linalloc_wrap_unintialized(linalloc_push((buffer_memory), sizeof(Cursor)*(1), SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_insertion.cpp" ":" "27" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_insertion.cpp" ":" "27" ":") - 1)))));
    *cursor = make_cursor(((u8*)linalloc_wrap_unintialized(linalloc_push((buffer_memory), sizeof(u8)*(buffer_memory_size), SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_insertion.cpp" ":" "28" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_insertion.cpp" ":" "28" ":") - 1))))), buffer_memory_size);
    return(begin_buffer_insertion_at_buffered(app, buffer_id, at, cursor));
}

static Buffer_Insertion
begin_buffer_insertion(Application_Links *app){
    View_ID view = get_active_view(app, Access_Always);
    Buffer_ID buffer = view_get_buffer(app, view, Access_Always);
    i64 cursor_pos = view_get_cursor_pos(app, view);
    Buffer_Insertion result = begin_buffer_insertion_at(app, buffer, cursor_pos);
    return(result);
}

static void
insert_string__no_buffering(Buffer_Insertion *insertion, String_Const_u8 string){
    buffer_replace_range(insertion->app, insertion->buffer, Ii64(insertion->at), string);
    insertion->at += string.size;
}

static void
insert__flush(Buffer_Insertion *insertion){
    Cursor *cursor = insertion->cursor;
    u64 pos = insertion->temp.temp_memory_cursor.pos;
    String_Const_u8 string = SCu8(cursor->base + pos, cursor->pos - pos);
    insert_string__no_buffering(insertion, string);
    end_temp(insertion->temp);
}

static char*
insert__reserve(Buffer_Insertion *insertion, u64 size){
    char *space = ((char*)linalloc_wrap_unintialized(linalloc_push((insertion->cursor), sizeof(char)*(size), SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_insertion.cpp" ":" "58" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_insertion.cpp" ":" "58" ":") - 1)))));
    if (space == 0){
        insert__flush(insertion);
        space = ((char*)linalloc_wrap_unintialized(linalloc_push((insertion->cursor), sizeof(char)*(size), SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_insertion.cpp" ":" "61" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_insertion.cpp" ":" "61" ":") - 1)))));
    }
    return(space);
}

static void
end_buffer_insertion(Buffer_Insertion *insertion){
    if (insertion->buffering){
        insert__flush(insertion);
    }
}

static void
insert_string(Buffer_Insertion *insertion, String_Const_u8 string){
    if (!insertion->buffering){
        insert_string__no_buffering(insertion, string);
    }
    else{
        char *space = insert__reserve(insertion, string.size);
        if (space != 0){
            block_copy(space, string.str, string.size);
        }
        else{
            insert_string__no_buffering(insertion, string);
        }
    }
}

static u64
insertf(Buffer_Insertion *insertion, char *format, ...){
    Scratch_Block scratch(insertion->app);
    va_list args;
    
# 93 "/home/sam/.bin/4coder/custom/4coder_insertion.cpp" 3 4
   __builtin_va_start(
# 93 "/home/sam/.bin/4coder/custom/4coder_insertion.cpp"
   args
# 93 "/home/sam/.bin/4coder/custom/4coder_insertion.cpp" 3 4
   ,
# 93 "/home/sam/.bin/4coder/custom/4coder_insertion.cpp"
   format
# 93 "/home/sam/.bin/4coder/custom/4coder_insertion.cpp" 3 4
   )
# 93 "/home/sam/.bin/4coder/custom/4coder_insertion.cpp"
                         ;
    String_Const_u8 string = push_u8_stringfv(scratch, format, args);
    
# 95 "/home/sam/.bin/4coder/custom/4coder_insertion.cpp" 3 4
   __builtin_va_end(
# 95 "/home/sam/.bin/4coder/custom/4coder_insertion.cpp"
   args
# 95 "/home/sam/.bin/4coder/custom/4coder_insertion.cpp" 3 4
   )
# 95 "/home/sam/.bin/4coder/custom/4coder_insertion.cpp"
               ;
    insert_string(insertion, string);
    return(string.size);
}

static void
insertc(Buffer_Insertion *insertion, char C){
    insert_string(insertion, SCu8(&C, 1));
}

static b32
insert_line_from_buffer(Buffer_Insertion *insertion, Buffer_ID buffer_id, i32 line, i32 truncate_at){
    b32 success = is_valid_line(insertion->app, buffer_id, line);
    if (success){
        Scratch_Block scratch(insertion->app);
        insert_string(insertion, push_buffer_line(insertion->app, scratch, buffer_id, line));
    }
    return(success);
}

static b32
insert_line_from_buffer(Buffer_Insertion *insertion, Buffer_ID buffer_id, i32 line){
    return(insert_line_from_buffer(insertion, buffer_id, line, 0));
}
# 107 "/home/sam/.bin/4coder/custom/4coder_default_include.cpp" 2
# 1 "/home/sam/.bin/4coder/custom/4coder_eol.cpp" 1







static void
rewrite_lines_to_crlf(Application_Links *app, Buffer_ID buffer){
    Profile_Scope_Block profile_block_10 ((app), SCu8((u8*)("rewrite lines to crlf"), (u64)(sizeof("rewrite lines to crlf") - 1)), SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_eol.cpp" ":" "10" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_eol.cpp" ":" "10" ":") - 1)));
    Scratch_Block scratch(app);
    i64 size = buffer_get_size(app, buffer);

    Batch_Edit *first = 0;
    Batch_Edit *last = 0;

    Profile_Block profile_batch ((app), SCu8((u8*)("build batch edit"), (u64)(sizeof("build batch edit") - 1)), SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_eol.cpp" ":" "17" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_eol.cpp" ":" "17" ":") - 1)));
    i64 pos = -1;
    Character_Predicate pred_cr = character_predicate_from_character('\r');
    Character_Predicate pred_lf = character_predicate_from_character('\n');
    Character_Predicate pred = character_predicate_or(&pred_cr, &pred_lf);
    for (;;){
        String_Match match = buffer_seek_character_class(app, buffer, &pred,
                                                         Scan_Forward, pos);
        if (match.range.min == match.range.max){
            break;
        }
        pos = match.range.min;

        u8 c1 = buffer_get_char(app, buffer, pos);
        u8 c2 = buffer_get_char(app, buffer, pos + 1);
        if (c1 == '\r'){
            if (pos + 1 == size || c2 != '\n'){
                Batch_Edit *edit = ((Batch_Edit*)linalloc_wrap_unintialized(linalloc_push((scratch), sizeof(Batch_Edit)*(1), SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_eol.cpp" ":" "34" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_eol.cpp" ":" "34" ":") - 1)))));
                do{ if((edit)){if((first)){(last)->next=(edit);}else{(first)=(edit);}(last)=(edit);(last)->next=0;} }while(0);
                edit->edit.text = SCu8((u8*)(""), (u64)(sizeof("") - 1));
                edit->edit.range = match.range;
            }
            else{
                pos += 1;
            }
        }
        else{
            Batch_Edit *edit = ((Batch_Edit*)linalloc_wrap_unintialized(linalloc_push((scratch), sizeof(Batch_Edit)*(1), SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_eol.cpp" ":" "44" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_eol.cpp" ":" "44" ":") - 1)))));
            do{ if((edit)){if((first)){(last)->next=(edit);}else{(first)=(edit);}(last)=(edit);(last)->next=0;} }while(0);
            edit->edit.text = SCu8((u8*)("\r"), (u64)(sizeof("\r") - 1));
            edit->edit.range = Ii64(pos);
        }
    }
    ((profile_batch).close_now());

    buffer_batch_edit(app, buffer, first);
}

static void
rewrite_lines_to_lf(Application_Links *app, Buffer_ID buffer){
    Profile_Scope_Block profile_block_57 ((app), SCu8((u8*)("rewrite lines to lf"), (u64)(sizeof("rewrite lines to lf") - 1)), SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_eol.cpp" ":" "57" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_eol.cpp" ":" "57" ":") - 1)));
    Scratch_Block scratch(app);

    Batch_Edit *first = 0;
    Batch_Edit *last = 0;

    Profile_Block profile_batch ((app), SCu8((u8*)("build batch edit"), (u64)(sizeof("build batch edit") - 1)), SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_eol.cpp" ":" "63" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_eol.cpp" ":" "63" ":") - 1)));
    i64 pos = -1;
    Character_Predicate pred = character_predicate_from_character('\r');
    for (;;){
        String_Match match = buffer_seek_character_class(app, buffer, &pred,
                                                         Scan_Forward, pos);
        if (match.range.min == match.range.max){
            break;
        }
        pos = match.range.min;

        Batch_Edit *edit = ((Batch_Edit*)linalloc_wrap_unintialized(linalloc_push((scratch), sizeof(Batch_Edit)*(1), SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_eol.cpp" ":" "74" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_eol.cpp" ":" "74" ":") - 1)))));
        do{ if((edit)){if((first)){(last)->next=(edit);}else{(first)=(edit);}(last)=(edit);(last)->next=0;} }while(0);
        edit->edit.text = SCu8((u8*)(""), (u64)(sizeof("") - 1));
        edit->edit.range = match.range;
    }
    ((profile_batch).close_now());

 buffer_batch_edit(app, buffer, first);
}



CUSTOM_COMMAND(set_eol_mode_to_crlf, "/home/sam/.bin/4coder/custom/4coder_eol.cpp", 86, Normal)
CUSTOM_DOC("Puts the buffer in crlf line ending mode.")
{
    View_ID view = get_active_view(app, Access_ReadWriteVisible);
    Buffer_ID buffer = view_get_buffer(app, view, Access_ReadWriteVisible);
    Managed_Scope scope = buffer_get_managed_scope(app, buffer);
    Line_Ending_Kind *eol_setting = ((Line_Ending_Kind*)managed_scope_get_attachment((app), (scope), (buffer_eol_setting), sizeof(Line_Ending_Kind)))
                                                                      ;
    if (eol_setting != 0){
    *eol_setting = LineEndingKind_CRLF;
    }
}

CUSTOM_COMMAND(set_eol_mode_to_lf, "/home/sam/.bin/4coder/custom/4coder_eol.cpp", 99, Normal)
CUSTOM_DOC("Puts the buffer in lf line ending mode.")
{
    View_ID view = get_active_view(app, Access_ReadWriteVisible);
    Buffer_ID buffer = view_get_buffer(app, view, Access_ReadWriteVisible);
    Managed_Scope scope = buffer_get_managed_scope(app, buffer);
    Line_Ending_Kind *eol_setting = ((Line_Ending_Kind*)managed_scope_get_attachment((app), (scope), (buffer_eol_setting), sizeof(Line_Ending_Kind)))
                                                                      ;
    if (eol_setting != 0){
    *eol_setting = LineEndingKind_LF;
    }
}

CUSTOM_COMMAND(set_eol_mode_to_binary, "/home/sam/.bin/4coder/custom/4coder_eol.cpp", 112, Normal)
CUSTOM_DOC("Puts the buffer in bin line ending mode.")
{
    View_ID view = get_active_view(app, Access_ReadWriteVisible);
    Buffer_ID buffer = view_get_buffer(app, view, Access_ReadWriteVisible);
    Managed_Scope scope = buffer_get_managed_scope(app, buffer);
    Line_Ending_Kind *eol_setting = ((Line_Ending_Kind*)managed_scope_get_attachment((app), (scope), (buffer_eol_setting), sizeof(Line_Ending_Kind)))
                                                                      ;
    if (eol_setting != 0){
        *eol_setting = LineEndingKind_Binary;
    }
}

CUSTOM_COMMAND(set_eol_mode_from_contents, "/home/sam/.bin/4coder/custom/4coder_eol.cpp", 125, Normal)
CUSTOM_DOC("Sets the buffer's line ending mode to match the contents of the buffer.")
{
    View_ID view = get_active_view(app, Access_ReadWriteVisible);
    Buffer_ID buffer = view_get_buffer(app, view, Access_ReadWriteVisible);
    Line_Ending_Kind setting = guess_line_ending_kind_from_buffer(app, buffer);
    Managed_Scope scope = buffer_get_managed_scope(app, buffer);
    Line_Ending_Kind *eol_setting = ((Line_Ending_Kind*)managed_scope_get_attachment((app), (scope), (buffer_eol_setting), sizeof(Line_Ending_Kind)))
                                                                      ;
    if (eol_setting != 0){
        *eol_setting = setting;
    }
}
# 108 "/home/sam/.bin/4coder/custom/4coder_default_include.cpp" 2
# 1 "/home/sam/.bin/4coder/custom/4coder_lists.cpp" 1







static void
generate_all_buffers_list__output_buffer(Application_Links *app, Lister *lister,
                                         Buffer_ID buffer){
    Dirty_State dirty = buffer_get_dirty_state(app, buffer);
    String_Const_u8 status = {};
    switch (dirty){
        case DirtyState_UnsavedChanges: status = SCu8((u8*)("*"), (u64)(sizeof("*") - 1)); break;
        case DirtyState_UnloadedChanges: status = SCu8((u8*)("!"), (u64)(sizeof("!") - 1)); break;
        case DirtyState_UnsavedChangesAndUnloadedChanges: status = SCu8((u8*)("*!"), (u64)(sizeof("*!") - 1)); break;
    }
    Scratch_Block scratch(app, lister->arena);
    String_Const_u8 buffer_name = push_buffer_unique_name(app, scratch, buffer);
    lister_add_item(lister, buffer_name, status, (void*)(((u8*)0) + buffer), 0);
}

static void
generate_all_buffers_list(Application_Links *app, Lister *lister){
    lister_begin_new_item_set(app, lister);

    Buffer_ID viewed_buffers[16];
    i32 viewed_buffer_count = 0;


    for (View_ID view = get_view_next(app, 0, Access_Always);
         view != 0;
         view = get_view_next(app, view, Access_Always)){
        Buffer_ID new_buffer_id = view_get_buffer(app, view, Access_Always);
        for (i32 i = 0; i < viewed_buffer_count; i += 1){
            if (new_buffer_id == viewed_buffers[i]){
                goto skip0;
            }
        }
        viewed_buffers[viewed_buffer_count++] = new_buffer_id;
        skip0:;
    }


    for (Buffer_ID buffer = get_buffer_next(app, 0, Access_Always);
         buffer != 0;
         buffer = get_buffer_next(app, buffer, Access_Always)){
        for (i32 i = 0; i < viewed_buffer_count; i += 1){
            if (buffer == viewed_buffers[i]){
                goto skip1;
            }
        }
        if (!buffer_has_name_with_star(app, buffer)){
            generate_all_buffers_list__output_buffer(app, lister, buffer);
        }
        skip1:;
    }


    for (Buffer_ID buffer = get_buffer_next(app, 0, Access_Always);
         buffer != 0;
         buffer = get_buffer_next(app, buffer, Access_Always)){
        for (i32 i = 0; i < viewed_buffer_count; i += 1){
            if (buffer == viewed_buffers[i]){
                goto skip2;
            }
        }
        if (buffer_has_name_with_star(app, buffer)){
            generate_all_buffers_list__output_buffer(app, lister, buffer);
        }
        skip2:;
    }


    for (i32 i = 0; i < viewed_buffer_count; i += 1){
        generate_all_buffers_list__output_buffer(app, lister, viewed_buffers[i]);
    }
}

static Buffer_ID
get_buffer_from_user(Application_Links *app, String_Const_u8 query){
    Lister_Handlers handlers = lister_get_default_handlers();
    handlers.refresh = generate_all_buffers_list;
    Lister_Result l_result = run_lister_with_refresh_handler(app, query, handlers);
    Buffer_ID result = 0;
    if (!l_result.canceled){
        result = (Buffer_ID)(((u8*)(l_result.user_data) - (u8*)(0)));
    }
    return(result);
}

static Buffer_ID
get_buffer_from_user(Application_Links *app, char *query){
    return(get_buffer_from_user(app, SCu8(query)));
}



typedef i32 Command_Lister_Status_Mode;
enum{
    CommandLister_None,
    CommandLister_Descriptions,
    CommandLister_Bindings
};

struct Command_Lister_Status_Rule{
    Command_Lister_Status_Mode mode;
    Mapping *mapping;
    Command_Map_ID map_id;
};

static Command_Lister_Status_Rule
command_lister_status_descriptions(void){
    Command_Lister_Status_Rule result = {};
    result.mode = CommandLister_Descriptions;
    return(result);
}

static Command_Lister_Status_Rule
command_lister_status_bindings(Mapping *mapping, Command_Map_ID map_id){
    Command_Lister_Status_Rule result = {};
    result.mode = CommandLister_Bindings;
    result.mapping = mapping;
    result.map_id = map_id;
    return(result);
}

static Custom_Command_Function*
get_command_from_user(Application_Links *app, String_Const_u8 query, i32 *command_ids, i32 command_id_count, Command_Lister_Status_Rule *status_rule){
    if (command_ids == 0){
        command_id_count = command_one_past_last_id;
    }

    Scratch_Block scratch(app);
    Lister_Block lister(app, scratch);
    lister_set_query(lister, query);
    lister_set_default_handlers(lister);

    for (i32 i = 0; i < command_id_count; i += 1){
        i32 j = i;
        if (command_ids != 0){
            j = command_ids[i];
        }
        j = (((0)>(j))?(0):(((command_one_past_last_id)<(j))?(command_one_past_last_id):(j)));

        Custom_Command_Function *proc = fcoder_metacmd_table[j].proc;
        String_Const_u8 status = {};
        switch (status_rule->mode){
            case CommandLister_Descriptions:
            {
                status = SCu8(fcoder_metacmd_table[j].description);
            }break;
            case CommandLister_Bindings:
            {
                Command_Trigger_List triggers = map_get_triggers_recursive(scratch, status_rule->mapping, status_rule->map_id, proc);

                List_String_Const_u8 list = {};
                for (Command_Trigger *node = triggers.first;
                     node != 0;
                     node = node->next){
                    command_trigger_stringize(scratch, &list, node);
                    if (node->next != 0){
                        string_list_push(scratch, &list, SCu8((u8*)(" "), (u64)(sizeof(" ") - 1)));
                    }
                }

                status = string_list_flatten(scratch, list);
            }break;
        }

        lister_add_item(lister, SCu8(fcoder_metacmd_table[j].name), status,
                        (void*)proc, 0);
    }

    Lister_Result l_result = run_lister(app, lister);

    Custom_Command_Function *result = 0;
    if (!l_result.canceled){
        result = (Custom_Command_Function*)l_result.user_data;
    }
    return(result);
}

static Custom_Command_Function*
get_command_from_user(Application_Links *app, String_Const_u8 query, Command_Lister_Status_Rule *status_rule){
    return(get_command_from_user(app, query, 0, 0, status_rule));
}

static Custom_Command_Function*
get_command_from_user(Application_Links *app, char *query,
                      i32 *command_ids, i32 command_id_count, Command_Lister_Status_Rule *status_rule){
    return(get_command_from_user(app, SCu8(query), command_ids, command_id_count, status_rule));
}

static Custom_Command_Function*
get_command_from_user(Application_Links *app, char *query, Command_Lister_Status_Rule *status_rule){
    return(get_command_from_user(app, SCu8(query), 0, 0, status_rule));
}



static Color_Table*
get_color_table_from_user(Application_Links *app, String_Const_u8 query, Color_Table_List *color_table_list){
    if (color_table_list == 0){
        color_table_list = &global_theme_list;
    }

    Scratch_Block scratch(app);
    Lister_Block lister(app, scratch);
    lister_set_query(lister, query);
    lister_set_default_handlers(lister);

    lister_add_item(lister, SCu8((u8*)("4coder"), (u64)(sizeof("4coder") - 1)), SCu8((u8*)(""), (u64)(sizeof("") - 1)),
                    (void*)&default_color_table, 0);

    for (Color_Table_Node *node = color_table_list->first;
         node != 0;
         node = node->next){
        lister_add_item(lister, node->name, SCu8((u8*)(""), (u64)(sizeof("") - 1)),
                        (void*)&node->table, 0);
    }

    Lister_Result l_result = run_lister(app, lister);

    Color_Table *result = 0;
    if (!l_result.canceled){
        result = (Color_Table*)l_result.user_data;
    }
    return(result);
}

static Color_Table*
get_color_table_from_user(Application_Links *app){
    return(get_color_table_from_user(app, SCu8((u8*)("Theme:"), (u64)(sizeof("Theme:") - 1)), 0));
}



static Lister_Activation_Code
lister__write_character__file_path(Application_Links *app){
    Lister_Activation_Code result = ListerActivation_Continue;
    View_ID view = get_this_ctx_view(app, Access_Always);
    Lister *lister = view_get_lister(app, view);
    if (lister != 0){
        User_Input in = get_current_input(app);
        String_Const_u8 string = to_writable(&in);
        if (string.str != 0 && string.size > 0){
            lister_append_text_field(lister, string);
            if (character_is_slash(string.str[0])){
                lister->out.text_field = lister->text_field.string;
                result = ListerActivation_Finished;
            }
            else{
                String_Const_u8 front_name = string_front_of_path(lister->text_field.string);
                lister_set_key(lister, front_name);
            }
            lister->item_index = 0;
            lister_zero_scroll(lister);
            lister_update_filtered_list(app, lister);
        }
    }
    return(result);
}

static void
lister__backspace_text_field__file_path(Application_Links *app){
    View_ID view = get_this_ctx_view(app, Access_Always);
    Lister *lister = view_get_lister(app, view);
    if (lister != 0){
        if (lister->text_field.size > 0){
            char last_char = lister->text_field.str[lister->text_field.size - 1];
            lister->text_field.string = backspace_utf8(lister->text_field.string);
            if (character_is_slash(last_char)){
                User_Input input = get_current_input(app);
                String_Const_u8 text_field = lister->text_field.string;
                String_Const_u8 new_hot = string_remove_last_folder(text_field);
                b32 is_modified = has_modifier(&input, KeyCode_Control);
                b32 whole_word_backspace = (is_modified == global_config.lister_whole_word_backspace_when_modified);
                if (whole_word_backspace){
                    lister->text_field.size = new_hot.size;
                }
                set_hot_directory(app, new_hot);


                String_u8 dingus = lister->text_field;
                lister_call_refresh_handler(app, lister);
                lister->text_field = dingus;
            }
            else{
                String_Const_u8 text_field = lister->text_field.string;
                String_Const_u8 new_key = string_front_of_path(text_field);
                lister_set_key(lister, new_key);
            }

            lister->item_index = 0;
            lister_zero_scroll(lister);
            lister_update_filtered_list(app, lister);
        }
    }
}

static void
generate_hot_directory_file_list(Application_Links *app, Lister *lister){
    Scratch_Block scratch(app, lister->arena);

    Temp_Memory temp = begin_temp(lister->arena);
    String_Const_u8 hot = push_hot_directory(app, lister->arena);
    if (!character_is_slash(string_get_character(hot, hot.size - 1))){
        hot = push_u8_stringf(lister->arena, "%.*s/", (i32)(hot).size, (char*)(hot).str);
    }
    lister_set_text_field(lister, hot);
    lister_set_key(lister, string_front_of_path(hot));

    File_List file_list = system_get_file_list(scratch, hot);
    end_temp(temp);

    File_Info **one_past_last = file_list.infos + file_list.count;

    lister_begin_new_item_set(app, lister);

    hot = push_hot_directory(app, lister->arena);
    (linalloc_align((lister->arena), (8)));
    if (hot.str != 0){
        String_Const_u8 empty_string = SCu8((u8*)(""), (u64)(sizeof("") - 1));
        Lister_Prealloced_String empty_string_prealloced = lister_prealloced(empty_string);
        for (File_Info **info = file_list.infos;
             info < one_past_last;
             info += 1){
            if (!((((**info).attributes.flags)&(FileAttribute_IsDirectory))!=0)) continue;
            String_Const_u8 file_name = push_u8_stringf(lister->arena, "%.*s/",
                                                        (i32)((**info).file_name).size, (char*)((**info).file_name).str);
            lister_add_item(lister, lister_prealloced(file_name), empty_string_prealloced, file_name.str, 0);
        }

        for (File_Info **info = file_list.infos;
             info < one_past_last;
             info += 1){
            if (((((**info).attributes.flags)&(FileAttribute_IsDirectory))!=0)) continue;
            String_Const_u8 file_name = push_string_copy(lister->arena, (**info).file_name);
            char *is_loaded = "";
            char *status_flag = "";

            Buffer_ID buffer = {};

            {
                Temp_Memory path_temp = begin_temp(lister->arena);
                List_String_Const_u8 list = {};
                string_list_push(lister->arena, &list, hot);
                string_list_push_overlap(lister->arena, &list, '/', (**info).file_name);
                String_Const_u8 full_file_path = string_list_flatten(lister->arena, list);
                buffer = get_buffer_by_file_name(app, full_file_path, Access_Always);
                end_temp(path_temp);
            }

            if (buffer != 0){
                is_loaded = "LOADED";
                Dirty_State dirty = buffer_get_dirty_state(app, buffer);
                switch (dirty){
                    case DirtyState_UnsavedChanges: status_flag = " *"; break;
                    case DirtyState_UnloadedChanges: status_flag = " !"; break;
                    case DirtyState_UnsavedChangesAndUnloadedChanges: status_flag = " *!"; break;
                }
            }
            String_Const_u8 status = push_u8_stringf(lister->arena, "%s%s", is_loaded, status_flag);
            lister_add_item(lister, lister_prealloced(file_name), lister_prealloced(status), file_name.str, 0);
        }
    }
}

struct File_Name_Result{
    b32 canceled;
    b32 clicked;
    b32 is_folder;
    String_Const_u8 file_name_activated;
    String_Const_u8 file_name_in_text_field;
    String_Const_u8 path_in_text_field;
};

static File_Name_Result
get_file_name_from_user(Application_Links *app, Arena *arena, String_Const_u8 query, View_ID view){
    Lister_Handlers handlers = lister_get_default_handlers();
    handlers.refresh = generate_hot_directory_file_list;
    handlers.write_character = lister__write_character__file_path;
    handlers.backspace = lister__backspace_text_field__file_path;

    Lister_Result l_result = run_lister_with_refresh_handler(app, arena, query, handlers);

    File_Name_Result result = {};
    result.canceled = l_result.canceled;
    if (!l_result.canceled){
        result.clicked = l_result.activated_by_click;
        if (l_result.user_data != 0){
            String_Const_u8 name = SCu8((u8*)l_result.user_data);
            result.file_name_activated = name;
            result.is_folder = character_is_slash(string_get_character(name, name.size - 1));
        }
        result.file_name_in_text_field = string_front_of_path(l_result.text_field);

        String_Const_u8 path = {};
        if (l_result.user_data == 0 && result.file_name_in_text_field.size == 0 && l_result.text_field.size > 0){
            result.file_name_in_text_field = string_front_folder_of_path(l_result.text_field);
            path = string_remove_front_folder_of_path(l_result.text_field);
        }
        else{
            path = string_remove_front_of_path(l_result.text_field);
        }
        if (character_is_slash(string_get_character(path, path.size - 1))){
            path = string_chop(path, 1);
        }
        result.path_in_text_field = path;
    }

    return(result);
}

static File_Name_Result
get_file_name_from_user(Application_Links *app, Arena *arena, char *query, View_ID view){
    return(get_file_name_from_user(app, arena, SCu8(query), view));
}



enum{
    SureToKill_NULL = 0,
    SureToKill_No = 1,
    SureToKill_Yes = 2,
    SureToKill_Save = 3,
};

static b32
do_buffer_kill_user_check(Application_Links *app, Buffer_ID buffer, View_ID view){
    Scratch_Block scratch(app);
    Lister_Choice_List list = {};
    lister_choice(scratch, &list, "(N)o" , "", KeyCode_N, SureToKill_No);
    lister_choice(scratch, &list, "(Y)es" , "", KeyCode_Y, SureToKill_Yes);
    lister_choice(scratch, &list, "(S)ave", "", KeyCode_S, SureToKill_Save);

    Lister_Choice *choice = get_choice_from_user(app, "There are unsaved changes, close anyway?", list);

    b32 do_kill = false;
    if (choice != 0){
        switch (choice->user_data){
            case SureToKill_No:
            {}break;

            case SureToKill_Yes:
            {
                do_kill = true;
            }break;

            case SureToKill_Save:
            {
                String_Const_u8 file_name = push_buffer_file_name(app, scratch, buffer);
                if (buffer_save(app, buffer, file_name, BufferSave_IgnoreDirtyFlag)){
                    do_kill = true;
                }
                else{

                    String_Const_u8 str =
                        push_u8_stringf(scratch, "Did not close '%.*s' because it did not successfully save.", (i32)(file_name).size, (char*)(file_name).str);

                    print_message(app, str);
                }
            }break;
        }
    }

    return(do_kill);
}

static b32
do_4coder_close_user_check(Application_Links *app, View_ID view){
    Scratch_Block scratch(app);
    Lister_Choice_List list = {};
    lister_choice(scratch, &list, "(N)o" , "", KeyCode_N, SureToKill_No);
    lister_choice(scratch, &list, "(Y)es" , "", KeyCode_Y, SureToKill_Yes);
    lister_choice(scratch, &list, "(S)ave all and close", "",
                  KeyCode_S, SureToKill_Save);


    Lister_Choice *choice = get_choice_from_user(app, "There are one or more buffers with unsave changes, close anyway?", list);


    b32 do_exit = false;
    if (choice != 0){
        switch (choice->user_data){
            case SureToKill_No:
            {}break;

            case SureToKill_Yes:
            {
                allow_immediate_close_without_checking_for_changes = true;
                do_exit = true;
            }break;

            case SureToKill_Save:
            {
                save_all_dirty_buffers(app);
                allow_immediate_close_without_checking_for_changes = true;
                do_exit = true;
            }break;
        }
    }

    return(do_exit);
}



CUSTOM_COMMAND(interactive_switch_buffer, "/home/sam/.bin/4coder/custom/4coder_lists.cpp", 510, UI)
CUSTOM_DOC("Interactively switch to an open buffer.")
{
    Buffer_ID buffer = get_buffer_from_user(app, "Switch:");
    if (buffer != 0){
        View_ID view = get_this_ctx_view(app, Access_Always);
        view_set_buffer(app, view, buffer, 0);
    }
}

CUSTOM_COMMAND(interactive_kill_buffer, "/home/sam/.bin/4coder/custom/4coder_lists.cpp", 520, UI)
CUSTOM_DOC("Interactively kill an open buffer.")
{
    Buffer_ID buffer = get_buffer_from_user(app, "Kill:");
    if (buffer != 0){
        View_ID view = get_this_ctx_view(app, Access_Always);
        try_buffer_kill(app, buffer, view, 0);
    }
}



enum{
    SureToCreateFolder_NULL = 0,
    SureToCreateFolder_No = 1,
    SureToCreateFolder_Yes = 2,
};

static b32
query_create_folder(Application_Links *app, String_Const_u8 folder_name){
    Scratch_Block scratch(app);
    Lister_Choice_List list = {};
    lister_choice(scratch, &list, "(N)o" , "", KeyCode_N, SureToKill_No);
    lister_choice(scratch, &list, "(Y)es" , "", KeyCode_Y, SureToKill_Yes);

    String_Const_u8 message = push_u8_stringf(scratch, "Create the folder %.*s?", (i32)(folder_name).size, (char*)(folder_name).str);
    Lister_Choice *choice = get_choice_from_user(app, message, list);

    b32 did_create_folder = false;
    if (choice != 0){
        switch (choice->user_data){
            case SureToCreateFolder_No:
            {}break;

            case SureToCreateFolder_Yes:
            {
                String_Const_u8 hot = push_hot_directory(app, scratch);
                String_Const_u8 fixed_folder_name = folder_name;
                for (;fixed_folder_name.size > 0 &&
                     character_is_slash(fixed_folder_name.str[fixed_folder_name.size - 1]);){
                    fixed_folder_name = string_chop(fixed_folder_name, 1);
                }
                if (fixed_folder_name.size > 0){
                    String_Const_u8 cmd = push_u8_stringf(scratch, "mkdir %.*s", (i32)(fixed_folder_name).size, (char*)(fixed_folder_name).str);
                    exec_system_command(app, 0, buffer_identifier(0), hot, cmd, 0);
                    did_create_folder = true;
                }
            }break;
        }
    }

    return(did_create_folder);
}



static Lister_Activation_Code
activate_open_or_new__generic(Application_Links *app, View_ID view,
                              String_Const_u8 path, String_Const_u8 file_name, b32 is_folder,
                              Buffer_Create_Flag flags){
    Lister_Activation_Code result = 0;

    if (file_name.size == 0){

        print_message(app, SCu8((u8*)("Zero length file_name passed to activate_open_or_new__generic\n"), (u64)(sizeof("Zero length file_name passed to activate_open_or_new__generic\n") - 1)));

        result = ListerActivation_Finished;
    }
    else{
        Scratch_Block scratch(app);
        String_Const_u8 full_file_name = {};
        if (character_is_slash(string_get_character(path, path.size - 1))){
            path = string_chop(path, 1);
        }
        full_file_name = push_u8_stringf(scratch, "%.*s/%.*s", (i32)(path).size, (char*)(path).str, (i32)(file_name).size, (char*)(file_name).str);
        if (is_folder){
            set_hot_directory(app, full_file_name);
            result = ListerActivation_ContinueAndRefresh;
        }
        else{
            Buffer_ID buffer = create_buffer(app, full_file_name, flags);
            if (buffer != 0){
                view_set_buffer(app, view, buffer, SetBuffer_KeepOriginalGUI);
            }
            result = ListerActivation_Finished;
        }
    }

    return(result);
}

CUSTOM_COMMAND(interactive_open_or_new, "/home/sam/.bin/4coder/custom/4coder_lists.cpp", 611, UI)
CUSTOM_DOC("Interactively open a file out of the file system.")
{
    for (;;){
        Scratch_Block scratch(app);
        View_ID view = get_this_ctx_view(app, Access_Always);
        File_Name_Result result = get_file_name_from_user(app, scratch, "Open:", view);
        if (result.canceled) break;

        String_Const_u8 file_name = result.file_name_activated;
        if (file_name.size == 0){
            file_name = result.file_name_in_text_field;
        }
        if (file_name.size == 0) break;

        String_Const_u8 path = result.path_in_text_field;
        String_Const_u8 full_file_name = push_u8_stringf(scratch, "%.*s/%.*s",
                                                         (i32)(path).size, (char*)(path).str, (i32)(file_name).size, (char*)(file_name).str);

        if (result.is_folder){
            set_hot_directory(app, full_file_name);
            continue;
        }

        if (character_is_slash(file_name.str[file_name.size - 1])){
            File_Attributes attribs = system_quick_file_attributes(scratch, full_file_name);
            if ((((attribs.flags)&(FileAttribute_IsDirectory))!=0)){
                set_hot_directory(app, full_file_name);
                continue;
   }
   if (string_looks_like_drive_letter(file_name)){
    set_hot_directory(app, file_name);
    continue;
   }
            if (query_create_folder(app, file_name)){
                set_hot_directory(app, full_file_name);
                continue;
            }
            break;
        }

        Buffer_ID buffer = create_buffer(app, full_file_name, 0);
        if (buffer != 0){
            view_set_buffer(app, view, buffer, 0);
        }
        break;
    }
}

CUSTOM_COMMAND(interactive_new, "/home/sam/.bin/4coder/custom/4coder_lists.cpp", 660, UI)
CUSTOM_DOC("Interactively creates a new file.")
{
    for (;;){
        Scratch_Block scratch(app);
        View_ID view = get_this_ctx_view(app, Access_Always);
        File_Name_Result result = get_file_name_from_user(app, scratch, "New:",
                                                          view);
        if (result.canceled) break;



        String_Const_u8 file_name = result.file_name_in_text_field;
        if (result.is_folder || result.clicked){
            file_name = result.file_name_activated;
        }
        if (file_name.size == 0) break;

        String_Const_u8 path = result.path_in_text_field;
        String_Const_u8 full_file_name =
            push_u8_stringf(scratch, "%.*s/%.*s",
                            (i32)(path).size, (char*)(path).str, (i32)(file_name).size, (char*)(file_name).str);

        if (result.is_folder){
            set_hot_directory(app, full_file_name);
            continue;
        }

        if (character_is_slash(file_name.str[file_name.size - 1])){
            File_Attributes attribs = system_quick_file_attributes(scratch, full_file_name);
            if ((((attribs.flags)&(FileAttribute_IsDirectory))!=0)){
                set_hot_directory(app, full_file_name);
                continue;
   }
   if (string_looks_like_drive_letter(file_name)){
    set_hot_directory(app, file_name);
    continue;
   }
            if (query_create_folder(app, file_name)){
                set_hot_directory(app, full_file_name);
                continue;
            }
            break;
        }

        Buffer_Create_Flag flags = BufferCreate_AlwaysNew;
        Buffer_ID buffer = create_buffer(app, full_file_name, flags);
        if (buffer != 0){
            view_set_buffer(app, view, buffer, 0);
        }
        break;
    }
}

CUSTOM_COMMAND(interactive_open, "/home/sam/.bin/4coder/custom/4coder_lists.cpp", 714, UI)
CUSTOM_DOC("Interactively opens a file.")
{
    for (;;){
        Scratch_Block scratch(app);
        View_ID view = get_this_ctx_view(app, Access_Always);
        File_Name_Result result = get_file_name_from_user(app, scratch, "Open:", view);
        if (result.canceled) break;

        String_Const_u8 file_name = result.file_name_activated;
        if (file_name.size == 0) break;

        String_Const_u8 path = result.path_in_text_field;
        String_Const_u8 full_file_name =
            push_u8_stringf(scratch, "%.*s/%.*s",
                            (i32)(path).size, (char*)(path).str, (i32)(file_name).size, (char*)(file_name).str);

        if (result.is_folder){
            set_hot_directory(app, full_file_name);
            continue;
        }

        if (character_is_slash(file_name.str[file_name.size - 1])){
            File_Attributes attribs = system_quick_file_attributes(scratch, full_file_name);
            if ((((attribs.flags)&(FileAttribute_IsDirectory))!=0)){
                set_hot_directory(app, full_file_name);
                continue;
            }
            if (query_create_folder(app, file_name)){
                set_hot_directory(app, full_file_name);
                continue;
            }
            break;
        }

        Buffer_Create_Flag flags = BufferCreate_NeverNew;
        Buffer_ID buffer = create_buffer(app, full_file_name, flags);
        if (buffer != 0){
            view_set_buffer(app, view, buffer, 0);
        }
        break;
    }
}



CUSTOM_COMMAND(command_lister, "/home/sam/.bin/4coder/custom/4coder_lists.cpp", 760, UI)
CUSTOM_DOC("Opens an interactive list of all registered commands.")
{
    View_ID view = get_this_ctx_view(app, Access_Always);
    if (view != 0){
        Command_Lister_Status_Rule rule = {};
        Buffer_ID buffer = view_get_buffer(app, view, Access_Visible);
        Managed_Scope buffer_scope = buffer_get_managed_scope(app, buffer);
        Command_Map_ID *map_id_ptr = ((Command_Map_ID*)managed_scope_get_attachment((app), (buffer_scope), (buffer_map_id), sizeof(Command_Map_ID)));
        if (map_id_ptr != 0){
            rule = command_lister_status_bindings(&framework_mapping, *map_id_ptr);
        }
        else{
            rule = command_lister_status_descriptions();
        }
        Custom_Command_Function *func = get_command_from_user(app, "Command:", &rule);
        if (func != 0){
            view_enqueue_command_function(app, view, func);
        }
    }
}



CUSTOM_COMMAND(theme_lister, "/home/sam/.bin/4coder/custom/4coder_lists.cpp", 784, UI)
CUSTOM_DOC("Opens an interactive list of all registered themes.")
{
    Color_Table *color_table = get_color_table_from_user(app);
    if (color_table != 0){
        active_color_table = *color_table;
    }
}
# 109 "/home/sam/.bin/4coder/custom/4coder_default_include.cpp" 2
# 1 "/home/sam/.bin/4coder/custom/4coder_auto_indent.cpp" 1






static Batch_Edit*
make_batch_from_indentations(Application_Links *app, Arena *arena, Buffer_ID buffer, Range_i64 lines, i64 *indentations, Indent_Flag flags, i32 tab_width){
    i64 *shifted_indentations = indentations - lines.first;

    Batch_Edit *batch_first = 0;
    Batch_Edit *batch_last = 0;

    for (i64 line_number = lines.first;
         line_number <= lines.max;
         ++line_number){
        i64 line_start_pos = get_line_start_pos(app, buffer, line_number);
        Indent_Info indent_info = get_indent_info_line_number_and_start(app, buffer, line_number, line_start_pos, tab_width);

        i64 correct_indentation = shifted_indentations[line_number];
        if (indent_info.is_blank && (((flags)&(Indent_ClearLine))!=0)){
            correct_indentation = 0;
        }
        if (correct_indentation <= -1){
            correct_indentation = indent_info.indent_pos;
        }

        if (correct_indentation != indent_info.indent_pos){
            u64 str_size = 0;
            u8 *str = 0;
            if ((((flags)&(Indent_UseTab))!=0)){
                i64 tab_count = correct_indentation/tab_width;
                i64 indent = tab_count*tab_width;
                i64 space_count = correct_indentation - indent;
                str_size = tab_count + space_count;
                str = ((u8*)linalloc_wrap_unintialized(linalloc_push((arena), sizeof(u8)*(str_size), SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_auto_indent.cpp" ":" "36" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_auto_indent.cpp" ":" "36" ":") - 1)))));
                block_fill_u8(str, tab_count, '\t');
                block_fill_u8(str + tab_count, space_count, ' ');
            }
            else{
                str_size = correct_indentation;
                str = ((u8*)linalloc_wrap_unintialized(linalloc_push((arena), sizeof(u8)*(str_size), SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_auto_indent.cpp" ":" "42" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_auto_indent.cpp" ":" "42" ":") - 1)))));
                block_fill_u8(str, str_size, ' ');
            }

            Batch_Edit *batch = ((Batch_Edit*)linalloc_wrap_unintialized(linalloc_push((arena), sizeof(Batch_Edit)*(1), SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_auto_indent.cpp" ":" "46" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_auto_indent.cpp" ":" "46" ":") - 1)))));
            do{ if((batch)){if((batch_first)){(batch_last)->next=(batch);}else{(batch_first)=(batch);}(batch_last)=(batch);(batch_last)->next=0;} }while(0);
            batch->edit.text = SCu8(str, str_size);
            batch->edit.range = Ii64(line_start_pos, indent_info.first_char_pos);
        }
    }

    return(batch_first);
}

static void
set_line_indents(Application_Links *app, Arena *arena, Buffer_ID buffer, Range_i64 lines, i64 *indentations, Indent_Flag flags, i32 tab_width){
    Batch_Edit *batch = make_batch_from_indentations(app, arena, buffer, lines, indentations, flags, tab_width);
    if (batch != 0){
        buffer_batch_edit(app, buffer, batch);
    }
}

static Token*
find_anchor_token(Application_Links *app, Buffer_ID buffer, Token_Array *tokens, i64 invalid_line){
    Profile_Scope_Block profile_block_66 ((app), SCu8((u8*)("find anchor token"), (u64)(sizeof("find anchor token") - 1)), SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_auto_indent.cpp" ":" "66" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_auto_indent.cpp" ":" "66" ":") - 1)));
    Token *result = 0;

    if (tokens != 0 && tokens->tokens != 0){
        result = tokens->tokens;
        i64 invalid_pos = get_line_start_pos(app, buffer, invalid_line);
        i32 scope_counter = 0;
        i32 paren_counter = 0;
        Token *token = tokens->tokens;
        for (;;token += 1){
            if (token->pos + token->size > invalid_pos){
                break;
            }
            if (!(((token->flags)&(TokenBaseFlag_PreprocessorBody))!=0)){
                if (scope_counter == 0 && paren_counter == 0){
                    result = token;
                }
                switch (token->kind){
                    case TokenBaseKind_ScopeOpen:
                    {
                        scope_counter += 1;
                    }break;
                    case TokenBaseKind_ScopeClose:
                    {
                        paren_counter = 0;
                        if (scope_counter > 0){
                            scope_counter -= 1;
                        }
                    }break;
                    case TokenBaseKind_ParentheticalOpen:
                    {
                        paren_counter += 1;
                    }break;
                    case TokenBaseKind_ParentheticalClose:
                    {
                        if (paren_counter > 0){
                            paren_counter -= 1;
                        }
                    }break;
                }
            }
        }
    }

    return(result);
}

static Nest*
indent__new_nest(Arena *arena, Nest_Alloc *alloc){
    Nest *new_nest = alloc->free_nest;
    if (new_nest == 0){
        new_nest = ((Nest*)linalloc_wrap_unintialized(linalloc_push((arena), sizeof(Nest)*(1), SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_auto_indent.cpp" ":" "117" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_auto_indent.cpp" ":" "117" ":") - 1)))));
    }
    else{
        ((alloc->free_nest)=(alloc->free_nest)=(alloc->free_nest)->next);
    }
    return(new_nest);
}

static void
indent__free_nest(Nest_Alloc *alloc, Nest *nest){
    ((nest)->next=(alloc->free_nest),(alloc->free_nest)=(nest));
}

static b32
indent__unfinished_statement(Token *token, Nest *current_nest){
    b32 result = false;
    if (current_nest != 0 && current_nest->kind == TokenBaseKind_ScopeOpen){
        result = true;
        switch (token->kind){
            case TokenBaseKind_ScopeOpen:
            case TokenBaseKind_ScopeClose:
            case TokenBaseKind_StatementClose:
            {
                result = false;
            }break;
        }
        if ((((token->flags)&(TokenBaseFlag_PreprocessorBody))!=0)){
            result = false;
        }
    }
    return(result);
}

static void
line_indent_cache_update(Application_Links *app, Buffer_ID buffer, i32 tab_width, Indent_Line_Cache *line_cache){
    if (line_cache->line_number_for_cached_indent != line_cache->where_token_starts){
        Profile_Scope_Block profile_block_153 ((app), SCu8((u8*)("get indent info"), (u64)(sizeof("get indent info") - 1)), SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_auto_indent.cpp" ":" "153" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_auto_indent.cpp" ":" "153" ":") - 1)));
        line_cache->line_number_for_cached_indent = line_cache->where_token_starts;
        line_cache->start_pos = get_line_start_pos(app, buffer, line_cache->where_token_starts);
        Range_i64 range = Ii64(line_cache->start_pos, line_cache->one_past_last_pos);
        line_cache->indent_info = get_indent_info_range(app, buffer, range, tab_width);
    }
}

static i64*
get_indentation_array(Application_Links *app, Arena *arena, Buffer_ID buffer, Range_i64 lines, Indent_Flag flags, i32 tab_width, i32 indent_width){
    Profile_Scope_Block profile_block_163 ((app), SCu8((u8*)("get indentation array"), (u64)(sizeof("get indentation array") - 1)), SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_auto_indent.cpp" ":" "163" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_auto_indent.cpp" ":" "163" ":") - 1)));
    i64 count = lines.max - lines.min + 1;
    i64 *indentations = ((i64*)linalloc_wrap_unintialized(linalloc_push((arena), sizeof(i64)*(count), SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_auto_indent.cpp" ":" "165" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_auto_indent.cpp" ":" "165" ":") - 1)))));
    i64 *shifted_indentations = indentations - lines.first;
    block_fill_u64(indentations, sizeof(*indentations)*count, (u64)(-1));






    Token_Array token_array = get_token_array_from_buffer(app, buffer);
    Token_Array *tokens = &token_array;

    i64 anchor_line = (((1)>(lines.first - 1))?(1):(lines.first - 1));
    Token *anchor_token = find_anchor_token(app, buffer, tokens, anchor_line);
    if (anchor_token != 0 &&
        anchor_token >= tokens->tokens &&
        anchor_token < tokens->tokens + tokens->count){
        i64 line = get_line_number_from_pos(app, buffer, anchor_token->pos);
        line = (((line)<(lines.first))?(line):(lines.first));

        Token_Iterator_Array token_it = token_iterator(0, tokens, anchor_token);

        Scratch_Block scratch(app, arena);
        Nest *nest = 0;
        Nest_Alloc nest_alloc = {};

        i64 line_last_indented = line - 1;
        i64 last_indent = 0;
        i64 actual_indent = 0;
        b32 in_unfinished_statement = false;

        Indent_Line_Cache line_cache = {};

        for (;;){
            Token *token = token_it_read(&token_it);

            if (line_cache.where_token_starts == 0 ||
                token->pos >= line_cache.one_past_last_pos){
                Profile_Scope_Block profile_block_203 ((app), SCu8((u8*)("get line number"), (u64)(sizeof("get line number") - 1)), SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_auto_indent.cpp" ":" "203" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_auto_indent.cpp" ":" "203" ":") - 1)));
                line_cache.where_token_starts = get_line_number_from_pos(app, buffer, token->pos);
                line_cache.one_past_last_pos = get_line_end_pos(app, buffer, line_cache.where_token_starts);
            }

            i64 current_indent = 0;
            if (nest != 0){
                current_indent = nest->indent;
            }
            i64 this_indent = current_indent;
            i64 following_indent = current_indent;

            b32 shift_by_actual_indent = false;
            b32 ignore_unfinished_statement = false;
            if ((((token->flags)&(TokenBaseFlag_PreprocessorBody))!=0)){
                this_indent = 0;
            }
            else{
                switch (token->kind){
                    case TokenBaseKind_ScopeOpen:
                    {
                        Nest *new_nest = indent__new_nest(arena, &nest_alloc);
                        ((new_nest)->next=(nest),(nest)=(new_nest));
                        nest->kind = TokenBaseKind_ScopeOpen;
                        nest->indent = current_indent + indent_width;
                        following_indent = nest->indent;
                        ignore_unfinished_statement = true;
                    }break;

                    case TokenBaseKind_ScopeClose:
                    {
                        for (;nest != 0 && nest->kind != TokenBaseKind_ScopeOpen;){
                            Nest *n = nest;
                            ((nest)=(nest)=(nest)->next);
                            indent__free_nest(&nest_alloc, n);
                        }
                        if (nest != 0 && nest->kind == TokenBaseKind_ScopeOpen){
                            Nest *n = nest;
                            ((nest)=(nest)=(nest)->next);
                            indent__free_nest(&nest_alloc, n);
                        }
                        this_indent = 0;
                        if (nest != 0){
                            this_indent = nest->indent;
                        }
                        following_indent = this_indent;
                        ignore_unfinished_statement = true;
                    }break;

                    case TokenBaseKind_ParentheticalOpen:
                    {
                        Nest *new_nest = indent__new_nest(arena, &nest_alloc);
                        ((new_nest)->next=(nest),(nest)=(new_nest));
                        nest->kind = TokenBaseKind_ParentheticalOpen;
                        line_indent_cache_update(app, buffer, tab_width, &line_cache);
                        nest->indent = (token->pos - line_cache.indent_info.first_char_pos) + 1;
                        following_indent = nest->indent;
                        shift_by_actual_indent = true;
                    }break;

                    case TokenBaseKind_ParentheticalClose:
                    {
                        if (nest != 0 && nest->kind == TokenBaseKind_ParentheticalOpen){
                            Nest *n = nest;
                            ((nest)=(nest)=(nest)->next);
                            indent__free_nest(&nest_alloc, n);
                        }
                        following_indent = 0;
                        if (nest != 0){
                            following_indent = nest->indent;
                        }

                    }break;
                }

                if (token->sub_kind == TokenCppKind_BlockComment ||
                    token->sub_kind == TokenCppKind_LiteralStringRaw){
                    ignore_unfinished_statement = true;
                }

                if (in_unfinished_statement && !ignore_unfinished_statement){
                    this_indent += indent_width;
                }
            }






            i64 line_it = line_last_indented;
            if (lines.first <= line_cache.where_token_starts){
                for (;line_it < line_cache.where_token_starts;){
                    line_it += 1;
                    if (line_it == line_cache.where_token_starts){
                        do{ if (lines.first <= line_it){shifted_indentations[line_it]=this_indent;} if (line_it == lines.end){goto finished;} actual_indent = this_indent; }while(0);
                    }
                    else{
                        do{ if (lines.first <= line_it){shifted_indentations[line_it]=last_indent;} if (line_it == lines.end){goto finished;} actual_indent = last_indent; }while(0);
                    }
                }
            }
            else{
                actual_indent = this_indent;
                line_it = line_cache.where_token_starts;
            }

            i64 line_where_token_ends = get_line_number_from_pos(app, buffer, token->pos + token->size);
            if (lines.first <= line_where_token_ends){
                line_indent_cache_update(app, buffer, tab_width, &line_cache);
                i64 line_where_token_starts_shift = this_indent - line_cache.indent_info.indent_pos;
                for (;line_it < line_where_token_ends;){
                    line_it += 1;
                    i64 line_it_start_pos = get_line_start_pos(app, buffer, line_it);
                    Indent_Info line_it_indent_info = get_indent_info_line_number_and_start(app, buffer, line_it, line_it_start_pos, tab_width);
                    i64 new_indent = line_it_indent_info.indent_pos + line_where_token_starts_shift;
                    new_indent = (((0)>(new_indent))?(0):(new_indent));
                    do{ if (lines.first <= line_it){shifted_indentations[line_it]=new_indent;} if (line_it == lines.end){goto finished;} actual_indent = new_indent; }while(0);
                }
            }
            else{
                line_it = line_where_token_ends;
            }


            if (shift_by_actual_indent){
                nest->indent += actual_indent;
                following_indent += actual_indent;
            }

            if (token->kind != TokenBaseKind_Comment){
                in_unfinished_statement = indent__unfinished_statement(token, nest);
                if (in_unfinished_statement){
                    following_indent += indent_width;
                }
            }

            last_indent = following_indent;
            line_last_indented = line_it;

            if (!token_it_inc_non_whitespace(&token_it)){
                break;
            }
        }
    }

    finished:;
    return(indentations);
}

static b32
auto_indent_buffer(Application_Links *app, Buffer_ID buffer, Range_i64 pos, Indent_Flag flags, i32 tab_width, i32 indent_width){
    Profile_Scope_Block profile_block_355 ((app), SCu8((u8*)("auto indent buffer"), (u64)(sizeof("auto indent buffer") - 1)), SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_auto_indent.cpp" ":" "355" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_auto_indent.cpp" ":" "355" ":") - 1)));
    Token_Array token_array = get_token_array_from_buffer(app, buffer);
    Token_Array *tokens = &token_array;

    b32 result = false;
    if (tokens->tokens != 0){
        result = true;

        Scratch_Block scratch(app);
        Range_i64 line_numbers = {};
        if ((((flags)&(Indent_FullTokens))!=0)){
            i32 safety_counter = 0;
            for (;;){
                Range_i64 expanded = enclose_tokens(app, buffer, pos);
                expanded = enclose_whole_lines(app, buffer, expanded);
                if (expanded == pos){
                    break;
                }
                pos = expanded;
                safety_counter += 1;
                if (safety_counter == 20){
                    pos = buffer_range(app, buffer);
                    break;
                }
            }
        }
        line_numbers = get_line_range_from_pos_range(app, buffer, pos);

        i64 *indentations = get_indentation_array(app, scratch, buffer, line_numbers, flags, tab_width, indent_width);
        set_line_indents(app, scratch, buffer, line_numbers, indentations, flags, tab_width);
    }

    return(result);
}

static void
auto_indent_buffer(Application_Links *app, Buffer_ID buffer, Range_i64 pos, Indent_Flag flags){
    i32 indent_width = global_config.indent_width;
    i32 tab_width = global_config.default_tab_width;
    ((flags)|=(Indent_FullTokens));
    if (global_config.indent_with_tabs){
        ((flags)|=(Indent_UseTab));
    }
    auto_indent_buffer(app, buffer, pos, flags, indent_width, tab_width);
}

static void
auto_indent_buffer(Application_Links *app, Buffer_ID buffer, Range_i64 pos){
    auto_indent_buffer(app, buffer, pos, 0);
}



CUSTOM_COMMAND(auto_indent_whole_file, "/home/sam/.bin/4coder/custom/4coder_auto_indent.cpp", 408, Normal)
CUSTOM_DOC("Audo-indents the entire current buffer.")
{
    View_ID view = get_active_view(app, Access_ReadWriteVisible);
    Buffer_ID buffer = view_get_buffer(app, view, Access_ReadWriteVisible);
    i64 buffer_size = buffer_get_size(app, buffer);
    auto_indent_buffer(app, buffer, Ii64(0, buffer_size));
}

CUSTOM_COMMAND(auto_indent_line_at_cursor, "/home/sam/.bin/4coder/custom/4coder_auto_indent.cpp", 417, Normal)
CUSTOM_DOC("Auto-indents the line on which the cursor sits.")
{
    View_ID view = get_active_view(app, Access_ReadWriteVisible);
    Buffer_ID buffer = view_get_buffer(app, view, Access_ReadWriteVisible);
    i64 pos = view_get_cursor_pos(app, view);
    auto_indent_buffer(app, buffer, Ii64(pos));
    move_past_lead_whitespace(app, view, buffer);
}

CUSTOM_COMMAND(auto_indent_range, "/home/sam/.bin/4coder/custom/4coder_auto_indent.cpp", 427, Normal)
CUSTOM_DOC("Auto-indents the range between the cursor and the mark.")
{
    View_ID view = get_active_view(app, Access_ReadWriteVisible);
    Buffer_ID buffer = view_get_buffer(app, view, Access_ReadWriteVisible);
    Range_i64 range = get_view_range(app, view);
    auto_indent_buffer(app, buffer, range);
    move_past_lead_whitespace(app, view, buffer);
}

CUSTOM_COMMAND(write_text_and_auto_indent, "/home/sam/.bin/4coder/custom/4coder_auto_indent.cpp", 437, Normal)
CUSTOM_DOC("Inserts text and auto-indents the line on which the cursor sits if any of the text contains 'layout punctuation' such as ;:{}()[]# and new lines.")
{
    Profile_Scope_Block profile_block_440 ((app), SCu8((u8*)("write and auto indent"), (u64)(sizeof("write and auto indent") - 1)), SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_auto_indent.cpp" ":" "440" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_auto_indent.cpp" ":" "440" ":") - 1)));
    User_Input in = get_current_input(app);
    String_Const_u8 insert = to_writable(&in);
    if (insert.str != 0 && insert.size > 0){
        b32 do_auto_indent = false;
        for (u64 i = 0; !do_auto_indent && i < insert.size; i += 1){
            switch (insert.str[i]){
                case ';': case ':':
                case '{': case '}':
                case '(': case ')':
                case '[': case ']':
                case '#':
                case '\n': case '\t':
                {
                    do_auto_indent = true;
                }break;
            }
        }
        if (do_auto_indent){
            View_ID view = get_active_view(app, Access_ReadWriteVisible);
            Buffer_ID buffer = view_get_buffer(app, view, Access_ReadWriteVisible);

            Range_i64 pos = {};
            if (view_has_highlighted_range(app, view)){
                pos = get_view_range(app, view);
            }
            else{
                pos.min = pos.max = view_get_cursor_pos(app, view);
            }

            write_text_input(app);

            i64 end_pos = view_get_cursor_pos(app, view);
            pos.min = (((pos.min)<(end_pos))?(pos.min):(end_pos));
            pos.max = (((pos.max)>(end_pos))?(pos.max):(end_pos));

            auto_indent_buffer(app, buffer, pos, 0);
            move_past_lead_whitespace(app, view, buffer);
        }
        else{
            write_text_input(app);
        }
    }
}
# 110 "/home/sam/.bin/4coder/custom/4coder_default_include.cpp" 2
# 1 "/home/sam/.bin/4coder/custom/4coder_search.cpp" 1







static String_Const_u8 search_name = SCu8((u8*)("*search*"), (u64)(sizeof("*search*") - 1));

static void
print_string_match_list_to_buffer(Application_Links *app, Buffer_ID out_buffer_id, String_Match_List matches){
    Scratch_Block scratch(app);
    clear_buffer(app, out_buffer_id);
    Buffer_Insertion out = begin_buffer_insertion_at_buffered(app, out_buffer_id, 0, scratch, ((64) << 10));
    buffer_set_setting(app, out_buffer_id, BufferSetting_ReadOnly, true);
    buffer_set_setting(app, out_buffer_id, BufferSetting_RecordsHistory, false);

    Temp_Memory buffer_name_restore_point = begin_temp(scratch);
    String_Const_u8 current_file_name = {};
    Buffer_ID current_buffer = 0;

    if (matches.first != 0){
        for (String_Match *node = matches.first;
             node != 0;
             node = node->next){
            if (node->buffer != out_buffer_id){
                if (current_buffer != 0 && current_buffer != node->buffer){
                    insertc(&out, '\n');
                }
                if (current_buffer != node->buffer){
                    end_temp(buffer_name_restore_point);
                    current_buffer = node->buffer;
                    current_file_name = push_buffer_file_name(app, scratch, current_buffer);
                    if (current_file_name.size == 0){
                        current_file_name = push_buffer_unique_name(app, scratch, current_buffer);
                    }
                }

                Buffer_Cursor cursor = buffer_compute_cursor(app, current_buffer, seek_pos(node->range.first));
                Temp_Memory line_temp = begin_temp(scratch);
                String_Const_u8 full_line_str = push_buffer_line(app, scratch, current_buffer, cursor.line);
                String_Const_u8 line_str = string_skip_chop_whitespace(full_line_str);
                insertf(&out, "%.*s:%d:%d: %.*s\n",
                        (i32)(current_file_name).size, (char*)(current_file_name).str, cursor.line, cursor.col,
                        (i32)(line_str).size, (char*)(line_str).str);
                end_temp(line_temp);
            }
        }
    }
    else{
        insertf(&out, "no matches");
    }

    end_buffer_insertion(&out);
}

static void
print_all_matches_all_buffers(Application_Links *app, String_Const_u8_Array match_patterns, String_Match_Flag must_have_flags, String_Match_Flag must_not_have_flags, Buffer_ID out_buffer_id){
    Scratch_Block scratch(app);
    String_Match_List matches = find_all_matches_all_buffers(app, scratch, match_patterns, must_have_flags, must_not_have_flags);
    string_match_list_filter_remove_buffer(&matches, out_buffer_id);
    string_match_list_filter_remove_buffer_predicate(app, &matches, buffer_has_name_with_star);
    print_string_match_list_to_buffer(app, out_buffer_id, matches);
}

static void
print_all_matches_all_buffers(Application_Links *app, String_Const_u8 pattern, String_Match_Flag must_have_flags, String_Match_Flag must_not_have_flags, Buffer_ID out_buffer_id){
    String_Const_u8_Array array = {&pattern, 1};
    print_all_matches_all_buffers(app, array, must_have_flags, must_not_have_flags, out_buffer_id);
}

static void
print_all_matches_all_buffers_to_search(Application_Links *app, String_Const_u8_Array match_patterns, String_Match_Flag must_have_flags, String_Match_Flag must_not_have_flags, View_ID default_target_view){
    Buffer_ID search_buffer = create_or_switch_to_buffer_and_clear_by_name(app, search_name, default_target_view);
    print_all_matches_all_buffers(app, match_patterns, must_have_flags, must_not_have_flags, search_buffer);
}

static void
print_all_matches_all_buffers_to_search(Application_Links *app, String_Const_u8 pattern, String_Match_Flag must_have_flags, String_Match_Flag must_not_have_flags, View_ID default_target_view){
    String_Const_u8_Array array = {&pattern, 1};
    print_all_matches_all_buffers_to_search(app, array, must_have_flags, must_not_have_flags, default_target_view);
}

static String_Const_u8
query_user_list_needle(Application_Links *app, Arena *arena){
    u8 *space = ((u8*)linalloc_wrap_unintialized(linalloc_push((arena), sizeof(u8)*(((1) << 10)), SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_search.cpp" ":" "86" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_search.cpp" ":" "86" ":") - 1)))));
    return(get_query_string(app, "List Locations For: ", space, ((1) << 10)));
}

static String_Const_u8_Array
user_list_definition_array(Application_Links *app, Arena *arena, String_Const_u8 base_needle){
    String_Const_u8_Array result = {};
    if (base_needle.size > 0){
        result.count = 12;
        result.vals = ((String_Const_u8*)linalloc_wrap_unintialized(linalloc_push((arena), sizeof(String_Const_u8)*(result.count), SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_search.cpp" ":" "95" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_search.cpp" ":" "95" ":") - 1)))));
        i32 i = 0;
        result.vals[i++] = (push_u8_stringf(arena, "struct %.*s{" , (i32)(base_needle).size, (char*)(base_needle).str));
        result.vals[i++] = (push_u8_stringf(arena, "struct %.*s\n{", (i32)(base_needle).size, (char*)(base_needle).str));
        result.vals[i++] = (push_u8_stringf(arena, "struct %.*s\r\n{", (i32)(base_needle).size, (char*)(base_needle).str));
        result.vals[i++] = (push_u8_stringf(arena, "struct %.*s {" , (i32)(base_needle).size, (char*)(base_needle).str));
        result.vals[i++] = (push_u8_stringf(arena, "union %.*s{" , (i32)(base_needle).size, (char*)(base_needle).str));
        result.vals[i++] = (push_u8_stringf(arena, "union %.*s\n{" , (i32)(base_needle).size, (char*)(base_needle).str));
        result.vals[i++] = (push_u8_stringf(arena, "union %.*s\r\n{" , (i32)(base_needle).size, (char*)(base_needle).str));
        result.vals[i++] = (push_u8_stringf(arena, "union %.*s {" , (i32)(base_needle).size, (char*)(base_needle).str));
        result.vals[i++] = (push_u8_stringf(arena, "enum %.*s{" , (i32)(base_needle).size, (char*)(base_needle).str));
        result.vals[i++] = (push_u8_stringf(arena, "enum %.*s\n{" , (i32)(base_needle).size, (char*)(base_needle).str));
        result.vals[i++] = (push_u8_stringf(arena, "enum %.*s\r\n{" , (i32)(base_needle).size, (char*)(base_needle).str));
        result.vals[i++] = (push_u8_stringf(arena, "enum %.*s {" , (i32)(base_needle).size, (char*)(base_needle).str));
        do{ if (!(i == result.count)) { (*((i32*)0) = 0xA11E); } }while(0);
    }
    return(result);
}

static String_Const_u8_Array
query_user_list_definition_needle(Application_Links *app, Arena *arena){
    u8 *space = ((u8*)linalloc_wrap_unintialized(linalloc_push((arena), sizeof(u8)*(((1) << 10)), SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_search.cpp" ":" "116" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_search.cpp" ":" "116" ":") - 1)))));
    String_Const_u8 base_needle = get_query_string(app, "List Definitions For: ", space, ((1) << 10));
    return(user_list_definition_array(app, arena, base_needle));
}

static void
list_all_locations__generic(Application_Links *app, String_Const_u8_Array needle, List_All_Locations_Flag flags){
    if (needle.count > 0){
        View_ID target_view = get_next_view_after_active(app, Access_Always);
        String_Match_Flag must_have_flags = 0;
        String_Match_Flag must_not_have_flags = 0;
        if ((((flags)&(ListAllLocationsFlag_CaseSensitive))!=0)){
            ((must_have_flags)|=(StringMatch_CaseSensitive));
        }
        if (!(((flags)&(ListAllLocationsFlag_MatchSubstring))!=0)){
            ((must_not_have_flags)|=(StringMatch_LeftSideSloppy));
            ((must_not_have_flags)|=(StringMatch_RightSideSloppy));
        }
        print_all_matches_all_buffers_to_search(app, needle, must_have_flags, must_not_have_flags, target_view);
    }
}

static void
list_all_locations__generic(Application_Links *app, String_Const_u8 needle, List_All_Locations_Flag flags){
    if (needle.size != 0){
        String_Const_u8_Array array = {&needle, 1};
        list_all_locations__generic(app, array, flags);
    }
}

static void
list_all_locations__generic_query(Application_Links *app, List_All_Locations_Flag flags){
    Scratch_Block scratch(app);
    u8 *space = ((u8*)linalloc_wrap_unintialized(linalloc_push((scratch), sizeof(u8)*(((1) << 10)), SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_search.cpp" ":" "149" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_search.cpp" ":" "149" ":") - 1)))));
    String_Const_u8 needle = get_query_string(app, "List Locations For: ", space, ((1) << 10));
    list_all_locations__generic(app, needle, flags);
}

static void
list_all_locations__generic_identifier(Application_Links *app, List_All_Locations_Flag flags){
    Scratch_Block scratch(app);
    String_Const_u8 needle = push_token_or_word_under_active_cursor(app, scratch);
    list_all_locations__generic(app, needle, flags);
}

static void
list_all_locations__generic_view_range(Application_Links *app, List_All_Locations_Flag flags){
    Scratch_Block scratch(app);
    String_Const_u8 needle = push_view_range_string(app, scratch);
    list_all_locations__generic(app, needle, flags);
}

CUSTOM_COMMAND(list_all_locations, "/home/sam/.bin/4coder/custom/4coder_search.cpp", 168, Normal)
CUSTOM_DOC("Queries the user for a string and lists all exact case-sensitive matches found in all open buffers.")
{
    list_all_locations__generic_query(app, ListAllLocationsFlag_CaseSensitive);
}

CUSTOM_COMMAND(list_all_substring_locations, "/home/sam/.bin/4coder/custom/4coder_search.cpp", 174, Normal)
CUSTOM_DOC("Queries the user for a string and lists all case-sensitive substring matches found in all open buffers.")
{
    list_all_locations__generic_query(app, ListAllLocationsFlag_CaseSensitive|ListAllLocationsFlag_MatchSubstring);
}

CUSTOM_COMMAND(list_all_locations_case_insensitive, "/home/sam/.bin/4coder/custom/4coder_search.cpp", 180, Normal)
CUSTOM_DOC("Queries the user for a string and lists all exact case-insensitive matches found in all open buffers.")
{
    list_all_locations__generic_query(app, 0);
}

CUSTOM_COMMAND(list_all_substring_locations_case_insensitive, "/home/sam/.bin/4coder/custom/4coder_search.cpp", 186, Normal)
CUSTOM_DOC("Queries the user for a string and lists all case-insensitive substring matches found in all open buffers.")
{
    list_all_locations__generic_query(app, ListAllLocationsFlag_MatchSubstring);
}

CUSTOM_COMMAND(list_all_locations_of_identifier, "/home/sam/.bin/4coder/custom/4coder_search.cpp", 192, Normal)
CUSTOM_DOC("Reads a token or word under the cursor and lists all exact case-sensitive mathces in all open buffers.")
{
    list_all_locations__generic_identifier(app, ListAllLocationsFlag_CaseSensitive);
}

CUSTOM_COMMAND(list_all_locations_of_identifier_case_insensitive, "/home/sam/.bin/4coder/custom/4coder_search.cpp", 198, Normal)
CUSTOM_DOC("Reads a token or word under the cursor and lists all exact case-insensitive mathces in all open buffers.")
{
    list_all_locations__generic_identifier(app, ListAllLocationsFlag_CaseSensitive|ListAllLocationsFlag_MatchSubstring);
}

CUSTOM_COMMAND(list_all_locations_of_selection, "/home/sam/.bin/4coder/custom/4coder_search.cpp", 204, Normal)
CUSTOM_DOC("Reads the string in the selected range and lists all exact case-sensitive mathces in all open buffers.")
{
    list_all_locations__generic_view_range(app, ListAllLocationsFlag_CaseSensitive);
}

CUSTOM_COMMAND(list_all_locations_of_selection_case_insensitive, "/home/sam/.bin/4coder/custom/4coder_search.cpp", 210, Normal)
CUSTOM_DOC("Reads the string in the selected range and lists all exact case-insensitive mathces in all open buffers.")
{
    list_all_locations__generic_view_range(app, 0);
}

CUSTOM_COMMAND(list_all_locations_of_type_definition, "/home/sam/.bin/4coder/custom/4coder_search.cpp", 216, Normal)
CUSTOM_DOC("Queries user for string, lists all locations of strings that appear to define a type whose name matches the input string.")
{
    Scratch_Block scratch(app);
    String_Const_u8_Array array = query_user_list_definition_needle(app, scratch);
    list_all_locations__generic(app, array, ListAllLocationsFlag_CaseSensitive|ListAllLocationsFlag_MatchSubstring);
}

CUSTOM_COMMAND(list_all_locations_of_type_definition_of_identifier, "/home/sam/.bin/4coder/custom/4coder_search.cpp", 224, Normal)
CUSTOM_DOC("Reads a token or word under the cursor and lists all locations of strings that appear to define a type whose name matches it.")
{
    Scratch_Block scratch(app);
    String_Const_u8 base_needle = push_token_or_word_under_active_cursor(app, scratch);
    String_Const_u8_Array array = user_list_definition_array(app, scratch, base_needle);
    list_all_locations__generic(app, array, ListAllLocationsFlag_CaseSensitive|ListAllLocationsFlag_MatchSubstring);
}

static Range_i64
get_word_complete_needle_range(Application_Links *app, Buffer_ID buffer, i64 pos){
    Range_i64 needle_range = {};
    needle_range.max = pos;
    needle_range.min = scan(app, boundary_alpha_numeric_underscore_utf8, buffer, Scan_Backward, pos);
    i64 e = scan(app, boundary_alpha_numeric_underscore_utf8, buffer, Scan_Forward, needle_range.min);
    if (pos > e){
        needle_range = Ii64(pos);
    }
    return(needle_range);
}

static void
string_match_list_enclose_all(Application_Links *app, String_Match_List list,
                              Enclose_Function *enclose){
    for (String_Match *node = list.first;
         node != 0;
         node = node->next){
        node->range = enclose(app, node->buffer, node->range);
    }
}

static String_Match_Flag complete_must = (StringMatch_CaseSensitive|
                                          StringMatch_RightSideSloppy);
static String_Match_Flag complete_must_not = StringMatch_LeftSideSloppy;

static String_Match_List
get_complete_list_raw(Application_Links *app, Arena *arena, Buffer_ID buffer,
                      Range_i64 needle_range, String_Const_u8 needle){
    static Character_Predicate *pred =
        &character_predicate_alpha_numeric_underscore_utf8;

    String_Match_List result = {};
    i64 size = buffer_get_size(app, buffer);
    if (range_size(needle_range) > 0){
        String_Match_List up = buffer_find_all_matches(app, arena, buffer, 0,
                                                       Ii64(0, needle_range.min),
                                                       needle, pred, Scan_Backward);
        String_Match_List down = buffer_find_all_matches(app, arena, buffer, 0,
                                                         Ii64(needle_range.max, size),
                                                         needle, pred, Scan_Forward);
        string_match_list_filter_flags(&up, complete_must, complete_must_not);
        string_match_list_filter_flags(&down, complete_must, complete_must_not);
        result = string_match_list_merge_nearest(&up, &down, needle_range);
    }
    else{
        result = buffer_find_all_matches(app, arena, buffer, 0,
                                         Ii64(0, size), needle, pred, Scan_Forward);
        string_match_list_filter_flags(&result, complete_must, complete_must_not);
    }

    string_match_list_enclose_all(app, result,
                                  right_enclose_alpha_numeric_underscore_utf8);
    return(result);
}

static void
word_complete_list_extend_from_raw(Application_Links *app, Arena *arena, String_Match_List *matches, List_String_Const_u8 *list, Table_Data_u64 *used_table){
    Profile_Scope_Block profile_block_291 ((app), SCu8((u8*)("word complete list extend from raw"), (u64)(sizeof("word complete list extend from raw") - 1)), SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_search.cpp" ":" "291" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_search.cpp" ":" "291" ":") - 1)));
    Scratch_Block scratch(app);
    for (String_Match *node = matches->first;
         node != 0;
         node = node->next){
        String_Const_u8 s = push_buffer_range(app, scratch, node->buffer, node->range);
        Data data = make_data(s.str, s.size);
        Table_Lookup lookup = table_lookup(used_table, data);
        if (!lookup.found_match){
            data = push_data_copy(arena, data);
            table_insert(used_table, data, 1);
            string_list_push(arena, list, SCu8(data.data, data.size));
        }
    }
}

static void
word_complete_iter_init__inner(Buffer_ID buffer, String_Const_u8 needle, Range_i64 range, Word_Complete_Iterator *iter){
    Application_Links *app = iter->app;
    Arena *arena = iter->arena;

    Base_Allocator *allocator = get_base_allocator_system();
    if (iter->already_used_table.allocator != 0){
        end_temp(iter->arena_restore);
        table_clear(&iter->already_used_table);
    }

    block_zero((iter), sizeof(*(iter)));
    iter->app = app;
    iter->arena = arena;

    iter->arena_restore = begin_temp(arena);
    iter->needle = push_string_copy(arena, needle);
    iter->first_buffer = buffer;
    iter->current_buffer = buffer;

    Scratch_Block scratch(app, arena);
    String_Match_List list = get_complete_list_raw(app, scratch, buffer, range, needle);

    iter->already_used_table = make_table_Data_u64__inner((allocator),(100),SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_search.cpp" ":" "330" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_search.cpp" ":" "330" ":") - 1)));
    word_complete_list_extend_from_raw(app, arena, &list, &iter->list, &iter->already_used_table);

    iter->scan_all_buffers = true;
}

static void
word_complete_iter_init(Buffer_ID buffer, Range_i64 range, Word_Complete_Iterator *iter){
    if (iter->app != 0 && iter->arena != 0){
        Application_Links *app = iter->app;
        Arena *arena = iter->arena;
        Scratch_Block scratch(app, arena);
        String_Const_u8 needle = push_buffer_range(app, scratch, buffer, range);
        word_complete_iter_init__inner(buffer, needle, range, iter);
    }
}

static void
word_complete_iter_init(Buffer_ID first_buffer, String_Const_u8 needle, Word_Complete_Iterator *iter){
    if (iter->app != 0 && iter->arena != 0){
        word_complete_iter_init__inner(first_buffer, needle, Ii64(), iter);
    }
}

static void
word_complete_iter_init(String_Const_u8 needle, Word_Complete_Iterator *iter){
    if (iter->app != 0 && iter->arena != 0){
        Application_Links *app = iter->app;
        Buffer_ID first_buffer = get_buffer_next(app, 0, Access_Read);
        word_complete_iter_init__inner(first_buffer, needle, Ii64(), iter);
    }
}

static void
word_complete_iter_stop_on_this_buffer(Word_Complete_Iterator *iter){
    iter->scan_all_buffers = false;
}

static void
word_complete_iter_next(Word_Complete_Iterator *it){
    for (;;){
        if (it->node == 0){
            it->node = it->list.first;
        }
        else{
            it->node = it->node->next;
        }

        if (it->node != 0){
            break;
        }

        if (!it->scan_all_buffers){
            break;
        }

        Application_Links *app = it->app;
        Buffer_ID next = get_buffer_next_looped(app, it->current_buffer, Access_Read);
        if (next == it->first_buffer){
            break;
        }

        it->node = it->list.last;
        it->current_buffer = next;
        Scratch_Block scratch(app);
        String_Match_List list = get_complete_list_raw(app, scratch,
                                                       next, Ii64(), it->needle);
        word_complete_list_extend_from_raw(app, it->arena, &list,
                                           &it->list, &it->already_used_table);
    }
}

static String_Const_u8
word_complete_iter_read(Word_Complete_Iterator *it){
    String_Const_u8 result = {};
    if (it->node == 0){
        result = it->needle;
    }
    else{
        result = it->node->string;
    }
    return(result);
}


static b32
word_complete_iter_is_at_base_slot(Word_Complete_Iterator *it){
    return(it->node == 0);
}

static Word_Complete_Iterator*
word_complete_get_shared_iter(Application_Links *app){
    static Arena completion_arena = {};
    static Word_Complete_Iterator it = {};
    static b32 first_call = true;
    if (first_call){
        first_call = false;
        completion_arena = make_arena_system();
    }
    it.app = app;
    it.arena = &completion_arena;
    return(&it);
}

CUSTOM_COMMAND(word_complete, "/home/sam/.bin/4coder/custom/4coder_search.cpp", 434, Normal)
CUSTOM_DOC("Iteratively tries completing the word to the left of the cursor with other words in open buffers that have the same prefix string.")
{
    Profile_Scope_Block profile_block_437 ((app), SCu8((u8*)("word complete"), (u64)(sizeof("word complete") - 1)), SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_search.cpp" ":" "437" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_search.cpp" ":" "437" ":") - 1)));

    View_ID view = get_active_view(app, Access_ReadWriteVisible);
    Buffer_ID buffer = view_get_buffer(app, view, Access_ReadWriteVisible);
    if (buffer != 0){
        Managed_Scope scope = view_get_managed_scope(app, view);

        b32 first_completion = false;
        Rewrite_Type *rewrite = ((Rewrite_Type*)managed_scope_get_attachment((app), (scope), (view_rewrite_loc), sizeof(Rewrite_Type)));
        if (*rewrite != Rewrite_WordComplete){
            first_completion = true;
        }

        set_next_rewrite(app, view, Rewrite_WordComplete);

        Word_Complete_Iterator *it = word_complete_get_shared_iter(app);
        static b32 initialized = false;
        static Range_i64 range = {};

        if (first_completion || !initialized){
            Profile_Block profile_block_457 ((app), SCu8((u8*)("word complete state init"), (u64)(sizeof("word complete state init") - 1)), SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_search.cpp" ":" "457" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_search.cpp" ":" "457" ":") - 1)));
            initialized = false;
            i64 pos = view_get_cursor_pos(app, view);
            Range_i64 needle_range = get_word_complete_needle_range(app, buffer, pos);
            if (range_size(needle_range) > 0){
                initialized = true;
                range = needle_range;
                word_complete_iter_init(buffer, needle_range, it);
            }
        }

        if (initialized){
            Profile_Block profile_block_469 ((app), SCu8((u8*)("word complete apply"), (u64)(sizeof("word complete apply") - 1)), SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_search.cpp" ":" "469" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_search.cpp" ":" "469" ":") - 1)));

            word_complete_iter_next(it);
            String_Const_u8 str = word_complete_iter_read(it);

            buffer_replace_range(app, buffer, range, str);

            range.max = range.min + str.size;
            view_set_cursor_and_preferred_x(app, view, seek_pos(range.max));
        }
    }
}

static Word_Complete_Menu
make_word_complete_menu(Render_Caller_Function *prev_render_caller, Word_Complete_Iterator *it){
    Word_Complete_Menu menu = {};
    menu.prev_render_caller = prev_render_caller;
    menu.it = it;
    return(menu);
}

static void
word_complete_menu_next(Word_Complete_Menu *menu){
    i32 count = 0;
    for (i32 i = 0; i < ((sizeof(menu->options))/(sizeof(*menu->options))); i += 1){
        word_complete_iter_next(menu->it);
        if (word_complete_iter_is_at_base_slot(menu->it)){
            break;
        }
        else{
            menu->options[i] = word_complete_iter_read(menu->it);
            count += 1;
        }
    }
    menu->count = count;
}

static void
word_complete_menu_render(Application_Links *app, Frame_Info frame_info, View_ID view){
    Managed_Scope scope = view_get_managed_scope(app, view);
    Word_Complete_Menu **menu_ptr = ((Word_Complete_Menu**)managed_scope_get_attachment((app), (scope), (view_word_complete_menu), sizeof(Word_Complete_Menu*)));
    Word_Complete_Menu *menu = *menu_ptr;

    if (menu != 0){
        menu->prev_render_caller(app, frame_info, view);

        Buffer_ID buffer = view_get_buffer(app, view, Access_Always);
        Face_ID face = get_face_id(app, buffer);

        Scratch_Block scratch(app);

        Fancy_Block block = {};
        for (i32 i = 0; i < menu->count; i += 1){
            if (menu->options[i].size > 0){
                Fancy_Line *line = push_fancy_line(scratch, &block, face);
                push_fancy_stringf(scratch, line, fcolor_id(defcolor_pop1), "F%d:", i + 1);
                push_fancy_string(scratch, line, fcolor_id(defcolor_text_default), menu->options[i]);
            }
        }

        Rect_f32 region = view_get_buffer_region(app, view);

        Buffer_Scroll scroll = view_get_buffer_scroll(app, view);
        Buffer_Point buffer_point = scroll.position;
        i64 pos = view_get_cursor_pos(app, view);
        Vec2_f32 cursor_p = view_relative_xy_of_pos(app, view, buffer_point.line_number, pos);
        cursor_p -= buffer_point.pixel_shift;
        cursor_p += region.p0;

        Face_Metrics metrics = get_face_metrics(app, face);
        f32 x_padding = metrics.normal_advance;
        f32 x_half_padding = x_padding*0.5f;

        draw_drop_down(app, face, &block, cursor_p, region, x_padding, x_half_padding,
                       fcolor_id(defcolor_margin_hover), fcolor_id(defcolor_back));
    }
}

static Edit
get_word_complete_from_user_drop_down(Application_Links *app){
    View_ID view = get_this_ctx_view(app, Access_Always);
    View_Context ctx = view_current_context(app, view);
    Render_Caller_Function *prev_render_caller = ctx.render_caller;

    Edit result = {};

    Word_Complete_Iterator *it = word_complete_get_shared_iter(app);

    i64 pos = view_get_cursor_pos(app, view);
    Buffer_ID buffer = view_get_buffer(app, view, Access_ReadWriteVisible);
    Range_i64 range = get_word_complete_needle_range(app, buffer, pos);
    if (range_size(range) != 0){
        word_complete_iter_init(buffer, range, it);
        Word_Complete_Menu menu = make_word_complete_menu(prev_render_caller, it);
        word_complete_menu_next(&menu);

        ctx.render_caller = word_complete_menu_render;
        View_Context_Block ctx_block(app, view, &ctx);

        Managed_Scope scope = view_get_managed_scope(app, view);
        Word_Complete_Menu **menu_ptr = ((Word_Complete_Menu**)managed_scope_get_attachment((app), (scope), (view_word_complete_menu), sizeof(Word_Complete_Menu*)));
        *menu_ptr = &menu;

        b32 keep_looping_menu = true;
        for (;keep_looping_menu;){
            User_Input in = get_next_input(app, EventPropertyGroup_Any,
                                           EventProperty_Escape);
            if (in.abort){
                break;
            }

            b32 handled = true;
            switch (in.event.kind){
                case InputEventKind_TextInsert:
                {
                    write_text_input(app);
                    pos = view_get_cursor_pos(app, view);
                    range = get_word_complete_needle_range(app, buffer, pos);
                    if (range_size(range) == 0){
                        keep_looping_menu = false;
                    }
                    else{
                        word_complete_iter_init(buffer, range, it);
                        menu = make_word_complete_menu(prev_render_caller, it);
                        word_complete_menu_next(&menu);
                        if (menu.count == 0){
                            keep_looping_menu = false;
                        }
                    }
                }break;

                case InputEventKind_KeyStroke:
                {
                    switch (in.event.key.code){
                        case KeyCode_Return:
                        {
                            result.text = menu.options[0];
                            result.range = range;
                            keep_looping_menu = false;
                        }break;

                        case KeyCode_Tab:
                        {
                            word_complete_menu_next(&menu);
                        }break;

                        case KeyCode_F1:
                        case KeyCode_F2:
                        case KeyCode_F3:
                        case KeyCode_F4:
                        case KeyCode_F5:
                        case KeyCode_F6:
                        case KeyCode_F7:
                        case KeyCode_F8:
                        {
                            i32 index = (in.event.key.code - KeyCode_F1);
                            result.text = menu.options[index];
                            result.range = range;
                            keep_looping_menu = false;
                        }break;

                        case KeyCode_Backspace:
                        {
                            backspace_char(app);
                            pos = view_get_cursor_pos(app, view);
                            range = get_word_complete_needle_range(app, buffer, pos);
                            if (range_size(range) == 0){
                                keep_looping_menu = false;
                            }
                            else{
                                word_complete_iter_init(buffer, range, it);
                                menu = make_word_complete_menu(prev_render_caller, it);
                                word_complete_menu_next(&menu);
                                if (menu.count == 0){
                                    keep_looping_menu = false;
                                }
                            }
                        }break;

                        default:
                        {
                            leave_current_input_unhandled(app);
                        }break;
                    }
                }break;

                case InputEventKind_MouseButton:
                {
                    leave_current_input_unhandled(app);
                    keep_looping_menu = false;
                }break;

                default:
                {
                    handled = false;
                }break;
            }

            if (!handled){
                leave_current_input_unhandled(app);
            }
        }

        scope = view_get_managed_scope(app, view);
        menu_ptr = ((Word_Complete_Menu**)managed_scope_get_attachment((app), (scope), (view_word_complete_menu), sizeof(Word_Complete_Menu*)));
        *menu_ptr = 0;
    }

    return(result);
}

CUSTOM_COMMAND(word_complete_drop_down, "/home/sam/.bin/4coder/custom/4coder_search.cpp", 680, Normal)
CUSTOM_DOC("Word complete with drop down menu.")
{
    View_ID view = get_active_view(app, Access_ReadWriteVisible);
    Buffer_ID buffer = view_get_buffer(app, view, Access_ReadWriteVisible);
    if (buffer != 0){
        Edit edit = get_word_complete_from_user_drop_down(app);
        if (edit.text.size > 0){
            buffer_replace_range(app, buffer, edit.range, edit.text);
            view_set_cursor_and_preferred_x(app, view, seek_pos(edit.range.min + edit.text.size));
        }
    }
}
# 111 "/home/sam/.bin/4coder/custom/4coder_default_include.cpp" 2
# 1 "/home/sam/.bin/4coder/custom/4coder_jumping.cpp" 1






static b32
ms_style_verify(String_Const_u8 line, u64 left_paren_pos, u64 right_paren_pos){
    i32 result = false;
    String_Const_u8 line_part = string_skip(line, right_paren_pos);
    if (string_match(string_prefix(line_part, 4), SCu8((u8*)(") : "), (u64)(sizeof(") : ") - 1))) ||
        string_match(string_prefix(line_part, 3), SCu8((u8*)("): "), (u64)(sizeof("): ") - 1)))){
        result = true;
    }
    if (result){
        String_Const_u8 number = string_skip(string_prefix(line, right_paren_pos), left_paren_pos + 1);
        if (!string_is_integer(number, 10)){
            result = false;
            u64 comma_pos = string_find_first(number, ',');
            if (comma_pos < number.size){
                String_Const_u8 sub_number0 = string_prefix(number, comma_pos);
                String_Const_u8 sub_number1 = string_skip(number, comma_pos + 1);
                if (string_is_integer(sub_number0, 10) && string_is_integer(sub_number1, 10)){
                    result = true;
                }
            }
        }
    }
    return(result);
}

static u64
try_skip_rust_arrow(String_Const_u8 line){
    u64 pos = 0;
    if (string_match(string_prefix(line, 3), SCu8((u8*)("-->"), (u64)(sizeof("-->") - 1)))){
        String_Const_u8 sub = string_skip(line, 3);
        sub = string_skip_chop_whitespace(sub);
        pos = (u64)(sub.str - line.str);
    }
    return(pos);
}

static b32
check_is_note(String_Const_u8 line, u64 colon_pos){
    b32 is_note = false;
    u64 note_pos = colon_pos + string_find_first(string_skip(line, colon_pos), SCu8((u8*)("note"), (u64)(sizeof("note") - 1)));
    if (note_pos < line.size){
        b32 is_all_whitespace = true;
        for (u64 i = colon_pos + 1; i < note_pos; i += 1){
            if (!character_is_whitespace(line.str[i])){
                is_all_whitespace = false;
                break;
            }
        }
        if (is_all_whitespace){
            is_note = true;
        }
    }
    return(is_note);
}

static Parsed_Jump
parse_jump_location(String_Const_u8 line){
    Parsed_Jump jump = {};
    jump.sub_jump_indented = (string_get_character(line, 0) == ' ');

    String_Const_u8 reduced_line = string_skip_chop_whitespace(line);
    u64 whitespace_length = (u64)(reduced_line.str - line.str);
    line = reduced_line;

    u64 left_paren_pos = string_find_first(line, '(');
    u64 right_paren_pos = left_paren_pos + string_find_first(string_skip(line, left_paren_pos), ')');
    for (;!jump.is_ms_style && right_paren_pos < line.size;){
        if (ms_style_verify(line, left_paren_pos, right_paren_pos)){
            jump.is_ms_style = true;
            jump.colon_position = (i32)(right_paren_pos + string_find_first(string_skip(line, right_paren_pos), ':'));
            if (jump.colon_position < line.size){
                if (check_is_note(line, jump.colon_position)){
                    jump.sub_jump_note = true;
                }

                String_Const_u8 location_str = string_prefix(line, jump.colon_position);
                location_str = string_skip_chop_whitespace(location_str);

                i32 close_pos = (i32)right_paren_pos;
                i32 open_pos = (i32)left_paren_pos;

                if (0 < open_pos && open_pos < location_str.size){
                    String_Const_u8 file = SCu8(location_str.str, open_pos);
                    file = string_skip_chop_whitespace(file);

                    if (file.size > 0){
                        String_Const_u8 line_number = string_skip(string_prefix(location_str, close_pos), open_pos + 1);
                        line_number = string_skip_chop_whitespace(line_number);

                        if (line_number.size > 0){
                            u64 comma_pos = string_find_first(line_number, ',');
                            if (comma_pos < line_number.size){
                                String_Const_u8 column_number = string_skip(line_number, comma_pos + 1);
                                line_number = string_prefix(line_number, comma_pos);
                                jump.location.line = (i32)string_to_integer(line_number, 10);
                                jump.location.column = (i32)string_to_integer(column_number, 10);
                            }
                            else{
                                jump.location.line = (i32)string_to_integer(line_number, 10);
                                jump.location.column = 0;
                            }
                            jump.location.file = file;
                            jump.colon_position = jump.colon_position + (i32)whitespace_length;
                            jump.success = true;
                        }
                    }
                }
            }
        }
        else{
            left_paren_pos = string_find_first(string_skip(line, left_paren_pos + 1), '(') + left_paren_pos + 1;
            right_paren_pos = string_find_first(string_skip(line, left_paren_pos), ')') + left_paren_pos;
        }
    }

    if (!jump.is_ms_style){
        i32 start = (i32)try_skip_rust_arrow(line);
        if (start != 0){
            jump.has_rust_arrow = true;
        }

        u64 colon_pos1 = string_find_first(string_skip(line, start), ':') + start;
        if (line.size > colon_pos1 + 1){
            if (character_is_slash(string_get_character(line, colon_pos1 + 1))){
                colon_pos1 = string_find_first(string_skip(line, colon_pos1 + 1), ':') + colon_pos1 + 1;
            }
        }

        u64 colon_pos2 = string_find_first(string_skip(line, colon_pos1 + 1), ':') + colon_pos1 + 1;
        u64 colon_pos3 = string_find_first(string_skip(line, colon_pos2 + 1), ':') + colon_pos2 + 1;

        if (colon_pos3 < line.size){
            if (check_is_note(line, colon_pos3)){
                jump.sub_jump_note = true;
            }

            String_Const_u8 file_name = string_skip(string_prefix(line, colon_pos1), start);
            String_Const_u8 line_number = string_skip(string_prefix(line, colon_pos2), colon_pos1 + 1);
            String_Const_u8 column_number = string_skip(string_prefix(line, colon_pos3), colon_pos2 + 1);

            if (file_name.size > 0 && line_number.size > 0 && column_number.size > 0){
                jump.location.file = file_name;
                jump.location.line = (i32)string_to_integer(line_number, 10);
                jump.location.column = (i32)string_to_integer(column_number, 10);
                jump.colon_position = (i32)(colon_pos3 + whitespace_length);
                jump.success = true;
            }
        }
        else{
            if (colon_pos2 < line.size){
                if (check_is_note(line, colon_pos2)){
                    jump.sub_jump_note = true;
                }

                String_Const_u8 file_name = string_prefix(line, colon_pos1);
                String_Const_u8 line_number = string_skip(string_prefix(line, colon_pos2), colon_pos1 + 1);

                if (string_is_integer(line_number, 10)){
                    if (file_name.size > 0 && line_number.size > 0){
                        jump.location.file = file_name;
                        jump.location.line = (i32)string_to_integer(line_number, 10);
                        jump.location.column = 0;
                        jump.colon_position = (i32)(colon_pos3 + whitespace_length);
                        jump.success = true;
                    }
                }
            }
        }
    }

    if (!jump.success){
        block_zero((&jump), sizeof(*(&jump)));
    }
    else{
        jump.is_sub_jump = (jump.sub_jump_indented || jump.sub_jump_note);
    }
    return(jump);
}

static Parsed_Jump
parse_jump_location(String_Const_u8 line, Jump_Flag flags){
    Parsed_Jump jump = parse_jump_location(line);
    if ((((flags)&(JumpFlag_SkipSubs))!=0) && jump.is_sub_jump){
        block_zero((&jump), sizeof(*(&jump)));
    }
    return(jump);
}

static Parsed_Jump
parse_jump_from_buffer_line(Application_Links *app, Arena *arena, Buffer_ID buffer, i64 line, Jump_Flag flags){
    Parsed_Jump jump = {};
    String_Const_u8 line_str = push_buffer_line(app, arena, buffer, line);
    if (line_str.size > 0){
        jump = parse_jump_location(line_str, flags);
    }
    return(jump);
}



static b32
get_jump_buffer(Application_Links *app, Buffer_ID *buffer, Name_Line_Column_Location *location){
    return(open_file(app, buffer, location->file, false, true));
}

static b32
get_jump_buffer(Application_Links *app, Buffer_ID *buffer, ID_Pos_Jump_Location *location, Access_Flag access){
    *buffer = location->buffer_id;
    return(buffer_exists(app, *buffer));
}

static b32
get_jump_buffer(Application_Links *app, Buffer_ID *buffer, ID_Pos_Jump_Location *location){
    return(get_jump_buffer(app, buffer, location, Access_Always));
}

static View_ID
switch_to_existing_view(Application_Links *app, View_ID view, Buffer_ID buffer){
    Buffer_ID current_buffer = view_get_buffer(app, view, Access_Always);
    if (view != 0 || current_buffer != buffer){
        View_ID existing_view = get_first_view_with_buffer(app, buffer);
        if (existing_view != 0){
            view = existing_view;
        }
    }
    return(view);
}

static void
set_view_to_location(Application_Links *app, View_ID view, Buffer_ID buffer, Buffer_Seek seek){
    Buffer_ID current_buffer = view_get_buffer(app, view, Access_Always);
    if (current_buffer != buffer){
        view_set_buffer(app, view, buffer, 0);
    }
    view_set_cursor_and_preferred_x(app, view, seek);
}

static void
jump_to_location(Application_Links *app, View_ID view, Buffer_ID buffer, i64 pos){
    view_set_active(app, view);
    set_view_to_location(app, view, buffer, seek_pos(pos));
    if (auto_center_after_jumps){
        center_view(app);
    }
}

static void
jump_to_location(Application_Links *app, View_ID view, Buffer_ID buffer,
                 Name_Line_Column_Location location){
    view_set_active(app, view);
    set_view_to_location(app, view, buffer, seek_line_col(location.line, location.column));
    if (auto_center_after_jumps){
        center_view(app);
    }
}

static void
jump_to_location(Application_Links *app, View_ID view,
                 Name_Line_Column_Location location){
    Buffer_ID buffer = 0;
    if (get_jump_buffer(app, &buffer, &location)){
        jump_to_location(app, view, buffer, location);
    }
}

static void
jump_to_location(Application_Links *app, View_ID view, Buffer_ID buffer, ID_Pos_Jump_Location location){
    view_set_active(app, view);
    set_view_to_location(app, view, buffer, seek_pos(location.pos));
    if (auto_center_after_jumps){
        center_view(app);
    }
}

static void
jump_to_location(Application_Links *app, View_ID view, String_Const_u8 location){
    Parsed_Jump jump = parse_jump_location(location);
    if (jump.success){
        jump_to_location(app, view, jump.location);
    }
}




static Parsed_Jump
seek_next_jump_in_buffer(Application_Links *app, Arena *arena,
                         Buffer_ID buffer, i64 first_line, Jump_Flag flags, Scan_Direction direction,
                         i64 *line_out){
    do{ if (!(direction == 1 || direction == -1)) { (*((i32*)0) = 0xA11E); } }while(0);
    Parsed_Jump jump = {};
    i64 line = first_line;
    for (;;){
        if (is_valid_line(app, buffer, line)){
            String_Const_u8 line_str = push_buffer_line(app, arena, buffer, line);
            jump = parse_jump_location(line_str, flags);
            if (jump.success){
                break;
            }
            line += direction;
        }
        else{
            break;
        }
    }
    if (jump.success){
        *line_out = (((line)>(0))?(line):(0));
    }
    return(jump);
}

static ID_Line_Column_Jump_Location
convert_name_based_to_id_based(Application_Links *app, Name_Line_Column_Location loc){
    ID_Line_Column_Jump_Location result = {};
    Buffer_ID buffer = get_buffer_by_name(app, loc.file, Access_Always);
    if (buffer != 0){
        result.buffer_id = buffer;
        result.line = loc.line;
        result.column = loc.column;
    }
    return(result);
}

static Parsed_Jump
seek_next_jump_in_view(Application_Links *app, Arena *arena, View_ID view, i32 skip_sub_errors, Scan_Direction direction, i64 *line_out){
    i64 cursor_position = view_get_cursor_pos(app, view);
    Buffer_Cursor cursor = view_compute_cursor(app, view, seek_pos(cursor_position));
    i64 line = cursor.line;
    Buffer_ID buffer = view_get_buffer(app, view, Access_Always);
    Parsed_Jump jump = seek_next_jump_in_buffer(app, arena, buffer, line + direction, skip_sub_errors, direction, &line);
    if (jump.success){
        *line_out = line;
    }
    return(jump);
}

static b32
skip_this_jump(ID_Line_Column_Jump_Location prev, ID_Line_Column_Jump_Location jump){
    b32 result = false;
    if (prev.buffer_id != 0 && prev.buffer_id == jump.buffer_id && prev.line == jump.line && prev.column <= jump.column){
        result = true;
    }
    return(result);
}
# 112 "/home/sam/.bin/4coder/custom/4coder_default_include.cpp" 2
# 1 "/home/sam/.bin/4coder/custom/4coder_jump_sticky.cpp" 1







static Marker_List_Node *marker_list_first = 0;
static Marker_List_Node *marker_list_last = 0;



static i32
binary_search(i64 *array, i32 stride, i32 count, i64 x){
    u8 *raw = (u8*)array;
    i32 i = 0;
    i32 first = 0;
    i32 last = count;
    if (first < last){
        for (;;){
            i = (first + last)/2;
            i64 k = *(i64*)(raw + stride*i);
            if (k < x){
                first = i;
            }
            else if (k > x){
                last = i;
            }
            else{
                break;
            }
            if (first + 1 >= last){
                i = first;
                break;
            }
        }
    }
    return(i);
}

static Sticky_Jump_Array
parse_buffer_to_jump_array(Application_Links *app, Arena *arena, Buffer_ID buffer){
    Sticky_Jump_Node *jump_first = 0;;
    Sticky_Jump_Node *jump_last = 0;
    i32 jump_count = 0;

    for (i32 line = 1;; line += 1){
        b32 output_jump = false;
        i32 colon_index = 0;
        b32 is_sub_error = false;
        Buffer_ID out_buffer_id = 0;
        i64 out_pos = 0;

        {
            Temp_Memory_Block line_auto_closer(arena);
            if (is_valid_line(app, buffer, line)){
                String_Const_u8 line_str = push_buffer_line(app, arena, buffer, line);
                Parsed_Jump parsed_jump = parse_jump_location(line_str);
                if (parsed_jump.success){
                    Buffer_ID jump_buffer = {};
                    if (open_file(app, &jump_buffer, parsed_jump.location.file, false, true)){
                        if (buffer_exists(app, jump_buffer)){
                            Buffer_Cursor cursor = buffer_compute_cursor(app, jump_buffer, seek_jump(parsed_jump));
                            if (cursor.line > 0){
                                out_buffer_id = jump_buffer;
                                out_pos = cursor.pos;
                                output_jump = true;
                            }
                        }
                    }
                }
            }
            else{
                break;
            }
        }

        if (output_jump){
            Sticky_Jump_Node *jump = ((Sticky_Jump_Node*)linalloc_wrap_unintialized(linalloc_push((arena), sizeof(Sticky_Jump_Node)*(1), SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_jump_sticky.cpp" ":" "79" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_jump_sticky.cpp" ":" "79" ":") - 1)))));
            do{ if((jump)){if((jump_first)){(jump_last)->next=(jump);}else{(jump_first)=(jump);}(jump_last)=(jump);(jump_last)->next=0;} }while(0);
            jump_count += 1;
            jump->jump.list_line = line;
            jump->jump.list_colon_index = colon_index;
            jump->jump.is_sub_error = is_sub_error;
            jump->jump.jump_buffer_id = out_buffer_id;
            jump->jump.jump_pos = out_pos;
        }
    }

    Sticky_Jump_Array result = {};
    result.count = jump_count;
    result.jumps = ((Sticky_Jump*)linalloc_wrap_unintialized(linalloc_push((arena), sizeof(Sticky_Jump)*(result.count), SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_jump_sticky.cpp" ":" "92" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_jump_sticky.cpp" ":" "92" ":") - 1)))));
    i32 index = 0;
    for (Sticky_Jump_Node *node = jump_first;
         node != 0;
         node = node->next){
        result.jumps[index] = node->jump;
        index += 1;
    }

    return(result);
}

static void
init_marker_list(Application_Links *app, Heap *heap, Buffer_ID buffer, Marker_List *list){
    Scratch_Block scratch(app);

    Sticky_Jump_Array jumps = parse_buffer_to_jump_array(app, scratch, buffer);
    Range_i32_Array buffer_ranges = get_ranges_of_duplicate_keys(scratch, &jumps.jumps->jump_buffer_id, sizeof(*jumps.jumps), jumps.count);
    Sort_Pair_i32 *range_index_buffer_id_pairs = ((Sort_Pair_i32*)linalloc_wrap_unintialized(linalloc_push((scratch), sizeof(Sort_Pair_i32)*(buffer_ranges.count), SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_jump_sticky.cpp" ":" "110" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_jump_sticky.cpp" ":" "110" ":") - 1)))));
    for (i32 i = 0; i < buffer_ranges.count; i += 1){
        range_index_buffer_id_pairs[i].index = i;
        range_index_buffer_id_pairs[i].key = jumps.jumps[buffer_ranges.ranges[i].first].jump_buffer_id;
    }
    sort_pairs_by_key(range_index_buffer_id_pairs, buffer_ranges.count);
    Range_i32_Array scoped_buffer_ranges = get_ranges_of_duplicate_keys(scratch,
                                                                        &range_index_buffer_id_pairs->key,
                                                                        sizeof(*range_index_buffer_id_pairs),
                                                                        buffer_ranges.count);

    Sticky_Jump_Stored *stored = ((Sticky_Jump_Stored*)linalloc_wrap_unintialized(linalloc_push((scratch), sizeof(Sticky_Jump_Stored)*(jumps.count), SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_jump_sticky.cpp" ":" "121" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_jump_sticky.cpp" ":" "121" ":") - 1)))));

    Managed_Scope scope_array[2] = {};
    scope_array[0] = buffer_get_managed_scope(app, buffer);

    for (i32 i = 0; i < scoped_buffer_ranges.count; i += 1){
        Range_i32 buffer_range_indices = scoped_buffer_ranges.ranges[i];

        u32 total_jump_count = 0;
        for (i32 j = buffer_range_indices.first;
             j < buffer_range_indices.one_past_last;
             j += 1){
            i32 range_index = range_index_buffer_id_pairs[j].index;
            Range_i32 range = buffer_ranges.ranges[range_index];
            total_jump_count += range_size(range);
        }

        Temp_Memory marker_temp = begin_temp(scratch);
        Marker *markers = ((Marker*)linalloc_wrap_unintialized(linalloc_push((scratch), sizeof(Marker)*(total_jump_count), SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_jump_sticky.cpp" ":" "139" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_jump_sticky.cpp" ":" "139" ":") - 1)))));
        Buffer_ID target_buffer_id = 0;
        u32 marker_index = 0;
        for (i32 j = buffer_range_indices.first;
             j < buffer_range_indices.one_past_last;
             j += 1){
            i32 range_index = range_index_buffer_id_pairs[j].index;
            Range_i32 range = buffer_ranges.ranges[range_index];
            if (target_buffer_id == 0){
                target_buffer_id = jumps.jumps[range.first].jump_buffer_id;
            }
            for (i32 k = range.first; k < range.one_past_last; k += 1){
                markers[marker_index].pos = jumps.jumps[k].jump_pos;
                markers[marker_index].lean_right = false;
                stored[k].list_line = jumps.jumps[k].list_line;
                stored[k].list_colon_index = jumps.jumps[k].list_colon_index;
                stored[k].is_sub_error = jumps.jumps[k].is_sub_error;
                stored[k].jump_buffer_id = jumps.jumps[k].jump_buffer_id;
                stored[k].index_into_marker_array = marker_index;
                marker_index += 1;
            }
        }

        scope_array[1] = buffer_get_managed_scope(app, target_buffer_id);
        Managed_Scope scope = get_managed_scope_with_multiple_dependencies(app, scope_array, ((sizeof(scope_array))/(sizeof(*scope_array))));
        Managed_Object marker_handle = alloc_buffer_markers_on_buffer(app, target_buffer_id, total_jump_count, &scope);
        managed_object_store_data(app, marker_handle, 0, total_jump_count, markers);

        end_temp(marker_temp);

        do{ if (!(managed_object_get_item_size(app, marker_handle) == sizeof(Marker))) { (*((i32*)0) = 0xA11E); } }while(0);
        do{ if (!(managed_object_get_item_count(app, marker_handle) == total_jump_count)) { (*((i32*)0) = 0xA11E); } }while(0);
        do{ if (!(managed_object_get_type(app, marker_handle) == ManagedObjectType_Markers)) { (*((i32*)0) = 0xA11E); } }while(0);

        Managed_Object *marker_handle_ptr = ((Managed_Object*)managed_scope_get_attachment((app), (scope), (sticky_jump_marker_handle), sizeof(Managed_Object)));
        if (marker_handle_ptr != 0){
            *marker_handle_ptr = marker_handle;
        }
    }

    Managed_Object stored_jump_array = alloc_managed_memory_in_scope(app, scope_array[0], sizeof(Sticky_Jump_Stored), jumps.count);
    managed_object_store_data(app, stored_jump_array, 0, jumps.count, stored);

    list->jump_array = stored_jump_array;
    list->jump_count = jumps.count;
    list->previous_size = (i32)buffer_get_size(app, buffer);
    list->buffer_id = buffer;
}

static void
delete_marker_list(Marker_List_Node *node){
    (((marker_list_last)==(node))?((((marker_list_first)==(marker_list_last))?((marker_list_first)=(marker_list_last)=0):((marker_list_last)->prev->next=0,(marker_list_last)=(marker_list_last)->prev))) :((marker_list_first)==(node))?((((marker_list_last)==(marker_list_first))?((marker_list_last)=(marker_list_first)=0):((marker_list_first)->next->prev=0,(marker_list_first)=(marker_list_first)->next))) : ((node)->next->prev=(node)->prev,(node)->prev->next=(node)->next,(node)->next=(node)->prev=0));
}

static void
delete_marker_list(Marker_List *list){
    delete_marker_list((Marker_List_Node*)( (u8*)(list) - ((u8*)(&(((Marker_List_Node*)0)->list)) - (u8*)(0)) ));
}

static Marker_List*
make_new_marker_list_for_buffer(Heap *heap, i32 buffer_id){
    Marker_List_Node *new_node = (Marker_List_Node*)(heap_allocate((heap), sizeof(Marker_List_Node)*(1)));
    (((marker_list_first)==0)?((new_node)->next=(new_node)->prev=0,(marker_list_first)=(marker_list_last)=(new_node)):((new_node)->prev=(marker_list_last),(new_node)->next=0,(marker_list_last)->next=(new_node),(marker_list_last)=(new_node)));
    new_node->buffer_id = buffer_id;
    block_zero((&new_node->list), sizeof(*(&new_node->list)));
    Marker_List *result = &new_node->list;
    return(result);
}

static Marker_List*
get_marker_list_for_buffer(Buffer_ID buffer_id){
    for (Marker_List_Node *node = marker_list_first;
         node != 0;
         node = node->next){
        if (buffer_id == node->buffer_id){
            return(&node->list);
        }
    }
    return(0);
}

static Marker_List*
get_or_make_list_for_buffer(Application_Links *app, Heap *heap, Buffer_ID buffer_id){
    Marker_List *result = get_marker_list_for_buffer(buffer_id);
    if (result != 0){
        i32 buffer_size = (i32)buffer_get_size(app, buffer_id);

        if (result->previous_size != buffer_size){
            delete_marker_list(result);
            result = 0;
        }
    }
    if (result == 0){
        result = make_new_marker_list_for_buffer(heap, buffer_id);
        init_marker_list(app, heap, buffer_id, result);
        if (result->jump_count == 0){
            delete_marker_list(result);
            result = 0;
        }
    }
    return(result);
}

static b32
get_stored_jump_from_list(Application_Links *app, Marker_List *list, i32 index,
                          Sticky_Jump_Stored *stored_out){
    Sticky_Jump_Stored stored = {};
    if (list != 0){
        if (managed_object_load_data(app, list->jump_array, index, 1, &stored)){
            *stored_out = stored;
            return(true);
        }
    }
    return(false);
}

static Sticky_Jump_Stored*
get_all_stored_jumps_from_list(Application_Links *app, Arena *arena, Marker_List *list){
    Sticky_Jump_Stored *stored = 0;
    if (list != 0){
        Temp_Memory restore_point = begin_temp(arena);
        stored = ((Sticky_Jump_Stored*)linalloc_wrap_unintialized(linalloc_push((arena), sizeof(Sticky_Jump_Stored)*(list->jump_count), SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_jump_sticky.cpp" ":" "260" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_jump_sticky.cpp" ":" "260" ":") - 1)))));
        if (stored != 0){
            if (!managed_object_load_data(app, list->jump_array, 0, list->jump_count, stored)){
                stored = 0;
                end_temp(restore_point);
            }
        }
    }
    return(stored);
}

static b32
get_jump_from_list(Application_Links *app, Marker_List *list, i32 index, ID_Pos_Jump_Location *location){
    b32 result = false;
    Sticky_Jump_Stored stored = {};
    if (get_stored_jump_from_list(app, list, index, &stored)){
        Buffer_ID target_buffer_id = stored.jump_buffer_id;

        Managed_Scope scope_array[2] = {};
        scope_array[0] = buffer_get_managed_scope(app, list->buffer_id);
        scope_array[1] = buffer_get_managed_scope(app, target_buffer_id);
        Managed_Scope scope = get_managed_scope_with_multiple_dependencies(app, scope_array, ((sizeof(scope_array))/(sizeof(*scope_array))));

        Managed_Object *marker_array = ((Managed_Object*)managed_scope_get_attachment((app), (scope), (sticky_jump_marker_handle), sizeof(Managed_Object)));
        if (marker_array != 0 && *marker_array != 0){
            Marker marker = {};
            managed_object_load_data(app, *marker_array, stored.index_into_marker_array, 1, &marker);
            location->buffer_id = target_buffer_id;
            location->pos = marker.pos;
            result = true;
        }
    }
    return(result);
}

static i64
get_line_from_list(Application_Links *app, Marker_List *list, i32 index){
    i64 result = 0;
    if (list != 0){
        Sticky_Jump_Stored stored = {};
        if (get_stored_jump_from_list(app, list, index, &stored)){
            result = stored.list_line;
        }
    }
    return(result);
}

static b32
get_is_sub_error_from_list(Application_Links *app, Marker_List *list, i32 index){
    b32 result = false;
    if (list != 0){
        Sticky_Jump_Stored stored = {};
        if (get_stored_jump_from_list(app, list, index, &stored)){
            result = stored.is_sub_error;
        }
    }
    return(result);
}

static i32
get_index_nearest_from_list(Application_Links *app, Marker_List *list, i64 line){
    i32 result = -1;
    if (list != 0){
        Scratch_Block scratch(app);
        Sticky_Jump_Stored *stored = get_all_stored_jumps_from_list(app, scratch, list);
        if (stored != 0){
            result = binary_search((i64*)&stored->list_line, sizeof(*stored), list->jump_count, line);
        }
    }
    return(result);
}

static i32
get_index_exact_from_list(Application_Links *app, Marker_List *list, i64 line){
    i32 result = -1;
    if (list != 0){
        Scratch_Block scratch(app);
        Sticky_Jump_Stored *stored = get_all_stored_jumps_from_list(app, scratch, list);
        if (stored != 0){
            i32 index = binary_search((i64*)&stored->list_line, sizeof(*stored), list->jump_count, line);
            if (stored[index].list_line == line){
                result = index;
            }
        }
    }
    return(result);
}

CUSTOM_COMMAND(goto_jump_at_cursor, "/home/sam/.bin/4coder/custom/4coder_jump_sticky.cpp", 348, Normal)
CUSTOM_DOC("If the cursor is found to be on a jump location, parses the jump location and brings up the file and position in another view and changes the active panel to the view containing the jump.")
{
    Heap *heap = &global_heap;

    View_ID view = get_active_view(app, Access_ReadVisible);
    Buffer_ID buffer = view_get_buffer(app, view, Access_ReadVisible);
    Marker_List *list = get_or_make_list_for_buffer(app, heap, buffer);

    i64 pos = view_get_cursor_pos(app, view);
    Buffer_Cursor cursor = buffer_compute_cursor(app, buffer, seek_pos(pos));

    i32 list_index = get_index_exact_from_list(app, list, cursor.line);

    if (list_index >= 0){
        ID_Pos_Jump_Location location = {};
        if (get_jump_from_list(app, list, list_index, &location)){
            if (get_jump_buffer(app, &buffer, &location)){
                change_active_panel(app);
                View_ID target_view = get_active_view(app, Access_Always);
                switch_to_existing_view(app, target_view, buffer);
                jump_to_location(app, target_view, buffer, location);
            }
        }
    }
}

CUSTOM_COMMAND(goto_jump_at_cursor_same_panel, "/home/sam/.bin/4coder/custom/4coder_jump_sticky.cpp", 375, Normal)
CUSTOM_DOC("If the cursor is found to be on a jump location, parses the jump location and brings up the file and position in this view, losing the compilation output or jump list.")
{
    Heap *heap = &global_heap;

    View_ID view = get_active_view(app, Access_ReadVisible);
    Buffer_ID buffer = view_get_buffer(app, view, Access_ReadVisible);

    Marker_List *list = get_or_make_list_for_buffer(app, heap, buffer);

    i64 pos = view_get_cursor_pos(app, view);
    Buffer_Cursor cursor = buffer_compute_cursor(app, buffer, seek_pos(pos));

    i32 list_index = get_index_exact_from_list(app, list, cursor.line);

    if (list_index >= 0){
        ID_Pos_Jump_Location location = {};
        if (get_jump_from_list(app, list, list_index, &location)){
            if (get_jump_buffer(app, &buffer, &location)){
                jump_to_location(app, view, buffer, location);
            }
        }
    }
}

static void
goto_jump_in_order(Application_Links *app, Marker_List *list, View_ID jump_view, ID_Pos_Jump_Location location){
    Buffer_ID buffer = {};
    if (get_jump_buffer(app, &buffer, &location)){
        View_ID target_view = get_active_view(app, Access_Always);
        if (target_view == jump_view){
            change_active_panel(app);
            target_view = get_active_view(app, Access_Always);
        }
        switch_to_existing_view(app, target_view, buffer);
        jump_to_location(app, target_view, buffer, location);
        prev_location = location;
    }
}

static b32
jump_is_repeat(ID_Pos_Jump_Location prev, ID_Pos_Jump_Location location){
    return(prev.buffer_id == location.buffer_id && prev.pos == location.pos);
}

static void
goto_next_filtered_jump(Application_Links *app, Marker_List *list, View_ID jump_view, i32 list_index, i32 direction, b32 skip_repeats, b32 skip_sub_errors){
    do{ if (!(direction == 1 || direction == -1)) { (*((i32*)0) = 0xA11E); } }while(0);

    if (list != 0){
        for (;list_index >= 0 && list_index < list->jump_count;){
            ID_Pos_Jump_Location location = {};
            if (get_jump_from_list(app, list, list_index, &location)){
                b32 skip_this = false;
                if (skip_repeats && jump_is_repeat(prev_location, location)){
                    skip_this = true;
                }
                else if (skip_sub_errors && get_is_sub_error_from_list(app, list, list_index)){
                    skip_this = true;
                }

                if (!skip_this){
                    goto_jump_in_order(app, list, jump_view, location);
                    i64 updated_line = get_line_from_list(app, list, list_index);
                    view_set_cursor_and_preferred_x(app, jump_view, seek_line_col(updated_line, 1));
                    break;
                }
            }

            list_index += direction;
        }
    }
}

static Locked_Jump_State
get_locked_jump_state(Application_Links *app, Heap *heap){
    Locked_Jump_State result = {};
    result.view = get_view_for_locked_jump_buffer(app);
    if (result.view != 0){
        Buffer_ID buffer = view_get_buffer(app, result.view, Access_Always);
        result.list = get_or_make_list_for_buffer(app, heap, buffer);

        i64 cursor_position = view_get_cursor_pos(app, result.view);
        Buffer_Cursor cursor = buffer_compute_cursor(app, buffer, seek_pos(cursor_position));
        result.list_index = get_index_nearest_from_list(app, result.list, cursor.line);
    }
    return(result);
}

CUSTOM_COMMAND(goto_next_jump, "/home/sam/.bin/4coder/custom/4coder_jump_sticky.cpp", 464, Normal)
CUSTOM_DOC("If a buffer containing jump locations has been locked in, goes to the next jump in the buffer, skipping sub jump locations.")
{
    Heap *heap = &global_heap;

    Locked_Jump_State jump_state = get_locked_jump_state(app, heap);
    if (jump_state.view != 0){
        i64 cursor_position = view_get_cursor_pos(app, jump_state.view);
        Buffer_Cursor cursor = view_compute_cursor(app, jump_state.view, seek_pos(cursor_position));
        i64 line = get_line_from_list(app, jump_state.list, jump_state.list_index);
        if (line <= cursor.line){
            jump_state.list_index += 1;
        }
        goto_next_filtered_jump(app, jump_state.list, jump_state.view, jump_state.list_index, 1, true, true);
    }
}

CUSTOM_COMMAND(goto_prev_jump, "/home/sam/.bin/4coder/custom/4coder_jump_sticky.cpp", 481, Normal)
CUSTOM_DOC("If a buffer containing jump locations has been locked in, goes to the previous jump in the buffer, skipping sub jump locations."){
    Heap *heap = &global_heap;

    Locked_Jump_State jump_state = get_locked_jump_state(app, heap);
    if (jump_state.view != 0){
        if (jump_state.list_index > 0){
            --jump_state.list_index;
        }
        goto_next_filtered_jump(app, jump_state.list, jump_state.view, jump_state.list_index, -1, true, true);
    }
}

CUSTOM_COMMAND(goto_next_jump_no_skips, "/home/sam/.bin/4coder/custom/4coder_jump_sticky.cpp", 494, Normal)
CUSTOM_DOC("If a buffer containing jump locations has been locked in, goes to the next jump in the buffer, and does not skip sub jump locations.")
{
    Heap *heap = &global_heap;

    Locked_Jump_State jump_state = get_locked_jump_state(app, heap);
    if (jump_state.view != 0){
        i64 cursor_position = view_get_cursor_pos(app, jump_state.view);
        Buffer_Cursor cursor = view_compute_cursor(app, jump_state.view, seek_pos(cursor_position));
        i64 line = get_line_from_list(app, jump_state.list, jump_state.list_index);
        if (line <= cursor.line){
            ++jump_state.list_index;
        }
        goto_next_filtered_jump(app, jump_state.list, jump_state.view, jump_state.list_index, 1, true, false);
    }
}

CUSTOM_COMMAND(goto_prev_jump_no_skips, "/home/sam/.bin/4coder/custom/4coder_jump_sticky.cpp", 511, Normal)
CUSTOM_DOC("If a buffer containing jump locations has been locked in, goes to the previous jump in the buffer, and does not skip sub jump locations.")
{
    Heap *heap = &global_heap;

    Locked_Jump_State jump_state = get_locked_jump_state(app, heap);
    if (jump_state.view != 0){
        if (jump_state.list_index > 0){
            --jump_state.list_index;
        }
        goto_next_filtered_jump(app, jump_state.list, jump_state.view, jump_state.list_index, -1, true, false);
    }
}

CUSTOM_COMMAND(goto_first_jump, "/home/sam/.bin/4coder/custom/4coder_jump_sticky.cpp", 525, Normal)
CUSTOM_DOC("If a buffer containing jump locations has been locked in, goes to the first jump in the buffer.")
{
    Heap *heap = &global_heap;

    Locked_Jump_State jump_state = get_locked_jump_state(app, heap);
    if (jump_state.view != 0){
        i32 list_index = 0;
        ID_Pos_Jump_Location location = {};
        if (get_jump_from_list(app, jump_state.list, list_index, &location)){
            goto_jump_in_order(app, jump_state.list, jump_state.view, location);
            i64 updated_line = get_line_from_list(app, jump_state.list, list_index);
            view_set_cursor_and_preferred_x(app, jump_state.view, seek_line_col(updated_line, 1));
        }
    }
}

CUSTOM_COMMAND(goto_first_jump_same_panel_sticky, "/home/sam/.bin/4coder/custom/4coder_jump_sticky.cpp", 542, Normal)
CUSTOM_DOC("If a buffer containing jump locations has been locked in, goes to the first jump in the buffer and views the buffer in the panel where the jump list was.")
{
    Heap *heap = &global_heap;

    Locked_Jump_State jump_state = get_locked_jump_state(app, heap);
    if (jump_state.view != 0){
        i32 list_index = 0;
        ID_Pos_Jump_Location location = {};
        if (get_jump_from_list(app, jump_state.list, list_index, &location)){
            Buffer_ID buffer = {};
            if (get_jump_buffer(app, &buffer, &location)){
                jump_to_location(app, jump_state.view, buffer, location);
            }
        }
    }
}





CUSTOM_COMMAND(if_read_only_goto_position, "/home/sam/.bin/4coder/custom/4coder_jump_sticky.cpp", 564, Normal)
CUSTOM_DOC("If the buffer in the active view is writable, inserts a character, otherwise performs goto_jump_at_cursor.")
{
    View_ID view = get_active_view(app, Access_ReadVisible);
    Buffer_ID buffer = view_get_buffer(app, view, Access_ReadWriteVisible);
    if (buffer == 0){
        buffer = view_get_buffer(app, view, Access_ReadVisible);
        if (buffer != 0){
            goto_jump_at_cursor(app);
            lock_jump_buffer(app, buffer);
        }
    }
    else{
        leave_current_input_unhandled(app);
    }
}

CUSTOM_COMMAND(if_read_only_goto_position_same_panel, "/home/sam/.bin/4coder/custom/4coder_jump_sticky.cpp", 581, Normal)
CUSTOM_DOC("If the buffer in the active view is writable, inserts a character, otherwise performs goto_jump_at_cursor_same_panel.")
{
    View_ID view = get_active_view(app, Access_ReadVisible);
    Buffer_ID buffer = view_get_buffer(app, view, Access_ReadWriteVisible);
    if (buffer == 0){
        buffer = view_get_buffer(app, view, Access_ReadVisible);
        if (buffer != 0){
            goto_jump_at_cursor_same_panel(app);
            lock_jump_buffer(app, buffer);
        }
    }
    else{
        leave_current_input_unhandled(app);
    }
}





i32 default_end_buffer(Application_Links *app, Buffer_ID buffer_id);
i32 end_buffer_close_jump_list(Application_Links *app, Buffer_ID buffer_id){
    Marker_List *list = get_marker_list_for_buffer(buffer_id);
    if (list != 0){
        delete_marker_list(list);
    }
    default_end_buffer(app, buffer_id);
    return(0);
}
# 113 "/home/sam/.bin/4coder/custom/4coder_default_include.cpp" 2
# 1 "/home/sam/.bin/4coder/custom/4coder_jump_lister.cpp" 1






static Jump_Lister_Result
get_jump_index_from_user(Application_Links *app, Marker_List *list,
                         String_Const_u8 query){
    Jump_Lister_Result result = {};
    if (list != 0){
        Scratch_Block scratch(app);
        Lister_Block lister(app, scratch);
        lister_set_query(lister, query);
        lister_set_default_handlers(lister);

        Buffer_ID list_buffer = list->buffer_id;

        i32 option_count = list->jump_count;
        Managed_Object stored_jumps = list->jump_array;
        for (i32 i = 0; i < option_count; i += 1){
            Sticky_Jump_Stored stored = {};
            managed_object_load_data(app, stored_jumps, i, 1, &stored);
            String_Const_u8 line = push_buffer_line(app, scratch, list_buffer,
                                                    stored.list_line);
            lister_add_item(lister, line, SCu8(), (void*)(((u8*)0) + i), 0);
        }

        Lister_Result l_result = run_lister(app, lister);
        if (!l_result.canceled){
            result.success = true;
            result.index = (i32)((u8*)(l_result.user_data) - (u8*)(0));
        }
    }

    return(result);
}

static Jump_Lister_Result
get_jump_index_from_user(Application_Links *app, Marker_List *list, char *query){
    return(get_jump_index_from_user(app, list, SCu8(query)));
}

static void
jump_to_jump_lister_result(Application_Links *app, View_ID view,
                           Marker_List *list, Jump_Lister_Result *jump){
    if (jump->success){
        ID_Pos_Jump_Location location = {};
        if (get_jump_from_list(app, list, jump->index, &location)){
            Buffer_ID jump_dst_buffer = {};
            if (get_jump_buffer(app, &jump_dst_buffer, &location)){
                view_set_active(app, view);
                jump_to_location(app, view, jump_dst_buffer, location);
            }
        }
    }
}

CUSTOM_COMMAND(view_jump_list_with_lister, "/home/sam/.bin/4coder/custom/4coder_jump_lister.cpp", 59, Normal)
CUSTOM_DOC("When executed on a buffer with jumps, creates a persistent lister for all the jumps")
{
    Heap *heap = &global_heap;
    View_ID view = get_active_view(app, Access_Always);
    Buffer_ID buffer = view_get_buffer(app, view, Access_Always);
    Marker_List *list = get_or_make_list_for_buffer(app, heap, buffer);
    if (list != 0){
        Jump_Lister_Result jump = get_jump_index_from_user(app, list, "Jump:");
        jump_to_jump_lister_result(app, view, list, &jump);
    }
}
# 114 "/home/sam/.bin/4coder/custom/4coder_default_include.cpp" 2
# 1 "/home/sam/.bin/4coder/custom/4coder_code_index_listers.cpp" 1






struct Tiny_Jump{
    Buffer_ID buffer;
    i64 pos;
};

CUSTOM_COMMAND(jump_to_definition, "/home/sam/.bin/4coder/custom/4coder_code_index_listers.cpp", 12, UI)
CUSTOM_DOC("List all definitions in the code index and jump to one chosen by the user.")
{
    char *query = "Definition:";

    Scratch_Block scratch(app);
    Lister_Block lister(app, scratch);
    lister_set_query(lister, query);
    lister_set_default_handlers(lister);

    code_index_lock();
    for (Buffer_ID buffer = get_buffer_next(app, 0, Access_Always);
         buffer != 0;
         buffer = get_buffer_next(app, buffer, Access_Always)){
        Code_Index_File *file = code_index_get_file(buffer);
        if (file != 0){
            for (i32 i = 0; i < file->note_array.count; i += 1){
                Code_Index_Note *note = file->note_array.ptrs[i];
                Tiny_Jump *jump = ((Tiny_Jump*)linalloc_wrap_unintialized(linalloc_push((scratch), sizeof(Tiny_Jump)*(1), SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_code_index_listers.cpp" ":" "30" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_code_index_listers.cpp" ":" "30" ":") - 1)))));
                jump->buffer = buffer;
                jump->pos = note->pos.first;

                String_Const_u8 sort = {};
                switch (note->note_kind){
                    case CodeIndexNote_Type:
                    {
                        sort = SCu8((u8*)("type"), (u64)(sizeof("type") - 1));
                    }break;
                    case CodeIndexNote_Function:
                    {
                        sort = SCu8((u8*)("function"), (u64)(sizeof("function") - 1));
                    }break;
                    case CodeIndexNote_Macro:
                    {
                        sort = SCu8((u8*)("macro"), (u64)(sizeof("macro") - 1));
                    }break;
                }
                lister_add_item(lister, note->text, sort, jump, 0);
            }
        }
    }
    code_index_unlock();

    Lister_Result l_result = run_lister(app, lister);
    Tiny_Jump result = {};
    if (!l_result.canceled && l_result.user_data != 0){
        block_copy((&result), ((Tiny_Jump*)l_result.user_data), sizeof(*(&result)));
    }

    if (result.buffer != 0){
        View_ID view = get_this_ctx_view(app, Access_Always);
        point_stack_push_view_cursor(app, view);
        jump_to_location(app, view, result.buffer, result.pos);
    }
}

CUSTOM_COMMAND(jump_to_definition_at_cursor, "/home/sam/.bin/4coder/custom/4coder_code_index_listers.cpp", 68, UI)
CUSTOM_DOC("Jump to the first definition in the code index matching an identifier at the cursor")
{
    View_ID view = get_active_view(app, Access_Visible);

    if (view != 0){
        Scratch_Block scratch(app);
        String_Const_u8 query = push_token_or_word_under_active_cursor(app, scratch);

        code_index_lock();
        for (Buffer_ID buffer = get_buffer_next(app, 0, Access_Always);
             buffer != 0;
             buffer = get_buffer_next(app, buffer, Access_Always)){
            Code_Index_File *file = code_index_get_file(buffer);
            if (file != 0){
                for (i32 i = 0; i < file->note_array.count; i += 1){
                    Code_Index_Note *note = file->note_array.ptrs[i];
                    if (string_match(note->text, query)){
                        point_stack_push_view_cursor(app, view);
                        jump_to_location(app, view, buffer, note->pos.first);
                        goto done;
                    }
                }
            }
        }
        done:;
        code_index_unlock();
    }
}
# 115 "/home/sam/.bin/4coder/custom/4coder_default_include.cpp" 2
# 1 "/home/sam/.bin/4coder/custom/4coder_log_parser.cpp" 1
# 12 "/home/sam/.bin/4coder/custom/4coder_log_parser.cpp"
static u64
log_parse__string_code(Log_Parse *parse, String_Const_u8 string, Log_String_Source string_source){
    u64 result = 0;
    if (string.size > 0){
        Data data = make_data(string.str, string.size);
        Table_Lookup lookup = table_lookup(&parse->string_to_id_table, data);
        if (lookup.found_match){
            table_read(&parse->string_to_id_table, lookup, &result);
        }
        else{
            if (string_source == LogParse_ExternalString){
                data = push_data_copy(parse->arena, data);
            }
            result = parse->string_id_counter;
            parse->string_id_counter += 1;
            table_insert(&parse->string_to_id_table, data, result);
            table_insert(&parse->id_to_string_table, result, data);
        }
    }
    return(result);
}

static String_Const_u8
log_parse__get_string(Log_Parse *parse, u64 code){
    Table_Lookup lookup = table_lookup(&parse->id_to_string_table, code);
    String_Const_u8 result = {};
    if (lookup.found_match){
        Data val = {};
        table_read(&parse->id_to_string_table, lookup, &val);
        result = SCu8(val.data, val.size);
    }
    return(result);
}

static Log_Event*
log_parse__event(Log_Parse *parse,
                 String_Const_u8 file_name, String_Const_u8 line_number, String_Const_u8 event_name){
    Log_Event *new_event = ((Log_Event*)linalloc_wrap_unintialized(linalloc_push((parse->arena), sizeof(Log_Event)*(1), SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_log_parser.cpp" ":" "49" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_log_parser.cpp" ":" "49" ":") - 1)))));
    do{ if((new_event)){if((parse->first_event)){(parse->last_event)->next=(new_event);}else{(parse->first_event)=(new_event);}(parse->last_event)=(new_event);(parse->last_event)->next=0;} }while(0);
    parse->event_count += 1;
    new_event->src_file_name = log_parse__string_code(parse, file_name, LogParse_ExternalString);
    new_event->event_name = log_parse__string_code(parse, event_name, LogParse_ExternalString);
    new_event->line_number = string_to_integer(line_number, 10);
    new_event->event_number = parse->event_count;
    return(new_event);
}

static Log_Tag*
log_parse__tag(Log_Parse *parse, Log_Event *event, String_Const_u8 tag_name, String_Const_u8 tag_value){
    Log_Tag *new_tag = ((Log_Tag*)linalloc_wrap_unintialized(linalloc_push((parse->arena), sizeof(Log_Tag)*(1), SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_log_parser.cpp" ":" "61" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_log_parser.cpp" ":" "61" ":") - 1)))));
    do{ if((new_tag)){if((event->first_tag)){(event->last_tag)->next=(new_tag);}else{(event->first_tag)=(new_tag);}(event->last_tag)=(new_tag);(event->last_tag)->next=0;} }while(0);
    event->tag_count += 1;
    new_tag->name = log_parse__string_code(parse, tag_name, LogParse_ExternalString);
    if (tag_value.size == 0){
        new_tag->value.kind = LogTagKind_String;
        new_tag->value.value = 0;
    }
    else{
        if (tag_value.str[0] == '"'){
            if (tag_value.size == 1){
                new_tag->value.kind = LogTagKind_String;
                new_tag->value.value = 0;
            }
            else{
                tag_value = string_skip(tag_value, 1);
                if (tag_value.str[tag_value.size - 1] == '"'){
                    tag_value = string_chop(tag_value, 1);
                }
                String_Const_u8 escape = string_interpret_escapes(parse->arena, tag_value);
                new_tag->value.kind = LogTagKind_String;
                new_tag->value.value = log_parse__string_code(parse, escape, LogParse_PreAllocatedString);
            }
        }
        else{
            new_tag->value.kind = LogTagKind_Integer;
            b32 is_negative = false;
            if (string_match(string_prefix(tag_value, 1), SCu8((u8*)("-"), (u64)(sizeof("-") - 1)))){
                tag_value = string_skip(tag_value, 1);
                is_negative = true;
            }
            if (string_match(string_prefix(tag_value, 2), SCu8((u8*)("0x"), (u64)(sizeof("0x") - 1)))){
                tag_value = string_skip(tag_value, 2);
                new_tag->value.value_s = (i64)string_to_integer(tag_value, 16);
            }
            else{
                new_tag->value.value_s = (i64)string_to_integer(tag_value, 10);
            }
            if (is_negative){
                new_tag->value.value_s = -new_tag->value.value_s;
            }
        }
    }
    return(new_tag);
}

static Log_Event_List*
log_parse_get_list_tag_value(Log_Parse *parse, u64 name, Log_Tag_Value value){
    Log_Event_List *result = 0;
    Log_Tag_Name_Value key = {name, value};
    Table_Lookup lookup = table_lookup(&parse->tag_value_to_event_list_table, make_data((&key), sizeof(*(&key))));
    if (lookup.found_match){
        u64 val = 0;
        table_read(&parse->tag_value_to_event_list_table, lookup, &val);
        result = (Log_Event_List*)(void*)(((u8*)0) + val);
    }
    return(result);
}

static Log_Event_List*
log_parse__get_or_make_list_tag_value(Log_Parse *parse, Log_Tag *tag){
    Log_Event_List *result = 0;
    Log_Tag_Name_Value key = {tag->name, tag->value};
 Data data_key = make_data((&key), sizeof(*(&key)));
    Table_Lookup lookup = table_lookup(&parse->tag_value_to_event_list_table, data_key);
    if (lookup.found_match){
        u64 val = 0;
        table_read(&parse->tag_value_to_event_list_table, lookup, &val);
        result = (Log_Event_List*)(void*)(((u8*)0) + val);
    }
    else{
        result = ((Log_Event_List*)linalloc_wrap_zero(linalloc_push((parse->arena), sizeof(Log_Event_List)*(1), SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_log_parser.cpp" ":" "132" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_log_parser.cpp" ":" "132" ":") - 1)))));
        table_insert(&parse->tag_value_to_event_list_table, push_data_copy(parse->arena, data_key),
                     (u64)((u8*)(result) - (u8*)(0)));
    }
    return(result);
}

static Log_Event_List*
log_parse_get_list_tag_name(Log_Parse *parse, u64 name){
    Log_Event_List *result = 0;
    Table_Lookup lookup = table_lookup(&parse->tag_name_to_event_list_table, name);
    if (lookup.found_match){
        u64 val = 0;
        table_read(&parse->tag_name_to_event_list_table, lookup, &val);
        result = (Log_Event_List*)(void*)(((u8*)0) + val);
    }
    return(result);
}

static Log_Event_List*
log_parse__get_or_make_list_tag_name(Log_Parse *parse, Log_Tag *tag){
    Log_Event_List *result = 0;
    Table_Lookup lookup = table_lookup(&parse->tag_name_to_event_list_table, tag->name);
    if (lookup.found_match){
        u64 val = 0;
        table_read(&parse->tag_name_to_event_list_table, lookup, &val);
        result = (Log_Event_List*)(void*)(((u8*)0) + val);
    }
    else{
        result = ((Log_Event_List*)linalloc_wrap_zero(linalloc_push((parse->arena), sizeof(Log_Event_List)*(1), SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_log_parser.cpp" ":" "161" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_log_parser.cpp" ":" "161" ":") - 1)))));
        table_insert(&parse->tag_name_to_event_list_table, tag->name, (u64)((u8*)(result) - (u8*)(0)));
    }
    return(result);
}

static Log_Parse
make_log_parse(Arena *arena, String_Const_u8 source){
    Log_Parse parse = {};
    parse.arena = arena;
    parse.string_id_counter = 1;
    parse.string_to_id_table = make_table_Data_u64__inner((arena->base_allocator),(500),SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_log_parser.cpp" ":" "172" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_log_parser.cpp" ":" "172" ":") - 1)));
    parse.id_to_string_table = make_table_u64_Data__inner((arena->base_allocator),(500),SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_log_parser.cpp" ":" "173" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_log_parser.cpp" ":" "173" ":") - 1)));

    for (;source.size > 0;){
        u64 end_of_line = string_find_first(source, '\n');
        String_Const_u8 line = string_prefix(source, end_of_line);
        line = string_skip_chop_whitespace(line);
        source = string_skip(source, end_of_line + 1);

        String_Const_u8 src_file_name = {};
        String_Const_u8 src_line_number = {};
        b32 got_source_position = false;

        String_Const_u8 whole_line = line;

        {
            u64 colon1 = string_find_first(line, ':');
            src_file_name = string_prefix(line, colon1);
            line = string_skip(line, colon1 + 1);

            u64 colon2 = string_find_first(line, ':');
            src_line_number = string_prefix(line, colon2);
            line = string_skip(line, colon2 + 1);

            if (string_is_integer(src_line_number, 10)){
                got_source_position = true;
            }
        }

        if (!got_source_position){
            line = whole_line;

            u64 colon0 = string_find_first(line, ':');
            u64 colon1 = string_find_first(line, colon0 + 1, ':');
            src_file_name = string_prefix(line, colon1);
            line = string_skip(line, colon1 + 1);

            u64 colon2 = string_find_first(line, ':');
            src_line_number = string_prefix(line, colon2);
            line = string_skip(line, colon2 + 1);

            if (string_is_integer(src_line_number, 10)){
                got_source_position = true;
            }
        }

        if (got_source_position){
            u64 bracket_open = string_find_first(line, '[');
            String_Const_u8 event_name = string_prefix(line, bracket_open);
            event_name = string_skip_chop_whitespace(event_name);
            line = string_skip(line, bracket_open + 1);

            Log_Event *event = log_parse__event(&parse,
                                                src_file_name, src_line_number, event_name);

            for (;line.size > 0;){
                u64 bracket_close = string_find_first(line, ']');
                String_Const_u8 tag = string_prefix(line, bracket_close);
                line = string_skip(line, bracket_close + 1);
                bracket_open = string_find_first(line, '[');
                line = string_skip(line, bracket_open + 1);

                u64 equal_sign = string_find_first(tag, '=');
                String_Const_u8 tag_name = string_prefix(tag, equal_sign);
                String_Const_u8 tag_contents = string_skip(tag, equal_sign + 1);

                log_parse__tag(&parse, event, tag_name, tag_contents);
            }
        }
    }





    parse.tag_value_to_event_list_table = make_table_Data_u64__inner((arena->base_allocator),(((1)*1000)),SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_log_parser.cpp" ":" "247" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_log_parser.cpp" ":" "247" ":") - 1)));
    parse.tag_name_to_event_list_table = make_table_u64_u64__inner((arena->base_allocator),(100),SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_log_parser.cpp" ":" "248" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_log_parser.cpp" ":" "248" ":") - 1)));

    for (Log_Event *event = parse.first_event;
         event != 0;
         event = event->next){
        for (Log_Tag *tag = event->first_tag;
             tag != 0;
             tag = tag->next){
            {
                Log_Event_List *list = log_parse__get_or_make_list_tag_value(&parse, tag);
                Log_Event_Ptr_Node *node = ((Log_Event_Ptr_Node*)linalloc_wrap_unintialized(linalloc_push((arena), sizeof(Log_Event_Ptr_Node)*(1), SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_log_parser.cpp" ":" "258" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_log_parser.cpp" ":" "258" ":") - 1)))));
                do{ if((node)){if((list->first)){(list->last)->next=(node);}else{(list->first)=(node);}(list->last)=(node);(list->last)->next=0;} }while(0);
                list->count += 1;
                node->event = event;
            }
            {
                Log_Event_List *list = log_parse__get_or_make_list_tag_name(&parse, tag);
                Log_Event_Ptr_Node *node = ((Log_Event_Ptr_Node*)linalloc_wrap_unintialized(linalloc_push((arena), sizeof(Log_Event_Ptr_Node)*(1), SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_log_parser.cpp" ":" "265" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_log_parser.cpp" ":" "265" ":") - 1)))));
                do{ if((node)){if((list->first)){(list->last)->next=(node);}else{(list->first)=(node);}(list->last)=(node);(list->last)->next=0;} }while(0);
                list->count += 1;
                node->event = event;
            }
        }
    }

    for (Log_Event *event = parse.first_event;
         event != 0;
         event = event->next){
        i32 slot_count = event->tag_count*3/2;
        event->tag_name_to_tag_ptr_table = make_table_u64_u64__inner((arena->base_allocator),(slot_count),SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_log_parser.cpp" ":" "277" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_log_parser.cpp" ":" "277" ":") - 1)));
        for (Log_Tag *tag = event->first_tag;
             tag != 0;
             tag = tag->next){
            table_insert(&event->tag_name_to_tag_ptr_table, tag->name, (u64)((u8*)(tag) - (u8*)(0)));
        }
    }

    return(parse);
}



static void
log_events_sort_by_tag__inner(Log_Event **events, Log_Sort_Key *keys, i32 first, i32 one_past_last){
    if (first + 1 < one_past_last){
        i32 pivot_index = one_past_last - 1;
        Log_Sort_Key *pivot_key = keys + pivot_index;
        i32 j = first;
        for (i32 i = first; i < one_past_last; i += 1){
            Log_Sort_Key *key = keys + i;
            b32 key_is_less_than_pivot_key = false;
            if (key->value.kind < pivot_key->value.kind){
                key_is_less_than_pivot_key = true;
            }
            else if (key->value.kind == pivot_key->value.kind){
                if (key->value.value < pivot_key->value.value){
                    key_is_less_than_pivot_key = true;
                }
                else if (key->value.value == pivot_key->value.value){
                    if (key->number < pivot_key->number){
                        key_is_less_than_pivot_key = true;
                    }
                }
            }
            if (key_is_less_than_pivot_key){
                if (j < i){
                    do { Log_Event* hidden_temp_314 = events[i]; events[i] = events[j]; events[j] = hidden_temp_314; } while(0);
                    do { Log_Sort_Key hidden_temp_315 = keys[i]; keys[i] = keys[j]; keys[j] = hidden_temp_315; } while(0);
                }
                j += 1;
            }
        }
        do { Log_Event* hidden_temp_320 = events[pivot_index]; events[pivot_index] = events[j]; events[j] = hidden_temp_320; } while(0);
        do { Log_Sort_Key hidden_temp_321 = keys[pivot_index]; keys[pivot_index] = keys[j]; keys[j] = hidden_temp_321; } while(0);
        log_events_sort_by_tag__inner(events, keys, first, j);
        log_events_sort_by_tag__inner(events, keys, j + 1, one_past_last);
    }
}

static void
log_events_sort_by_tag(Arena *scratch, Log_Event_Ptr_Array array, u64 tag_name){
    Temp_Memory temp = begin_temp(scratch);
    Log_Sort_Key *keys = ((Log_Sort_Key*)linalloc_wrap_unintialized(linalloc_push((scratch), sizeof(Log_Sort_Key)*(array.count), SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_log_parser.cpp" ":" "330" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_log_parser.cpp" ":" "330" ":") - 1)))));
    for (i32 i = 0; i < array.count; i += 1){
        Log_Event *event = array.events[i];
        Table_Lookup lookup = table_lookup(&event->tag_name_to_tag_ptr_table, tag_name);
        if (lookup.found_match){
            u64 read_val = 0;
            table_read(&event->tag_name_to_tag_ptr_table, lookup, &read_val);
            Log_Tag *tag = (Log_Tag*)(void*)(((u8*)0) + read_val);
            keys[i].value = tag->value;
        }
        else{
            keys[i].value.kind = LogTagKind_Null;
            keys[i].value.value = 0;
        }
        keys[i].number = event->event_number;
    }

    log_events_sort_by_tag__inner(array.events, keys, 0, array.count);

    end_temp(temp);
}

static Log_Event_Ptr_Array
log_event_array_from_list(Arena *arena, Log_Event_List list){
    Log_Event_Ptr_Array array = {};
    array.count = list.count;
    array.events = ((Log_Event**)linalloc_wrap_unintialized(linalloc_push((arena), sizeof(Log_Event*)*(array.count), SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_log_parser.cpp" ":" "356" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_log_parser.cpp" ":" "356" ":") - 1)))));
    i32 counter = 0;
    for (Log_Event_Ptr_Node *node = list.first;
         node != 0;
         node = node->next){
        array.events[counter] = node->event;
        counter += 1;
    }
    return(array);
}



static View_ID log_view = 0;
static Arena log_arena = {};
static Log_Parse log_parse = {};
static Log_Graph log_graph = {};
static Log_Filter_Set log_filter_set = {};
static Log_Filter_Set log_preview_set = {};

static void
log_filter_set_init(Log_Filter_Set *set){
    block_zero((set), sizeof(*(set)));
    for (i32 i = ((sizeof(set->filters_memory))/(sizeof(*set->filters_memory))) - 1; i >= 0; i -= 1){
        ((&set->filters_memory[i])->next=(set->free_filters),(set->free_filters)=(&set->filters_memory[i]));
    }
}

static Log_Filter_Set*
log_filter_set_from_tab(Log_Graph_List_Tab tab){
    Log_Filter_Set *result = 0;
    switch (tab){
        case LogTab_Filters:
        {
            result = &log_filter_set;
        }break;
        case LogTab_Previews:
        {
            result = &log_preview_set;
        }break;
    }
    return(result);
}

static Log_Filter*
log_filter_set__new_filter(Log_Filter_Set *set, Log_Filter *prototype){
    Log_Filter *result = set->free_filters;
    if (result != 0){
        for (Log_Filter *filter = set->first;
             filter != 0;
             filter = filter->next){
            if (filter->kind == prototype->kind &&
                filter->tag_name_code == prototype->tag_name_code &&
                block_match((&filter->tag_value), (&prototype->tag_value), sizeof(*(&filter->tag_value)))){
                result = 0;
                break;
            }
        }
        if (result != 0){
            ((set->free_filters)=(set->free_filters)=(set->free_filters)->next);
            block_copy((result), (prototype), sizeof(*(result)));
            (((set->first)==0)?((result)->next=(result)->prev=0,(set->first)=(set->last)=(result)):((result)->prev=(set->last),(result)->next=0,(set->last)->next=(result),(set->last)=(result)));
            set->count += 1;
            set->alter_counter += 1;
        }
    }
    return(result);
}

static void
log_filter_set__free_filter(Log_Filter_Set *set, Log_Filter *filter){
    (((set->last)==(filter))?((((set->first)==(set->last))?((set->first)=(set->last)=0):((set->last)->prev->next=0,(set->last)=(set->last)->prev))) :((set->first)==(filter))?((((set->last)==(set->first))?((set->last)=(set->first)=0):((set->first)->next->prev=0,(set->first)=(set->first)->next))) : ((filter)->next->prev=(filter)->prev,(filter)->prev->next=(filter)->next,(filter)->next=(filter)->prev=0));
    set->count -= 1;
    set->alter_counter += 1;
    ((filter)->next=(set->free_filters),(set->free_filters)=(filter));
}

static void
log_graph_fill(Application_Links *app, Rect_f32 layout_region, Face_ID face_id){
    if (log_parse.arena != 0){
        if (log_graph.holding_temp){
            end_temp(log_graph.temp);
        }
        block_zero((&log_graph), sizeof(*(&log_graph)));
        log_graph.holding_temp = true;
        log_graph.temp = begin_temp(&log_arena);
        log_graph.layout_region = layout_region;
        log_graph.face_id = face_id;
        log_graph.filter_alter_counter = log_filter_set.alter_counter;
        log_graph.preview_alter_counter = log_preview_set.alter_counter;
        log_graph.tab = LogTab_Filters;

        f32 details_h = rect_height(layout_region)*.22f;
        details_h = (((details_h)<(250.f))?(details_h):(250.f));

        Rect_f32 details_region = Rf32(layout_region.x0, layout_region.y0,
                                       layout_region.x1, layout_region.y0 + details_h);
        Rect_f32 event_list_region = Rf32(layout_region.x0, layout_region.y0 + details_h,
                                          layout_region.x1, layout_region.y1);

        log_graph.details_region = details_region;
        log_graph.details_region.p0 -= layout_region.p0;
        log_graph.details_region.p1 -= layout_region.p0;

        u64 thread_code = log_parse__string_code(&log_parse, SCu8((u8*)("thread"), (u64)(sizeof("thread") - 1)),
                                                 LogParse_ExternalString);

        if (log_filter_set.count == 0){

            for (Log_Event *event = log_parse.first_event;
                 event != 0;
                 event = event->next){
                Log_Event_Ptr_Node *node = ((Log_Event_Ptr_Node*)linalloc_wrap_unintialized(linalloc_push((&log_arena), sizeof(Log_Event_Ptr_Node)*(1), SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_log_parser.cpp" ":" "468" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_log_parser.cpp" ":" "468" ":") - 1)))));
                node->event = event;
                do{ if((node)){if((log_graph.filtered_list.first)){(log_graph.filtered_list.last)->next=(node);}else{(log_graph.filtered_list.first)=(node);}(log_graph.filtered_list.last)=(node);(log_graph.filtered_list.last)->next=0;} }while(0);
                log_graph.filtered_list.count += 1;
            }
        }
        else{
            for (Log_Filter *filter = log_filter_set.first;
                 filter != 0;
                 filter = filter->next){
                Log_Event_List *filter_list = 0;
                if (filter->kind == LogFilter_TagValue){
                    filter_list = log_parse_get_list_tag_value(&log_parse, filter->tag_name_code,
                                                               filter->tag_value);
                }
                else if (filter->kind == LogFilter_Tag){
                    filter_list = log_parse_get_list_tag_name(&log_parse, filter->tag_name_code);
                }


                if (filter == log_filter_set.first){
                    for (Log_Event_Ptr_Node *node = filter_list->first;
                         node != 0;
                         node = node->next){
                        Log_Event_Ptr_Node *new_node = ((Log_Event_Ptr_Node*)linalloc_wrap_unintialized(linalloc_push((&log_arena), sizeof(Log_Event_Ptr_Node)*(1), SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_log_parser.cpp" ":" "492" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_log_parser.cpp" ":" "492" ":") - 1)))));
                        new_node->event = node->event;
                        do{ if((new_node)){if((log_graph.filtered_list.first)){(log_graph.filtered_list.last)->next=(new_node);}else{(log_graph.filtered_list.first)=(new_node);}(log_graph.filtered_list.last)=(new_node);(log_graph.filtered_list.last)->next=0;} }while(0);
                        log_graph.filtered_list.count += 1;
                    }
                }
                else{
                    Log_Event_Ptr_Node **fixup_ptr = &log_graph.filtered_list.first;
                    log_graph.filtered_list.last = 0;
                    for (Log_Event_Ptr_Node *node_a = log_graph.filtered_list.first, *next = 0;
                         node_a != 0;
                         node_a = next){
                        next = node_a->next;

                        b32 remove_node_a = true;
                        for (Log_Event_Ptr_Node *node_b = filter_list->first;
                             node_b != 0;
                             node_b = node_b->next){
                            if (node_a->event == node_b->event){
                                remove_node_a = false;
                                break;
                            }
                        }

                        if (remove_node_a){
                            *fixup_ptr = next;
                        }
                        else{
                            fixup_ptr = &node_a->next;
                            log_graph.filtered_list.last = node_a;
                        }
                    }
                }
            }
        }

        log_graph.event_array = log_event_array_from_list(&log_arena, log_graph.filtered_list);
        log_events_sort_by_tag(&log_arena, log_graph.event_array, thread_code);

        b32 had_a_tag = true;
        u64 thread_id_value = 0;
        Log_Graph_Thread_Bucket *prev_bucket = 0;

        for (i32 i = 0; i < log_graph.event_array.count; i += 1){
            Table_u64_u64 *tag_table = &log_graph.event_array.events[i]->tag_name_to_tag_ptr_table;
            Table_Lookup lookup = table_lookup(tag_table, thread_code);

            b32 emit_next_bucket = false;
            if (!lookup.found_match){
                if (had_a_tag){
                    had_a_tag = false;
                    thread_id_value = 0;
                    emit_next_bucket = true;
                }
            }
            else{
                u64 read_val = 0;
                table_read(tag_table, lookup, &read_val);
                Log_Tag *tag = (Log_Tag*)(void*)(((u8*)0) + read_val);
                if (!had_a_tag){
                    had_a_tag = true;
                    thread_id_value = tag->value.value;
                    emit_next_bucket = true;
                }
                else if (thread_id_value != tag->value.value){
                    thread_id_value = tag->value.value;
                    emit_next_bucket = true;
                }
            }

            if (emit_next_bucket){
                Log_Graph_Thread_Bucket *bucket = ((Log_Graph_Thread_Bucket*)linalloc_wrap_unintialized(linalloc_push((&log_arena), sizeof(Log_Graph_Thread_Bucket)*(1), SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_log_parser.cpp" ":" "563" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_log_parser.cpp" ":" "563" ":") - 1)))));
                do{ if((bucket)){if((log_graph.first_bucket)){(log_graph.last_bucket)->next=(bucket);}else{(log_graph.first_bucket)=(bucket);}(log_graph.last_bucket)=(bucket);(log_graph.last_bucket)->next=0;} }while(0);
                log_graph.bucket_count += 1;
                bucket->range.first = i;
                bucket->had_a_tag = had_a_tag;
                bucket->thread_id_value = thread_id_value;
                if (prev_bucket != 0){
                    prev_bucket->range.one_past_last = i;
                }
                prev_bucket = bucket;
            }
        }
        if (prev_bucket != 0){
            prev_bucket->range.one_past_last = log_graph.event_array.count;
        }

        Face_Metrics metrics = get_face_metrics(app, face_id);
        f32 line_height = metrics.line_height;
        f32 box_h = f32_floor32(line_height*1.5f);
        f32 box_w = f32_floor32(rect_width(event_list_region)/log_graph.bucket_count);
        f32 y_cursor = event_list_region.y0 - layout_region.y0;

        if (log_graph.bucket_count > 0){
            f32 y_bottom = 0.f;

            for (;;){
                i32 smallest_event_number = max_i32;
                i32 bucket_with_next_event_index = -1;
                Log_Graph_Thread_Bucket *bucket_with_next_event = 0;
                Log_Event *next_event = 0;
                i32 iteration_counter = 0;
                for (Log_Graph_Thread_Bucket *bucket = log_graph.first_bucket;
                     bucket != 0;
                     bucket = bucket->next, iteration_counter += 1){
                    if (bucket->range.first < bucket->range.one_past_last){
                        Log_Event *event = log_graph.event_array.events[bucket->range.first];
                        if (event->event_number < smallest_event_number){
                            smallest_event_number = event->event_number;
                            bucket_with_next_event_index = iteration_counter;
                            bucket_with_next_event = bucket;
                            next_event = event;
                        }
                    }
                }

                if (bucket_with_next_event == 0){
                    break;
                }

                bucket_with_next_event->range.first += 1;

                Log_Graph_Box *box_node = ((Log_Graph_Box*)linalloc_wrap_unintialized(linalloc_push((&log_arena), sizeof(Log_Graph_Box)*(1), SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_log_parser.cpp" ":" "614" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_log_parser.cpp" ":" "614" ":") - 1)))));
                do{ if((box_node)){if((log_graph.first_box)){(log_graph.last_box)->next=(box_node);}else{(log_graph.first_box)=(box_node);}(log_graph.last_box)=(box_node);(log_graph.last_box)->next=0;} }while(0);
                log_graph.box_count += 1;
                Rect_f32 rect = Rf32(box_w*bucket_with_next_event_index , y_cursor,
                                     box_w*(bucket_with_next_event_index + 1), y_cursor + box_h);
                box_node->rect = rect;
                box_node->event = next_event;

                y_bottom = (((y_bottom)>(rect.y1))?(y_bottom):(rect.y1));

                y_cursor += box_h;
            }

            log_graph.max_y_scroll = (((line_height)>(y_bottom - rect_height(event_list_region)*0.5f))?(line_height):(y_bottom - rect_height(event_list_region)*0.5f));
        }
    }
}

static void
log_parse_fill(Application_Links *app, Buffer_ID buffer){
    if (log_arena.base_allocator == 0){
        log_arena = make_arena_system();
    }

    linalloc_clear(&log_arena);
    block_zero((&log_graph), sizeof(*(&log_graph)));
    log_filter_set_init(&log_filter_set);
    log_filter_set_init(&log_preview_set);

    String_Const_u8 log_text = push_whole_buffer(app, &log_arena, buffer);
    log_parse = make_log_parse(&log_arena, log_text);
}

static void
log_graph_render__tag(Arena *arena, Fancy_Line *line,
                      Log_Parse *log, Log_Tag *tag){
    String_Const_u8 tag_name = log_parse__get_string(log, tag->name);
    push_fancy_stringf(arena, line, f_white, "[");
    push_fancy_string(arena, line, f_green, tag_name);
    push_fancy_stringf(arena, line, f_white, "=");
    if (tag->value.kind == LogTagKind_Integer){
        push_fancy_stringf(arena, line, f_pink, "0x%llx", tag->value.value_s);
    }
    else if (tag->value.kind == LogTagKind_String){
        String_Const_u8 value = log_parse__get_string(log, tag->value.value);
        push_fancy_string(arena, line, f_pink, value);
    }
    push_fancy_stringf(arena, line, f_white, "]");
}

static void
log_graph_render(Application_Links *app, Frame_Info frame_info, View_ID view){
    if (log_parse.arena != 0){

        View_ID active_view = get_active_view(app, Access_Always);
        b32 is_active_view = (active_view == view);

        Rect_f32 view_rect = view_get_screen_rect(app, view);
        Rect_f32 inner = rect_inner(view_rect, 3);
        draw_rectangle_fcolor(app, view_rect, 0.f,
                              get_item_margin_color(is_active_view?UIHighlight_Active:UIHighlight_None));
        draw_rectangle_fcolor(app, inner, 0.f, fcolor_id(defcolor_back));

        Rect_f32 prev_clip = draw_set_clip(app, inner);


        Face_ID face_id = get_face_id(app, 0);
        f32 y_scroll = log_graph.y_scroll;
        Log_Event *selected_event = log_graph.selected_event;
        if (!log_graph.holding_temp ||
            inner != log_graph.layout_region ||
            face_id != log_graph.face_id ||
            log_filter_set.alter_counter != log_graph.filter_alter_counter){
            log_graph_fill(app, inner, face_id);
        }
        log_graph.y_scroll = (((0.f)>(y_scroll))?(0.f):(((log_graph.max_y_scroll)<(y_scroll))?(log_graph.max_y_scroll):(y_scroll)));
        log_graph.selected_event = selected_event;

        Mouse_State mouse = get_mouse_state(app);
        Vec2_f32 m_p = V2f32(mouse.p) - inner.p0;

        Face_Metrics metrics = get_face_metrics(app, log_graph.face_id);
        f32 line_height = metrics.line_height;

        Log_Event *hover_event = 0;

        b32 in_details_region = (rect_contains_point(log_graph.details_region, m_p));

        for (Log_Graph_Box *box_node = log_graph.first_box;
             box_node != 0;
             box_node = box_node->next){
            Scratch_Block scratch(app);

            Rect_f32 box = box_node->rect;
            box.y0 -= log_graph.y_scroll;
            box.y1 -= log_graph.y_scroll;

            Rect_f32 box_inner = rect_inner(box, 3.f);

            FColor margin_color = f_dark_gray;
            if (!in_details_region && hover_event == 0 && rect_contains_point(box, m_p)){
                margin_color = f_gray;
                hover_event = box_node->event;
            }
            if (box_node->event == log_graph.selected_event){
                margin_color = f_light_gray;
            }

            draw_rectangle_fcolor(app, box , 0.f, margin_color);
            draw_rectangle_fcolor(app, box_inner, 0.f, f_black );

            Log_Event *event = box_node->event;

            String_Const_u8 event_name = log_parse__get_string(&log_parse, event->event_name);
            Fancy_Line line = {};
            push_fancy_string(scratch, &line, f_white, event_name);

            for (Log_Filter *filter = log_preview_set.first;
                 filter != 0;
                 filter = filter->next){
                Table_u64_u64 *table = &event->tag_name_to_tag_ptr_table;
                Table_Lookup lookup = table_lookup(table, filter->tag_name_code);
                if (lookup.found_match){
                    u64 val = 0;
                    table_read(table, lookup, &val);
                    Log_Tag *tag = (Log_Tag*)(void*)(((u8*)0) + val);
                    push_fancy_string(scratch, &line, SCu8((u8*)(" "), (u64)(sizeof(" ") - 1)));
                    log_graph_render__tag(scratch, &line, &log_parse, tag);
                }
            }


            Vec2_f32 p = V2f32(box_inner.x0 + 3.f,
                               (f32_round32((box_inner.y0 + box_inner.y1 - line_height)*0.5f)));
            draw_fancy_line(app, log_graph.face_id, fcolor_zero(), &line, p);
        }

        {
            Scratch_Block scratch(app);

            Rect_f32 box = log_graph.details_region;
            Rect_f32 box_inner = rect_inner(box, 3.f);

            Log_Graph_List_Tab current_tab = log_graph.tab;
            Log_Filter_Set *viewing_filter_set = log_filter_set_from_tab(current_tab);

            draw_rectangle_fcolor(app, box , 0.f, f_dark_gray);
            draw_rectangle_fcolor(app, box_inner, 0.f, f_black );

            {
                f32 y_cursor = box_inner.y0 + 3.f;
                if (y_cursor + line_height > box_inner.y1) goto finish_list_display;

                {
                    f32 x_cursor = box_inner.x0 + 3.f;
                    for (i32 i = LogTab_ERROR + 1; i < LogTab_COUNT; i += 1){
                        FColor color = (i == current_tab)?f_white:f_gray;
                        Fancy_Line line = {};
                        switch (i){
                            case LogTab_Filters:
                            {
                                push_fancy_stringf(scratch, &line, color, "filters");
                            }break;
                            case LogTab_Previews:
                            {
                                push_fancy_stringf(scratch, &line, color, "previews");
                            }break;
                        }

                        Vec2_f32 p = V2f32(x_cursor, y_cursor);
                        f32 width = get_fancy_line_width(app, log_graph.face_id,
                                                         &line);
                        draw_fancy_line(app, log_graph.face_id, fcolor_zero(),
                                        &line, p);
                        x_cursor += width + metrics.normal_advance;

                        if (log_graph.has_unused_click){
                            Rect_f32 click_rect = Rf32_xy_wh(p.x, p.y,
                                                             width, line_height);
                            if (rect_contains_point(click_rect, log_graph.unused_click)){
                                log_graph.has_unused_click = false;
                                log_graph.tab = i;
                            }
                        }
                    }
                }

                if (viewing_filter_set != 0){
                    for (Log_Filter *filter = viewing_filter_set->first, *next = 0;
                         filter != 0;
                         filter = next){
                        next = filter->next;

                        y_cursor += line_height;
                        if (y_cursor + line_height > box_inner.y1) goto finish_list_display;

                        Fancy_Line line = {};

                        if (filter->kind == LogFilter_TagValue){
                            push_fancy_stringf(scratch, &line, f_white, "val  [");
                            String_Const_u8 tag_name = log_parse__get_string(&log_parse, filter->tag_name_code);
                            push_fancy_stringf(scratch, &line, f_green, "%.*s", (i32)(tag_name).size, (char*)(tag_name).str);
                            push_fancy_stringf(scratch, &line, f_white, "=");
                            if (filter->tag_value.kind == LogTagKind_Integer){
                                push_fancy_stringf(scratch, &line, f_pink, "0x%llx", filter->tag_value.value_s);
                            }
                            else if (filter->tag_value.kind == LogTagKind_String){
                                String_Const_u8 value = log_parse__get_string(&log_parse, filter->tag_value.value);
                                push_fancy_stringf(scratch, &line, f_pink, "%.*s", (i32)(value).size, (char*)(value).str);
                            }
                            push_fancy_stringf(scratch, &line, f_white, "]");
                        }
                        else{
                            push_fancy_stringf(scratch, &line, f_white, "name [");
                            String_Const_u8 tag_name = log_parse__get_string(&log_parse, filter->tag_name_code);
                            push_fancy_stringf(scratch, &line, f_green, "%.*s", (i32)(tag_name).size, (char*)(tag_name).str);
                            push_fancy_stringf(scratch, &line, f_white, "]");
                        }

                        Vec2_f32 p = V2f32(box_inner.x0 + 3.f, y_cursor);
                        f32 width = get_fancy_line_width(app, log_graph.face_id,
                                                         &line);
                        draw_fancy_line(app, log_graph.face_id, fcolor_zero(),
                                        &line, p);

                        if (log_graph.has_unused_click){
                            Rect_f32 click_rect = Rf32_xy_wh(p.x, p.y,
                                                             width, line_height);
                            if (rect_contains_point(click_rect, log_graph.unused_click)){
                                log_graph.has_unused_click = false;
                                log_filter_set__free_filter(viewing_filter_set, filter);
                            }
                        }
                    }
                }

                finish_list_display:;
            }

            Log_Event *view_event = (hover_event!=0)?hover_event:log_graph.selected_event;
            if (view_event != 0){
                f32 y_cursor = box_inner.y0 + 3.f;
                if (y_cursor + line_height > box_inner.y1) goto finish_event_display;

                {
                    Fancy_Line line = {};
                    String_Const_u8 file_name = log_parse__get_string(&log_parse, view_event->src_file_name);
                    push_fancy_stringf(scratch, &line, f_green, "[%d]  ", view_event->event_number);
                    push_fancy_stringf(scratch, &line, f_white, "%.*s:", (i32)(file_name).size, (char*)(file_name).str);
                    push_fancy_stringf(scratch, &line, f_pink, "%llu", view_event->line_number);

                    Vec2_f32 right_p = V2f32(box_inner.x1 - 3.f, y_cursor);
                    f32 width = get_fancy_line_width(app, log_graph.face_id, &line);
                    Vec2_f32 p = V2f32(right_p.x - width, right_p.y);
                    draw_fancy_line(app, log_graph.face_id, fcolor_zero(), &line, p);
                }

                for (Log_Tag *tag = view_event->first_tag;
                     tag != 0;
                     tag = tag->next){
                    y_cursor += line_height;
                    if (y_cursor + line_height > box_inner.y1) goto finish_event_display;

                    {
                        Fancy_Line line = {};
                        log_graph_render__tag(scratch, &line, &log_parse, tag);

                        Vec2_f32 right_p = V2f32(box_inner.x1 - 3.f, y_cursor);
                        f32 width = get_fancy_line_width(app, log_graph.face_id, &line);
                        Vec2_f32 p = V2f32(right_p.x - width, right_p.y);
                        draw_fancy_line(app, log_graph.face_id, fcolor_zero(),
                                        &line, p);

                        if (log_graph.has_unused_click){
                            Rect_f32 click_rect = Rf32(p.x, p.y, right_p.x, p.y + line_height);
                            if (rect_contains_point(click_rect, log_graph.unused_click)){
                                log_graph.has_unused_click = false;
                                Log_Filter filter = {};
                                switch (log_graph.tab){
                                    case LogTab_Filters:
                                    {
                                        filter.kind = LogFilter_TagValue;
                                        filter.tag_name_code = tag->name;
                                        filter.tag_value = tag->value;
                                    }break;
                                    case LogTab_Previews:
                                    {
                                        filter.kind = LogFilter_Tag;
                                        filter.tag_name_code = tag->name;
                                    }break;
                                }
                                if (filter.kind != LogTab_ERROR){
                                    log_filter_set__new_filter(viewing_filter_set, &filter);
                                    animate_in_n_milliseconds(app, 0);
                                }
                            }
                        }
                    }
                }

                finish_event_display:;
            }
        }

        log_graph.has_unused_click = false;
        draw_set_clip(app, prev_clip);
    }
}

static Log_Graph_Box*
log_graph__get_box_at_point(Log_Graph *graph, Vec2_f32 p){
    Log_Graph_Box *result = 0;
    if (!rect_contains_point(graph->details_region, p)){
        for (Log_Graph_Box *box_node = graph->first_box;
             box_node != 0;
             box_node = box_node->next){
            Rect_f32 box = box_node->rect;
            box.y0 -= graph->y_scroll;
            box.y1 -= graph->y_scroll;
            if (rect_contains_point(box, p)){
                result = box_node;
                break;
            }
        }
    }
    return(result);
}

static Log_Graph_Box*
log_graph__get_box_at_mouse_point(Application_Links *app, Log_Graph *graph){
    Mouse_State mouse = get_mouse_state(app);
    Vec2_f32 m_p = V2f32(mouse.p) - graph->layout_region.p0;
    return(log_graph__get_box_at_point(graph, m_p));
}

static void
log_graph__click_select_event(Application_Links *app, Vec2_f32 m_p)
{
    if (log_view != 0 && log_graph.holding_temp){
        Log_Graph_Box *box_node = log_graph__get_box_at_point(&log_graph, m_p);
        if (box_node != 0){
            log_graph.selected_event = box_node->event;
        }
        else{
            log_graph.has_unused_click = true;
            log_graph.unused_click = m_p;
        }
    }
}

static void
log_graph__click_jump_to_event_source(Application_Links *app, Vec2_f32 m_p){
    if (log_view != 0 && log_graph.holding_temp){
        Log_Graph_Box *box_node = log_graph__get_box_at_point(&log_graph, m_p);
        if (box_node != 0){
            Log_Event *event = box_node->event;
            log_graph.selected_event = event;

            View_ID target_view = get_next_view_looped_primary_panels(app, log_view,
                                                                      Access_ReadVisible);
            if (target_view != 0){
                String_Const_u8 file_name = log_parse__get_string(&log_parse, event->src_file_name);
                Buffer_ID target_buffer = get_buffer_by_file_name(app, file_name, Access_Always);
                if (target_buffer == 0){
                    target_buffer = get_buffer_by_name(app, file_name, Access_Always);
                }
                if (target_buffer != 0){
                    set_view_to_location(app, target_view, target_buffer,
                                         seek_line_col(event->line_number, 1));
                }
            }
        }
        else{
            log_graph.has_unused_click = true;
            log_graph.unused_click = m_p;
        }
    }
}

CUSTOM_COMMAND(show_the_log_graph, "/home/sam/.bin/4coder/custom/4coder_log_parser.cpp", 993, UI)
CUSTOM_DOC("Parses *log* and displays the 'log graph' UI")
{
    if (log_view != 0){
        return;
    }

    Buffer_ID log_buffer = get_buffer_by_name(app, SCu8((u8*)("*log*"), (u64)(sizeof("*log*") - 1)), Access_Always);
    log_parse_fill(app, log_buffer);

    log_view = get_this_ctx_view(app, Access_Always);
    View_ID view = log_view;

    View_Context ctx = view_current_context(app, view);
    ctx.render_caller = log_graph_render;
    View_Context_Block ctx_block(app, view, &ctx);

    for (;;){
        User_Input in = get_next_input(app, EventPropertyGroup_AnyUserInput, KeyCode_Escape);
        if (in.abort){
            view = 0;
            break;
        }

        b32 handled = true;
        switch (in.event.kind){
            case InputEventKind_KeyStroke:
            {
                switch (in.event.key.code){
                    case KeyCode_PageUp:
                    {
                        log_graph.y_scroll -= get_page_jump(app, view);
                    }break;

                    case KeyCode_PageDown:
                    {
                        log_graph.y_scroll += get_page_jump(app, view);
                    }break;

                    default:
                    {
                        handled = false;
                    }break;
                }
            }break;

            case InputEventKind_MouseButton:
            {
                Vec2_f32 m_p = V2f32(in.event.mouse.p) - log_graph.layout_region.p0;
                switch (in.event.mouse.code){
                    case MouseCode_Left:
                    {
                        log_graph__click_jump_to_event_source(app, m_p);
                    }break;

                    case MouseCode_Right:
                    {
                        log_graph__click_select_event(app, m_p);
                    }break;

                    default:
                    {
                        handled = false;
                    }break;
                }
            }break;

            case InputEventKind_MouseWheel:
            {
                f32 value = in.event.mouse_wheel.value;
                log_graph.y_scroll += f32_round32(value);
            }break;

            default:
            {
                handled = false;
            }break;
        }

        if (!handled){
            if (ui_fallback_command_dispatch(app, view, &in)){
                break;
            }
        }
    }

    log_view = 0;
}
# 116 "/home/sam/.bin/4coder/custom/4coder_default_include.cpp" 2
# 1 "/home/sam/.bin/4coder/custom/4coder_keyboard_macro.cpp" 1






static Buffer_ID
get_keyboard_log_buffer(Application_Links *app){
    return(get_buffer_by_name(app, SCu8((u8*)("*keyboard*"), (u64)(sizeof("*keyboard*") - 1)), Access_Always));
}

static void
keyboard_macro_play_single_line(Application_Links *app, String_Const_u8 macro_line){
    Scratch_Block scratch(app);
    Input_Event event = parse_keyboard_event(scratch, macro_line);
    if (event.kind != InputEventKind_None){
        enqueue_virtual_event(app, &event);
    }
}

static void
keyboard_macro_play(Application_Links *app, String_Const_u8 macro){
    Scratch_Block scratch(app);
    List_String_Const_u8 lines = string_split(scratch, macro, (u8*)"\n", 1);
    for (Node_String_Const_u8 *node = lines.first;
         node != 0;
         node = node->next){
        String_Const_u8 line = string_skip_chop_whitespace(node->string);
        keyboard_macro_play_single_line(app, line);
    }
}

static b32
get_current_input_is_virtual(Application_Links *app){
    User_Input input = get_current_input(app);
    return(input.event.virtual_event);
}



CUSTOM_COMMAND(keyboard_macro_start_recording, "/home/sam/.bin/4coder/custom/4coder_keyboard_macro.cpp", 41, Normal)
CUSTOM_DOC("Start macro recording, do nothing if macro recording is already started")
{
    if (global_keyboard_macro_is_recording ||
        get_current_input_is_virtual(app)){
        return;
    }

    Buffer_ID buffer = get_keyboard_log_buffer(app);
    global_keyboard_macro_is_recording = true;
    global_keyboard_macro_range.first = buffer_get_size(app, buffer);
}

CUSTOM_COMMAND(keyboard_macro_finish_recording, "/home/sam/.bin/4coder/custom/4coder_keyboard_macro.cpp", 54, Normal)
CUSTOM_DOC("Stop macro recording, do nothing if macro recording is not already started")
{
    if (!global_keyboard_macro_is_recording ||
        get_current_input_is_virtual(app)){
        return;
    }

    Buffer_ID buffer = get_keyboard_log_buffer(app);
    global_keyboard_macro_is_recording = false;
    i64 end = buffer_get_size(app, buffer);
    Buffer_Cursor cursor = buffer_compute_cursor(app, buffer, seek_pos(end));
    Buffer_Cursor back_cursor = buffer_compute_cursor(app, buffer, seek_line_col(cursor.line - 1, 1));
    global_keyboard_macro_range.one_past_last = back_cursor.pos;







}

CUSTOM_COMMAND(keyboard_macro_replay, "/home/sam/.bin/4coder/custom/4coder_keyboard_macro.cpp", 77, Normal)
CUSTOM_DOC("Replay the most recently recorded keyboard macro")
{
    if (global_keyboard_macro_is_recording ||
        get_current_input_is_virtual(app)){
        return;
    }

    Buffer_ID buffer = get_keyboard_log_buffer(app);
    Scratch_Block scratch(app);
    String_Const_u8 macro = push_buffer_range(app, scratch, buffer, global_keyboard_macro_range);
    keyboard_macro_play(app, macro);
}
# 117 "/home/sam/.bin/4coder/custom/4coder_default_include.cpp" 2
# 1 "/home/sam/.bin/4coder/custom/4coder_cli_command.cpp" 1






CUSTOM_COMMAND(execute_previous_cli, "/home/sam/.bin/4coder/custom/4coder_cli_command.cpp", 7, Normal)
CUSTOM_DOC("If the command execute_any_cli has already been used, this will execute a CLI reusing the most recent buffer name and command.")
{
    String_Const_u8 out_buffer = SCu8(out_buffer_space);
    String_Const_u8 cmd = SCu8(command_space);
    String_Const_u8 hot_directory = SCu8(hot_directory_space);

    if (out_buffer.size > 0 && cmd.size > 0 && hot_directory.size > 0){
        View_ID view = get_active_view(app, Access_Always);
        Buffer_Identifier id = buffer_identifier(out_buffer);
        exec_system_command(app, view, id, hot_directory, cmd, CLI_OverlapWithConflict|CLI_CursorAtEnd|CLI_SendEndSignal);
        lock_jump_buffer(app, out_buffer);
    }
}

CUSTOM_COMMAND(execute_any_cli, "/home/sam/.bin/4coder/custom/4coder_cli_command.cpp", 22, Normal)
CUSTOM_DOC("Queries for an output buffer name and system command, runs the system command as a CLI and prints the output to the specified buffer."){
    Scratch_Block scratch(app);
    Query_Bar_Group group(app);

    Query_Bar bar_out = {};
    bar_out.prompt = SCu8((u8*)("Output Buffer: "), (u64)(sizeof("Output Buffer: ") - 1));
    bar_out.string = SCu8(out_buffer_space, (u64)0);
    bar_out.string_capacity = sizeof(out_buffer_space);
    if (!query_user_string(app, &bar_out)) return;
    bar_out.string.size = (((bar_out.string.size)<(sizeof(out_buffer_space) - 1))?(bar_out.string.size):(sizeof(out_buffer_space) - 1));
    out_buffer_space[bar_out.string.size] = 0;

    Query_Bar bar_cmd = {};
    bar_cmd.prompt = SCu8((u8*)("Command: "), (u64)(sizeof("Command: ") - 1));
    bar_cmd.string = SCu8(command_space, (u64)0);
    bar_cmd.string_capacity = sizeof(command_space);
    if (!query_user_string(app, &bar_cmd)) return;
    bar_cmd.string.size = (((bar_cmd.string.size)<(sizeof(command_space) - 1))?(bar_cmd.string.size):(sizeof(command_space) - 1));
    command_space[bar_cmd.string.size] = 0;

    String_Const_u8 hot = push_hot_directory(app, scratch);
    {
        u64 size = (((hot.size)<(sizeof(hot_directory_space)))?(hot.size):(sizeof(hot_directory_space)));
        block_copy(hot_directory_space, hot.str, size);
        hot_directory_space[hot.size] = 0;
    }

    execute_previous_cli(app);
}
# 118 "/home/sam/.bin/4coder/custom/4coder_default_include.cpp" 2
# 1 "/home/sam/.bin/4coder/custom/4coder_build_commands.cpp" 1






static String_Const_u8
push_build_directory_at_file(Application_Links *app, Arena *arena, Buffer_ID buffer){
    String_Const_u8 result = {};
    String_Const_u8 file_name = push_buffer_file_name(app, arena, buffer);
    Temp_Memory restore_point = begin_temp(arena);
    String_Const_u8 base_name = push_buffer_base_name(app, arena, buffer);
    b32 is_match = string_match(file_name, base_name);
    end_temp(restore_point);
    if (!is_match){
        result = push_string_copy(arena, string_remove_last_folder(file_name));
    }
    return(result);
}
# 32 "/home/sam/.bin/4coder/custom/4coder_build_commands.cpp"
static String_Const_u8 standard_build_file_name_array[] = {
    {(u8*)("build.sh"), sizeof("build.sh") - 1},
    {(u8*)("Makefile"), sizeof("Makefile") - 1},
};
static String_Const_u8 standard_build_cmd_string_array[] = {
    {(u8*)("build.sh"), sizeof("build.sh") - 1},
    {(u8*)("make"), sizeof("make") - 1},
};





static String_Const_u8
push_fallback_command(Arena *arena, String_Const_u8 file_name){
    return(push_u8_stringf(arena, "echo could not find %.*s", (i32)(file_name).size, (char*)(file_name).str));
}

static String_Const_u8
push_fallback_command(Arena *arena){
    return(push_fallback_command(arena, standard_build_file_name_array[0]));
}

static const Buffer_Identifier standard_build_build_buffer_identifier = buffer_identifier(SCu8((u8*)("*compilation*"), (u64)(sizeof("*compilation*") - 1)));

static const u32 standard_build_exec_flags = CLI_OverlapWithConflict|CLI_SendEndSignal;

static void
standard_build_exec_command(Application_Links *app, View_ID view, String_Const_u8 dir, String_Const_u8 cmd){
    exec_system_command(app, view, standard_build_build_buffer_identifier,
                        dir, cmd,
                        standard_build_exec_flags);
}

static b32
standard_search_and_build_from_dir(Application_Links *app, View_ID view, String_Const_u8 start_dir){
    Scratch_Block scratch(app);


    String_Const_u8 full_file_path = {};
    String_Const_u8 cmd_string = {};
    for (i32 i = 0; i < ((sizeof(standard_build_file_name_array))/(sizeof(*standard_build_file_name_array))); i += 1){
        full_file_path = push_file_search_up_path(app, scratch, start_dir, standard_build_file_name_array[i]);
        if (full_file_path.size > 0){
            cmd_string = standard_build_cmd_string_array[i];
            break;
        }
    }

    b32 result = (full_file_path.size > 0);
    if (result){

        String_Const_u8 path = string_remove_last_folder(full_file_path);
        String_Const_u8 command = push_u8_stringf(scratch, "\"%.*s/%.*s\"",
                                                  (i32)(path).size, (char*)(path).str,
                                                  (i32)(cmd_string).size, (char*)(cmd_string).str);
        if (global_config.automatically_save_changes_on_build){
            save_all_dirty_buffers(app);
        }
        standard_build_exec_command(app, view, path, command);
        print_message(app, push_u8_stringf(scratch, "Building with: %.*s\n",
                                           (i32)(full_file_path).size, (char*)(full_file_path).str));
    }

    return(result);
}



static void
standard_search_and_build(Application_Links *app, View_ID view, Buffer_ID active_buffer){
    Scratch_Block scratch(app);
    b32 did_build = false;
    String_Const_u8 build_dir = push_build_directory_at_file(app, scratch, active_buffer);
    if (build_dir.size > 0){
        did_build = standard_search_and_build_from_dir(app, view, build_dir);
    }
    if (!did_build){
        build_dir = push_hot_directory(app, scratch);
        if (build_dir.size > 0){
            did_build = standard_search_and_build_from_dir(app, view, build_dir);
        }
    }
    if (!did_build){
        standard_build_exec_command(app, view,
                                    push_hot_directory(app, scratch),
                                    push_fallback_command(scratch));
    }
}

CUSTOM_COMMAND(build_search, "/home/sam/.bin/4coder/custom/4coder_build_commands.cpp", 122, Normal)
CUSTOM_DOC("Looks for a build.bat, build.sh, or makefile in the current and parent directories.  Runs the first that it finds and prints the output to *compilation*.")
{
    View_ID view = get_active_view(app, Access_Always);
    Buffer_ID buffer = view_get_buffer(app, view, Access_Always);
    standard_search_and_build(app, view, buffer);
    block_zero((&prev_location), sizeof(*(&prev_location)));
    lock_jump_buffer(app, SCu8((u8*)("*compilation*"), (u64)(sizeof("*compilation*") - 1)));
}

static Buffer_ID
get_comp_buffer(Application_Links *app){
    return(get_buffer_by_name(app, SCu8((u8*)("*compilation*"), (u64)(sizeof("*compilation*") - 1)), Access_Always));
}

static View_ID
get_or_open_build_panel(Application_Links *app){
    View_ID view = 0;
    Buffer_ID buffer = get_comp_buffer(app);
    if (buffer != 0){
        view = get_first_view_with_buffer(app, buffer);
    }
    if (view == 0){
        view = open_build_footer_panel(app);
    }
    return(view);
}

static void
set_fancy_compilation_buffer_font(Application_Links *app){
    Buffer_ID buffer = get_comp_buffer(app);
    Font_Load_Location font = {};
    Scratch_Block scratch(app);
    font.file_name = get_file_path_in_fonts_folder(scratch, SCu8((u8*)("Inconsolata-Regular.ttf"), (u64)(sizeof("Inconsolata-Regular.ttf") - 1)));
    set_buffer_face_by_font_load_location(app, buffer, &font);
}

CUSTOM_COMMAND(build_in_build_panel, "/home/sam/.bin/4coder/custom/4coder_build_commands.cpp", 159, Normal)
CUSTOM_DOC("Looks for a build.bat, build.sh, or makefile in the current and parent directories.  Runs the first that it finds and prints the output to *compilation*.  Puts the *compilation* buffer in a panel at the footer of the current view.")
{
    View_ID view = get_active_view(app, Access_Always);
    Buffer_ID buffer = view_get_buffer(app, view, Access_Always);

    View_ID build_view = get_or_open_build_panel(app);

    standard_search_and_build(app, build_view, buffer);
    set_fancy_compilation_buffer_font(app);

    block_zero((&prev_location), sizeof(*(&prev_location)));
    lock_jump_buffer(app, SCu8((u8*)("*compilation*"), (u64)(sizeof("*compilation*") - 1)));
}

CUSTOM_COMMAND(close_build_panel, "/home/sam/.bin/4coder/custom/4coder_build_commands.cpp", 174, Normal)
CUSTOM_DOC("If the special build panel is open, closes it.")
{
    close_build_footer_panel(app);
}

CUSTOM_COMMAND(change_to_build_panel, "/home/sam/.bin/4coder/custom/4coder_build_commands.cpp", 180, Normal)
CUSTOM_DOC("If the special build panel is open, makes the build panel the active panel.")
{
    View_ID view = get_or_open_build_panel(app);
    if (view != 0){
        view_set_active(app, view);
    }
}
# 119 "/home/sam/.bin/4coder/custom/4coder_default_include.cpp" 2
# 1 "/home/sam/.bin/4coder/custom/4coder_project_commands.cpp" 1






static Project current_project = {};
static Arena current_project_arena = {};



static Project_File_Pattern_Array
get_pattern_array_from_string_array(Arena *arena, String_Const_u8_Array list){
    Project_File_Pattern_Array array = {};
    array.count = list.count;
    array.patterns = ((Project_File_Pattern*)linalloc_wrap_unintialized(linalloc_push((arena), sizeof(Project_File_Pattern)*(list.count), SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_project_commands.cpp" ":" "16" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_project_commands.cpp" ":" "16" ":") - 1)))));
    for (i32 i = 0; i < list.count; ++i){
        String_Const_u8 str = push_u8_stringf(arena, "*.%.*s", (i32)(list.strings[i]).size, (char*)(list.strings[i]).str);
        array.patterns[i].absolutes = string_split_wildcards(arena, str);
    }
    return(array);
}



static void
close_all_files_with_extension(Application_Links *app, String_Const_u8_Array extension_array){
    Scratch_Block scratch(app);

    i32 buffers_to_close_max = ((100)*1000);
    Buffer_ID *buffers_to_close = ((Buffer_ID*)linalloc_wrap_unintialized(linalloc_push((scratch), sizeof(Buffer_ID)*(buffers_to_close_max), SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_project_commands.cpp" ":" "31" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_project_commands.cpp" ":" "31" ":") - 1)))));

    b32 do_repeat = false;
    do{
        i32 buffers_to_close_count = 0;
        do_repeat = false;

        for (Buffer_ID buffer = get_buffer_next(app, 0, Access_Always);
             buffer != 0;
             buffer = get_buffer_next(app, buffer, Access_Always)){
            b32 is_match = true;

            if (extension_array.count > 0){
                Temp_Memory name_temp = begin_temp(scratch);
                String_Const_u8 file_name = push_buffer_file_name(app, scratch, buffer);
                is_match = false;
                if (file_name.size > 0){
                    String_Const_u8 extension = string_file_extension(file_name);
                    for (i32 i = 0; i < extension_array.count; ++i){
                        if (string_match(extension, extension_array.strings[i])){
                            is_match = true;
                            break;
                        }
                    }
                }
                end_temp(name_temp);
            }

            if (is_match){
                if (buffers_to_close_count >= buffers_to_close_max){
                    do_repeat = true;
                    break;
                }
                buffers_to_close[buffers_to_close_count++] = buffer;
            }
        }

        for (i32 i = 0; i < buffers_to_close_count; ++i){
            buffer_kill(app, buffers_to_close[i], BufferKill_AlwaysKill);
        }
    }while(do_repeat);
}

static b32
match_in_pattern_array(String_Const_u8 string, Project_File_Pattern_Array array){
    b32 found_match = false;
    Project_File_Pattern *pattern = array.patterns;
    for (i32 i = 0; i < array.count; ++i, ++pattern){
        if (string_wildcard_match(pattern->absolutes, string, StringMatch_Exact)){
            found_match = true;
            break;
        }
    }
    return(found_match);
}

static void
open_files_pattern_match__recursive(Application_Links *app, String_Const_u8 path,
                                    Project_File_Pattern_Array whitelist,
                                    Project_File_Pattern_Array blacklist,
                                    u32 flags){
    Scratch_Block scratch(app);

    Profile_Scope_Block profile_get_file_list ((app), SCu8((u8*)("get file list"), (u64)(sizeof("get file list") - 1)), SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_project_commands.cpp" ":" "94" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_project_commands.cpp" ":" "94" ":") - 1)));
    File_List list = system_get_file_list(scratch, path);
    ((profile_get_file_list).close_now());

    File_Info **info = list.infos;
    for (u32 i = 0; i < list.count; ++i, ++info){
        String_Const_u8 file_name = (**info).file_name;

        if (((((**info).attributes.flags)&(FileAttribute_IsDirectory))!=0)){
            if ((flags & OpenAllFilesFlag_Recursive) == 0) continue;
            if (match_in_pattern_array(file_name, blacklist)) continue;

            String_Const_u8 new_path = push_u8_stringf(scratch, "%.*s%.*s/",
                                                       (i32)(path).size, (char*)(path).str,
                                                       (i32)(file_name).size, (char*)(file_name).str);
            open_files_pattern_match__recursive(app, new_path, whitelist, blacklist, flags);
        }
        else{
            if (!match_in_pattern_array(file_name, whitelist)){
                continue;
            }
            if (match_in_pattern_array(file_name, blacklist)){
                continue;
            }

            String_Const_u8 full_path = push_u8_stringf(scratch, "%.*s%.*s",
                                                        (i32)(path).size, (char*)(path).str,
                                                        (i32)(file_name).size, (char*)(file_name).str);

            create_buffer(app, full_path, 0);
        }
    }
}

static Project_File_Pattern_Array
get_standard_blacklist(Arena *arena){
    String_Const_u8 dot = SCu8((u8*)(".*"), (u64)(sizeof(".*") - 1));
    String_Const_u8_Array black_array = {};
    black_array.strings = &dot;
    black_array.count = 1;
    return(get_pattern_array_from_string_array(arena, black_array));
}

static void
open_files_pattern_match(Application_Links *app, String_Const_u8 dir, Project_File_Pattern_Array whitelist, Project_File_Pattern_Array blacklist, u32 flags){
    Profile_Scope_Block profile_block_139 ((app), SCu8((u8*)("open all files in directory pattern"), (u64)(sizeof("open all files in directory pattern") - 1)), SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_project_commands.cpp" ":" "139" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_project_commands.cpp" ":" "139" ":") - 1)));
    Scratch_Block scratch(app);
    String_Const_u8 directory = dir;
    if (!character_is_slash(string_get_character(directory, directory.size - 1))){
        directory = push_u8_stringf(scratch, "%.*s/", (i32)(dir).size, (char*)(dir).str);
    }
    open_files_pattern_match__recursive(app, directory, whitelist, blacklist, flags);
}

static void
open_files_with_extension(Application_Links *app, String_Const_u8 dir, String_Const_u8_Array array, u32 flags){
    Scratch_Block scratch(app);
    Project_File_Pattern_Array whitelist = get_pattern_array_from_string_array(scratch, array);
    Project_File_Pattern_Array blacklist = get_standard_blacklist(scratch);
    open_files_pattern_match(app, dir, whitelist, blacklist, flags);
}

static void
open_all_files_in_hot_with_extension(Application_Links *app, String_Const_u8_Array array, u32 flags){
    Scratch_Block scratch(app);
    String_Const_u8 hot = push_hot_directory(app, scratch);
    String_Const_u8 directory = hot;
    if (!character_is_slash(string_get_character(hot, hot.size - 1))){
        directory = push_u8_stringf(scratch, "%.*s/", (i32)(hot).size, (char*)(hot).str);
    }
    open_files_with_extension(app, hot, array, flags);
}
# 179 "/home/sam/.bin/4coder/custom/4coder_project_commands.cpp"
static void
parse_project__extract_pattern_array(Arena *arena, Config *parsed, char *root_variable_name, Project_File_Pattern_Array *array_out){
    Config_Compound *compound = 0;
    if (config_compound_var(parsed, root_variable_name, 0, &compound)){
        Config_Get_Result_List list = typed_string_array_reference_list(arena, parsed, compound);

        array_out->patterns = ((Project_File_Pattern*)linalloc_wrap_unintialized(linalloc_push((arena), sizeof(Project_File_Pattern)*(list.count), SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_project_commands.cpp" ":" "185" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_project_commands.cpp" ":" "185" ":") - 1)))));
        array_out->count = list.count;

        i32 i = 0;
        for (Config_Get_Result_Node *node = list.first;
             node != 0;
             node = node->next, i += 1){
            String_Const_u8 str = push_string_copy(arena, node->result.string);
            array_out->patterns[i].absolutes = string_split_wildcards(arena, str);
        }
    }
}

static Project_OS_Match_Level
parse_project__version_1__os_match(String_Const_u8 str, String_Const_u8 this_os_str){
    if (string_match(str, this_os_str)){
        return(ProjectOSMatchLevel_ActiveMatch);
    }
    else if (string_match(str, SCu8((u8*)("all"), (u64)(sizeof("all") - 1)))){
        return(ProjectOSMatchLevel_ActiveMatch);
    }
    else if (string_match(str, SCu8((u8*)("default"), (u64)(sizeof("default") - 1)))){
        return(ProjectOSMatchLevel_PassiveMatch);
    }
    return(ProjectOSMatchLevel_NoMatch);
}

static Project*
parse_project__config_data__version_1(Application_Links *app, Arena *arena, String_Const_u8 root_dir, Config *parsed){
    Project *project = ((Project*)linalloc_wrap_zero(linalloc_push((arena), sizeof(Project)*(1), SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_project_commands.cpp" ":" "214" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_project_commands.cpp" ":" "214" ":") - 1)))));


    project->dir = push_string_copy(arena, root_dir);


    {
        String_Const_u8 str = {};
        if (config_string_var(parsed, "project_name", 0, &str)){
            project->name = push_string_copy(arena, str);
        }
        else{
            project->name = SCu8("");
        }
    }


    parse_project__extract_pattern_array(arena, parsed, "patterns", &project->pattern_array);


    parse_project__extract_pattern_array(arena, parsed, "blacklist_patterns", &project->blacklist_pattern_array);


    {
        Config_Compound *compound = 0;
        if (config_compound_var(parsed, "load_paths", 0, &compound)){
            b32 found_match = false;
            Config_Compound *best_paths = 0;

            for (i32 i = 0;; ++i){
                Config_Iteration_Step_Result result = typed_array_iteration_step(parsed, compound, ConfigRValueType_Compound, i);
                if (result.step == Iteration_Skip){
                    continue;
                }
                else if (result.step == Iteration_Quit){
                    break;
                }
                Config_Compound *paths_option = result.get.compound;

                Config_Compound *paths = 0;
                if (config_compound_compound_member(parsed, paths_option, "paths", 0, &paths)){
                    String_Const_u8 str = {};
                    if (config_compound_string_member(parsed, paths_option, "os", 1, &str)){
                        Project_OS_Match_Level r = parse_project__version_1__os_match(str, SCu8((u8*)("linux"), (u64)(sizeof("linux") - 1)));
                        if (r == ProjectOSMatchLevel_ActiveMatch){
                            found_match = true;
                            best_paths = paths;
                            break;
                        }
                        else if (r == ProjectOSMatchLevel_PassiveMatch){
                            if (!found_match){
                                found_match = true;
                                best_paths = paths;
                            }
                        }
                    }
                }
            }

            if (found_match){
                Config_Get_Result_List list = typed_compound_array_reference_list(arena, parsed, best_paths);

                project->load_path_array.paths = ((Project_File_Load_Path*)linalloc_wrap_unintialized(linalloc_push((arena), sizeof(Project_File_Load_Path)*(list.count), SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_project_commands.cpp" ":" "276" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_project_commands.cpp" ":" "276" ":") - 1)))));
                project->load_path_array.count = list.count;

                Project_File_Load_Path *dst = project->load_path_array.paths;
                for (Config_Get_Result_Node *node = list.first;
                     node != 0;
                     node = node->next, ++dst){
                    Config_Compound *src = node->result.compound;
                    block_zero((dst), sizeof(*(dst)));
                    dst->recursive = true;
                    dst->relative = true;

                    String_Const_u8 str = {};
                    if (config_compound_string_member(parsed, src, "path", 0, &str)){
                        dst->path = push_string_copy(arena, str);
                    }

                    config_compound_bool_member(parsed, src, "recursive", 1, &dst->recursive);
                    config_compound_bool_member(parsed, src, "relative", 2, &dst->relative);
                }
            }
        }
    }


    {
        Config_Compound *compound = 0;
        if (config_compound_var(parsed, "command_list", 0, &compound)){
            Config_Get_Result_List list = typed_compound_array_reference_list(arena, parsed, compound);

            project->command_array.commands = ((Project_Command*)linalloc_wrap_unintialized(linalloc_push((arena), sizeof(Project_Command)*(list.count), SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_project_commands.cpp" ":" "306" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_project_commands.cpp" ":" "306" ":") - 1)))));
            project->command_array.count = list.count;

            Project_Command *dst = project->command_array.commands;
            for (Config_Get_Result_Node *node = list.first;
                 node != 0;
                 node = node->next, ++dst){
                u8 *pos = node->result.pos;
                Config_Compound *src = node->result.compound;
                block_zero((dst), sizeof(*(dst)));

                b32 can_emit_command = true;

                Config_Get_Result cmd_result = {};
                Config_Compound *cmd_set = 0;
                u8 *cmd_pos = 0;
                String_Const_u8 cmd_str = {};
                String_Const_u8 out = {};
                b32 footer_panel = false;
                b32 save_dirty_files = true;
                b32 cursor_at_end = false;
                String_Const_u8 name = {};

                if (!config_compound_string_member(parsed, src, "name", 0, &name)){
                    can_emit_command = false;
                    config_add_error(arena, parsed, pos, "a command must have a string type name member");
                    goto finish_command;
                }

                cmd_result = config_compound_member(parsed, src, SCu8((u8*)("cmd"), (u64)(sizeof("cmd") - 1)), 1);
                if (cmd_result.success && cmd_result.type == ConfigRValueType_Compound){
                    cmd_set = cmd_result.compound;
                    cmd_pos = cmd_result.pos;
                }
                else{
                    can_emit_command = false;
                    config_add_error(arena, parsed, pos, "a command must have an array type cmd member");
                    goto finish_command;
                }

                can_emit_command = false;
                for (i32 j = 0;; ++j){
                    Config_Iteration_Step_Result result = typed_array_iteration_step(parsed, cmd_set, ConfigRValueType_Compound, j);
                    if (result.step == Iteration_Skip){
                        continue;
                    }
                    else if (result.step == Iteration_Quit){
                        break;
                    }
                    Config_Compound *cmd_option = result.get.compound;

                    String_Const_u8 cmd = {};
                    if (config_compound_string_member(parsed, cmd_option, "cmd", 0, &cmd)){
                        String_Const_u8 str = {};
                        if (config_compound_string_member(parsed, cmd_option, "os", 1, &str)){
                            Project_OS_Match_Level r = parse_project__version_1__os_match(str, SCu8((u8*)("linux"), (u64)(sizeof("linux") - 1)));
                            if (r == ProjectOSMatchLevel_ActiveMatch){
                                can_emit_command = true;
                                cmd_str = cmd;
                                break;
                            }
                            else if (r == ProjectOSMatchLevel_PassiveMatch){
                                if (!can_emit_command){
                                    can_emit_command = true;
                                    cmd_str = cmd;
                                }
                            }
                        }
                    }
                }

                if (!can_emit_command){
                    config_add_error(arena, parsed, cmd_pos, "no usable command strings found in cmd");
                    goto finish_command;
                }

                config_compound_string_member(parsed, src, "out", 2, &out);
                config_compound_bool_member(parsed, src, "footer_panel", 3, &footer_panel);
                config_compound_bool_member(parsed, src, "save_dirty_files", 4,
                                            &save_dirty_files);
                config_compound_bool_member(parsed, src, "cursor_at_end", 5,
                                            &cursor_at_end);

                dst->name = push_string_copy(arena, name);
                dst->cmd = push_string_copy(arena, cmd_str);
                dst->out = push_string_copy(arena, out);
                dst->footer_panel = footer_panel;
                dst->save_dirty_files = save_dirty_files;
                dst->cursor_at_end = cursor_at_end;

                finish_command:;
            }
        }
    }


    {
        for (i32 i = 1; i <= 16; ++i){
            String_Const_u8 name = {};
            i32 index = -1;
            if (config_string_var(parsed, "fkey_command", i, &name)){
                i32 count = project->command_array.count;
                Project_Command *command_ptr = project->command_array.commands;
                for (i32 j = 0; j < count; ++j, ++command_ptr){
                    if (string_match(command_ptr->name, name)){
                        index = j;
                        break;
                    }
                }
            }
            project->fkey_commands[i - 1] = index;
        }
    }

    project->loaded = true;
    return(project);
}

static Project*
parse_project__config_data(Application_Links *app, Arena *arena, String_Const_u8 file_dir, Config *parsed){
    i32 version = 0;
    if (parsed->version != 0){
        version = *parsed->version;
    }

    Project *result = 0;
    switch (version){
        case 1:
        {
            result = parse_project__config_data__version_1(app, arena, file_dir, parsed);
        }break;
    }

    return(result);
}

static Project_Parse_Result
parse_project__data(Application_Links *app, Arena *arena, String_Const_u8 file_name, Data raw_data, String_Const_u8 file_dir){
    String_Const_u8 data = SCu8(raw_data);
    Project_Parse_Result result = {};
    Token_Array array = token_array_from_text(app, arena, data);
    if (array.tokens != 0){
        result.parsed = config_parse(app, arena, file_name, data, array);
        if (result.parsed != 0){
            result.project = parse_project__config_data(app, arena, file_dir,
                                                        result.parsed);
        }
    }
    return(result);
}

static Project_Parse_Result
parse_project__nearest_file(Application_Links *app, Arena *arena){
    Project_Parse_Result result = {};

    Temp_Memory restore_point = begin_temp(arena);
    String_Const_u8 project_path = push_hot_directory(app, arena);
    if (project_path.size == 0){
        print_message(app, SCu8((u8*)("The hot directory is empty, cannot search for a project.\n"), (u64)(sizeof("The hot directory is empty, cannot search for a project.\n") - 1)));
    }
    else{
        File_Name_Data dump = dump_file_search_up_path(app, arena, project_path, SCu8((u8*)("project.4coder"), (u64)(sizeof("project.4coder") - 1)));
        if (dump.data.data != 0){
            String_Const_u8 project_root = string_remove_last_folder(dump.file_name);
            result = parse_project__data(app, arena, dump.file_name, dump.data,
                                         project_root);
        }
        else{
            List_String_Const_u8 list = {};
            string_list_push(arena, &list, SCu8((u8*)("Did not find project.4coder.  "), (u64)(sizeof("Did not find project.4coder.  ") - 1)));
            if (current_project.loaded){
                string_list_push(arena, &list, SCu8((u8*)("Continuing with: "), (u64)(sizeof("Continuing with: ") - 1)));
                if (current_project.name.size > 0){
                    string_list_push(arena, &list, current_project.name);
                }
                else{
                    string_list_push(arena, &list, current_project.dir);
                }
            }
            else{
                string_list_push(arena, &list, SCu8((u8*)("Continuing without a project."), (u64)(sizeof("Continuing without a project.") - 1)));
            }
            string_list_push(arena, &list, SCu8((u8*)("\n"), (u64)(sizeof("\n") - 1)));
            String_Const_u8 message = string_list_flatten(arena, list);
            print_message(app, message);
            end_temp(restore_point);
        }
    }

    return(result);
}

static void
project_deep_copy__pattern_array(Arena *arena, Project_File_Pattern_Array *src_array, Project_File_Pattern_Array *dst_array){
    i32 pattern_count = src_array->count;
    dst_array->patterns = ((Project_File_Pattern*)linalloc_wrap_unintialized(linalloc_push((arena), sizeof(Project_File_Pattern)*(pattern_count), SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_project_commands.cpp" ":" "501" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_project_commands.cpp" ":" "501" ":") - 1)))));
    dst_array->count = pattern_count;
    Project_File_Pattern *dst = dst_array->patterns;
    Project_File_Pattern *src = src_array->patterns;
    for (i32 i = 0; i < pattern_count; ++i, ++dst, ++src){
        for (Node_String_Const_u8 *node = src->absolutes.first;
             node != 0;
             node = node->next){
            String_Const_u8 string = push_string_copy(arena, node->string);
            string_list_push(arena, &dst->absolutes, string);
        }
    }
}

static Project
project_deep_copy__inner(Arena *arena, Project *project){
    Project result = {};
    result.dir = push_string_copy(arena, project->dir);
    result.name = push_string_copy(arena, project->name);
    project_deep_copy__pattern_array(arena, &project->pattern_array, &result.pattern_array);
    project_deep_copy__pattern_array(arena, &project->blacklist_pattern_array, &result.blacklist_pattern_array);

    {
        i32 path_count = project->load_path_array.count;
        result.load_path_array.paths = ((Project_File_Load_Path*)linalloc_wrap_unintialized(linalloc_push((arena), sizeof(Project_File_Load_Path)*(path_count), SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_project_commands.cpp" ":" "525" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_project_commands.cpp" ":" "525" ":") - 1)))));
        result.load_path_array.count = path_count;

        Project_File_Load_Path *dst = result.load_path_array.paths;
        Project_File_Load_Path *src = project->load_path_array.paths;
        for (i32 i = 0; i < path_count; ++i, ++dst, ++src){
            dst->path = push_string_copy(arena, src->path);
            dst->recursive = src->recursive;
            dst->relative = src->relative;
        }
    }

    {
        i32 command_count = project->command_array.count;
        result.command_array.commands = ((Project_Command*)linalloc_wrap_zero(linalloc_push((arena), sizeof(Project_Command)*(command_count), SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_project_commands.cpp" ":" "539" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_project_commands.cpp" ":" "539" ":") - 1)))));
        result.command_array.count = command_count;

        Project_Command *dst = result.command_array.commands;
        Project_Command *src = project->command_array.commands;
        for (i32 i = 0; i < command_count; ++i, ++dst, ++src){
            if (src->name.str != 0){
                dst->name = push_string_copy(arena, src->name);
            }
            if (src->cmd.str != 0){
                dst->cmd = push_string_copy(arena, src->cmd);
            }
            if (src->out.str != 0){
                dst->out = push_string_copy(arena, src->out);
            }
            dst->footer_panel = src->footer_panel;
            dst->save_dirty_files = src->save_dirty_files;
            dst->cursor_at_end = src->cursor_at_end;
        }
    }

    block_copy((result.fkey_commands), (project->fkey_commands), sizeof(result.fkey_commands));

    result.loaded = true;
    return(result);
}

static Project
project_deep_copy(Arena *arena, Project *project){
    Temp_Memory restore_point = begin_temp(arena);
    Project result = project_deep_copy__inner(arena, project);
    if (!result.loaded){
        end_temp(restore_point);
        block_zero((&result), sizeof(*(&result)));
    }
    return(result);
}

static void
config_feedback_file_pattern_array(Arena *arena, List_String_Const_u8 *list, char *name, Project_File_Pattern_Array *array){
    string_list_pushf(arena, list, "%s = {\n", name);
    Project_File_Pattern *pattern = array->patterns;
    for (i32 i = 0; i < array->count; ++i, ++pattern){
        string_list_push((arena), (list), SCu8((u8*)("\""), (u64)(sizeof("\"") - 1)));
        b32 is_first = true;
        for (Node_String_Const_u8 *node = pattern->absolutes.first;
             node != 0;
             node = node->next){
            if (is_first){
                string_list_push(arena, list, node->string);
                is_first = false;
            }
            else{
                string_list_pushf(arena, list, "*%.*s", (i32)(node->string).size, (char*)(node->string).str);
            }
        }
        string_list_push((arena), (list), SCu8((u8*)("\",\n"), (u64)(sizeof("\",\n") - 1)));
    }
    string_list_push((arena), (list), SCu8((u8*)("};\n"), (u64)(sizeof("};\n") - 1)));
}

static void
config_feedback_file_load_path_array(Arena *arena, List_String_Const_u8 *list, char *name, Project_File_Load_Path_Array *array){
    string_list_pushf(arena, list, "%s = {\n", name);
    Project_File_Load_Path *path = array->paths;
    for (i32 i = 0; i < array->count; ++i, ++path){
        string_list_pushf(arena, list, "{ .path = \"%.*s\", .recursive = %s, .relative = %s, },\n",
                          (i32)(path->path).size, (char*)(path->path).str, (char*)(path->recursive?"true":"false"), (char*)(path->relative?"true":"false"));
    }
    string_list_push((arena), (list), SCu8((u8*)("};\n"), (u64)(sizeof("};\n") - 1)));
}

static void
config_feedback_command_array(Arena *arena, List_String_Const_u8 *list, char *name, Project_Command_Array *array){
    string_list_pushf(arena, list, "%s = {\n", name);
    Project_Command *command = array->commands;
    for (i32 i = 0; i < array->count; ++i, ++command){
        string_list_pushf(arena, list,
                          "{ .name = \"%.*s\", .cmd = \"%.*s\", .out = \"%.*s\", "
                          ".footer_panel = %s, .save_dirty_files = %s, .cursor_at_end = %s, },\n",
                          (i32)(command->name).size, (char*)(command->name).str, (i32)(command->cmd).size, (char*)(command->cmd).str, (i32)(command->out).size, (char*)(command->out).str,
                          (char*)(command->footer_panel?"true":"false"),
                          (char*)(command->save_dirty_files?"true":"false"),
                          (char*)(command->cursor_at_end?"true":"false"));
    }
    string_list_push((arena), (list), SCu8((u8*)("};\n"), (u64)(sizeof("};\n") - 1)));
}

static void
set_current_project(Application_Links *app, Project *project, Config *parsed){
    b32 print_feedback = false;
    Scratch_Block scratch(app);

    if (parsed != 0 && project != 0){
        if (current_project_arena.base_allocator == 0){
            current_project_arena = make_arena_system();
        }


        linalloc_clear(&current_project_arena);
        Project new_project = project_deep_copy(&current_project_arena, project);
        if (new_project.loaded){
            current_project = new_project;

            print_feedback = true;


            for (i32 i = 0; i < current_project.load_path_array.count; ++i){
                Project_File_Load_Path *load_path = &current_project.load_path_array.paths[i];
                u32 flags = 0;
                if (load_path->recursive){
                    flags |= OpenAllFilesFlag_Recursive;
                }

                Temp_Memory temp = begin_temp(scratch);
                String_Const_u8 path_str = load_path->path;
                String_Const_u8 file_dir = path_str;
                if (load_path->relative){
                    String_Const_u8 project_dir = current_project.dir;
                    List_String_Const_u8 file_dir_list = {};
                    string_list_push(scratch, &file_dir_list, project_dir);
                    string_list_push_overlap(scratch, &file_dir_list, '/', path_str);
                    string_list_push_overlap(scratch, &file_dir_list, '/', SCu8());
                    file_dir = string_list_flatten(scratch, file_dir_list, StringFill_NullTerminate);
                }

                Project_File_Pattern_Array whitelist = current_project.pattern_array;
                Project_File_Pattern_Array blacklist = current_project.blacklist_pattern_array;
                open_files_pattern_match(app, file_dir, whitelist, blacklist, flags);
                end_temp(temp);
            }


            if (project->name.size > 0){
                Temp_Memory temp = begin_temp(scratch);
                String_Const_u8 builder = push_u8_stringf(scratch, "4coder project: %.*s",
                                                          (i32)(project->name).size, (char*)(project->name).str);
                set_window_title(app, builder);
                end_temp(temp);
            }
        }
        else{

            print_message(app, SCu8((u8*)("Failed to initialize new project; need more memory dedicated to the project system.\n"), (u64)(sizeof("Failed to initialize new project; need more memory dedicated to the project system.\n") - 1)));

        }
    }
    else if (parsed != 0){
        print_feedback = true;
    }

    if (print_feedback){
        Temp_Memory temp = begin_temp(scratch);


        String_Const_u8 error_text = config_stringize_errors(app, scratch, parsed);
        if (error_text.size > 0){
            print_message(app, SCu8((u8*)("Project errors:\n"), (u64)(sizeof("Project errors:\n") - 1)));
            print_message(app, error_text);
            print_message(app, SCu8((u8*)("\n"), (u64)(sizeof("\n") - 1)));
        }


        if (project == 0){
            print_message(app, SCu8((u8*)("Could not instantiate project\n"), (u64)(sizeof("Could not instantiate project\n") - 1)));
        }
        else{
            print_message(app, SCu8((u8*)("New project contents:\n"), (u64)(sizeof("New project contents:\n") - 1)));

            Temp_Memory temp2 = begin_temp(scratch);
            List_String_Const_u8 list = {};

            config_feedback_string(scratch, &list, "'root_directory'", project->dir);
            config_feedback_string(scratch, &list, "project_name", project->name);

            config_feedback_file_pattern_array(scratch, &list, "patterns", &project->pattern_array);
            config_feedback_file_pattern_array(scratch, &list, "blacklist_patterns", &project->blacklist_pattern_array);
            config_feedback_file_load_path_array(scratch, &list, "load_paths", &project->load_path_array);
            config_feedback_command_array(scratch, &list, "command_list", &project->command_array);

            string_list_push((scratch), (&list), SCu8((u8*)("\n"), (u64)(sizeof("\n") - 1)));

            String_Const_u8 message = string_list_flatten(scratch, list);
            print_message(app, message);
            end_temp(temp2);
        }

        end_temp(temp);
    }
}

static void
set_current_project_from_data(Application_Links *app, String_Const_u8 file_name,
                              Data data, String_Const_u8 file_dir){
    Scratch_Block scratch(app);
    Project_Parse_Result project_parse = parse_project__data(app, scratch, file_name, data, file_dir);
    set_current_project(app, project_parse.project, project_parse.parsed);
}

static void
set_current_project_from_nearest_project_file(Application_Links *app){
    Scratch_Block scratch(app);
    Project_Parse_Result project_parse = parse_project__nearest_file(app, scratch);
    set_current_project(app, project_parse.project, project_parse.parsed);
}

static void
exec_project_command(Application_Links *app, Project_Command *command){
    if (command->cmd.size > 0){
        b32 footer_panel = command->footer_panel;
        b32 save_dirty_files = command->save_dirty_files;
        b32 cursor_at_end = command->cursor_at_end;

        if (save_dirty_files){
            save_all_dirty_buffers(app);
        }

        View_ID view = 0;
        Buffer_Identifier buffer_id = {};
        u32 flags = CLI_OverlapWithConflict|CLI_SendEndSignal;
        if (cursor_at_end){
            flags |= CLI_CursorAtEnd;
        }

        b32 set_fancy_font = false;
        if (command->out.size > 0){
            buffer_id = buffer_identifier(command->out);

            if (footer_panel){
                view = get_or_open_build_panel(app);
                if (string_match(command->out, SCu8((u8*)("*compilation*"), (u64)(sizeof("*compilation*") - 1)))){
                    set_fancy_font = true;
                }
            }
            else{
                Buffer_ID buffer = buffer_identifier_to_id(app, buffer_id);
                view = get_first_view_with_buffer(app, buffer);
                if (view == 0){
                    view = get_active_view(app, Access_Always);
                }
            }

            block_zero((&prev_location), sizeof(*(&prev_location)));
            lock_jump_buffer(app, command->out);
        }
        else{

            buffer_id = buffer_identifier(SCu8((u8*)("*dump*"), (u64)(sizeof("*dump*") - 1)));
        }

        String_Const_u8 dir = current_project.dir;
        String_Const_u8 cmd = command->cmd;
        exec_system_command(app, view, buffer_id, dir, cmd, flags);
        if (set_fancy_font){
            set_fancy_compilation_buffer_font(app);
        }
    }
}

static void
exec_project_command_by_index(Application_Links *app, i32 command_index){
    if (!current_project.loaded){
        return;
    }
    if (command_index < 0 || command_index >= current_project.command_array.count){
        return;
    }
    Project_Command *command = &current_project.command_array.commands[command_index];
    exec_project_command(app, command);
}

static void
exec_project_fkey_command(Application_Links *app, i32 fkey_index){
    if (!current_project.loaded){
        return;
    }
    i32 command_index = current_project.fkey_commands[fkey_index];
    if (command_index < 0 || command_index >= current_project.command_array.count){
        return;
    }
    Project_Command *command = &current_project.command_array.commands[command_index];
    exec_project_command(app, command);
}

static void
exec_project_command_by_name(Application_Links *app, String_Const_u8 name){
    if (!current_project.loaded){
        return;
    }
    Project_Command *command = current_project.command_array.commands;
    for (i32 i = 0; i < current_project.command_array.count; ++i, ++command){
        if (string_match(command->name, name)){
            exec_project_command(app, command);
            break;
        }
    }
}

static void
exec_project_command_by_name(Application_Links *app, char *name){
    exec_project_command_by_name(app, SCu8(name));
}



CUSTOM_COMMAND(close_all_code, "/home/sam/.bin/4coder/custom/4coder_project_commands.cpp", 844, Normal)
CUSTOM_DOC("Closes any buffer with a filename ending with an extension configured to be recognized as a code file type.")
{
    close_all_files_with_extension(app, global_config.code_exts);
}

CUSTOM_COMMAND(open_all_code, "/home/sam/.bin/4coder/custom/4coder_project_commands.cpp", 850, Normal)
CUSTOM_DOC("Open all code in the current directory. File types are determined by extensions. An extension is considered code based on the extensions specified in 4coder.config.")
{
    open_all_files_in_hot_with_extension(app, global_config.code_exts, 0);
}

CUSTOM_COMMAND(open_all_code_recursive, "/home/sam/.bin/4coder/custom/4coder_project_commands.cpp", 856, Normal)
CUSTOM_DOC("Works as open_all_code but also runs in all subdirectories.")
{
    open_all_files_in_hot_with_extension(app, global_config.code_exts, OpenAllFilesFlag_Recursive);
}



CUSTOM_COMMAND(load_project, "/home/sam/.bin/4coder/custom/4coder_project_commands.cpp", 864, Normal)
CUSTOM_DOC("Looks for a project.4coder file in the current directory and tries to load it.  Looks in parent directories until a project file is found or there are no more parents.")
{
    Profile_Scope_Block profile_block_867 ((app), SCu8((u8*)("load project"), (u64)(sizeof("load project") - 1)), SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_project_commands.cpp" ":" "867" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_project_commands.cpp" ":" "867" ":") - 1)));
    save_all_dirty_buffers(app);
    set_current_project_from_nearest_project_file(app);
}

CUSTOM_COMMAND(project_fkey_command, "/home/sam/.bin/4coder/custom/4coder_project_commands.cpp", 872, Normal)
CUSTOM_DOC("Run an 'fkey command' configured in a project.4coder file.  Determines the index of the 'fkey command' by which function key or numeric key was pressed to trigger the command.")
{
    Profile_Scope_Block profile_block_875 ((app), SCu8((u8*)("project fkey command"), (u64)(sizeof("project fkey command") - 1)), SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_project_commands.cpp" ":" "875" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_project_commands.cpp" ":" "875" ":") - 1)));
    User_Input input = get_current_input(app);
    b32 got_ind = false;
    i32 ind = 0;
    if (input.event.kind == InputEventKind_KeyStroke){
        if (KeyCode_F1 <= input.event.key.code && input.event.key.code <= KeyCode_F16){
            ind = (input.event.key.code - KeyCode_F1);
            got_ind = true;
        }
        else if (KeyCode_1 <= input.event.key.code && input.event.key.code <= KeyCode_9){
            ind = (input.event.key.code - '1');
            got_ind = true;
        }
        else if (input.event.key.code == KeyCode_0){
            ind = 9;
            got_ind = true;
        }
        if (got_ind){
            exec_project_fkey_command(app, ind);
        }
    }
}

CUSTOM_COMMAND(project_go_to_root_directory, "/home/sam/.bin/4coder/custom/4coder_project_commands.cpp", 898, Normal)
CUSTOM_DOC("Changes 4coder's hot directory to the root directory of the currently loaded project. With no loaded project nothing hapepns.")
{
    if (current_project.loaded){
        set_hot_directory(app, current_project.dir);
    }
}



static Project_Setup_Status
project_is_setup(Application_Links *app, String_Const_u8 script_path, String_Const_u8 script_file){
    Project_Setup_Status result = {};
    {
        Scratch_Block scratch(app);
        String_Const_u8 bat_path = push_u8_stringf(scratch, "%.*s/%.*s.bat",
                                                   (i32)(script_path).size, (char*)(script_path).str,
                                                   (i32)(script_file).size, (char*)(script_file).str);
        result.bat_exists = file_exists(app, bat_path);
    }
    {
        Scratch_Block scratch(app);
        String_Const_u8 sh_path = push_u8_stringf(scratch, "%.*s/%.*s.sh",
                                                  (i32)(script_path).size, (char*)(script_path).str,
                                                  (i32)(script_file).size, (char*)(script_file).str);
        result.sh_exists = file_exists(app, sh_path);
    }
    {
        Scratch_Block scratch(app);
        String_Const_u8 project_path = push_u8_stringf(scratch, "%.*s/project.4coder",
                                                       (i32)(script_path).size, (char*)(script_path).str);
        result.sh_exists = file_exists(app, project_path);
    }
    result.everything_exists = (result.bat_exists && result.sh_exists && result.project_exists);
    return(result);
}

static Project_Key_Strings
project_key_strings_query_user(Application_Links *app,
                               b32 get_script_file, b32 get_code_file,
                               u8 *script_file_space, i32 script_file_cap,
                               u8 *code_file_space, i32 code_file_cap,
                               u8 *output_dir_space, i32 output_dir_cap,
                               u8 *binary_file_space, i32 binary_file_cap){
    Project_Key_Strings keys = {};

    Query_Bar_Group bar_group(app);

    Query_Bar script_file_bar = {};
    Query_Bar code_file_bar = {};
    Query_Bar output_dir_bar = {};
    Query_Bar binary_file_bar = {};

    if (get_script_file){
        script_file_bar.prompt = SCu8((u8*)("Script Name: "), (u64)(sizeof("Script Name: ") - 1));
        script_file_bar.string = SCu8(script_file_space, (u64)0);
        script_file_bar.string_capacity = script_file_cap;
        if (!query_user_string(app, &script_file_bar)) return(keys);
        if (script_file_bar.string.size == 0) return(keys);
    }

    if (get_code_file){
        code_file_bar.prompt = SCu8((u8*)("Build Target: "), (u64)(sizeof("Build Target: ") - 1));
        code_file_bar.string = SCu8(code_file_space, (u64)0);
        code_file_bar.string_capacity = code_file_cap;
        if (!query_user_string(app, &code_file_bar)) return(keys);
        if (code_file_bar.string.size == 0) return(keys);
    }

    output_dir_bar.prompt = SCu8((u8*)("Output Directory: "), (u64)(sizeof("Output Directory: ") - 1));
    output_dir_bar.string = SCu8(output_dir_space, (u64)0);
    output_dir_bar.string_capacity = output_dir_cap;
    if (!query_user_string(app, &output_dir_bar)) return(keys);
    if (output_dir_bar.string.size == 0 && output_dir_cap > 0){
        output_dir_bar.string.str[0] = '.';
        output_dir_bar.string.size = 1;
    }

    binary_file_bar.prompt = SCu8((u8*)("Binary Output: "), (u64)(sizeof("Binary Output: ") - 1));
    binary_file_bar.string = SCu8(binary_file_space, (u64)0);
    binary_file_bar.string_capacity = binary_file_cap;
    if (!query_user_string(app, &binary_file_bar)) return(keys);
    if (binary_file_bar.string.size == 0) return(keys);

    keys.success = true;
    keys.script_file = script_file_bar.string;
    keys.code_file = code_file_bar.string;
    keys.output_dir = output_dir_bar.string;
    keys.binary_file = binary_file_bar.string;

    return(keys);
}

static b32
project_generate_bat_script(Arena *scratch, String_Const_u8 opts, String_Const_u8 compiler,
                            String_Const_u8 script_path, String_Const_u8 script_file,
                            String_Const_u8 code_file, String_Const_u8 output_dir, String_Const_u8 binary_file){
    b32 success = false;

    Temp_Memory temp = begin_temp(scratch);

    String_Const_u8 cf = push_string_copy(scratch, code_file);
    String_Const_u8 od = push_string_copy(scratch, output_dir);
    String_Const_u8 bf = push_string_copy(scratch, binary_file);

    cf = string_mod_replace_character(cf, '/', '\\');
    od = string_mod_replace_character(od, '/', '\\');
    bf = string_mod_replace_character(bf, '/', '\\');

    String_Const_u8 file_name = push_u8_stringf(scratch, "%.*s/%.*s.bat",
                                                (i32)(script_path).size, (char*)(script_path).str,
                                                (i32)(script_file).size, (char*)(script_file).str);

    FILE *bat_script = fopen((char*)file_name.str, "wb");
    if (bat_script != 0){
        fprintf(bat_script, "@echo off\n\n");
        fprintf(bat_script, "set opts=%.*s\n", (i32)opts.size, opts.str);
        fprintf(bat_script, "set code=%%cd%%\n");
        fprintf(bat_script, "pushd %.*s\n", (i32)od.size, od.str);
        fprintf(bat_script, "%.*s %%opts%% %%code%%\\%.*s -Fe%.*s\n",
                (i32)compiler.size, compiler.str, (i32)cf.size, cf.str, (i32)bf.size, bf.str);
        fprintf(bat_script, "popd\n");
        fclose(bat_script);
        success = true;
    }

    end_temp(temp);

    return(success);
}

static b32
project_generate_sh_script(Arena *scratch, String_Const_u8 opts, String_Const_u8 compiler,
                           String_Const_u8 script_path, String_Const_u8 script_file,
                           String_Const_u8 code_file, String_Const_u8 output_dir, String_Const_u8 binary_file){
    b32 success = false;

    Temp_Memory temp = begin_temp(scratch);

    String_Const_u8 cf = code_file;
    String_Const_u8 od = output_dir;
    String_Const_u8 bf = binary_file;

    String_Const_u8 file_name = push_u8_stringf(scratch, "%.*s/%.*s.sh",
                                                (i32)(script_path).size, (char*)(script_path).str,
                                                (i32)(script_file).size, (char*)(script_file).str);

    FILE *sh_script = fopen((char*)file_name.str, "wb");
    if (sh_script != 0){
        fprintf(sh_script, "#!/bin/bash\n\n");
        fprintf(sh_script, "code=\"$PWD\"\n");
        fprintf(sh_script, "opts=%.*s\n", (i32)(opts).size, (char*)(opts).str);
        fprintf(sh_script, "cd %.*s > /dev/null\n", (i32)(od).size, (char*)(od).str);
        fprintf(sh_script, "%.*s $opts $code/%.*s -o %.*s\n", (i32)(compiler).size, (char*)(compiler).str, (i32)(cf).size, (char*)(cf).str, (i32)(bf).size, (char*)(bf).str);
        fprintf(sh_script, "cd $code > /dev/null\n");
        fclose(sh_script);
        success = true;
    }

    end_temp(temp);

    return(success);
}

static b32
project_generate_project_4coder_file(Arena *scratch, String_Const_u8 script_path, String_Const_u8 script_file, String_Const_u8 output_dir, String_Const_u8 binary_file){
    b32 success = false;

    Temp_Memory temp = begin_temp(scratch);

    String_Const_u8 od = output_dir;
    String_Const_u8 bf = binary_file;

    String_Const_u8 od_win = string_replace(scratch, od,
                                            SCu8((u8*)("/"), (u64)(sizeof("/") - 1)), SCu8((u8*)("\\"), (u64)(sizeof("\\") - 1)));
    String_Const_u8 bf_win = string_replace(scratch, bf,
                                            SCu8((u8*)("/"), (u64)(sizeof("/") - 1)), SCu8((u8*)("\\"), (u64)(sizeof("\\") - 1)));

    String_Const_u8 file_name = push_u8_stringf(scratch, "%.*s/project.4coder", (i32)(script_path).size, (char*)(script_path).str);

    FILE *out = fopen((char*)file_name.str, "wb");
    if (out != 0){
        fprintf(out, "version(1);\n");
        fprintf(out, "project_name = \"%.*s\";\n", (i32)(binary_file).size, (char*)(binary_file).str);
        fprintf(out, "patterns = {\n");
        fprintf(out, "\"*.c\",\n");
        fprintf(out, "\"*.cpp\",\n");
        fprintf(out, "\"*.h\",\n");
        fprintf(out, "\"*.m\",\n");
        fprintf(out, "\"*.bat\",\n");
        fprintf(out, "\"*.sh\",\n");
        fprintf(out, "\"*.4coder\",\n");
        fprintf(out, "};\n");
        fprintf(out, "blacklist_patterns = {\n");
        fprintf(out, "\".*\",\n");
        fprintf(out, "};\n");
        fprintf(out, "load_paths_base = {\n");
        fprintf(out, " { \".\", .relative = true, .recursive = true, },\n");
        fprintf(out, "};\n");
        fprintf(out, "load_paths = {\n");
        fprintf(out, " { load_paths_base, .os = \"win\", },\n");
        fprintf(out, " { load_paths_base, .os = \"linux\", },\n");
        fprintf(out, " { load_paths_base, .os = \"mac\", },\n");
        fprintf(out, "};\n");

        fprintf(out, "\n");

        fprintf(out, "command_list = {\n");
        fprintf(out, " { .name = \"build\",\n");
        fprintf(out, "   .out = \"*compilation*\", .footer_panel = true, .save_dirty_files = true,\n");
        fprintf(out, "   .cmd = { { \"%.*s.bat\" , .os = \"win\"   },\n", (i32)(script_file).size, (char*)(script_file).str);
        fprintf(out, "            { \"./%.*s.sh\", .os = \"linux\" },\n", (i32)(script_file).size, (char*)(script_file).str);
        fprintf(out, "            { \"./%.*s.sh\", .os = \"mac\"   }, }, },\n", (i32)(script_file).size, (char*)(script_file).str);
        fprintf(out, " { .name = \"run\",\n");
        fprintf(out, "   .out = \"*run*\", .footer_panel = false, .save_dirty_files = false,\n");
        fprintf(out, "   .cmd = { { \"%.*s\\\\%.*s\", .os = \"win\"   },\n", (i32)(od_win).size, (char*)(od_win).str, (i32)(bf_win).size, (char*)(bf_win).str);
        fprintf(out, "            { \"%.*s/%.*s\" , .os = \"linux\" },\n", (i32)(od).size, (char*)(od).str, (i32)(bf).size, (char*)(bf).str);
        fprintf(out, "            { \"%.*s/%.*s\" , .os = \"mac\"   }, }, },\n", (i32)(od).size, (char*)(od).str, (i32)(bf).size, (char*)(bf).str);
        fprintf(out, "};\n");

        fprintf(out, "fkey_command[1] = \"build\";\n");
        fprintf(out, "fkey_command[2] = \"run\";\n");

        fclose(out);
        success = true;
    }

    end_temp(temp);

    return(success);
}

static void
project_setup_scripts__generic(Application_Links *app, b32 do_project_file, b32 do_bat_script, b32 do_sh_script){
    Scratch_Block scratch(app);
    String_Const_u8 script_path = push_hot_directory(app, scratch);

    b32 needs_to_do_work = false;
    Project_Setup_Status status = {};
    if (do_project_file){
        status = project_is_setup(app, script_path, SCu8((u8*)("build"), (u64)(sizeof("build") - 1)));
        needs_to_do_work =
            !status.project_exists ||
            (do_bat_script && !status.bat_exists) ||
            (do_sh_script && !status.sh_exists);
    }
    else{
        needs_to_do_work = true;
    }

    if (needs_to_do_work){

        u8 script_file_space[1024];
        u8 code_file_space [1024];
        u8 output_dir_space [1024];
        u8 binary_file_space[1024];

        b32 get_script_file = !do_project_file;
        b32 get_code_file =
            (do_bat_script && !status.bat_exists) ||
            (do_sh_script && !status.sh_exists);

        Project_Key_Strings keys = {};
        keys = project_key_strings_query_user(app, get_script_file, get_code_file,
                                              script_file_space, sizeof(script_file_space),
                                              code_file_space, sizeof(code_file_space),
                                              output_dir_space, sizeof(output_dir_space),
                                              binary_file_space, sizeof(binary_file_space));

        if (!keys.success){
            return;
        }

        if (do_project_file){
            keys.script_file = SCu8((u8*)("build"), (u64)(sizeof("build") - 1));
        }

        if (!do_project_file){
            status = project_is_setup(app, script_path, keys.script_file);
        }


        if (do_bat_script){
            if (!status.bat_exists){
                if (!project_generate_bat_script(scratch,
                                                 global_config.default_flags_bat,
                                                 global_config.default_compiler_bat,
                                                 script_path, keys.script_file,
                                                 keys.code_file, keys.output_dir, keys.binary_file)){
                    print_message(app, SCu8((u8*)("could not create build.bat for new project\n"), (u64)(sizeof("could not create build.bat for new project\n") - 1)));
                }
            }
            else{
                print_message(app, SCu8((u8*)("the batch script already exists, no changes made to it\n"), (u64)(sizeof("the batch script already exists, no changes made to it\n") - 1)));
            }
        }

        if (do_sh_script){
            if (!status.bat_exists){
                if (!project_generate_sh_script(scratch,
                                                global_config.default_flags_sh,
                                                global_config.default_compiler_sh,
                                                script_path, keys.script_file,
                                                keys.code_file, keys.output_dir, keys.binary_file)){
                    print_message(app, SCu8((u8*)("could not create build.sh for new project\n"), (u64)(sizeof("could not create build.sh for new project\n") - 1)));
                }
            }
            else{
                print_message(app, SCu8((u8*)("the shell script already exists, no changes made to it\n"), (u64)(sizeof("the shell script already exists, no changes made to it\n") - 1)));
            }
        }

        if (do_project_file){
            if (!status.project_exists){
                if (!project_generate_project_4coder_file(scratch,
                                                          script_path,
                                                          keys.script_file,
                                                          keys.output_dir,
                                                          keys.binary_file)){
                    print_message(app, SCu8((u8*)("could not create project.4coder for new project\n"), (u64)(sizeof("could not create project.4coder for new project\n") - 1)));
                }
            }
            else{
                print_message(app, SCu8((u8*)("project.4coder already exists, no changes made to it\n"), (u64)(sizeof("project.4coder already exists, no changes made to it\n") - 1)));
            }
        }
    }
    else{
        if (do_project_file){
            print_message(app, SCu8((u8*)("project already setup, no changes made\n"), (u64)(sizeof("project already setup, no changes made\n") - 1)));
        }
    }
}

CUSTOM_COMMAND(setup_new_project, "/home/sam/.bin/4coder/custom/4coder_project_commands.cpp", 1232, Normal)
CUSTOM_DOC("Queries the user for several configuration options and initializes a new 4coder project with build scripts for every OS.")
{
    project_setup_scripts__generic(app, true, true, true);
    load_project(app);
}

CUSTOM_COMMAND(setup_build_bat, "/home/sam/.bin/4coder/custom/4coder_project_commands.cpp", 1239, Normal)
CUSTOM_DOC("Queries the user for several configuration options and initializes a new build batch script.")
{
    project_setup_scripts__generic(app, false, true, false);
}

CUSTOM_COMMAND(setup_build_sh, "/home/sam/.bin/4coder/custom/4coder_project_commands.cpp", 1245, Normal)
CUSTOM_DOC("Queries the user for several configuration options and initializes a new build shell script.")
{
    project_setup_scripts__generic(app, false, false, true);
}

CUSTOM_COMMAND(setup_build_bat_and_sh, "/home/sam/.bin/4coder/custom/4coder_project_commands.cpp", 1251, Normal)
CUSTOM_DOC("Queries the user for several configuration options and initializes a new build batch script.")
{
    project_setup_scripts__generic(app, false, true, true);
}



static Project_Command_Lister_Result
get_project_command_from_user(Application_Links *app, Project *project, String_Const_u8 query){
    Project_Command_Lister_Result result = {};
    if (project != 0){
        Scratch_Block scratch(app);
        Lister_Block lister(app, scratch);
        lister_set_query(lister, query);
        lister_set_default_handlers(lister);

        Project_Command *proj_cmd = project->command_array.commands;
        i32 count = project->command_array.count;
        for (i32 i = 0; i < count; i += 1, proj_cmd += 1){
            lister_add_item(lister, proj_cmd->name, proj_cmd->cmd, (void*)(((u8*)0) + i), 0);
        }

        Lister_Result l_result = run_lister(app, lister);
        if (!l_result.canceled){
            result.success = true;
            result.index = (i32)((u8*)(l_result.user_data) - (u8*)(0));
        }
    }

    return(result);
}


static Project_Command_Lister_Result
get_project_command_from_user(Application_Links *app, Project *project, char *query){
    return(get_project_command_from_user(app, project, SCu8(query)));
}

CUSTOM_COMMAND(project_command_lister, "/home/sam/.bin/4coder/custom/4coder_project_commands.cpp", 1290, Normal)
CUSTOM_DOC("Open a lister of all commands in the currently loaded project.")
{
    if (current_project.loaded){
        Project_Command_Lister_Result proj_cmd =
            get_project_command_from_user(app, &current_project, "Command:");
        if (proj_cmd.success){
            exec_project_command_by_index(app, proj_cmd.index);
        }
    }
}
# 120 "/home/sam/.bin/4coder/custom/4coder_default_include.cpp" 2
# 1 "/home/sam/.bin/4coder/custom/4coder_function_list.cpp" 1
# 14 "/home/sam/.bin/4coder/custom/4coder_function_list.cpp"
static Get_Positions_Results
get_function_positions(Application_Links *app, Buffer_ID buffer, i64 first_token_index, Function_Positions *positions_array, i64 positions_max){
    Get_Positions_Results result = {};

    Token_Array array = get_token_array_from_buffer(app, buffer);
    if (array.tokens != 0){
        Token_Iterator_Array it = token_iterator_index(buffer, &array, first_token_index);

        i32 nest_level = 0;
        i32 paren_nest_level = 0;

        Token_Iterator_Array first_paren_it = {};
        i64 first_paren_index = 0;
        i64 first_paren_position = 0;
        i64 last_paren_index = 0;


        mode1:
        do{ if (!(nest_level == 0)) { (*((i32*)0) = 0xA11E); } }while(0);
        do{ if (!(paren_nest_level == 0)) { (*((i32*)0) = 0xA11E); } }while(0);
        first_paren_index = 0;
        first_paren_position = 0;
        last_paren_index = 0;
        for (;;){
            Token *token = token_it_read(&it);
            if (!(((token->flags)&(TokenBaseFlag_PreprocessorBody))!=0)){
                switch (token->sub_kind){
                    case TokenCppKind_BraceOp:
                    {
                        ++nest_level;
                    }break;

                    case TokenCppKind_BraceCl:
                    {
                        if (nest_level > 0){
                            --nest_level;
                        }
                    }break;

                    case TokenCppKind_ParenOp:
                    {
                        if (nest_level == 0){
                            first_paren_it = it;
                            first_paren_index = token_it_index(&it);
                            first_paren_position = token->pos;
                            goto paren_mode1;
                        }
                    }break;
                }
            }
            if (!token_it_inc(&it)){
                goto end;
            }
        }


        paren_mode1:
        paren_nest_level = 0;
        for (;;){
            Token *token = token_it_read(&it);
            if (!(((token->flags)&(TokenBaseFlag_PreprocessorBody))!=0)){
                switch (token->sub_kind){
                    case TokenCppKind_ParenOp:
                    {
                        ++paren_nest_level;
                    }break;

                    case TokenCppKind_ParenCl:
                    {
                        --paren_nest_level;
                        if (paren_nest_level == 0){
                            last_paren_index = token_it_index(&it);
                            goto paren_mode2;
                        }
                    }break;
                }
            }
            if (!token_it_inc(&it)){
                goto end;
            }
        }


        paren_mode2:
        {
            Token_Iterator_Array restore_point = it;
            it = first_paren_it;
            i64 signature_start_index = 0;
            for (;;){
                Token *token = token_it_read(&it);
                if ((((token->flags)&(TokenBaseFlag_PreprocessorBody))!=0) ||
                    token->sub_kind == TokenCppKind_BraceCl ||
                    token->sub_kind == TokenCppKind_Semicolon ||
                    token->sub_kind == TokenCppKind_ParenCl){
                    if (!token_it_inc(&it)){
                        signature_start_index = first_paren_index;
                    }
                    else{
                        signature_start_index = token_it_index(&it);
                    }
                    goto paren_mode2_done;
                }
                if (!token_it_dec(&it)){
                    break;
                }
            }



            signature_start_index = 0;

            paren_mode2_done:;
            {
                Function_Positions positions = {};
                positions.sig_start_index = signature_start_index;
                positions.sig_end_index = last_paren_index;
                positions.open_paren_pos = first_paren_position;
                positions_array[result.positions_count++] = positions;
            }

            it = restore_point;
            if (result.positions_count >= positions_max){
                result.next_token_index = token_it_index(&it);
                result.still_looping = true;
                goto end;
            }

            goto mode1;
        }
        end:;
    }

    return(result);
}

static void
print_positions_buffered(Application_Links *app, Buffer_Insertion *out, Buffer_ID buffer, Function_Positions *positions_array, i64 positions_count){
    Scratch_Block scratch(app);

    String_Const_u8 buffer_name = push_buffer_unique_name(app, scratch, buffer);

    for (i32 i = 0; i < positions_count; ++i){
        Function_Positions *positions = &positions_array[i];

        i64 start_index = positions->sig_start_index;
        i64 end_index = positions->sig_end_index;
        i64 open_paren_pos = positions->open_paren_pos;
        i64 line_number = get_line_number_from_pos(app, buffer, open_paren_pos);

        do{ if (!(end_index > start_index)) { (*((i32*)0) = 0xA11E); } }while(0);

        Token_Array array = get_token_array_from_buffer(app, buffer);
        if (array.tokens != 0){
            insertf(out, "%.*s:%lld: ", (i32)(buffer_name).size, (char*)(buffer_name).str, line_number);

            Token prev_token = {};
            Token_Iterator_Array it = token_iterator_index(buffer, &array, start_index);
            for (;;){
                Token *token = token_it_read(&it);
                if (!(((token->flags)&(TokenBaseFlag_PreprocessorBody))!=0) &&
                    token->kind != TokenBaseKind_Comment &&
                    token->kind != TokenBaseKind_Whitespace){
                    if ((prev_token.sub_kind == TokenCppKind_Identifier ||
                         prev_token.sub_kind == TokenCppKind_Star ||
                         prev_token.sub_kind == TokenCppKind_Comma ||
                         prev_token.kind == TokenBaseKind_Keyword) &&
                        !(token->sub_kind == TokenCppKind_ParenOp ||
                          token->sub_kind == TokenCppKind_ParenCl ||
                          token->sub_kind == TokenCppKind_Comma)){
                        insertc(out, ' ');
                    }

                    Temp_Memory token_temp = begin_temp(scratch);
                    String_Const_u8 lexeme = push_token_lexeme(app, scratch, buffer, token);
                    insert_string(out, lexeme);
                    end_temp(token_temp);

                    prev_token = *token;
                }
                if (!token_it_inc(&it)){
                    break;
                }
                i64 index = token_it_index(&it);
                if (index > end_index){
                    break;
                }
            }

            insertc(out, '\n');
        }
    }
}

static void
list_all_functions(Application_Links *app, Buffer_ID optional_target_buffer){

    String_Const_u8 decls_name = SCu8((u8*)("*decls*"), (u64)(sizeof("*decls*") - 1));
    Buffer_ID decls_buffer = get_buffer_by_name(app, decls_name, Access_Always);
    if (!buffer_exists(app, decls_buffer)){
        decls_buffer = create_buffer(app, decls_name, BufferCreate_AlwaysNew);
        buffer_set_setting(app, decls_buffer, BufferSetting_Unimportant, true);
        buffer_set_setting(app, decls_buffer, BufferSetting_ReadOnly, true);

    }
    else{
        clear_buffer(app, decls_buffer);
        buffer_send_end_signal(app, decls_buffer);
    }

    Scratch_Block scratch(app);


    i32 positions_max = ((4) << 10)/sizeof(Function_Positions);
    Function_Positions *positions_array = ((Function_Positions*)linalloc_wrap_unintialized(linalloc_push((scratch), sizeof(Function_Positions)*(positions_max), SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_function_list.cpp" ":" "227" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_function_list.cpp" ":" "227" ":") - 1)))));

    Cursor insertion_cursor = make_cursor(((u8*)linalloc_wrap_unintialized(linalloc_push((scratch), sizeof(u8)*(((256) << 10)), SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_function_list.cpp" ":" "229" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_function_list.cpp" ":" "229" ":") - 1))))), ((256) << 10));
    Buffer_Insertion out = begin_buffer_insertion_at_buffered(app, decls_buffer, 0, &insertion_cursor);

    for (Buffer_ID buffer_it = get_buffer_next(app, 0, Access_Always);
         buffer_it != 0;
         buffer_it = get_buffer_next(app, buffer_it, Access_Always)){
        Buffer_ID buffer = buffer_it;
        if (optional_target_buffer != 0){
            buffer = optional_target_buffer;
        }

        Token_Array array = get_token_array_from_buffer(app, buffer);
        if (array.tokens != 0){
            i64 token_index = 0;
            b32 still_looping = false;
            do{
                Get_Positions_Results get_positions_results = get_function_positions(app, buffer, token_index, positions_array, positions_max);

                i64 positions_count = get_positions_results.positions_count;
                token_index = get_positions_results.next_token_index;
                still_looping = get_positions_results.still_looping;

                print_positions_buffered(app, &out, buffer, positions_array, positions_count);
            }while(still_looping);

            if (optional_target_buffer != 0){
                break;
            }
        }
    }

    end_buffer_insertion(&out);

    View_ID view = get_active_view(app, Access_Always);
    view_set_buffer(app, view, decls_buffer, 0);

    lock_jump_buffer(app, decls_name);
}

CUSTOM_COMMAND(list_all_functions_current_buffer, "/home/sam/.bin/4coder/custom/4coder_function_list.cpp", 268, Normal)
CUSTOM_DOC("Creates a jump list of lines of the current buffer that appear to define or declare functions.")
{
    View_ID view = get_active_view(app, Access_ReadVisible);
    Buffer_ID buffer = view_get_buffer(app, view, Access_ReadVisible);
    if (buffer != 0){
        list_all_functions(app, buffer);
    }
}

CUSTOM_COMMAND(list_all_functions_current_buffer_lister, "/home/sam/.bin/4coder/custom/4coder_function_list.cpp", 278, UI)
CUSTOM_DOC("Creates a lister of locations that look like function definitions and declarations in the buffer.")
{
    Heap *heap = &global_heap;
    View_ID view = get_active_view(app, Access_ReadVisible);
    Buffer_ID buffer = view_get_buffer(app, view, Access_ReadVisible);
    if (buffer != 0){
        list_all_functions(app, buffer);
        view = get_active_view(app, Access_Always);
        buffer = view_get_buffer(app, view, Access_Always);
        Marker_List *list = get_or_make_list_for_buffer(app, heap, buffer);
        if (list != 0){
            Jump_Lister_Result jump = get_jump_index_from_user(app, list, "Function:");
            jump_to_jump_lister_result(app, view, list, &jump);
        }
    }
}

CUSTOM_COMMAND(list_all_functions_all_buffers, "/home/sam/.bin/4coder/custom/4coder_function_list.cpp", 296, Normal)
CUSTOM_DOC("Creates a jump list of lines from all buffers that appear to define or declare functions.")
{
    list_all_functions(app, 0);
}

CUSTOM_COMMAND(list_all_functions_all_buffers_lister, "/home/sam/.bin/4coder/custom/4coder_function_list.cpp", 302, UI)
CUSTOM_DOC("Creates a lister of locations that look like function definitions and declarations all buffers.")
{
    Heap *heap = &global_heap;
    list_all_functions(app, 0);
    View_ID view = get_active_view(app, Access_Always);
    Buffer_ID buffer = view_get_buffer(app, view, Access_Always);
    Marker_List *list = get_or_make_list_for_buffer(app, heap, buffer);
    if (list != 0){
        Jump_Lister_Result jump = get_jump_index_from_user(app, list, "Function:");
        jump_to_jump_lister_result(app, view, list, &jump);
    }
}
# 121 "/home/sam/.bin/4coder/custom/4coder_default_include.cpp" 2
# 1 "/home/sam/.bin/4coder/custom/4coder_scope_commands.cpp" 1






static void
select_next_scope_after_pos(Application_Links *app, View_ID view, Buffer_ID buffer,
                            i64 pos){
    Find_Nest_Flag flags = FindNest_Scope;
    Range_i64 range = {};
    if (find_nest_side(app, buffer, pos + 1, flags, Scan_Forward, NestDelim_Open,
                       &range) &&
        find_nest_side(app, buffer, range.end,
                       flags|FindNest_Balanced|FindNest_EndOfToken, Scan_Forward,
                       NestDelim_Close, &range.end)){
        select_scope(app, view, range);
    }
}

static b32
range_is_scope_selection(Application_Links *app, Buffer_ID buffer, Range_i64 range){
    return (buffer_get_char(app, buffer, range.min) == '{' &&
            buffer_get_char(app, buffer, range.max - 1) == '}');
}

CUSTOM_COMMAND(select_surrounding_scope, "/home/sam/.bin/4coder/custom/4coder_scope_commands.cpp", 27, Normal)
CUSTOM_DOC("Finds the scope enclosed by '{' '}' surrounding the cursor and puts the cursor and mark on the '{' and '}'.")
{
    View_ID view = get_active_view(app, Access_ReadVisible);
    Buffer_ID buffer = view_get_buffer(app, view, Access_ReadVisible);
    i64 pos = view_get_cursor_pos(app, view);
    Range_i64 range = {};
    if (find_surrounding_nest(app, buffer, pos, FindNest_Scope, &range)){
        select_scope(app, view, range);
    }
}

CUSTOM_COMMAND(select_surrounding_scope_maximal, "/home/sam/.bin/4coder/custom/4coder_scope_commands.cpp", 39, Normal)
CUSTOM_DOC("Selects the top-most scope that surrounds the cursor.")
{
    View_ID view = get_active_view(app, Access_ReadVisible);
    Buffer_ID buffer = view_get_buffer(app, view, Access_ReadVisible);
    i64 pos = view_get_cursor_pos(app, view);
    Range_i64 range = {};
    if (find_surrounding_nest(app, buffer, pos, FindNest_Scope, &range)){
        for (;;){
            pos = range.min;
            if (!find_surrounding_nest(app, buffer, pos, FindNest_Scope, &range)){
                break;
            }
        }
        select_scope(app, view, range);
    }
}

CUSTOM_COMMAND(select_next_scope_absolute, "/home/sam/.bin/4coder/custom/4coder_scope_commands.cpp", 57, Normal)
CUSTOM_DOC("Finds the first scope started by '{' after the cursor and puts the cursor and mark on the '{' and '}'.")
{
    View_ID view = get_active_view(app, Access_ReadVisible);
    Buffer_ID buffer = view_get_buffer(app, view, Access_ReadVisible);
    i64 pos = view_get_cursor_pos(app, view);
    select_next_scope_after_pos(app, view, buffer, pos);
}

CUSTOM_COMMAND(select_next_scope_after_current, "/home/sam/.bin/4coder/custom/4coder_scope_commands.cpp", 66, Normal)
CUSTOM_DOC("If a scope is selected, find first scope that starts after the selected scope. Otherwise find the first scope that starts after the cursor.")
{
    View_ID view = get_active_view(app, Access_ReadVisible);
    Buffer_ID buffer = view_get_buffer(app, view, Access_ReadVisible);
    i64 cursor_pos = view_get_cursor_pos(app, view);
    i64 mark_pos = view_get_mark_pos(app, view);
    Range_i64 range = Ii64(cursor_pos, mark_pos);
    if (range_is_scope_selection(app, buffer, range)){
        select_next_scope_after_pos(app, view, buffer, range.max);
    }
    else{
        select_next_scope_after_pos(app, view, buffer, cursor_pos);
    }
}

CUSTOM_COMMAND(select_prev_scope_absolute, "/home/sam/.bin/4coder/custom/4coder_scope_commands.cpp", 82, Normal)
CUSTOM_DOC("Finds the first scope started by '{' before the cursor and puts the cursor and mark on the '{' and '}'.")
{
    View_ID view = get_active_view(app, Access_ReadVisible);
    Buffer_ID buffer = view_get_buffer(app, view, Access_ReadVisible);
    i64 pos = view_get_cursor_pos(app, view);
    Find_Nest_Flag flags = FindNest_Scope;
    Range_i64 range = {};
    if (find_nest_side(app, buffer, pos - 1,
                       flags, Scan_Backward, NestDelim_Open, &range) &&
        find_nest_side(app, buffer, range.end,
                       flags|FindNest_Balanced|FindNest_EndOfToken, Scan_Forward,
                       NestDelim_Close, &range.end)){
        select_scope(app, view, range);
    }
}

CUSTOM_COMMAND(select_prev_top_most_scope, "/home/sam/.bin/4coder/custom/4coder_scope_commands.cpp", 99, Normal)
CUSTOM_DOC("Finds the first scope that starts before the cursor, then finds the top most scope that contains that scope.")
{
    select_prev_scope_absolute(app);
    select_surrounding_scope_maximal(app);
}

CUSTOM_COMMAND(place_in_scope, "/home/sam/.bin/4coder/custom/4coder_scope_commands.cpp", 106, Normal)
CUSTOM_DOC("Wraps the code contained in the range between cursor and mark with a new curly brace scope.")
{
    place_begin_and_end_on_own_lines(app, "{", "}");
}

CUSTOM_COMMAND(delete_current_scope, "/home/sam/.bin/4coder/custom/4coder_scope_commands.cpp", 112, Normal)
CUSTOM_DOC("Deletes the braces surrounding the currently selected scope.  Leaves the contents within the scope.")
{
    View_ID view = get_active_view(app, Access_ReadWriteVisible);
    Buffer_ID buffer = view_get_buffer(app, view, Access_ReadWriteVisible);

    Range_i64 range = get_view_range(app, view);
    if (range_is_scope_selection(app, buffer, range)){
        i32 top_len = 1;
        i32 bot_len = 1;
        if (buffer_get_char(app, buffer, range.min - 1) == '\n'){
            top_len = 2;
        }
        if (buffer_get_char(app, buffer, range.max + 1) == '\n'){
            bot_len = 2;
        }

        Batch_Edit batch_first = {};
        Batch_Edit batch_last = {};

        batch_first.edit.text = SCu8();
        batch_first.edit.range = Ii64(range.min + 1 - top_len, range.min + 1);
        batch_first.next = &batch_last;
        batch_last.edit.text = SCu8();
        batch_last.edit.range = Ii64((i32)(range.max - 1), (i32)(range.max - 1 + bot_len));

        buffer_batch_edit(app, buffer, &batch_first);
    }
}
# 122 "/home/sam/.bin/4coder/custom/4coder_default_include.cpp" 2
# 1 "/home/sam/.bin/4coder/custom/4coder_combined_write_commands.cpp" 1






static void
write_string(Application_Links *app, View_ID view, Buffer_ID buffer, String_Const_u8 string){
    i64 pos = view_get_cursor_pos(app, view);
    buffer_replace_range(app, buffer, Ii64(pos), string);
    view_set_cursor_and_preferred_x(app, view, seek_pos(pos + string.size));
}

static void
write_string(Application_Links *app, String_Const_u8 string){
    View_ID view = get_active_view(app, Access_ReadWriteVisible);
    Buffer_ID buffer = view_get_buffer(app, view, Access_ReadWriteVisible);
    write_string(app, view, buffer, string);
}

static void
write_named_comment_string(Application_Links *app, char *type_string){
    Scratch_Block scratch(app);
    String_Const_u8 name = global_config.user_name;
    String_Const_u8 str = {};
    if (name.size > 0){
        str = push_u8_stringf(scratch, "// %s(%.*s): ", type_string, (i32)(name).size, (char*)(name).str);
    }
    else{
        str = push_u8_stringf(scratch, "// %s: ", type_string);
    }
    write_string(app, str);
}

static void
long_braces(Application_Links *app, char *text, i32 size){
    View_ID view = get_active_view(app, Access_ReadWriteVisible);
    Buffer_ID buffer = view_get_buffer(app, view, Access_ReadWriteVisible);
    i64 pos = view_get_cursor_pos(app, view);
    buffer_replace_range(app, buffer, Ii64(pos), SCu8(text, size));
    view_set_cursor_and_preferred_x(app, view, seek_pos(pos + 2));
    auto_indent_buffer(app, buffer, Ii64_size(pos, size));
    move_past_lead_whitespace(app, view, buffer);
}

CUSTOM_COMMAND(open_long_braces, "/home/sam/.bin/4coder/custom/4coder_combined_write_commands.cpp", 46, Normal)
CUSTOM_DOC("At the cursor, insert a '{' and '}' separated by a blank line.")
{
    char text[] = "{\n\n}";
    i32 size = sizeof(text) - 1;
    long_braces(app, text, size);
}

CUSTOM_COMMAND(open_long_braces_semicolon, "/home/sam/.bin/4coder/custom/4coder_combined_write_commands.cpp", 54, Normal)
CUSTOM_DOC("At the cursor, insert a '{' and '};' separated by a blank line.")
{
    char text[] = "{\n\n};";
    i32 size = sizeof(text) - 1;
    long_braces(app, text, size);
}

CUSTOM_COMMAND(open_long_braces_break, "/home/sam/.bin/4coder/custom/4coder_combined_write_commands.cpp", 62, Normal)
CUSTOM_DOC("At the cursor, insert a '{' and '}break;' separated by a blank line.")
{
    char text[] = "{\n\n}break;";
    i32 size = sizeof(text) - 1;
    long_braces(app, text, size);
}

CUSTOM_COMMAND(if0_off, "/home/sam/.bin/4coder/custom/4coder_combined_write_commands.cpp", 70, Normal)
CUSTOM_DOC("Surround the range between the cursor and mark with an '#if 0' and an '#endif'")
{
    place_begin_and_end_on_own_lines(app, "#if 0", "#endif");
}

CUSTOM_COMMAND(write_todo, "/home/sam/.bin/4coder/custom/4coder_combined_write_commands.cpp", 76, Normal)
CUSTOM_DOC("At the cursor, insert a '// TODO' comment, includes user name if it was specified in config.4coder.")
{
    write_named_comment_string(app, "TODO");
}

CUSTOM_COMMAND(write_hack, "/home/sam/.bin/4coder/custom/4coder_combined_write_commands.cpp", 82, Normal)
CUSTOM_DOC("At the cursor, insert a '// HACK' comment, includes user name if it was specified in config.4coder.")
{
    write_named_comment_string(app, "HACK");
}

CUSTOM_COMMAND(write_note, "/home/sam/.bin/4coder/custom/4coder_combined_write_commands.cpp", 88, Normal)
CUSTOM_DOC("At the cursor, insert a '// NOTE' comment, includes user name if it was specified in config.4coder.")
{
    write_named_comment_string(app, "NOTE");
}

CUSTOM_COMMAND(write_block, "/home/sam/.bin/4coder/custom/4coder_combined_write_commands.cpp", 94, Normal)
CUSTOM_DOC("At the cursor, insert a block comment.")
{
    place_begin_and_end_on_own_lines(app, "/* ", " */");
}

CUSTOM_COMMAND(write_zero_struct, "/home/sam/.bin/4coder/custom/4coder_combined_write_commands.cpp", 100, Normal)
CUSTOM_DOC("At the cursor, insert a ' = {};'.")
{
    write_string(app, SCu8((u8*)(" = {};"), (u64)(sizeof(" = {};") - 1)));
}

static i64
get_start_of_line_at_cursor(Application_Links *app, View_ID view, Buffer_ID buffer){
    i64 pos = view_get_cursor_pos(app, view);
    i64 line = get_line_number_from_pos(app, buffer, pos);
    return(get_pos_past_lead_whitespace_from_line_number(app, buffer, line));
}

static b32
c_line_comment_starts_at_position(Application_Links *app, Buffer_ID buffer, i64 pos){
    b32 alread_has_comment = false;
    u8 check_buffer[2];
    if (buffer_read_range(app, buffer, Ii64(pos, pos + 2), check_buffer)){
        if (check_buffer[0] == '/' && check_buffer[1] == '/'){
            alread_has_comment = true;
        }
    }
    return(alread_has_comment);
}

CUSTOM_COMMAND(comment_line, "/home/sam/.bin/4coder/custom/4coder_combined_write_commands.cpp", 125, Normal)
CUSTOM_DOC("Insert '//' at the beginning of the line after leading whitespace.")
{
    View_ID view = get_active_view(app, Access_ReadWriteVisible);
    Buffer_ID buffer = view_get_buffer(app, view, Access_ReadWriteVisible);
    i64 pos = get_start_of_line_at_cursor(app, view, buffer);
    b32 alread_has_comment = c_line_comment_starts_at_position(app, buffer, pos);
    if (!alread_has_comment){
        buffer_replace_range(app, buffer, Ii64(pos), SCu8((u8*)("//"), (u64)(sizeof("//") - 1)));
    }
}

CUSTOM_COMMAND(uncomment_line, "/home/sam/.bin/4coder/custom/4coder_combined_write_commands.cpp", 137, Normal)
CUSTOM_DOC("If present, delete '//' at the beginning of the line after leading whitespace.")
{
    View_ID view = get_active_view(app, Access_ReadWriteVisible);
    Buffer_ID buffer = view_get_buffer(app, view, Access_ReadWriteVisible);
    i64 pos = get_start_of_line_at_cursor(app, view, buffer);
    b32 alread_has_comment = c_line_comment_starts_at_position(app, buffer, pos);
    if (alread_has_comment){
        buffer_replace_range(app, buffer, Ii64(pos, pos + 2), string_u8_empty);
    }
}

CUSTOM_COMMAND(comment_line_toggle, "/home/sam/.bin/4coder/custom/4coder_combined_write_commands.cpp", 149, Normal)
CUSTOM_DOC("Turns uncommented lines into commented lines and vice versa for comments starting with '//'.")
{
    View_ID view = get_active_view(app, Access_ReadWriteVisible);
    Buffer_ID buffer = view_get_buffer(app, view, Access_ReadWriteVisible);
    i64 pos = get_start_of_line_at_cursor(app, view, buffer);
    b32 alread_has_comment = c_line_comment_starts_at_position(app, buffer, pos);
    if (alread_has_comment){
        buffer_replace_range(app, buffer, Ii64(pos, pos + 2), string_u8_empty);
    }
    else{
        buffer_replace_range(app, buffer, Ii64(pos), SCu8((u8*)("//"), (u64)(sizeof("//") - 1)));
    }
}



static Snippet default_snippets[] = {

    {"if", "if (){\n\n}\n", 4, 7},
    {"ifelse", "if (){\n\n}\nelse{\n\n}", 4, 7},
    {"forn", "for (node = ;\nnode != 0;\nnode = node->next){\n\n}\n", 5, 38},
    {"fori", "for (i = 0; i < ; i += 1){\n\n}\n", 5, 16},
    {"forj", "for (j = 0; j < ; j += 1){\n\n}\n", 5, 16},
    {"fork", "for (k = 0; k < ; k += 1){\n\n}\n", 5, 16},
    {"for", "for (;;){\n\n}\n", 5, 10},
    {"///", "////////////////////////////////", 32, 32},
    {"#guard", "#if !defined(Z)\n#define Z\n#endif\n", 0, 26},

    {"op+", "Z\noperator+(Z a, Z b){\n,\n}\n", 0, 23},
    {"op-", "Z\noperator-(Z a, Z b){\n,\n}\n", 0, 23},
    {"op*", "Z\noperator*(Z a, Z b){\n,\n}\n", 0, 23},
    {"op/", "Z\noperator/(Z a, Z b){\n,\n}\n", 0, 23},
    {"op+=", "Z&\noperator+=(Z &a, Z b){\n,\n}\n", 0, 26},
    {"op-=", "Z&\noperator-=(Z &a, Z b){\n,\n}\n", 0, 26},
    {"op*=", "Z&\noperator*=(Z &a, Z b){\n,\n}\n", 0, 26},
    {"op/=", "Z&\noperator/=(Z &a, Z b){\n,\n}\n", 0, 26},


    {"4command", "CUSTOM_COMMAND_SIG()\nCUSTOM_DOC()\n{\n\n}\n", 19, 32},
    {"4app", "Application_Links *app", 22, 22},




};

static void
write_snippet(Application_Links *app, View_ID view, Buffer_ID buffer,
              i64 pos, Snippet *snippet){
    if (snippet != 0){
        String_Const_u8 snippet_text = SCu8(snippet->text);
        buffer_replace_range(app, buffer, Ii64(pos), snippet_text);
        i64 new_cursor = pos + snippet->cursor_offset;
        view_set_cursor_and_preferred_x(app, view, seek_pos(new_cursor));
        i64 new_mark = pos + snippet->mark_offset;
        view_set_mark(app, view, seek_pos(new_mark));
        auto_indent_buffer(app, buffer, Ii64_size(pos, snippet_text.size));
    }
}

static Snippet*
get_snippet_from_user(Application_Links *app, Snippet *snippets, i32 snippet_count,
                      String_Const_u8 query){
    Scratch_Block scratch(app);
    Lister_Block lister(app, scratch);
    lister_set_query(lister, query);
    lister_set_default_handlers(lister);

    Snippet *snippet = snippets;
    for (i32 i = 0; i < snippet_count; i += 1, snippet += 1){
        lister_add_item(lister, SCu8(snippet->name), SCu8(snippet->text), snippet, 0);
    }
    Lister_Result l_result = run_lister(app, lister);
    Snippet *result = 0;
    if (!l_result.canceled){
        result = (Snippet*)l_result.user_data;
    }
    return(result);
}


static Snippet*
get_snippet_from_user(Application_Links *app, Snippet *snippets, i32 snippet_count,
                      char *query){
    return(get_snippet_from_user(app, snippets, snippet_count, SCu8(query)));
}

CUSTOM_COMMAND(snippet_lister, "/home/sam/.bin/4coder/custom/4coder_combined_write_commands.cpp", 237, UI)
CUSTOM_DOC("Opens a snippet lister for inserting whole pre-written snippets of text.")
{
    View_ID view = get_this_ctx_view(app, Access_ReadWrite);
    if (view != 0){
        Snippet *snippet = get_snippet_from_user(app, default_snippets,
                                                 ((sizeof(default_snippets))/(sizeof(*default_snippets))),
                                                 "Snippet:");

        Buffer_ID buffer = view_get_buffer(app, view, Access_ReadWriteVisible);
        i64 pos = view_get_cursor_pos(app, view);
        write_snippet(app, view, buffer, pos, snippet);
    }
}
# 123 "/home/sam/.bin/4coder/custom/4coder_default_include.cpp" 2
# 1 "/home/sam/.bin/4coder/custom/4coder_miblo_numbers.cpp" 1







struct Miblo_Number_Info{
    Range_i64 range;
    i64 x;
};

static b32
get_numeric_at_cursor(Application_Links *app, Buffer_ID buffer, i64 pos, Miblo_Number_Info *info){
    b32 result = false;
    Range_i64 range = enclose_pos_base10(app, buffer, pos);
    if (range_size(range) > 0){
        Scratch_Block scratch(app);
        String_Const_u8 str = push_buffer_range(app, scratch, buffer, range);
        if (str.size > 0){
            info->range = range;
            info->x = string_to_integer(str, 10);
            result = true;
        }
    }
    return(result);
}

CUSTOM_COMMAND(miblo_increment_basic, "/home/sam/.bin/4coder/custom/4coder_miblo_numbers.cpp", 29, Normal)
CUSTOM_DOC("Increment an integer under the cursor by one.")
{
    View_ID view = get_active_view(app, Access_ReadWriteVisible);
    Buffer_ID buffer = view_get_buffer(app, view, Access_ReadWriteVisible);
    i64 pos = view_get_cursor_pos(app, view);
    Miblo_Number_Info number = {};
    if (get_numeric_at_cursor(app, buffer, pos, &number)){
        Scratch_Block scratch(app);
        String_Const_u8 str = push_u8_stringf(scratch, "%d", number.x + 1);
        buffer_replace_range(app, buffer, number.range, str);
        view_set_cursor_and_preferred_x(app, view, seek_pos(number.range.start + str.size - 1));
    }
}

CUSTOM_COMMAND(miblo_decrement_basic, "/home/sam/.bin/4coder/custom/4coder_miblo_numbers.cpp", 44, Normal)
CUSTOM_DOC("Decrement an integer under the cursor by one.")
{
    View_ID view = get_active_view(app, Access_ReadWriteVisible);
    Buffer_ID buffer = view_get_buffer(app, view, Access_ReadWriteVisible);
    i64 pos = view_get_cursor_pos(app, view);
    Miblo_Number_Info number = {};
    if (get_numeric_at_cursor(app, buffer, pos, &number)){
        Scratch_Block scratch(app);
        String_Const_u8 str = push_u8_stringf(scratch, "%d", number.x - 1);
        buffer_replace_range(app, buffer, number.range, str);
        view_set_cursor_and_preferred_x(app, view, seek_pos(number.range.start + str.size - 1));
    }
}




struct Miblo_Timestamp{
    i32 second;
    i32 minute;
    i32 hour;
};
static Miblo_Timestamp null_miblo_timestamp = {};

enum{
    MIBLO_SECOND,
    MIBLO_MINUTE,
    MIBLO_HOUR
};

static Miblo_Timestamp
increment_timestamp(Miblo_Timestamp t, i32 type, i32 amt){
    Miblo_Timestamp r = t;
    switch (type){
        case MIBLO_SECOND:
        r.second += amt;



        amt = 0;
        if (r.second < 0){
            i32 pos_second = -r.second;
            amt = -((pos_second + 59)/60);
            r.second = 60 - (pos_second % 60);
        }
        else if (r.second >= 60){
            amt = r.second/60;
            r.second = (r.second % 60);
        }

        case MIBLO_MINUTE:
        r.minute += amt;



        amt = 0;
        if (r.minute < 0){
            i32 pos_minute = -r.minute;
            amt = -((pos_minute + 59)/60);
            r.minute = 60 - (pos_minute % 60);
        }
        else if (r.minute >= 60){
            amt = r.minute/60;
            r.minute = (r.minute % 60);
        }

        case MIBLO_HOUR:
        r.hour += amt;
        if (r.hour < 0){
            r.second = 0;
            r.minute = 0;
            r.hour = 0;
        }
    }

    return(r);
}

static String_Const_u8
timestamp_to_string(Arena *arena, Miblo_Timestamp t){
    List_String_Const_u8 list = {};
    if (t.hour > 0){
        string_list_pushf(arena, &list, "%d:", t.hour);
    }
    i32 minute = (((0)>(t.minute))?(0):(t.minute));
    string_list_pushf(arena, &list, "%02d:", minute);
    i32 second = (((0)>(t.second))?(0):(t.second));
    string_list_pushf(arena, &list, "%02d", second);
    String_Const_u8 str = string_list_flatten(arena, list);
    return(str);
}

struct Miblo_Timestamp_Info{
    Range_i64 range;
    Miblo_Timestamp time;
};

static b32
get_timestamp_at_cursor(Application_Links *app, Buffer_ID buffer, i64 pos, Miblo_Timestamp_Info *info){
    b32 result = false;

    Scratch_Block scratch(app);

    Range_i64 time_stamp_range = enclose_pos_base10_colon(app, buffer, pos);
    if (range_size(time_stamp_range) > 0){
        String_Const_u8 string = push_buffer_range(app, scratch, buffer, time_stamp_range);
        if (string.size > 0){
            i32 count_colons = 0;
            for (u64 i = 0; i < string.size; ++i){
                if (string.str[i] == ':'){
                    count_colons += 1;
                }
            }

            if (count_colons == 1 || count_colons == 2){
                Miblo_Timestamp t = {};

                b32 success = false;

                Range_i64 number[3];
                i32 k = 0;
                number[0].min = 0;
                for (i64 i = 0; i < (i64)string.size; i += 1){
                    if (string.str[i] == ':'){
                        number[k].max = i;
                        k += 1;
                        number[k].min = i + 1;
                    }
                }
                number[k].max = (i64)string.size;

                if (count_colons == 2){
                    String_Const_u8 hour_str = string_substring(string, number[0]);
                    t.hour = (i32)string_to_integer(hour_str, 10);

                    if (range_size(number[1]) == 2){
                        String_Const_u8 minute_str = string_substring(string, number[1]);
                        t.minute = (i32)string_to_integer(minute_str, 10);
                        if (range_size(number[2]) == 2){
                            String_Const_u8 second_str = string_substring(string, number[2]);
                            t.second = (i32)string_to_integer(second_str, 10);
                            success = true;
                        }
                    }
                }
                else{
                    if (range_size(number[0]) == 2 || range_size(number[0]) == 1){
                        String_Const_u8 minute_str = string_substring(string, number[0]);
                        t.minute = (i32)string_to_integer(minute_str, 10);

                        if (range_size(number[1]) == 2){
                            String_Const_u8 second_str = string_substring(string, number[1]);
                            t.second = (i32)string_to_integer(second_str, 10);
                            success = true;
                        }
                    }
                }

                if (success){
                    info->range = time_stamp_range;
                    info->time = t;
                    result = true;
                }
            }
        }
    }

    return(result);
}

static void
miblo_time_stamp_alter(Application_Links *app, i32 unit_type, i32 amt){
    View_ID view = get_active_view(app, Access_ReadWriteVisible);
    Buffer_ID buffer = view_get_buffer(app, view, Access_ReadWriteVisible);
    i64 pos = view_get_cursor_pos(app, view);

    Miblo_Timestamp_Info timestamp = {};
    if (get_timestamp_at_cursor(app, buffer, pos, &timestamp)){
        Scratch_Block scratch(app);
        Miblo_Timestamp inc_timestamp = increment_timestamp(timestamp.time, unit_type, amt);
        String_Const_u8 str = timestamp_to_string(scratch, inc_timestamp);
        buffer_replace_range(app, buffer, timestamp.range, str);
        view_set_cursor_and_preferred_x(app, view, seek_pos(timestamp.range.start + str.size - 1));
    }
}

CUSTOM_COMMAND(miblo_increment_time_stamp, "/home/sam/.bin/4coder/custom/4coder_miblo_numbers.cpp", 231, Normal)
CUSTOM_DOC("Increment a time stamp under the cursor by one second. (format [m]m:ss or h:mm:ss")
{
    miblo_time_stamp_alter(app, MIBLO_SECOND, 1);
}

CUSTOM_COMMAND(miblo_decrement_time_stamp, "/home/sam/.bin/4coder/custom/4coder_miblo_numbers.cpp", 237, Normal)
CUSTOM_DOC("Decrement a time stamp under the cursor by one second. (format [m]m:ss or h:mm:ss")
{
    miblo_time_stamp_alter(app, MIBLO_SECOND, -1);
}

CUSTOM_COMMAND(miblo_increment_time_stamp_minute, "/home/sam/.bin/4coder/custom/4coder_miblo_numbers.cpp", 243, Normal)
CUSTOM_DOC("Increment a time stamp under the cursor by one minute. (format [m]m:ss or h:mm:ss")
{
    miblo_time_stamp_alter(app, MIBLO_MINUTE, 1);
}

CUSTOM_COMMAND(miblo_decrement_time_stamp_minute, "/home/sam/.bin/4coder/custom/4coder_miblo_numbers.cpp", 249, Normal)
CUSTOM_DOC("Decrement a time stamp under the cursor by one minute. (format [m]m:ss or h:mm:ss")
{
    miblo_time_stamp_alter(app, MIBLO_MINUTE, -1);
}
# 124 "/home/sam/.bin/4coder/custom/4coder_default_include.cpp" 2
# 1 "/home/sam/.bin/4coder/custom/4coder_profile_inspect.cpp" 1






static Profile_Slot*
profile_parse_get_slot(Arena *arena, Profile_Inspection *insp,
                       String_Const_u8 loc, String_Const_u8 name){
    Profile_Slot *result = 0;
    for (Profile_Slot *node = insp->first_slot;
         node != 0;
         node = node->next){
        if (string_match(node->location, loc) &&
            string_match(node->name, name)){
            result = node;
            break;
        }
    }
    if (result == 0){
        result = ((Profile_Slot*)linalloc_wrap_zero(linalloc_push((arena), sizeof(Profile_Slot)*(1), SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_profile_inspect.cpp" ":" "21" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_profile_inspect.cpp" ":" "21" ":") - 1)))));
        do{ if((result)){if((insp->first_slot)){(insp->last_slot)->next=(result);}else{(insp->first_slot)=(result);}(insp->last_slot)=(result);(insp->last_slot)->next=0;} }while(0);
        insp->slot_count += 1;
        result->location = loc;
        result->name = name;
    }
    return(result);
}

static void
profile_parse_error(Arena *arena, Profile_Inspection *insp, String_Const_u8 message,
                    String_Const_u8 location){
    Profile_Error *error = ((Profile_Error*)linalloc_wrap_unintialized(linalloc_push((arena), sizeof(Profile_Error)*(1), SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_profile_inspect.cpp" ":" "33" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_profile_inspect.cpp" ":" "33" ":") - 1)))));
    do{ if((error)){if((insp->first_error)){(insp->last_error)->next=(error);}else{(insp->first_error)=(error);}(insp->last_error)=(error);(insp->last_error)->next=0;} }while(0);
    insp->error_count += 1;
    error->message = message;
    error->location = location;
}

static Profile_Record*
profile_parse_record(Arena *arena, Profile_Inspection *insp,
                     Profile_Node *parent, Profile_Record *record,
                     Range_u64 *total_time_range){
    for (;record != 0;){
        if (record->id <= parent->id){
            break;
        }

        Profile_ID id = record->id;
        Profile_Node *node = ((Profile_Node*)linalloc_wrap_unintialized(linalloc_push((arena), sizeof(Profile_Node)*(1), SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_profile_inspect.cpp" ":" "50" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_profile_inspect.cpp" ":" "50" ":") - 1)))));
        do{ if((node)){if((parent->first_child)){(parent->last_child)->next=(node);}else{(parent->first_child)=(node);}(parent->last_child)=(node);(parent->last_child)->next=0;} }while(0);
        parent->child_count += 1;
        node->parent = parent;
        node->thread = parent->thread;

        String_Const_u8 location = record->location;
        String_Const_u8 name = record->name;

        node->time.min = record->time;
        node->time.max = max_u64;
        node->id = id;
        node->first_child = 0;
        node->last_child = 0;
        node->child_count = 0;
        node->closed = false;

        record = profile_parse_record(arena, insp, node, record->next,
                                      total_time_range);

        b32 quit_loop = false;
        Profile_Slot *slot = 0;
        if (record == 0 || record->id < id){
            if (record == 0){

                profile_parse_error(arena, insp, SCu8((u8*)("List ended before all nodes closed"), (u64)(sizeof("List ended before all nodes closed") - 1)), location);

            }
            else{

                String_Const_u8 str = push_u8_stringf(arena, "Node '%.*s' closed by parent ending (or higher priority sibling starting)", (i32)(name).size, (char*)(name).str);
                profile_parse_error(arena, insp, str, location);

                if (parent->id != 0){
                    quit_loop = true;
                }
            }
            slot = profile_parse_get_slot(arena, insp, location, name);
        }
        else if (record->id == id){
            slot = profile_parse_get_slot(arena, insp, location, name);
            node->time.max = record->time;
            node->closed = true;
            total_time_range->min = (((total_time_range->min)<(node->time.min))?(total_time_range->min):(node->time.min));
            total_time_range->max = (((total_time_range->max)>(node->time.max))?(total_time_range->max):(node->time.max));
            record = record->next;
        }
        else{


            (*((i32*)0) = 0xA11E);
        }

        node->slot = slot;
        if (!slot->corrupted_time){
            if (node->closed){
                slot->total_time += range_size(node->time);
            }
            else{
                slot->corrupted_time = true;
            }
        }
        {
            Profile_Node_Ptr *node_ptr = ((Profile_Node_Ptr*)linalloc_wrap_unintialized(linalloc_push((arena), sizeof(Profile_Node_Ptr)*(1), SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_profile_inspect.cpp" ":" "113" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_profile_inspect.cpp" ":" "113" ":") - 1)))));
            do{ if((node_ptr)){if((slot->first_hit)){(slot->last_hit)->next=(node_ptr);}else{(slot->first_hit)=(node_ptr);}(slot->last_hit)=(node_ptr);(slot->last_hit)->next=0;} }while(0);
            slot->hit_count += 1;
            node_ptr->ptr = node;
            node->unique_counter = (u64)slot->hit_count;
        }

        if (quit_loop){
            break;
        }
    }
    return(record);
}

static Profile_Inspection
profile_parse(Arena *arena, Profile_Global_List *src){
    Mutex_Lock lock(src->mutex);

    Profile_Inspection result = {};

    result.thread_count = src->thread_count;
    result.threads = ((Profile_Inspection_Thread*)linalloc_wrap_zero(linalloc_push((arena), sizeof(Profile_Inspection_Thread)*(result.thread_count), SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_profile_inspect.cpp" ":" "134" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_profile_inspect.cpp" ":" "134" ":") - 1)))))
                                                         ;

    i32 counter = 0;
    Profile_Inspection_Thread *insp_thread = result.threads;
    for (Profile_Thread *node = src->first_thread;
         node != 0;
         node = node->next, counter += 1, insp_thread += 1){
        insp_thread->thread_id = node->thread_id;
        insp_thread->name = node->name;




        Range_u64 time_range = {max_u64, 0};
        insp_thread->root.thread = insp_thread;
        profile_parse_record(arena, &result, &insp_thread->root, node->first_record, &time_range);
        insp_thread->root.time = time_range;
        insp_thread->root.closed = true;

        for (Profile_Node *prof_node = insp_thread->root.first_child;
             prof_node != 0;
             prof_node = prof_node->next){
            insp_thread->active_time += range_size(prof_node->time);
        }
    }

    return(result);
}



struct Tab_State{
    Vec2_f32 p;
    Range_f32 tabs_y;
    Face_ID face_id;
    f32 x_half_padding;
    Vec2_f32 m_p;
};

static void
profile_draw_tab(Application_Links *app, Tab_State *state, Profile_Inspection *insp,
                 String_Const_u8 string, Profile_Inspection_Tab tab_id){
    Scratch_Block scratch(app);

    state->p.x += state->x_half_padding;

    Fancy_String *fstring = push_fancy_string(scratch, 0, string);

    b32 hover = false;
    f32 width = get_fancy_string_width(app, state->face_id, fstring);
    Rect_f32 box = Rf32(If32_size(state->p.x, width), state->tabs_y);
    if (rect_contains_point(box, state->m_p)){
        hover = true;
        insp->tab_id_hovered = tab_id;
    }

    FColor text = fcolor_id(defcolor_text_default);
    if (insp->tab_id == tab_id){
        text = fcolor_id(defcolor_pop2);
    }
    else if (hover){
        text = fcolor_id(defcolor_pop1);
    }

    Vec2_f32 np = draw_fancy_string(app, state->face_id, text, fstring, state->p);
    state->p = np;
    state->p.x += state->x_half_padding;
}

static void
profile_select_thread(Profile_Inspection *inspect, Profile_Inspection_Thread *thread){
    inspect->tab_id = ProfileInspectTab_Selection;
    inspect->selected_thread = thread;
    inspect->selected_slot = 0;
    inspect->selected_node = 0;
}

static void
profile_select_slot(Profile_Inspection *inspect, Profile_Slot *slot){
    inspect->tab_id = ProfileInspectTab_Selection;
    inspect->selected_thread = 0;
    inspect->selected_slot = slot;
    inspect->selected_node = 0;
}

static void
profile_select_node(Profile_Inspection *inspect, Profile_Node *node){
    inspect->tab_id = ProfileInspectTab_Selection;
    inspect->selected_thread = 0;
    inspect->selected_slot = 0;
    inspect->selected_node = node;
}

static String_Const_u8
profile_node_thread_name(Profile_Node *node){
    String_Const_u8 result = {};
    if (node->thread != 0){
        result = node->thread->name;
    }
    return(result);
}

static String_Const_u8
profile_node_name(Profile_Node *node){
    String_Const_u8 result = SCu8((u8*)("*root*"), (u64)(sizeof("*root*") - 1));
    if (node->slot != 0){
        result = node->slot->name;
    }
    return(result);
}

static String_Const_u8
profile_node_location(Profile_Node *node){
    String_Const_u8 result = {};
    if (node->slot != 0){
        result = node->slot->location;
    }
    return(result);
}

static void
profile_qsort_nodes(Profile_Node **nodes, i32 first, i32 one_past_last){
    if (first + 1 < one_past_last){
        i32 pivot_index = one_past_last - 1;
        Profile_Node *pivot = nodes[pivot_index];
        u64 pivot_time = range_size(pivot->time);
        i32 j = first;
        for (i32 i = first; i < one_past_last; i += 1){
            Profile_Node *node = nodes[i];
            u64 node_time = range_size(node->time);
            if (node_time > pivot_time){
                do { Profile_Node* hidden_temp_266 = nodes[i]; nodes[i] = nodes[j]; nodes[j] = hidden_temp_266; } while(0);
                j += 1;
            }
        }
        do { Profile_Node* hidden_temp_270 = nodes[pivot_index]; nodes[pivot_index] = nodes[j]; nodes[j] = hidden_temp_270; } while(0);
        profile_qsort_nodes(nodes, first, j);
        profile_qsort_nodes(nodes, j + 1, one_past_last);
    }
}

static void
profile_draw_node(Application_Links *app, View_ID view, Face_ID face_id,
                  Profile_Node *node, Rect_f32 rect,
                  Profile_Inspection *insp, Vec2_f32 m_p){
    Range_f32 x = rect_range_x(rect);
    Range_f32 y = rect_range_y(rect);


    Face_Metrics metrics = get_face_metrics(app, face_id);
    f32 line_height = metrics.line_height;
    f32 normal_advance = metrics.normal_advance;
    f32 block_height = line_height*2.f;
    f32 x_padding = normal_advance*1.5f;
    f32 x_half_padding = x_padding*0.5f;

    Color_Array colors = finalize_color_array(defcolor_back_cycle);

    Scratch_Block scratch(app);

    f32 x_pos = x.min + x_half_padding;
    f32 nav_bar_w = 0.f;
    Range_f32 nav_bar_y = {};
    nav_bar_y.min = y.min;

    String_Const_u8 thread_name = profile_node_thread_name(node);
    if (thread_name.size > 0){
        Fancy_String *fstr =
            push_fancy_string(scratch, 0, fcolor_id(defcolor_pop1), thread_name);
        Vec2_f32 p = V2f32(x_pos, y.min + 1.f);
        draw_fancy_string(app, face_id, fcolor_zero(), fstr, p);
        f32 w = get_fancy_string_width(app, face_id, fstr);
        nav_bar_w = (((nav_bar_w)>(w))?(nav_bar_w):(w));
    }
    y.min += line_height + 2.f;

    String_Const_u8 name = profile_node_name(node);
    if (name.size > 0){
        Fancy_String *fstr =
            push_fancy_string(scratch, 0, fcolor_id(defcolor_text_default), name);
        Vec2_f32 p = V2f32(x_pos, y.min + 1.f);
        draw_fancy_string(app, face_id, fcolor_zero(), fstr, p);
        f32 w = get_fancy_string_width(app, face_id, fstr);
        nav_bar_w = (((nav_bar_w)>(w))?(nav_bar_w):(w));
    }
    y.min += line_height + 2.f;

    nav_bar_y.max = y.min;

    x_pos += nav_bar_w + x_half_padding;
    if (node->parent != 0){
        Fancy_String *fstr = push_fancy_string(scratch, 0, fcolor_zero(),
                                               SCu8((u8*)("to parent"), (u64)(sizeof("to parent") - 1)));
        f32 w = get_fancy_string_width(app, face_id, fstr) + x_padding;
        Range_f32 btn_x = If32_size(x_pos, w);
        Rect_f32 box = Rf32(btn_x, nav_bar_y);

        FColor color = fcolor_id(defcolor_text_default);
        if (rect_contains_point(box, m_p)){
            draw_rectangle_fcolor(app, box, 0.f, fcolor_id(defcolor_margin));
            color = fcolor_id(defcolor_pop1);
            insp->hover_node = node->parent;
        }

        Vec2_f32 p = V2f32(box.x0 + x_half_padding,
                           (box.y0 + box.y1 - line_height)*0.5f);
        draw_fancy_string(app, face_id, color, fstr, p);

        x_pos = btn_x.max;
    }

    Range_u64 top_time = node->time;

    Rect_f32_Pair side_by_side = rect_split_left_right_lerp(Rf32(x, y), 0.5f);

    Rect_f32 time_slice_box = side_by_side.min;
    time_slice_box = rect_inner(time_slice_box, 3.f);
    draw_rectangle_outline_fcolor(app, time_slice_box, 0.f, 3.f, f_white);
    time_slice_box = rect_inner(time_slice_box, 3.f);

    if (node->closed){
        draw_set_clip(app, time_slice_box);

        x = rect_range_x(time_slice_box);
        y = rect_range_y(time_slice_box);

        i32 cycle_counter = 0;
        for (Profile_Node *child = node->first_child;
             child != 0;
             child = child->next){
            if (!child->closed){
                continue;
            }

            Range_u64 child_time = child->time;
            Range_f32 child_y = {};
            child_y.min = unlerp(top_time.min, child_time.min, top_time.max);
            child_y.max = unlerp(top_time.min, child_time.max, top_time.max);
            child_y.min = lerp(y.min, child_y.min, y.max);
            child_y.max = lerp(y.min, child_y.max, y.max);

            Rect_f32 box = Rf32(x, child_y);
            ARGB_Color argb = finalize_color(colors, cycle_counter);
            draw_rectangle(app, box, 0.f, argb);
            cycle_counter += 1;

            if (rect_contains_point(box, m_p)){
                insp->full_name_hovered = profile_node_name(child);
                insp->unique_counter_hovered = child->unique_counter;
                insp->location_jump_hovered = profile_node_location(child);
                insp->hover_node = child;
            }

            if (range_size(child_y) >= line_height){
                String_Const_u8 child_name = profile_node_name(child);
                Fancy_Line line = {};
                push_fancy_string(scratch, &line, fcolor_id(defcolor_pop1),
                                  child_name);
                push_fancy_stringf(scratch, &line, fcolor_id(defcolor_text_default),
                                   0.5f, 0.f, "#%4llu", child->unique_counter);

                Vec2_f32 p = V2f32(x.min + x_half_padding,
                                   child_y.min);
                draw_fancy_line(app, face_id, fcolor_zero(),
                                &line, p);
            }
        }
    }

    Rect_f32 info_box = side_by_side.max;

    {
        draw_set_clip(app, info_box);

        x = rect_range_x(info_box);

        x_pos = x.min + x_half_padding;
        f32 y_pos = info_box.y0;


        {
            f32 duration = ((f32)range_size(node->time))/1000000.f;
            Fancy_Line list = {};
            push_fancy_stringf(scratch, &list, fcolor_id(defcolor_text_default),
                               "time: %11.9f", duration);
            draw_fancy_line(app, face_id, fcolor_zero(),
                            &list, V2f32(x_pos, y_pos + 1.f));
            y_pos += line_height + 2.f;
        }

        i32 child_count = node->child_count;
        Profile_Node **children_array = ((Profile_Node**)linalloc_wrap_unintialized(linalloc_push((scratch), sizeof(Profile_Node*)*(child_count), SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_profile_inspect.cpp" ":" "426" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_profile_inspect.cpp" ":" "426" ":") - 1)))));
        i32 counter = 0;
        for (Profile_Node *child = node->first_child;
             child != 0;
             child = child->next){
            children_array[counter] = child;
            counter += 1;
        }

        profile_qsort_nodes(children_array, 0, child_count);

        Profile_Node **child_ptr = children_array;
        for (i32 i = 0; i < child_count; i += 1, child_ptr += 1){
            Profile_Node *child = *child_ptr;
            y = If32_size(y_pos, block_height);

            f32 child_duration = ((f32)range_size(child->time))/1000000.f;

            String_Const_u8 child_name = profile_node_name(child);
            Fancy_Line line = {};
            push_fancy_string_trunc(scratch, &line, child_name, 20);
            push_fancy_stringf(scratch, &line, fcolor_id(defcolor_text_default), 0.5f, 0.f,
                               "#%4llu", child->unique_counter);
            push_fancy_stringf(scratch, &line, fcolor_id(defcolor_pop2),
                               0.5f, 0.f, "%6.4f", child_duration);

            Vec2_f32 p = V2f32(x.min + x_half_padding,
                               (y.min + y.max - line_height)*0.5f);
            draw_fancy_line(app, face_id, fcolor_id(defcolor_pop1), &line, p);

            Rect_f32 box = Rf32(x, y);
            FColor margin = fcolor_id(defcolor_margin);
            if (rect_contains_point(box, m_p)){
                insp->full_name_hovered = child_name;
                insp->unique_counter_hovered = child->unique_counter;
                insp->location_jump_hovered = profile_node_location(child);
                insp->hover_node = child;
                margin = fcolor_id(defcolor_margin_hover);
            }
            draw_rectangle_outline_fcolor(app, box, 6.f, 3.f, margin);

            y_pos = y.max;
            if (y_pos >= info_box.y1){
                break;
            }
        }
    }
}

static void
profile_memory_sort_by_count(Memory_Bucket **buckets, i32 first, i32 one_past_last){
    if (first + 1 < one_past_last){
        i32 pivot = one_past_last - 1;
        i32 pivot_key = buckets[pivot]->annotation.count;
        i32 j = first;
        for (i32 i = first; i < pivot; i += 1){
            i32 key = buckets[i]->annotation.count;
            if (key <= pivot_key){
                do { Memory_Bucket* hidden_temp_484 = buckets[j]; buckets[j] = buckets[i]; buckets[i] = hidden_temp_484; } while(0);
                j += 1;
            }
        }
        do { Memory_Bucket* hidden_temp_488 = buckets[j]; buckets[j] = buckets[pivot]; buckets[pivot] = hidden_temp_488; } while(0);
        profile_memory_sort_by_count(buckets, first, j);
        profile_memory_sort_by_count(buckets, j + 1, one_past_last);
    }
}

static void
profile_render(Application_Links *app, Frame_Info frame_info, View_ID view){
    Scratch_Block scratch(app);

    Rect_f32 region = draw_background_and_margin(app, view);
    Rect_f32 prev_clip = draw_set_clip(app, region);

    Face_ID face_id = get_face_id(app, 0);

    Face_Metrics metrics = get_face_metrics(app, face_id);
    f32 line_height = metrics.line_height;
    f32 normal_advance = metrics.normal_advance;
    f32 block_height = line_height*2.f;
    f32 x_padding = normal_advance*1.5f;
    f32 x_half_padding = x_padding*0.5f;

    Mouse_State mouse = get_mouse_state(app);
    Vec2_f32 m_p = V2f32(mouse.p);

    Profile_Inspection *inspect = &global_profile_inspection;

    if (inspect->thread_count == 0){
        Fancy_String *fstr = push_fancy_string(scratch, 0, fcolor_id(defcolor_pop2),
                                               SCu8((u8*)("no profile data"), (u64)(sizeof("no profile data") - 1)));
        f32 width = get_fancy_string_width(app, face_id, fstr);
        Vec2_f32 view_center = (region.p0 + region.p1)*0.5f;
        Vec2_f32 half_dim = V2f32(width, line_height)*0.5f;
        Vec2_f32 p = view_center - half_dim;
        draw_fancy_string(app, face_id, fcolor_zero(), fstr, p);
    }
    else{
        Rect_f32_Pair tabs_body = rect_split_top_bottom(region, line_height + 2.f);
        Range_f32 tabs_y = rect_range_y(tabs_body.min);

        inspect->tab_id_hovered = ProfileInspectTab_None;
        block_zero((&inspect->full_name_hovered), sizeof(*(&inspect->full_name_hovered)));
        inspect->unique_counter_hovered = 0;
        block_zero((&inspect->location_jump_hovered), sizeof(*(&inspect->location_jump_hovered)));
        inspect->hover_thread = 0;
        inspect->hover_slot = 0;
        inspect->hover_node = 0;


        {
            f32 y = (tabs_y.min + tabs_y.max - line_height)*0.5f;
            f32 x = region.x0;

            Tab_State tab_state = {};
            tab_state.p = V2f32(x, y);
            tab_state.tabs_y = tabs_y;
            tab_state.face_id = face_id;
            tab_state.x_half_padding = x_half_padding;
            tab_state.m_p = m_p;

            draw_rectangle_fcolor(app, tabs_body.min, 0.f, fcolor_id(defcolor_margin_hover));

            if (inspect->tab_id == ProfileInspectTab_None){
                inspect->tab_id = ProfileInspectTab_Threads;
            }

            profile_draw_tab(app, &tab_state, inspect,
                             SCu8((u8*)("threads"), (u64)(sizeof("threads") - 1)),
                             ProfileInspectTab_Threads);

            if (inspect->slot_count > 0){
                profile_draw_tab(app, &tab_state, inspect,
                                 SCu8((u8*)("blocks"), (u64)(sizeof("blocks") - 1)),
                                 ProfileInspectTab_Blocks);
            }

            if (inspect->error_count > 0){
                profile_draw_tab(app, &tab_state, inspect,
                                 SCu8((u8*)("errors"), (u64)(sizeof("errors") - 1)),
                                 ProfileInspectTab_Errors);
            }

                profile_draw_tab(app, &tab_state, inspect,
                                 SCu8((u8*)("memory"), (u64)(sizeof("memory") - 1)),
                                 ProfileInspectTab_Memory);

            if (inspect->tab_id == ProfileInspectTab_Selection){
                String_Const_u8 string = {};
                if (inspect->selected_thread != 0){
                    String_Const_u8 name = inspect->selected_thread->name;
                    string = push_u8_stringf(scratch, "%.*s (%d)",
                                             (i32)(name).size, (char*)(name).str,
                                             inspect->selected_thread->thread_id);
                }
                else if (inspect->selected_slot != 0){
                    String_Const_u8 name = inspect->selected_slot->name;
                    string = push_u8_stringf(scratch, "block %.*s",
                                             (i32)(name).size, (char*)(name).str);
                }
                else if (inspect->selected_node != 0){
                    String_Const_u8 name = profile_node_name(inspect->selected_node);
                    string = push_u8_stringf(scratch, "node %.*s",
                                             (i32)(name).size, (char*)(name).str);
                }
                else{
                    inspect->tab_id = ProfileInspectTab_Threads;
                }
                if (string.str != 0){
                    profile_draw_tab(app, &tab_state, inspect,
                                     string, ProfileInspectTab_Selection);
                }
            }
        }

        draw_set_clip(app, tabs_body.max);
        switch (inspect->tab_id){
            case ProfileInspectTab_Threads:
            {
                Range_f32 x = rect_range_x(tabs_body.max);
                f32 y_pos = tabs_body.max.y0;
                i32 count = inspect->thread_count;
                Profile_Inspection_Thread *thread = inspect->threads;
                for (i32 i = 0; i < count; i += 1, thread += 1){
                    Range_f32 y = If32_size(y_pos, block_height);

                    Fancy_Line list = {};
                    push_fancy_stringf(scratch, &list, fcolor_id(defcolor_pop1),
                                       "%-20.*s (%6d) ",
                                       (i32)(thread->name).size, (char*)(thread->name).str,
                                       thread->thread_id);

                    f32 active_time = ((f32)thread->active_time)/1000000.f;
                    push_fancy_stringf(scratch, &list, fcolor_id(defcolor_pop2),
                                       "active time %11.9f",
                                       active_time);

                    Vec2_f32 p = V2f32(x.min + x_half_padding,
                                       (y.min + y.max - line_height)*0.5f);
                    draw_fancy_line(app, face_id, fcolor_zero(), &list, p);

                    Rect_f32 box = Rf32(x, y);
                    FColor margin = fcolor_id(defcolor_margin);
                    if (rect_contains_point(box, m_p)){
                        inspect->hover_thread = thread;
                        margin = fcolor_id(defcolor_margin_hover);
                    }
                    draw_rectangle_outline_fcolor(app, box, 6.f, 3.f, margin);

                    y_pos = y.max;
                    if (y_pos >= tabs_body.max.y1){
                        break;
                    }
                }
            }break;

            case ProfileInspectTab_Blocks:
            {
                Range_f32 x = rect_range_x(tabs_body.max);
                f32 y_pos = tabs_body.max.y0;
                for (Profile_Slot *node = inspect->first_slot;
                     node != 0;
                     node = node->next){
                    Range_f32 y = If32_size(y_pos, block_height);

                    u32 name_width = 45;
                    b32 name_too_long = (node->name.size > name_width);
                    Fancy_Line list = {};
                    push_fancy_string_fixed(scratch, &list, fcolor_id(defcolor_pop1),
                                            node->name, name_width);

                    if (node->corrupted_time){
                        push_fancy_string(scratch, &list, fcolor_id(defcolor_pop2),
                                          SCu8((u8*)("timing error "), (u64)(sizeof("timing error ") - 1)));
                    }
                    else{
                        push_fancy_stringf(scratch, &list, fcolor_id(defcolor_pop2),
                                           "%11.9fs ",
                                           ((f32)node->total_time)/1000000.f);
                    }

                    push_fancy_stringf(scratch, &list, fcolor_id(defcolor_keyword),
                                       "hit # %5d", node->hit_count);

                    Vec2_f32 p = V2f32(x.min + x_half_padding,
                                       (y.min + y.max - line_height)*0.5f);
                    draw_fancy_line(app, face_id, fcolor_zero(), &list, p);

                    Rect_f32 box = Rf32(x, y);
                    FColor margin = fcolor_id(defcolor_margin);
                    if (rect_contains_point(box, m_p)){
                        if (name_too_long){
                            inspect->full_name_hovered = node->name;
                        }
                        inspect->location_jump_hovered = node->location;
                        inspect->hover_slot = node;
                        margin = fcolor_id(defcolor_margin_hover);
                    }
                    draw_rectangle_outline_fcolor(app, box, 6.f, 3.f, margin);

                    y_pos = y.max;
                    if (y_pos >= tabs_body.max.y1){
                        break;
                    }
                }
            }break;

            case ProfileInspectTab_Errors:
            {
                draw_set_clip(app, tabs_body.max);
                Range_f32 x = rect_range_x(tabs_body.max);
                f32 y_pos = tabs_body.max.y0;
                for (Profile_Error *node = inspect->first_error;
                     node != 0;
                     node = node->next){
                    Range_f32 y = If32_size(y_pos, block_height);

                    Fancy_Line list = {};
                    push_fancy_string(scratch, &list, fcolor_id(defcolor_pop2),
                                      node->message);

                    Vec2_f32 p = V2f32(x.min + x_half_padding,
                                       (y.min + y.max - line_height)*0.5f);
                    draw_fancy_line(app, face_id, fcolor_zero(), &list, p);

                    Rect_f32 box = Rf32(x, y);
                    FColor margin = fcolor_id(defcolor_margin);
                    if (rect_contains_point(box, m_p)){
                        inspect->location_jump_hovered = node->location;
                        margin = fcolor_id(defcolor_margin_hover);
                    }
                    draw_rectangle_outline_fcolor(app, box, 6.f, 3.f, margin);

                    y_pos = y.max;
                    if (y_pos >= tabs_body.max.y1){
                        break;
                    }
                }
            }break;

            case ProfileInspectTab_Memory:
            {
                draw_set_clip(app, tabs_body.max);
                Range_f32 x = rect_range_x(tabs_body.max);
                f32 y_pos = tabs_body.max.y0;
                Memory_Annotation annotation = system_memory_annotation(scratch);

                Base_Allocator *allocator = get_base_allocator_system();

                Memory_Bucket *first_bucket = 0;
                Memory_Bucket *last_bucket = 0;
                i32 bucket_count = 0;
                Table_Data_u64 table = make_table_Data_u64__inner((allocator),(100),SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_profile_inspect.cpp" ":" "739" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_profile_inspect.cpp" ":" "739" ":") - 1)));

                for (Memory_Annotation_Node *node = annotation.first, *next = 0;
                     node != 0;
                     node = next){
                    next = node->next;
                    Data key = make_data(node->location.str, node->location.size);
                    Table_Lookup lookup = table_lookup(&table, key);
                    Memory_Bucket *bucket = 0;
                    if (lookup.found_match){
                        u64 val = 0;
                        table_read(&table, lookup, &val);
                        bucket = (Memory_Bucket*)(void*)(((u8*)0) + val);
                    }
                    else{
                        bucket = ((Memory_Bucket*)linalloc_wrap_zero(linalloc_push((scratch), sizeof(Memory_Bucket)*(1), SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_profile_inspect.cpp" ":" "754" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_profile_inspect.cpp" ":" "754" ":") - 1)))));
                        do{ if((bucket)){if((first_bucket)){(last_bucket)->next=(bucket);}else{(first_bucket)=(bucket);}(last_bucket)=(bucket);(last_bucket)->next=0;} }while(0);
                        bucket_count += 1;
                        bucket->location = node->location;
                        table_insert(&table, key, ((u8*)(bucket) - (u8*)(0)));
                    }
                    do{ if((node)){if((bucket->annotation.first)){(bucket->annotation.last)->next=(node);}else{(bucket->annotation.first)=(node);}(bucket->annotation.last)=(node);(bucket->annotation.last)->next=0;} }while(0);
                    bucket->annotation.count += 1;
                    bucket->total_memory += node->size;
                }

                Memory_Bucket **buckets = ((Memory_Bucket**)linalloc_wrap_unintialized(linalloc_push((scratch), sizeof(Memory_Bucket*)*(bucket_count), SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_profile_inspect.cpp" ":" "765" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_profile_inspect.cpp" ":" "765" ":") - 1)))));
                i32 counter = 0;
                for (Memory_Bucket *node = first_bucket;
                     node != 0;
                     node = node->next){
                    buckets[counter] = node;
                    counter += 1;
                }

                profile_memory_sort_by_count(buckets, 0, bucket_count);

                for (i32 i = bucket_count - 1; i >= 0; i -= 1){
                    Memory_Bucket *node = buckets[i];
                    Range_f32 y = If32_size(y_pos, block_height);

                    Fancy_Line list = {};
                    push_fancy_stringf(scratch, &list, fcolor_id(defcolor_pop2), "[%12llu] / %6d ",
                                       node->total_memory, node->annotation.count);
                    push_fancy_stringf(scratch, &list, fcolor_id(defcolor_pop1), "%.*s",
                                       (i32)(node->location).size, (char*)(node->location).str);

                    Vec2_f32 p = V2f32(x.min + x_half_padding,
                                       (y.min + y.max - line_height)*0.5f);
                    draw_fancy_line(app, face_id, fcolor_zero(), &list, p);

                    Rect_f32 box = Rf32(x, y);
                    FColor margin = fcolor_id(defcolor_margin);
                    if (rect_contains_point(box, m_p)){
                        inspect->location_jump_hovered = node->location;
                        margin = fcolor_id(defcolor_margin_hover);
                    }

                    y_pos = y.max;
                    if (y_pos >= tabs_body.max.y1){
                        break;
                    }
                }

                table_free(&table);
            }break;

            case ProfileInspectTab_Selection:
            {
                if (inspect->selected_thread != 0){
                    profile_draw_node(app, view, face_id,
                                      &inspect->selected_thread->root, tabs_body.max,
                                      inspect, m_p);
                }
                else if (inspect->selected_slot != 0){

                }
                else if (inspect->selected_node != 0){
                    profile_draw_node(app, view, face_id,
                                      inspect->selected_node, tabs_body.max,
                                      inspect, m_p);
                }
            }break;
        }

        if (!rect_contains_point(region, m_p)){

        }
        else if (inspect->tab_id_hovered != ProfileInspectTab_None){

        }
        else{
            Fancy_Block block = {};
            FColor text_color = fcolor_change_alpha(f_white, 0.5f);
            FColor back_color = fcolor_change_alpha(f_black, 0.5f);

            if (inspect->full_name_hovered.size > 0){
                Fancy_Line *line = push_fancy_line(scratch, &block, text_color);
                push_fancy_stringf(scratch, line, "%.*s",
                                   (i32)(inspect->full_name_hovered).size, (char*)(inspect->full_name_hovered).str);
                if (inspect->unique_counter_hovered > 0){
                    push_fancy_stringf(scratch, line, text_color, 0.5f, 0.f,
                                       "#%4llu", inspect->unique_counter_hovered);
                }
            }
            if (inspect->location_jump_hovered.size > 0){
                Fancy_Line *line = push_fancy_line(scratch, &block, text_color);
                push_fancy_stringf(scratch, line, "[shift] '%.*s'",
                                   (i32)(inspect->location_jump_hovered).size, (char*)(inspect->location_jump_hovered).str);
            }

            draw_tool_tip(app, face_id, &block, m_p, region,
                          x_padding, x_half_padding, back_color);
        }
    }

    draw_set_clip(app, prev_clip);
}

static void
profile_inspect__left_click(Application_Links *app, View_ID view,
                            Profile_Inspection *insp, Input_Event *event){
    if (has_modifier(event, KeyCode_Shift)){
        if (insp->location_jump_hovered.size != 0){
            View_ID target_view = view;
            target_view = get_next_view_looped_primary_panels(app, target_view,
                                                              Access_Always);
            String_Const_u8 location = insp->location_jump_hovered;
            jump_to_location(app, target_view, location);
        }
    }
    else{
        if (insp->tab_id_hovered != ProfileInspectTab_None){
            insp->tab_id = insp->tab_id_hovered;
        }
        else if (insp->hover_thread != 0){
            profile_select_thread(insp, insp->hover_thread);
        }
        else if (insp->hover_slot != 0){
            profile_select_slot(insp, insp->hover_slot);
        }
        else if (insp->hover_node != 0){
            profile_select_node(insp, insp->hover_node);
        }
    }
}

CUSTOM_COMMAND(profile_inspect, "/home/sam/.bin/4coder/custom/4coder_profile_inspect.cpp", 886, UI)
CUSTOM_DOC("Inspect all currently collected profiling information in 4coder's self profiler.")
{
    Profile_Global_List *list = get_core_profile_list(app);
    if ((((list->disable_bits)&(ProfileEnable_InspectBit))!=0)){
        return;
    }

    profile_set_enabled(list, false, ProfileEnable_InspectBit);

    Scratch_Block scratch(app);
    global_profile_inspection = profile_parse(scratch, list);
    Profile_Inspection *insp = &global_profile_inspection;

    View_ID view = get_active_view(app, Access_Always);
    View_Context ctx = view_current_context(app, view);
    ctx.render_caller = profile_render;
    ctx.hides_buffer = true;
    View_Context_Block ctx_block(app, view, &ctx);

    for (;;){
        User_Input in = get_next_input(app, EventPropertyGroup_Any, EventProperty_Escape);
        if (in.abort){
            break;
        }

        b32 handled = true;
        switch (in.event.kind){
            case InputEventKind_MouseButton:
            {
                switch (in.event.mouse.code){
                    case MouseCode_Left:
                    {
                        profile_inspect__left_click(app, view, insp, &in.event);
                    }break;
                }
            }break;

            default:
            {
                handled = false;
            }break;
        }

        if (!handled){
            if (ui_fallback_command_dispatch(app, view, &in)){
                break;
            }
        }
    }

    profile_set_enabled(list, true, ProfileEnable_InspectBit);
}
# 125 "/home/sam/.bin/4coder/custom/4coder_default_include.cpp" 2
# 1 "/home/sam/.bin/4coder/custom/4coder_tutorial.cpp" 1






static Tutorial_State tutorial = {};

CUSTOM_COMMAND(kill_tutorial, "/home/sam/.bin/4coder/custom/4coder_tutorial.cpp", 9, Normal)
CUSTOM_DOC("If there is an active tutorial, kill it.")
{
    if (!tutorial.in_tutorial){
        return;
    }

    tutorial.in_tutorial = false;
    view_close(app, tutorial.view);
}

CUSTOM_COMMAND(tutorial_maximize, "/home/sam/.bin/4coder/custom/4coder_tutorial.cpp", 20, Normal)
CUSTOM_DOC("Expand the tutorial window")
{
    if (!tutorial.in_tutorial){
        return;
    }

    Panel_ID panel = view_get_panel(app, tutorial.view);
    Panel_ID parent = panel_get_parent(app, panel);
    panel_set_split(app, parent, PanelSplitKind_Ratio_Min, 0.5f);

    tutorial.is_active = true;
}

CUSTOM_COMMAND(tutorial_minimize, "/home/sam/.bin/4coder/custom/4coder_tutorial.cpp", 34, Normal)
CUSTOM_DOC("Shrink the tutorial window")
{
    if (!tutorial.in_tutorial){
        return;
    }

    Face_ID face = get_face_id(app, 0);
    Face_Metrics metrics = get_face_metrics(app, face);
    f32 line_height = metrics.line_height;

    Panel_ID panel = view_get_panel(app, tutorial.view);
    Panel_ID parent = panel_get_parent(app, panel);
    panel_set_split(app, parent, PanelSplitKind_FixedPixels_Min, line_height*4.f);

    tutorial.is_active = false;
}

static void
tutorial_action(Application_Links *app, Tutorial_Action action){
    switch (action){
        case TutorialAction_Minimize:
        {
            tutorial_minimize(app);
        }break;

        case TutorialAction_Maximize:
        {
            tutorial_maximize(app);
        }break;

        case TutorialAction_Prev:
        {
            tutorial.slide_index -= 1;
        }break;

        case TutorialAction_Next:
        {
            tutorial.slide_index += 1;
        }break;

        case TutorialAction_Exit:
        {
            kill_tutorial(app);
        }break;

        case TutorialAction_Restart:
        {
            tutorial.slide_index = 0;
        }break;
    }
}

static void
tutorial_init_title_face(Application_Links *app){
    if (tutorial.face == 0){
        Face_ID face = get_face_id(app, 0);
        Face_Description face_description = get_face_description(app, face);
        face_description.parameters.pt_size *= 2;
        tutorial.face = try_create_new_face(app, &face_description);
        if (tutorial.face == 0){
            tutorial.face = face;
        }
    }
}

static void
tutorial_render(Application_Links *app, Frame_Info frame_info, View_ID view_id){
    Face_ID face = get_face_id(app, 0);
    tutorial_init_title_face(app);
    Face_Metrics metrics = get_face_metrics(app, face);



    Scratch_Block scratch(app);
    tutorial.slide_index = (((0)>(tutorial.slide_index))?(0):(((tutorial.slide_count - 1)<(tutorial.slide_index))?(tutorial.slide_count - 1):(tutorial.slide_index)));
    Tutorial_Slide_Function *slide_func = tutorial.slide_func_ptrs[tutorial.slide_index];
    Tutorial_Slide slide = slide_func(app, scratch);



    f32 h0 = get_fancy_line_height(app, 0, &slide.short_details);
    f32 h1 = get_fancy_line_height(app, 0, slide.long_details.first);
    f32 title_height = (((h0)>(h1))?(h0):(h1));



    View_ID active_view = get_active_view(app, Access_Always);
    b32 is_active_view = (active_view == view_id);

    FColor margin_color = get_panel_margin_color(is_active_view?UIHighlight_Active:UIHighlight_None);
    Rect_f32 region = draw_background_and_margin(app, view_id, margin_color, margin_color);
    Rect_f32 prev_clip = draw_set_clip(app, region);

    f32 panel_y0 = region.y0 - 3.f;

    region = rect_inner(region, 3.f);
    draw_rectangle_fcolor(app, region, 20.f, fcolor_id(defcolor_back));
    region = rect_inner(region, 10.f);

    Vec2_f32 title_p = V2f32(region.x0, panel_y0 + (metrics.line_height*2.f) - title_height*0.5f);

    tutorial.hover_action = TutorialAction_None;
    if (tutorial.is_active){
        draw_fancy_block(app, 0, fcolor_zero(), &slide.long_details, title_p);


        Rect_f32_Pair footer_pair = rect_split_top_bottom_neg(region, metrics.line_height*2.f);
        Rect_f32 footer = footer_pair.max;
        footer.x0 += 10.f;
        footer.y0 -= 10.f;
        footer.y1 -= 10.f;

        f32 b_width = metrics.normal_advance*10.f;
        Mouse_State mouse = get_mouse_state(app);
        Vec2_f32 m_p = V2f32(mouse.p);

        {
            Rect_f32_Pair pair = rect_split_left_right(footer, b_width);
            footer = pair.max;
            footer.x0 += 10.f;
            if (draw_button(app, pair.min, m_p, face, SCu8((u8*)("minimize"), (u64)(sizeof("minimize") - 1)))){
                tutorial.hover_action = TutorialAction_Minimize;
            }
        }

        {
            Rect_f32_Pair pair = rect_split_left_right(footer, b_width);
            footer = pair.max;
            footer.x0 += 10.f;
            if (tutorial.slide_index > 0){
                if (draw_button(app, pair.min, m_p, face, SCu8((u8*)("prev"), (u64)(sizeof("prev") - 1)))){
                    tutorial.hover_action = TutorialAction_Prev;
                }
            }
        }

        {
            Rect_f32_Pair pair = rect_split_left_right(footer, b_width);
            footer = pair.max;
            footer.x0 += 10.f;
            if (tutorial.slide_index < tutorial.slide_count - 1){
                if (draw_button(app, pair.min, m_p, face, SCu8((u8*)("next"), (u64)(sizeof("next") - 1)))){
                    tutorial.hover_action = TutorialAction_Next;
                }
            }
        }

        {
            Rect_f32_Pair pair = rect_split_left_right(footer, b_width);
            footer = pair.max;
            footer.x0 += 10.f;
            Rect_f32 exit_box = pair.min;
            pair = rect_split_left_right(footer, b_width);
            Rect_f32 restart_box = pair.min;

            if (tutorial.slide_index == tutorial.slide_count - 1){
                if (draw_button(app, exit_box, m_p, face, SCu8((u8*)("end"), (u64)(sizeof("end") - 1)))){
                    tutorial.hover_action = TutorialAction_Exit;
                }

                if (draw_button(app, restart_box, m_p, face, SCu8((u8*)("restart"), (u64)(sizeof("restart") - 1)))){
                    tutorial.hover_action = TutorialAction_Restart;
                }
            }
        }
    }
    else{
        draw_fancy_line(app, 0, fcolor_zero(), &slide.short_details, title_p);
    }

    draw_set_clip(app, prev_clip);
}

static void
tutorial_run_loop(Application_Links *app){
    View_ID view = get_this_ctx_view(app, Access_Always);
    View_Context ctx = view_current_context(app, view);
    ctx.render_caller = tutorial_render;
    ctx.hides_buffer = true;
    View_Context_Block ctx_block(app, view, &ctx);

    tutorial.in_tutorial = true;
    tutorial.view = view;
    tutorial_maximize(app);

    change_active_panel(app);

    for (;;){
        User_Input in = get_next_input(app, EventPropertyGroup_Any, 0);
        if (in.abort){
            break;
        }

        b32 handled = true;
        switch (in.event.kind){
            case InputEventKind_MouseButton:
            {
                tutorial_maximize(app);
                if (in.event.mouse.code == MouseCode_Left){
                    tutorial_action(app, tutorial.hover_action);
                }
            }break;

            case InputEventKind_Core:
            {
                switch (in.event.core.code){
                    case CoreCode_ClickActivateView:
                    {
                        tutorial_maximize(app);
                        tutorial_action(app, tutorial.hover_action);
                        change_active_panel(app);
                    }break;

                    default:
                    {
                        handled = false;
                    }break;
                }
            }break;

            default:
            {
                handled = false;
            }break;
        }

        if (!handled){
            Mapping *mapping = ctx.mapping;
            Command_Map *map = mapping_get_map(mapping, ctx.map_id);

            Fallback_Dispatch_Result disp_result =
                fallback_command_dispatch(app, mapping, map, &in);
            if (disp_result.code == FallbackDispatch_DelayedUICall){
                call_after_ctx_shutdown(app, view, disp_result.func);
                break;
            }
            if (disp_result.code == FallbackDispatch_Unhandled){
                leave_current_input_unhandled(app);
            }
        }
    }

    tutorial.in_tutorial = false;
}

static void
run_tutorial(Application_Links *app, Tutorial_Slide_Function **slides, i32 slide_count){
    if (slide_count > 0){
        kill_tutorial(app);
        Panel_ID root_panel = panel_get_root(app);
        if (panel_split(app, root_panel, Dimension_Y)){
            panel_swap_children(app, root_panel);
            Panel_ID tutorial_panel = panel_get_child(app, root_panel, Side_Min);
            tutorial.view = panel_get_view(app, tutorial_panel, Access_Always);
            view_set_passive(app, tutorial.view, true);
            tutorial.slide_index = 0;
            tutorial.slide_func_ptrs = slides;
            tutorial.slide_count = slide_count;
            view_enqueue_command_function(app, tutorial.view, tutorial_run_loop);
        }
    }
}



static String_Const_u8 hms_title = SCu8((u8*)("Handmade Seattle Demo"), (u64)(sizeof("Handmade Seattle Demo") - 1));

static void
hms_demo_tutorial_short_details(Application_Links *app, Arena *arena, Fancy_Line *short_details){
    Face_ID face = get_face_id(app, 0);
    push_fancy_string(arena, short_details, tutorial.face, fcolor_id(defcolor_pop1), hms_title);
    push_fancy_string(arena, short_details, face, fcolor_id(defcolor_text_default), 8.f, 8.f, SCu8((u8*)("Welcome to Handmade Seattle and to this 4coder demo!"), (u64)(sizeof("Welcome to Handmade Seattle and to this 4coder demo!") - 1)));
    push_fancy_string(arena, short_details, face, fcolor_id(defcolor_pop2), SCu8((u8*)("Click here to see more."), (u64)(sizeof("Click here to see more.") - 1)));
}

static void
hms_demo_tutorial_long_start(Application_Links *app, Arena *arena, Fancy_Block *long_details){
    Fancy_Line *line = push_fancy_line(arena, long_details, tutorial.face, fcolor_id(defcolor_pop1), hms_title);

    Face_ID face = get_face_id(app, 0);

    line = push_fancy_line(arena, long_details, face, fcolor_id(defcolor_text_default));

    push_fancy_string(arena, line, SCu8((u8*)("If you want more information than what you can find here, please "), (u64)(sizeof("If you want more information than what you can find here, please ") - 1)));

    push_fancy_string(arena, line, fcolor_id(defcolor_pop2), SCu8((u8*)("ask!"), (u64)(sizeof("ask!") - 1)));


    push_fancy_line(arena, long_details, face, fcolor_id(defcolor_pop1), SCu8((u8*)(""), (u64)(sizeof("") - 1)));
}

static void
hms_demo_tutorial_binding_line(Application_Links *app, Arena *arena, Fancy_Block *long_details, Face_ID face, char *modifiers, char *key, char *description){
    String_Const_u8 m = SCu8(modifiers);
    String_Const_u8 k = SCu8(key);

    f32 fill_size = (f32)k.size;
    if (m.size > 0){
        fill_size += (f32)m.size + 0.5f;
    }
    f32 pad_size = 0.f;
    if (fill_size < 40.f){
        pad_size = 40.f - fill_size;
    }

    Fancy_Line *line = line = push_fancy_line(arena, long_details, face, fcolor_id(defcolor_text_default));
    push_fancy_stringf(arena, line, pad_size, 0.5f, "<");
    if (m.size > 0){
        push_fancy_stringf(arena, line, fcolor_id(defcolor_keyword), 0.f, 0.5f, "%s", modifiers);
    }
    push_fancy_stringf(arena, line, fcolor_id(defcolor_pop2), "%s", key);
    push_fancy_stringf(arena, line, 0.5f, 1.f, ">");
    push_fancy_stringf(arena, line, "%s", description);
}

static Tutorial_Slide
hms_demo_tutorial_slide_1(Application_Links *app, Arena *arena){
    Tutorial_Slide result = {};

    Face_ID face = get_face_id(app, 0);
    tutorial_init_title_face(app);

    hms_demo_tutorial_short_details(app, arena, &result.short_details);

    Fancy_Block *long_details = &result.long_details;
    hms_demo_tutorial_long_start(app, arena, long_details);

    push_fancy_line(arena, long_details, face, fcolor_id(defcolor_pop1), SCu8((u8*)("Let's start with a few navigation commands:"), (u64)(sizeof("Let's start with a few navigation commands:") - 1)));

    hms_demo_tutorial_binding_line(app, arena, long_details, face,
                                   "Control", "Comma", "change active panel");

    hms_demo_tutorial_binding_line(app, arena, long_details, face,
                                   "", "*AnyArrow*", "move cursor one character or line");

    hms_demo_tutorial_binding_line(app, arena, long_details, face,
                                   "Control", "*AnyArrow*", "move cursor by 'chunks'");

    hms_demo_tutorial_binding_line(app, arena, long_details, face,
                                   "", "Home/End", "move cursor to the first/last character of the line");

    hms_demo_tutorial_binding_line(app, arena, long_details, face,
                                   "", "PageUp/PageDown", "move cursor by full pages up/down");

    push_fancy_line(arena, long_details, face, fcolor_id(defcolor_pop1), SCu8((u8*)("Available in code files:"), (u64)(sizeof("Available in code files:") - 1)));


    hms_demo_tutorial_binding_line(app, arena, long_details, face,
                                   "Alt", "LeftBracket", "move cursor and mark to surrounding scope");

    hms_demo_tutorial_binding_line(app, arena, long_details, face,
                                   "Alt", "RightBracket", "move cursor and mark to previous scope");

    hms_demo_tutorial_binding_line(app, arena, long_details, face,
                                   "Alt", "Quote", "move cursor and mark to next scope");

    hms_demo_tutorial_binding_line(app, arena, long_details, face,
                                   "Alt Shift", "RightBracket", "move cursor and mark to previous top-level scope");

    hms_demo_tutorial_binding_line(app, arena, long_details, face,
                                   "Alt Shift", "Quote", "move cursor and mark to next scope at the same level as the current scope");

    return(result);
}

static Tutorial_Slide
hms_demo_tutorial_slide_2(Application_Links *app, Arena *arena){
    Tutorial_Slide result = {};

    Face_ID face = get_face_id(app, 0);
    tutorial_init_title_face(app);

    hms_demo_tutorial_short_details(app, arena, &result.short_details);

    Fancy_Block *long_details = &result.long_details;
    hms_demo_tutorial_long_start(app, arena, long_details);

    push_fancy_line(arena, long_details, face, fcolor_id(defcolor_pop1), SCu8((u8*)("Now a look at basic editing:"), (u64)(sizeof("Now a look at basic editing:") - 1)));

    hms_demo_tutorial_binding_line(app, arena, long_details, face,
                                   "", "TextInsert", "non-modal text insertion works in any user-writable buffers at the cursor");

    hms_demo_tutorial_binding_line(app, arena, long_details, face,
                                   "", "Backspace/Delete", "delete the previous/next character from the cursor");

    hms_demo_tutorial_binding_line(app, arena, long_details, face,
                                   "Control", "Z", "undo the last edit");

    hms_demo_tutorial_binding_line(app, arena, long_details, face,
                                   "Control", "Y", "redo the last undone edit");

    hms_demo_tutorial_binding_line(app, arena, long_details, face,
                                   "Control", "L", "duplicate the current line");

    hms_demo_tutorial_binding_line(app, arena, long_details, face,
                                   "Alt", "Up/Down", "move the current line");

    push_fancy_line(arena, long_details, face, fcolor_id(defcolor_pop1), SCu8((u8*)("Range commands based on a cursor and mark (emacs style):"), (u64)(sizeof("Range commands based on a cursor and mark (emacs style):") - 1)));

    hms_demo_tutorial_binding_line(app, arena, long_details, face,
                                   "Control", "Space", "moves the mark to the cursor");

    hms_demo_tutorial_binding_line(app, arena, long_details, face,
                                   "Control", "D", "delete the range");

    hms_demo_tutorial_binding_line(app, arena, long_details, face,
                                   "Control", "C", "copy the range");

    hms_demo_tutorial_binding_line(app, arena, long_details, face,
                                   "Control", "X", "cut the range");

    push_fancy_line(arena, long_details, face, fcolor_id(defcolor_pop1), SCu8((u8*)("Paste options with a multi-stage clipboard:"), (u64)(sizeof("Paste options with a multi-stage clipboard:") - 1)));

    hms_demo_tutorial_binding_line(app, arena, long_details, face,
                                   "Control", "V", "paste the clipboard to the buffer");

    hms_demo_tutorial_binding_line(app, arena, long_details, face,
                                   "Control Shift", "V", "paste the clipboard to the buffer cycling through the clipboard's 'clips'");

    return(result);
}

static Tutorial_Slide
hms_demo_tutorial_slide_3(Application_Links *app, Arena *arena){
    Tutorial_Slide result = {};

    Face_ID face = get_face_id(app, 0);
    tutorial_init_title_face(app);

    hms_demo_tutorial_short_details(app, arena, &result.short_details);

    Fancy_Block *long_details = &result.long_details;
    hms_demo_tutorial_long_start(app, arena, long_details);

    push_fancy_line(arena, long_details, face, fcolor_id(defcolor_pop1), SCu8((u8*)("Now try beginning a file lister:"), (u64)(sizeof("Now try beginning a file lister:") - 1)));

    hms_demo_tutorial_binding_line(app, arena, long_details, face,
                                   "Control", "N", "begin a file lister for exploring the file system - always creating a new file");

    hms_demo_tutorial_binding_line(app, arena, long_details, face,
                                   "Control", "O", "begin a file lister for exploring the file system - ultimiately opening or creating a file");

    hms_demo_tutorial_binding_line(app, arena, long_details, face,
                                   "Alt", "O", "same as previous option but opens in the other panel");

    push_fancy_line(arena, long_details, face, fcolor_id(defcolor_pop1), SCu8((u8*)("Inside a file lister:"), (u64)(sizeof("Inside a file lister:") - 1)));

    hms_demo_tutorial_binding_line(app, arena, long_details, face,
                                   "", "TextInsert", "narrows the lister down to options with substrings matching the text field");

    hms_demo_tutorial_binding_line(app, arena, long_details, face,
                                   "", "Backspace", "backspace the end of the text field");

    hms_demo_tutorial_binding_line(app, arena, long_details, face,
                                   "", "Up/Down", "move the highlighted option up/down");

    hms_demo_tutorial_binding_line(app, arena, long_details, face,
                                   "", "PageUp/PageDown", "move the highlighted option up/down by a 'large chunk'");

    hms_demo_tutorial_binding_line(app, arena, long_details, face,
                                   "", "Return/Tab", "select the highlighted option;  when a folder is highlighted it is opened in the lister");

    hms_demo_tutorial_binding_line(app, arena, long_details, face,
                                   "", "Escape", "cancel the operation");

    push_fancy_line(arena, long_details, face, fcolor_id(defcolor_pop1), SCu8((u8*)("There are also buffer listers for operations on buffers that are already open:"), (u64)(sizeof("There are also buffer listers for operations on buffers that are already open:") - 1)));

    hms_demo_tutorial_binding_line(app, arena, long_details, face,
                                   "Control", "I", "begin a buffer lister and switch to the selected buffer");

    hms_demo_tutorial_binding_line(app, arena, long_details, face,
                                   "Control", "K", "begin a buffer lister and try to kill the selected buffer");

    return(result);
}

static Tutorial_Slide
hms_demo_tutorial_slide_4(Application_Links *app, Arena *arena){
    Tutorial_Slide result = {};

    Face_ID face = get_face_id(app, 0);
    tutorial_init_title_face(app);

    hms_demo_tutorial_short_details(app, arena, &result.short_details);

    Fancy_Block *long_details = &result.long_details;
    hms_demo_tutorial_long_start(app, arena, long_details);

    push_fancy_line(arena, long_details, face, fcolor_id(defcolor_pop1), SCu8((u8*)("The command lister makes all commands available in one place:"), (u64)(sizeof("The command lister makes all commands available in one place:") - 1)));

    hms_demo_tutorial_binding_line(app, arena, long_details, face,
                                   "Alt", "X", "a lister of all commands");

    push_fancy_line(arena, long_details, face, fcolor_id(defcolor_pop1), SCu8((u8*)("Try some of these commands from the command lister:"), (u64)(sizeof("Try some of these commands from the command lister:") - 1)));

    hms_demo_tutorial_binding_line(app, arena, long_details, face,
                                   "", "toggle_filebar", "toggle the panel's filebar");

    hms_demo_tutorial_binding_line(app, arena, long_details, face,
                                   "", "toggle_line_numbers", "toggle the panel's line number");

    hms_demo_tutorial_binding_line(app, arena, long_details, face,
                                   "", "set_eol_mode_*", "change how a buffer prefers to fixup it's line endings");

    hms_demo_tutorial_binding_line(app, arena, long_details, face,
                                   "", "close_panel", "close the current panel");

    hms_demo_tutorial_binding_line(app, arena, long_details, face,
                                   "", "open_panel_vsplit", "create a vertical split in the current panel");

    hms_demo_tutorial_binding_line(app, arena, long_details, face,
                                   "", "open_panel_hsplit", "create a horizontal split in the current panel");

    return(result);
}

static Tutorial_Slide
hms_demo_tutorial_slide_5(Application_Links *app, Arena *arena){
    Tutorial_Slide result = {};

    Face_ID face = get_face_id(app, 0);
    tutorial_init_title_face(app);

    hms_demo_tutorial_short_details(app, arena, &result.short_details);

    Fancy_Block *long_details = &result.long_details;
    hms_demo_tutorial_long_start(app, arena, long_details);

    push_fancy_line(arena, long_details, face, fcolor_id(defcolor_pop1), SCu8((u8*)("Fast navigation by jump lists:"), (u64)(sizeof("Fast navigation by jump lists:") - 1)));

    hms_demo_tutorial_binding_line(app, arena, long_details, face,
                                   "Alt", "F", "after the user answers a query for a string generate a jump list of matches");

    hms_demo_tutorial_binding_line(app, arena, long_details, face,
                                   "Control Shift", "T", "extract an identifier from the text under cursor and generate a jump list of matches");

    hms_demo_tutorial_binding_line(app, arena, long_details, face,
                                   "Control Shift", "I", "parse the current buffer as a C/C++ source and generate a jump list of functions");

    push_fancy_line(arena, long_details, face, fcolor_id(defcolor_pop1), SCu8((u8*)("After generating a jump list it is bound as the active jump list enabling these commands:"), (u64)(sizeof("After generating a jump list it is bound as the active jump list enabling these commands:") - 1)));

    hms_demo_tutorial_binding_line(app, arena, long_details, face,
                                   "Alt", "N", "jump to the next jump location");

    hms_demo_tutorial_binding_line(app, arena, long_details, face,
                                   "Alt Shift", "N", "jump to the previous jump location");

    hms_demo_tutorial_binding_line(app, arena, long_details, face,
                                   "Alt Shift", "M", "jump to the first jump");

    return(result);
}

static Tutorial_Slide
hms_demo_tutorial_slide_6(Application_Links *app, Arena *arena){
    Tutorial_Slide result = {};

    Face_ID face = get_face_id(app, 0);
    tutorial_init_title_face(app);

    hms_demo_tutorial_short_details(app, arena, &result.short_details);

    Fancy_Block *long_details = &result.long_details;
    hms_demo_tutorial_long_start(app, arena, long_details);

    push_fancy_line(arena, long_details, face, fcolor_id(defcolor_pop1), SCu8((u8*)("Virtual whitespace:"), (u64)(sizeof("Virtual whitespace:") - 1)));

    push_fancy_line(arena, long_details, face, fcolor_id(defcolor_text_default),
                    SCu8((u8*)("\tBuffers that are indexed with information about nest structures can be equiped with the virtual whitespace layout algorithm."), (u64)(sizeof("\tBuffers that are indexed with information about nest structures can be equiped with the virtual whitespace layout algorithm.") - 1)));

    push_fancy_line(arena, long_details, face, fcolor_id(defcolor_text_default),
                    SCu8((u8*)("\tThe on screen layout of text is independent of the actual whitespace contents of the underlying text."), (u64)(sizeof("\tThe on screen layout of text is independent of the actual whitespace contents of the underlying text.") - 1)));

    push_fancy_line(arena, long_details, face, fcolor_id(defcolor_text_default), SCu8((u8*)(""), (u64)(sizeof("") - 1)));

    push_fancy_line(arena, long_details, face, fcolor_id(defcolor_keyword),
                    SCu8((u8*)("\tTry inserting new scopes and parenthetical sections in a code file."), (u64)(sizeof("\tTry inserting new scopes and parenthetical sections in a code file.") - 1)));

    push_fancy_line(arena, long_details, face, fcolor_id(defcolor_text_default),
                    SCu8((u8*)("\t\tObserve that indentation is updated automatically."), (u64)(sizeof("\t\tObserve that indentation is updated automatically.") - 1)));

    push_fancy_line(arena, long_details, face, fcolor_id(defcolor_keyword),
                    SCu8((u8*)("\tTry creating a line that is long enough to wrap around the edge."), (u64)(sizeof("\tTry creating a line that is long enough to wrap around the edge.") - 1)));

    push_fancy_line(arena, long_details, face, fcolor_id(defcolor_text_default),
                    SCu8((u8*)("\t\tObserve that wrapped lines obey the same indentation rules as literal lines."), (u64)(sizeof("\t\tObserve that wrapped lines obey the same indentation rules as literal lines.") - 1)));

    {
        Fancy_Line *line = push_fancy_line(arena, long_details, face, fcolor_id(defcolor_text_default));
        push_fancy_stringf(arena, line, "\tUse the command ");
        push_fancy_stringf(arena, line, fcolor_id(defcolor_pop2), "toggle_virtual_whitespace");
        push_fancy_stringf(arena, line, " to turn this feature on and off");
    }

    {
        Fancy_Line *line = push_fancy_line(arena, long_details, face, fcolor_id(defcolor_text_default));
        push_fancy_stringf(arena, line, "\tUse the command ");
        push_fancy_stringf(arena, line, fcolor_id(defcolor_pop2), "toggle_line_wrap");
        push_fancy_stringf(arena, line, " to see how layout changes with line wrapping on and off");
    }

    push_fancy_line(arena, long_details, face, fcolor_id(defcolor_pop1), SCu8((u8*)("Auto Indentation:"), (u64)(sizeof("Auto Indentation:") - 1)));

    hms_demo_tutorial_binding_line(app, arena, long_details, face,
                                   "Control", "Tab", "auto indent the lines marked by the range; the effect is only visible with virtual whitespace off.");

    return(result);
}

static Tutorial_Slide
hms_demo_tutorial_slide_7(Application_Links *app, Arena *arena){
    Tutorial_Slide result = {};

    Face_ID face = get_face_id(app, 0);
    tutorial_init_title_face(app);

    hms_demo_tutorial_short_details(app, arena, &result.short_details);

    Fancy_Block *long_details = &result.long_details;
    hms_demo_tutorial_long_start(app, arena, long_details);

    push_fancy_line(arena, long_details, face, fcolor_id(defcolor_pop1), SCu8((u8*)("Builds, scripts, and projects:"), (u64)(sizeof("Builds, scripts, and projects:") - 1)));

    hms_demo_tutorial_binding_line(app, arena, long_details, face,
                                   "Alt", "M", "searches for and runs a build script (windows -> 'build.bat'; unix -> 'build.sh')");

    hms_demo_tutorial_binding_line(app, arena, long_details, face,
                                   "", "execute_any_cli", "queries the user for a buffer name and a system command then runs the command and pipes output to the buffer");

    hms_demo_tutorial_binding_line(app, arena, long_details, face,
                                   "", "execute_previous_cli", "repeats an execute_any_cli command with the same command and ouptut buffer");

    push_fancy_line(arena, long_details, face, fcolor_id(defcolor_pop1), SCu8((u8*)("If a script/command generates output that can be parsed as jumps (e.g. compilation errors) then it becomes the active jump buffer:"), (u64)(sizeof("If a script/command generates output that can be parsed as jumps (e.g. compilation errors) then it becomes the active jump buffer:") - 1)));

    hms_demo_tutorial_binding_line(app, arena, long_details, face,
                                   "Alt", "N", "jump to the next jump location");

    hms_demo_tutorial_binding_line(app, arena, long_details, face,
                                   "Alt Shift", "N", "jump to the previous jump location");

    hms_demo_tutorial_binding_line(app, arena, long_details, face,
                                   "Alt Shift", "M", "jump to the first jump");

    push_fancy_line(arena, long_details, face, fcolor_id(defcolor_pop1), SCu8((u8*)("The project system enables rich bindings of arbitrary system scripts (when a project is loaded):"), (u64)(sizeof("The project system enables rich bindings of arbitrary system scripts (when a project is loaded):") - 1)));

    hms_demo_tutorial_binding_line(app, arena, long_details, face,
                                   "", "F#", "run a script bound to the corresponding index in the loaded project");

    hms_demo_tutorial_binding_line(app, arena, long_details, face,
                                   "", "project_command_lister", "use a lister to examine all system commands encoded in the loaded project");

    hms_demo_tutorial_binding_line(app, arena, long_details, face,
                                   "", "load_project", "searches for and loads a 'project.4coder' file");

    hms_demo_tutorial_binding_line(app, arena, long_details, face,
                                   "", "setup_new_project", "command to generate a new 'project.4coder' file and build scripts");

    push_fancy_line(arena, long_details, face, fcolor_id(defcolor_text_default),
                    SCu8((u8*)("\tCheckout 'project.4coder' to see more about what is in a project."), (u64)(sizeof("\tCheckout 'project.4coder' to see more about what is in a project.") - 1)));

    return(result);
}

static Tutorial_Slide
hms_demo_tutorial_slide_8(Application_Links *app, Arena *arena){
    Tutorial_Slide result = {};

    Face_ID face = get_face_id(app, 0);
    tutorial_init_title_face(app);

    hms_demo_tutorial_short_details(app, arena, &result.short_details);

    Fancy_Block *long_details = &result.long_details;
    hms_demo_tutorial_long_start(app, arena, long_details);

    push_fancy_line(arena, long_details, face, fcolor_id(defcolor_text_default),
                    SCu8((u8*)("Probably the biggest feature in 4coder is that so many things about it can be customized."), (u64)(sizeof("Probably the biggest feature in 4coder is that so many things about it can be customized.") - 1)));

    push_fancy_line(arena, long_details, face, fcolor_id(defcolor_text_default),
                    SCu8((u8*)("The project loaded for this demo is the 'default custom layer' everything here could be done differently, as you see fit."), (u64)(sizeof("The project loaded for this demo is the 'default custom layer' everything here could be done differently, as you see fit.") - 1)));

    push_fancy_line(arena, long_details, face, fcolor_id(defcolor_text_default),
                    SCu8((u8*)(""), (u64)(sizeof("") - 1)));

    push_fancy_line(arena, long_details, face, fcolor_id(defcolor_pop1),
                    SCu8((u8*)("Search for these commands to see some of the features available to customization:"), (u64)(sizeof("Search for these commands to see some of the features available to customization:") - 1)));

    hms_demo_tutorial_binding_line(app, arena, long_details, face,
                                   "Alt", "F", "(hint!) this is the default binding for search, use it to find these functions");

    hms_demo_tutorial_binding_line(app, arena, long_details, face,
                                   "", "write_text_input", "the default implementation for text insertion");

    hms_demo_tutorial_binding_line(app, arena, long_details, face,
                                   "", "copy", "the default implementation copying to clipboard");

    hms_demo_tutorial_binding_line(app, arena, long_details, face,
                                   "", "goto_line", "jump to a line specified by the user (which you should try by the way!)");

    hms_demo_tutorial_binding_line(app, arena, long_details, face,
                                   "", "interactive_switch_buffer", "see how this command encodes it's use of a lister with the call 'get_buffer_from_user'");

    hms_demo_tutorial_binding_line(app, arena, long_details, face,
                                   "", "project_command_lister", "again see how this command encodes a lister with a call, this time 'get_project_command_from_user'");

    hms_demo_tutorial_binding_line(app, arena, long_details, face,
                                   "", "setup_default_mapping", "defines the mapping of commands to bindings");

    push_fancy_line(arena, long_details, face, fcolor_id(defcolor_text_default), SCu8((u8*)(""), (u64)(sizeof("") - 1)));

    push_fancy_line(arena, long_details, face, fcolor_id(defcolor_text_default), SCu8((u8*)("\tThe macros CUSTOM_COMMAND_SIG and CUSTOM_DOC markup the commands to create the list of all available commands."), (u64)(sizeof("\tThe macros CUSTOM_COMMAND_SIG and CUSTOM_DOC markup the commands to create the list of all available commands.") - 1)));

    push_fancy_line(arena, long_details, face, fcolor_id(defcolor_text_default), SCu8((u8*)("\tThis means that user written commands that use the same markup automatically appear in the command_lister along side built in commands!"), (u64)(sizeof("\tThis means that user written commands that use the same markup automatically appear in the command_lister along side built in commands!") - 1)));

    return(result);
}

static Tutorial_Slide
hms_demo_tutorial_slide_9(Application_Links *app, Arena *arena){
    Tutorial_Slide result = {};

    Face_ID face = get_face_id(app, 0);
    tutorial_init_title_face(app);

    hms_demo_tutorial_short_details(app, arena, &result.short_details);

    Fancy_Block *long_details = &result.long_details;
    hms_demo_tutorial_long_start(app, arena, long_details);

    push_fancy_line(arena, long_details, face, fcolor_id(defcolor_text_default),
                    SCu8((u8*)("The customization system exposes much more than just commands to be customized..."), (u64)(sizeof("The customization system exposes much more than just commands to be customized...") - 1)));

    hms_demo_tutorial_binding_line(app, arena, long_details, face,
                                   "Alt", "F", "(hint!) this is the default binding for search, use it to find these functions");

    push_fancy_line(arena, long_details, face, fcolor_id(defcolor_pop1),
                    SCu8((u8*)("Write completely custom GUIs:"), (u64)(sizeof("Write completely custom GUIs:") - 1)));

    hms_demo_tutorial_binding_line(app, arena, long_details, face,
                                   "", "run_lister/lister_render", "the input handling loop for listers; and the render handler for listers");

    hms_demo_tutorial_binding_line(app, arena, long_details, face,
                                   "", "tutorial_run_loop/tutorial_render", "underlying implementation for the tutorial system powering this demo!");

    push_fancy_line(arena, long_details, face, fcolor_id(defcolor_pop1),
                    SCu8((u8*)("Write custom text coloring and highlighting in buffers:"), (u64)(sizeof("Write custom text coloring and highlighting in buffers:") - 1)));

    hms_demo_tutorial_binding_line(app, arena, long_details, face,
                                   "", "draw_cpp_token_colors", "syntax highlighting for C++ tokens.");

    hms_demo_tutorial_binding_line(app, arena, long_details, face,
                                   "", "draw_line_number_margin", "draws a line number margin");

    hms_demo_tutorial_binding_line(app, arena, long_details, face,
                                   "", "default_render_buffer", "puts together all the default markup in buffer rendering");

    push_fancy_line(arena, long_details, face, fcolor_id(defcolor_pop1),
                    SCu8((u8*)("Write custom line layout rules:"), (u64)(sizeof("Write custom line layout rules:") - 1)));

    hms_demo_tutorial_binding_line(app, arena, long_details, face,
                                   "", "layout_unwrapped_small_blank_lines", "a funky layout that makes blank lines half height");

    hms_demo_tutorial_binding_line(app, arena, long_details, face,
                                   "", "layout_index_unwrapped__inner", "the unwrapped version of the virtual whitespace layout logic");

    push_fancy_line(arena, long_details, face, fcolor_id(defcolor_pop1),
                    SCu8((u8*)("Write custom smoothing rules that interact with buffer and UI scrolling:"), (u64)(sizeof("Write custom smoothing rules that interact with buffer and UI scrolling:") - 1)));

    hms_demo_tutorial_binding_line(app, arena, long_details, face,
                                   "", "snap_delta", "a delta rule that snaps to the destination point instantly");

    hms_demo_tutorial_binding_line(app, arena, long_details, face,
                                   "", "fixed_time_cubic_delta", "the smooth scrolling enabled in this build");

    return(result);
}

static Tutorial_Slide
hms_demo_tutorial_slide_10(Application_Links *app, Arena *arena){
    Tutorial_Slide result = {};

    Face_ID face = get_face_id(app, 0);
    tutorial_init_title_face(app);

    hms_demo_tutorial_short_details(app, arena, &result.short_details);

    Fancy_Block *long_details = &result.long_details;
    hms_demo_tutorial_long_start(app, arena, long_details);

    push_fancy_line(arena, long_details, face, fcolor_id(defcolor_pop1),
                    SCu8((u8*)("Some miscellaneous things to try:"), (u64)(sizeof("Some miscellaneous things to try:") - 1)));

    hms_demo_tutorial_binding_line(app, arena, long_details, face,
                                   "", "Tab", "in a code file this triggers the cyclic word complete, often a handy command");

    hms_demo_tutorial_binding_line(app, arena, long_details, face,
                                   "Control", "F/R", "forward/reverse iterative search");

    hms_demo_tutorial_binding_line(app, arena, long_details, face,
                                   "Control", "A", "replace all instances of a string in the range");

    hms_demo_tutorial_binding_line(app, arena, long_details, face,
                                   "Control", "0", "insert an assignment to an empty struct or array");

    hms_demo_tutorial_binding_line(app, arena, long_details, face,
                                   "Alt", "0", "insert a #if 0 / #endif pair at the cursor and mark");

    hms_demo_tutorial_binding_line(app, arena, long_details, face,
                                   "Alt", "2", "open the corresponding .h/.cpp file to the current buffer in the second panel");

    return(result);
}

static Tutorial_Slide
hms_demo_tutorial_slide_11(Application_Links *app, Arena *arena){
    Tutorial_Slide result = {};

    Face_ID face = get_face_id(app, 0);
    tutorial_init_title_face(app);

    hms_demo_tutorial_short_details(app, arena, &result.short_details);

    Fancy_Block *long_details = &result.long_details;
    hms_demo_tutorial_long_start(app, arena, long_details);

    push_fancy_line(arena, long_details, face, fcolor_id(defcolor_pop1), SCu8((u8*)(""), (u64)(sizeof("") - 1)));

    push_fancy_line(arena, long_details, face, fcolor_id(defcolor_pop1), SCu8((u8*)(""), (u64)(sizeof("") - 1)));

    push_fancy_line(arena, long_details, face, fcolor_id(defcolor_pop1), SCu8((u8*)("\t\tThanks for checking out the demo!"), (u64)(sizeof("\t\tThanks for checking out the demo!") - 1)));

    return(result);
}

CUSTOM_COMMAND(hms_demo_tutorial, "/home/sam/.bin/4coder/custom/4coder_tutorial.cpp", 869, Normal)
CUSTOM_DOC("Tutorial for built in 4coder bindings and features.")
{
    static Tutorial_Slide_Function *slides[] = {

        hms_demo_tutorial_slide_1,

        hms_demo_tutorial_slide_2,

        hms_demo_tutorial_slide_3,

        hms_demo_tutorial_slide_4,

        hms_demo_tutorial_slide_5,

        hms_demo_tutorial_slide_6,

        hms_demo_tutorial_slide_7,

        hms_demo_tutorial_slide_8,

        hms_demo_tutorial_slide_9,

        hms_demo_tutorial_slide_10,

        hms_demo_tutorial_slide_11,
    };
    run_tutorial(app, slides, ((sizeof(slides))/(sizeof(*slides))));
}
# 126 "/home/sam/.bin/4coder/custom/4coder_default_include.cpp" 2
# 1 "/home/sam/.bin/4coder/custom/4coder_doc_content_types.cpp" 1
# 12 "/home/sam/.bin/4coder/custom/4coder_doc_content_types.cpp"
# 1 "/usr/include/time.h" 1 3 4
# 29 "/usr/include/time.h" 3 4
# 1 "/usr/lib/gcc/x86_64-pc-linux-gnu/10.2.0/include/stddef.h" 1 3 4
# 30 "/usr/include/time.h" 2 3 4



# 1 "/usr/include/bits/time.h" 1 3 4
# 73 "/usr/include/bits/time.h" 3 4
# 1 "/usr/include/bits/timex.h" 1 3 4
# 26 "/usr/include/bits/timex.h" 3 4

# 26 "/usr/include/bits/timex.h" 3 4
struct timex
{
  unsigned int modes;
  __syscall_slong_t offset;
  __syscall_slong_t freq;
  __syscall_slong_t maxerror;
  __syscall_slong_t esterror;
  int status;
  __syscall_slong_t constant;
  __syscall_slong_t precision;
  __syscall_slong_t tolerance;
  struct timeval time;
  __syscall_slong_t tick;
  __syscall_slong_t ppsfreq;
  __syscall_slong_t jitter;
  int shift;
  __syscall_slong_t stabil;
  __syscall_slong_t jitcnt;
  __syscall_slong_t calcnt;
  __syscall_slong_t errcnt;
  __syscall_slong_t stbcnt;

  int tai;


  int :32; int :32; int :32; int :32;
  int :32; int :32; int :32; int :32;
  int :32; int :32; int :32;
};
# 74 "/usr/include/bits/time.h" 2 3 4

extern "C" {


extern int clock_adjtime (__clockid_t __clock_id, struct timex *__utx) throw ();

}
# 34 "/usr/include/time.h" 2 3 4





# 1 "/usr/include/bits/types/struct_tm.h" 1 3 4






struct tm
{
  int tm_sec;
  int tm_min;
  int tm_hour;
  int tm_mday;
  int tm_mon;
  int tm_year;
  int tm_wday;
  int tm_yday;
  int tm_isdst;


  long int tm_gmtoff;
  const char *tm_zone;




};
# 40 "/usr/include/time.h" 2 3 4
# 48 "/usr/include/time.h" 3 4
# 1 "/usr/include/bits/types/struct_itimerspec.h" 1 3 4







struct itimerspec
  {
    struct timespec it_interval;
    struct timespec it_value;
  };
# 49 "/usr/include/time.h" 2 3 4
struct sigevent;
# 68 "/usr/include/time.h" 3 4
extern "C" {



extern clock_t clock (void) throw ();


extern time_t time (time_t *__timer) throw ();


extern double difftime (time_t __time1, time_t __time0)
     throw () __attribute__ ((__const__));


extern time_t mktime (struct tm *__tp) throw ();





extern size_t strftime (char *__restrict __s, size_t __maxsize,
   const char *__restrict __format,
   const struct tm *__restrict __tp) throw ();




extern char *strptime (const char *__restrict __s,
         const char *__restrict __fmt, struct tm *__tp)
     throw ();






extern size_t strftime_l (char *__restrict __s, size_t __maxsize,
     const char *__restrict __format,
     const struct tm *__restrict __tp,
     locale_t __loc) throw ();



extern char *strptime_l (const char *__restrict __s,
    const char *__restrict __fmt, struct tm *__tp,
    locale_t __loc) throw ();





extern struct tm *gmtime (const time_t *__timer) throw ();



extern struct tm *localtime (const time_t *__timer) throw ();




extern struct tm *gmtime_r (const time_t *__restrict __timer,
       struct tm *__restrict __tp) throw ();



extern struct tm *localtime_r (const time_t *__restrict __timer,
          struct tm *__restrict __tp) throw ();




extern char *asctime (const struct tm *__tp) throw ();


extern char *ctime (const time_t *__timer) throw ();






extern char *asctime_r (const struct tm *__restrict __tp,
   char *__restrict __buf) throw ();


extern char *ctime_r (const time_t *__restrict __timer,
        char *__restrict __buf) throw ();




extern char *__tzname[2];
extern int __daylight;
extern long int __timezone;




extern char *tzname[2];



extern void tzset (void) throw ();



extern int daylight;
extern long int timezone;
# 190 "/usr/include/time.h" 3 4
extern time_t timegm (struct tm *__tp) throw ();


extern time_t timelocal (struct tm *__tp) throw ();


extern int dysize (int __year) throw () __attribute__ ((__const__));
# 205 "/usr/include/time.h" 3 4
extern int nanosleep (const struct timespec *__requested_time,
        struct timespec *__remaining);



extern int clock_getres (clockid_t __clock_id, struct timespec *__res) throw ();


extern int clock_gettime (clockid_t __clock_id, struct timespec *__tp) throw ();


extern int clock_settime (clockid_t __clock_id, const struct timespec *__tp)
     throw ();






extern int clock_nanosleep (clockid_t __clock_id, int __flags,
       const struct timespec *__req,
       struct timespec *__rem);


extern int clock_getcpuclockid (pid_t __pid, clockid_t *__clock_id) throw ();




extern int timer_create (clockid_t __clock_id,
    struct sigevent *__restrict __evp,
    timer_t *__restrict __timerid) throw ();


extern int timer_delete (timer_t __timerid) throw ();


extern int timer_settime (timer_t __timerid, int __flags,
     const struct itimerspec *__restrict __value,
     struct itimerspec *__restrict __ovalue) throw ();


extern int timer_gettime (timer_t __timerid, struct itimerspec *__value)
     throw ();


extern int timer_getoverrun (timer_t __timerid) throw ();





extern int timespec_get (struct timespec *__ts, int __base)
     throw () __attribute__ ((__nonnull__ (1)));
# 274 "/usr/include/time.h" 3 4
extern int getdate_err;
# 283 "/usr/include/time.h" 3 4
extern struct tm *getdate (const char *__string);
# 297 "/usr/include/time.h" 3 4
extern int getdate_r (const char *__restrict __string,
        struct tm *__restrict __resbufp);


}
# 13 "/home/sam/.bin/4coder/custom/4coder_doc_content_types.cpp" 2


# 14 "/home/sam/.bin/4coder/custom/4coder_doc_content_types.cpp"
static Doc_Date
doc_date_now(void){
    time_t t = time(0);
    tm *time = localtime(&t);
    Doc_Date date = {};
    date.day = time->tm_mday;
    date.month = time->tm_mon + 1;
    date.year = 1900 + time->tm_year;
    return(date);
             }



static Doc_Content*
doc_content_push(Arena *arena, Doc_Content_List *list, String_Const_u8 text, Doc_Content_Emphasis emphasis){
    Doc_Content *content = ((Doc_Content*)linalloc_wrap_zero(linalloc_push((arena), sizeof(Doc_Content)*(1), SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_doc_content_types.cpp" ":" "29" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_doc_content_types.cpp" ":" "29" ":") - 1)))));
    do{ if((content)){if((list->first)){(list->last)->next=(content);}else{(list->first)=(content);}(list->last)=(content);(list->last)->next=0;} }while(0);
    list->total_size += text.size;
    list->node_count += 1;
    content->text = text;
    content->emphasis = emphasis;
    return(content);
}

static Doc_Content*
doc_content_push(Arena *arena, Doc_Content_List *list, String_Const_u8 text){
    return(doc_content_push(arena, list, text, DocContentEmphasis_Normal));
}

static void
doc_code_list_push(Arena *arena, Doc_Code_Sample_List *list, String_Const_u8 contents, Doc_Code_Language language){
    Doc_Code_Sample *sample = ((Doc_Code_Sample*)linalloc_wrap_zero(linalloc_push((arena), sizeof(Doc_Code_Sample)*(1), SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_doc_content_types.cpp" ":" "45" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_doc_content_types.cpp" ":" "45" ":") - 1)))));
    do{ if((sample)){if((list->first)){(list->last)->next=(sample);}else{(list->first)=(sample);}(list->last)=(sample);(list->last)->next=0;} }while(0);
    list->count += 1;
    sample->contents = contents;
    sample->language = language;
}



static Doc_Cluster*
new_doc_cluster(Arena *arena, char *title, char *name, Doc_Date *date){
    Doc_Cluster *result = ((Doc_Cluster*)linalloc_wrap_zero(linalloc_push((arena), sizeof(Doc_Cluster)*(1), SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_doc_content_types.cpp" ":" "56" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_doc_content_types.cpp" ":" "56" ":") - 1)))));
    result->title = SCu8(title);
    result->name = SCu8(name);
    result->gen_date = *date;
    return(result);
}

static Doc_Cluster*
new_doc_cluster(Arena *arena, char *title, char *name){
    Doc_Date date = doc_date_now();
    return(new_doc_cluster(arena, title, name, &date));
}

static Doc_Page*
new_doc_page(Arena *arena, Doc_Cluster *cluster, char *title, char *name){
    Doc_Page *result = ((Doc_Page*)linalloc_wrap_zero(linalloc_push((arena), sizeof(Doc_Page)*(1), SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_doc_content_types.cpp" ":" "71" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_doc_content_types.cpp" ":" "71" ":") - 1)))));

    result->owner = cluster;
    do{ if((result)){if((cluster->first_page)){(cluster->last_page)->next=(result);}else{(cluster->first_page)=(result);}(cluster->last_page)=(result);(cluster->last_page)->next=0;} }while(0);
    cluster->page_count += 1;

    result->title = SCu8(title);
    result->name = SCu8(name);

    return(result);
}

static Doc_Page*
new_doc_page_normal_title(Arena *arena, Doc_Cluster *cluster, char *title, char *name){
    String_Const_u8 full_title = push_u8_stringf(arena, "%s - %.*s", title, (i32)(cluster->title).size, (char*)(cluster->title).str);
    return(new_doc_page(arena, cluster, (char*)full_title.str, name));
}

static Doc_Page*
new_doc_page_function(Arena *arena, Doc_Cluster *cluster, char *name){
    return(new_doc_page_normal_title(arena, cluster, name, name));
}

static Doc_Page*
new_doc_page_function(Arena *arena, Doc_Cluster *cluster, String_Const_u8 name){
    name = push_string_copy(arena, name);
    char *c_name = (char*)name.str;
    return(new_doc_page_function(arena, cluster, c_name));
}

 static Doc_Block*
new_doc_block(Arena *arena, Doc_Page *page, char *name){
    Doc_Block *result = ((Doc_Block*)linalloc_wrap_zero(linalloc_push((arena), sizeof(Doc_Block)*(1), SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_doc_content_types.cpp" ":" "103" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_doc_content_types.cpp" ":" "103" ":") - 1)))));
    result->owner = page;
    do{ if((result)){if((page->first_block)){(page->last_block)->next=(result);}else{(page->first_block)=(result);}(page->last_block)=(result);(page->last_block)->next=0;} }while(0);
    page->block_count += 1;
    result->name = SCu8(name);
    return(result);
}

static void
new_doc_block_jump(Arena *arena, Doc_Page *page, Doc_Block *block){
    Doc_Block_Ptr *node = ((Doc_Block_Ptr*)linalloc_wrap_zero(linalloc_push((arena), sizeof(Doc_Block_Ptr)*(1), SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_doc_content_types.cpp" ":" "113" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_doc_content_types.cpp" ":" "113" ":") - 1)))));
    do{ if((node)){if((page->quick_jumps.first)){(page->quick_jumps.last)->next=(node);}else{(page->quick_jumps.first)=(node);}(page->quick_jumps.last)=(node);(page->quick_jumps.last)->next=0;} }while(0);
    page->quick_jumps.count += 1;
    node->block = block;
}

static Doc_Paragraph*
new_doc_par(Arena *arena, Doc_Block *block){
    Doc_Paragraph *result = ((Doc_Paragraph*)linalloc_wrap_zero(linalloc_push((arena), sizeof(Doc_Paragraph)*(1), SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_doc_content_types.cpp" ":" "121" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_doc_content_types.cpp" ":" "121" ":") - 1)))));
    do{ if((result)){if((block->first_par)){(block->last_par)->next=(result);}else{(block->first_par)=(result);}(block->last_par)=(result);(block->last_par)->next=0;} }while(0);
    block->par_count += 1;
    return(result);
}

static void
new_doc_par_single_code(Arena *arena, Doc_Block *block, String_Const_u8 contents, Doc_Code_Language language){
    Doc_Paragraph *paragraph = new_doc_par(arena, block);
    paragraph->kind = DocParagraphKind_Code;
    doc_code_list_push(arena, &paragraph->code, contents, language);
}

static Doc_Paragraph*
new_doc_par_table(Arena *arena, Doc_Block *block){
    Doc_Paragraph *result = new_doc_par(arena, block);
    result->kind = DocParagraphKind_Table;
    return(result);
}



static void
doc_log(Arena *arena, Doc_Cluster *cluster, String_Const_u8 string){
    Doc_Log *log = ((Doc_Log*)linalloc_wrap_zero(linalloc_push((arena), sizeof(Doc_Log)*(1), SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_doc_content_types.cpp" ":" "145" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_doc_content_types.cpp" ":" "145" ":") - 1)))));
    do{ if((log)){if((cluster->first_log)){(cluster->last_log)->next=(log);}else{(cluster->first_log)=(log);}(cluster->last_log)=(log);(cluster->last_log)->next=0;} }while(0);
    log->content = string;
}

static void
doc_log(Arena *arena, Doc_Cluster *cluster, char *str){
    doc_log(arena, cluster, SCu8(str));
}

static void
doc_logfv(Arena *arena, Doc_Cluster *cluster, char *format, va_list args){
    String_Const_u8 str = push_u8_stringfv(arena, format, args);
    doc_log(arena, cluster, str);
}

static void
doc_logf(Arena *arena, Doc_Cluster *cluster, char *format, ...){
    va_list args;
    
# 164 "/home/sam/.bin/4coder/custom/4coder_doc_content_types.cpp" 3 4
   __builtin_va_start(
# 164 "/home/sam/.bin/4coder/custom/4coder_doc_content_types.cpp"
   args
# 164 "/home/sam/.bin/4coder/custom/4coder_doc_content_types.cpp" 3 4
   ,
# 164 "/home/sam/.bin/4coder/custom/4coder_doc_content_types.cpp"
   format
# 164 "/home/sam/.bin/4coder/custom/4coder_doc_content_types.cpp" 3 4
   )
# 164 "/home/sam/.bin/4coder/custom/4coder_doc_content_types.cpp"
                         ;
    doc_logfv(arena, cluster, format, args);
    
# 166 "/home/sam/.bin/4coder/custom/4coder_doc_content_types.cpp" 3 4
   __builtin_va_end(
# 166 "/home/sam/.bin/4coder/custom/4coder_doc_content_types.cpp"
   args
# 166 "/home/sam/.bin/4coder/custom/4coder_doc_content_types.cpp" 3 4
   )
# 166 "/home/sam/.bin/4coder/custom/4coder_doc_content_types.cpp"
               ;
}
# 179 "/home/sam/.bin/4coder/custom/4coder_doc_content_types.cpp"
static Doc_Content*
doc_text(Arena *arena, Doc_Block *block, char *str){
    Doc_Paragraph *par = block->last_par;
    if (par != 0){
        if (par->kind != DocParagraphKind_Text){
            par = 0;
        }
    }

    if (par == 0){
        par = new_doc_par(arena, block);
        par->kind = DocParagraphKind_Text;
    }

    return(doc_content_push(arena, &par->text, SCu8(str)));
}

static Doc_Content*
doc_text(Arena *arena, Doc_Content_List *list, char *string){
    return(doc_content_push(arena, list, SCu8(string)));
}

static void
doc_paragraph(Arena *arena, Doc_Block *block){
    Doc_Paragraph *par = new_doc_par(arena, block);
    par->kind = DocParagraphKind_Text;
}



static Doc_Page*
doc_get_page(Doc_Cluster *cluster, String_Const_u8 name){
    Doc_Page *result = 0;
    for (Doc_Page *page = cluster->first_page;
         page != 0;
         page = page->next){
        if (string_match(name, page->name)){
            result = page;
            break;
        }
    }
    return(result);
}
# 127 "/home/sam/.bin/4coder/custom/4coder_default_include.cpp" 2
# 1 "/home/sam/.bin/4coder/custom/4coder_doc_commands.cpp" 1
# 12 "/home/sam/.bin/4coder/custom/4coder_doc_commands.cpp"
static Doc_Cluster*
doc_commands(Arena *arena){
    Doc_Cluster *cluster = new_doc_cluster(arena, "Commands", "commands");
    for (i32 i = 0; i < ((sizeof(fcoder_metacmd_table))/(sizeof(*fcoder_metacmd_table))); i += 1){
        String_Const_u8 cmd_name = SCu8(fcoder_metacmd_table[i].name,
                                        fcoder_metacmd_table[i].name_len);
        String_Const_u8 title = push_u8_stringf(arena, "Command %.*s", (i32)(cmd_name).size, (char*)(cmd_name).str);
        Doc_Page *page = new_doc_page(arena, cluster, (char*)title.str, (char*)cmd_name.str);
        Doc_Block *block = new_doc_block(arena, page, "brief");
        doc_text(arena, block, fcoder_metacmd_table[i].description);
    }
    return(cluster);
}

static Doc_Cluster*
doc_default_bindings(Arena *arena, i32 map_count, Mapping *mapping_array, char **page_titles, char **page_names,
                     i64 global_id, i64 file_id, i64 code_id){
    Doc_Cluster *cluster = new_doc_cluster(arena, "Bindings", "bindings");

    for (i32 i = 0; i < map_count; i += 1){
        Mapping *mapping = &mapping_array[i];
        Doc_Page *page = new_doc_page(arena, cluster, page_titles[i], page_names[i]);
        for (Command_Map *map = mapping->first_map;
             map != 0;
             map = map->next){
            char *map_name = "";
            if (map->id == global_id){
                map_name = "Global";
            }
            else if (map->id == file_id){
                map_name = "File";
            }
            else if (map->id == code_id){
                map_name = "Code";
            }

            Doc_Block *block = new_doc_block(arena, page, map_name);
            Doc_Paragraph *par = new_doc_par_table(arena, block);

            struct Bind_Node{
                Bind_Node *next;
                Input_Event_Kind kind;
                u32 sub_code;
                Input_Modifier_Set mods;
                Command_Binding binding;
                u32 j;
            };

            Bind_Node *first = 0;
            Bind_Node *last = 0;
            i32 node_count = 0;

            if (map->text_input_command.name != 0){
                Bind_Node *node = ((Bind_Node*)linalloc_wrap_zero(linalloc_push((arena), sizeof(Bind_Node)*(1), SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_doc_commands.cpp" ":" "65" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_doc_commands.cpp" ":" "65" ":") - 1)))));
                do{ if((node)){if((first)){(last)->next=(node);}else{(first)=(node);}(last)=(node);(last)->next=0;} }while(0);
                node_count += 1;
                node->binding = map->text_input_command;
                node->j = max_u32;
            }

            u32 counts[] = {
                KeyCode_COUNT,
                KeyCode_COUNT,
                MouseCode_COUNT,
                MouseCode_COUNT,
                1,
                1,
                CoreCode_COUNT,
            };

            u32 event_codes[] = {
                InputEventKind_KeyStroke,
                InputEventKind_KeyRelease,
                InputEventKind_MouseButton,
                InputEventKind_MouseButtonRelease,
                InputEventKind_MouseWheel,
                InputEventKind_MouseMove,
                InputEventKind_Core,
            };

            char *mouse_wheel_name[] = {"MoveWheel"};
            char *mouse_move_name[] = {"MoveMove"};

            char **event_names[] = {
                key_code_name,
                key_code_name,
                mouse_code_name,
                mouse_code_name,
                mouse_wheel_name,
                mouse_move_name,
                core_code_name,
            };

            b32 is_release[] = {
                false,
                true,
                false,
                true,
                false,
                false,
                false,
            };

            for (u32 j = 0; j < ((sizeof(counts))/(sizeof(*counts))); j += 1){
                for (u32 code = 0; code < counts[j]; code += 1){
                    u64 key = mapping__key(event_codes[j], code);
                    Table_Lookup lookup = table_lookup(&map->event_code_to_binding_list, key);
                    if (lookup.found_match){
                        u64 val = 0;
                        table_read(&map->event_code_to_binding_list, lookup, &val);
                        Command_Binding_List *list = (Command_Binding_List*)(void*)(((u8*)0) + val);
                        for (SNode *snode = list->first;
                             snode != 0;
                             snode = snode->next){
                            Command_Modified_Binding *mod_binding = (Command_Modified_Binding*)( (u8*)(snode) - ((u8*)(&(((Command_Modified_Binding*)0)->order_node)) - (u8*)(0)) );

                            Bind_Node *node = ((Bind_Node*)linalloc_wrap_zero(linalloc_push((arena), sizeof(Bind_Node)*(1), SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_doc_commands.cpp" ":" "128" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_doc_commands.cpp" ":" "128" ":") - 1)))));
                            do{ if((node)){if((first)){(last)->next=(node);}else{(first)=(node);}(last)=(node);(last)->next=0;} }while(0);
                            node_count += 1;
                            node->kind = event_codes[j];
                            node->sub_code = code;
                            node->mods = mod_binding->mods;
                            node->binding = mod_binding->binding;
                            node->j = j;
                        }
                    }
                }
            }

            Vec2_i32 table_dims = V2i32(2, node_count);
            Doc_Content_List *vals = ((Doc_Content_List*)linalloc_wrap_zero(linalloc_push((arena), sizeof(Doc_Content_List)*(table_dims.x*table_dims.y), SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_doc_commands.cpp" ":" "142" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_doc_commands.cpp" ":" "142" ":") - 1)))));
            Bind_Node *bnode = first;
            for (i32 y = 0; y < table_dims.y; y += 1, bnode = bnode->next){
                Doc_Content_List *line = &vals[y*table_dims.x];
                doc_text(arena, &line[0], "[");
                if (bnode->j != max_u32){
                    doc_text(arena, &line[0], event_names[bnode->j][bnode->sub_code]);
                    if (is_release[bnode->j]){
                        doc_text(arena, &line[0], "Release");
                    }

                    Input_Modifier_Set *mods = &bnode->mods;
                    for (i32 k = 0; k < mods->count; k += 1){
                        doc_text(arena, &line[0], key_code_name[mods->mods[k]]);
                    }
                }
                else{
                    doc_text(arena, &line[0], "TextInput");
                }
                doc_text(arena, &line[0], "]");

                Doc_Content *content = doc_text(arena, &line[1], bnode->binding.name);
                content->page_link = SCu8(bnode->binding.name);
            }

            par->table.dim = table_dims;
            par->table.vals = vals;
        }
    }

    return(cluster);
}
# 128 "/home/sam/.bin/4coder/custom/4coder_default_include.cpp" 2
# 1 "/home/sam/.bin/4coder/custom/4coder_docs.cpp" 1






static Doc_Page*
get_doc_page_from_user(Application_Links *app, Doc_Cluster *doc, String_Const_u8 query){
    Scratch_Block scratch(app);
    Lister_Block lister(app, scratch);
    lister_set_query(lister, query);
    lister_set_default_handlers(lister);

    for (Doc_Page *page = doc->first_page;
         page != 0;
         page = page->next){
        lister_add_item(lister, page->name, SCu8(""), page, 0);
    }
    Lister_Result l_result = run_lister(app, lister);
    Doc_Page *result = 0;
    if (!l_result.canceled){
        result = (Doc_Page*)l_result.user_data;
    }
    return(result);
}

static Doc_Page*
get_doc_page_from_user(Application_Links *app, Doc_Cluster *doc, char *query){
    return(get_doc_page_from_user(app, doc, SCu8(query)));
}

static void
render_doc_page__content(Application_Links *app, Buffer_Insertion *insert, Doc_Content_List *list){
    for (Doc_Content *content = list->first;
         content != 0;
         content = content->next){


        if (content->emphasis == DocContentEmphasis_SmallHeader){
            insertf(insert, "\n");
        }
        if (content->emphasis == DocContentEmphasis_Heavy){
            insertf(insert, "_");
        }
        if (content->emphasis == DocContentEmphasis_Stylish){
            insertf(insert, "*");
        }

        insertf(insert, "%.*s", (i32)(content->text).size, (char*)(content->text).str);
        if (content->page_link.size > 0){
            insertf(insert, " (link page %.*s)", (i32)(content->page_link).size, (char*)(content->page_link).str);
        }
        else if (content->block_link.size > 0){
            insertf(insert, " (link block %.*s)", (i32)(content->block_link).size, (char*)(content->block_link).str);
        }

        if (content->emphasis == DocContentEmphasis_Heavy){
            insertf(insert, "_");
        }
        if (content->emphasis == DocContentEmphasis_Stylish){
            insertf(insert, "*");
        }
        if (content->emphasis == DocContentEmphasis_SmallHeader){
            insertf(insert, "\n");
        }
        else{
            if (content->next != 0){
                insertf(insert, " ");
            }
        }
    }
}

static void
render_doc_page__code(Application_Links *app, Buffer_Insertion *insert, Doc_Code_Sample_List *code){
    for (Doc_Code_Sample *sample = code->first;
         sample != 0;
         sample = sample->next){
        insertf(insert, "language: ");
        switch (sample->language){
            case DocCodeLanguage_Cpp:
            {
                insertf(insert, "C++\n");
            }break;
            case DocCodeLanguage_Bat:
            {
                insertf(insert, "Batch\n\n");
            }break;
        }
        insertf(insert, "\n%.*s\n", (i32)(sample->contents).size, (char*)(sample->contents).str);
    }
}

static void
render_doc_page__table(Application_Links *app, Buffer_Insertion *insert, Vec2_i32 dim, Doc_Content_List *vals){

    Doc_Content_List *val = vals;
    for (i32 y = 0; y < dim.y; y += 1){
        for (i32 x = 0; x < dim.x; x += 1){
            render_doc_page__content(app, insert, val);
            insertf(insert, "; ");
            val += 1;
        }
        insertf(insert, "\n");
    }
}

static Buffer_ID
render_doc_page(Application_Links *app, Doc_Page *page){
    Scratch_Block scratch(app);

    String_Const_u8 doc_buffer_name = push_u8_stringf(scratch, "*doc: %.*s*",
                                                      (i32)(page->name).size, (char*)(page->name).str);

    Buffer_Create_Flag flags = BufferCreate_NeverAttachToFile;
    Buffer_ID buffer = create_buffer(app, doc_buffer_name, flags);
    if (buffer != 0){
        buffer_set_setting(app, buffer, BufferSetting_RecordsHistory, false);
        buffer_set_setting(app, buffer, BufferSetting_ReadOnly, true);
        buffer_set_setting(app, buffer, BufferSetting_Unimportant, true);

        i64 size = buffer_get_size(app, buffer);
        if (size != 0){
            buffer_replace_range(app, buffer, Ii64(0, size), SCu8(""));
        }
        Buffer_Insertion insert = begin_buffer_insertion_at_buffered(app, buffer, 0, scratch, ((16) << 10));

        char dashes[] =
            "----------------------------------------------------------------"
            "----------------------------------------------------------------"
            "----------------------------------------------------------------"
            "----------------------------------------------------------------";

        insertf(&insert, "%.*s\n%.*s\n",
                (i32)(page->title).size, (char*)(page->title).str,
                page->title.size, dashes);

        for (Doc_Block *block = page->first_block;
             block != 0;
             block = block->next){
            insertf(&insert, "%.*s\n\n", (i32)(block->name).size, (char*)(block->name).str);

            for (Doc_Paragraph *par = block->first_par;
                 par != 0;
                 par = par->next){
                switch (par->kind){
                    case DocParagraphKind_Text:
                    {
                        render_doc_page__content(app, &insert, &par->text);
                    }break;

                    case DocParagraphKind_Code:
                    {
                        render_doc_page__code(app, &insert, &par->code);
                    }break;

                    case DocParagraphKind_Table:
                    {
                        render_doc_page__table(app, &insert, par->table.dim, par->table.vals);
                    }break;
                }

                insert_string(&insert, SCu8((u8*)("\n"), (u64)(sizeof("\n") - 1)));
            }

            insertf(&insert, "%.*s\n", page->title.size, dashes);
        }

        end_buffer_insertion(&insert);
    }

    return(buffer);
}

CUSTOM_COMMAND(custom_api_documentation, "/home/sam/.bin/4coder/custom/4coder_docs.cpp", 175, UI)
CUSTOM_DOC("Prompts the user to select a Custom API item then loads a doc buffer for that item")
{
    View_ID view = get_this_ctx_view(app, Access_ReadWrite);
    if (view != 0){
        Scratch_Block scratch(app);
        Doc_Cluster *docs = get_custom_layer_boundary_docs(app, scratch);
        Doc_Page *page = get_doc_page_from_user(app, docs, "Doc Page:");
  if (page != 0){
            Buffer_ID buffer = render_doc_page(app, page);
            view_set_buffer(app, view, buffer, 0);
        }
    }
}

CUSTOM_COMMAND(command_documentation, "/home/sam/.bin/4coder/custom/4coder_docs.cpp", 190, UI)
CUSTOM_DOC("Prompts the user to select a command then loads a doc buffer for that item")
{
    View_ID view = get_this_ctx_view(app, Access_Always);
    if (view != 0){
        Scratch_Block scratch(app);
        Doc_Cluster *docs = doc_commands(scratch);
        Doc_Page *page = get_doc_page_from_user(app, docs, "Doc Page:");
        if (page != 0){
            Buffer_ID buffer = render_doc_page(app, page);
            view_set_buffer(app, view, buffer, 0);
        }
    }
}
# 129 "/home/sam/.bin/4coder/custom/4coder_default_include.cpp" 2

# 1 "/home/sam/.bin/4coder/custom/4coder_examples.cpp" 1
# 10 "/home/sam/.bin/4coder/custom/4coder_examples.cpp"
CUSTOM_COMMAND(double_backspace, "/home/sam/.bin/4coder/custom/4coder_examples.cpp", 10, Normal)
CUSTOM_DOC("Example of history group helpers")
{






    View_ID view = get_active_view(app, Access_ReadWriteVisible);
    Buffer_ID buffer = view_get_buffer(app, view, Access_ReadWriteVisible);
    History_Group group = history_group_begin(app, buffer);
    backspace_char(app);
    backspace_char(app);
    history_group_end(group);
}



CUSTOM_COMMAND(play_with_a_counter, "/home/sam/.bin/4coder/custom/4coder_examples.cpp", 29, Normal)
CUSTOM_DOC("Example of query bar")
{
# 44 "/home/sam/.bin/4coder/custom/4coder_examples.cpp"
    i32 counter = 0;

    Query_Bar_Group group(app);
    Query_Bar dumb_bar = {};
    dumb_bar.prompt = SCu8("Goes away at >= 10");
    if (!start_query_bar(app, &dumb_bar, 0)){
        return;
    }

    Query_Bar bar = {};
    bar.prompt = SCu8("Counter = ");
    bar.string = SCu8("");
    if (!start_query_bar(app, &bar, 0)){
        return;
    }

    for (;;){




        Scratch_Block scratch(app);
        bar.string = push_stringf(scratch, "%d", counter);
        if (counter >= 10){
            end_query_bar(app, &dumb_bar, 0);
        }

        User_Input in = get_next_input(app, EventPropertyGroup_Any, EventProperty_Escape);
        if (in.abort){
            break;
        }

        if (match_key_code(&in.event, KeyCode_Up)){
            counter += 1;
        }
        else if (match_key_code(&in.event, KeyCode_Down)){
            counter -= 1;
        }
        else{
            leave_current_input_unhandled(app);
        }
    }
}



CUSTOM_COMMAND(display_key_codes, "/home/sam/.bin/4coder/custom/4coder_examples.cpp", 90, Normal)
CUSTOM_DOC("Example of input handling loop")
{






    Query_Bar_Group group(app);
    Query_Bar bar = {};
    bar.prompt = SCu8("KeyCode = ");
    if (!start_query_bar(app, &bar, 0)){
        return;
    }

    Key_Code code = 0;
    b32 is_dead_key = false;

    for (;;){
        Scratch_Block scratch(app);
        if (code == 0){
            bar.string = SCu8("...");
        }
        else{
            bar.string = push_stringf(scratch, "KeyCode_%s (%d)%s", key_code_name[code], code,
                                      is_dead_key?" dead-key":"");
        }
        User_Input in = get_next_input(app, EventPropertyGroup_Any, EventProperty_Escape);
        if (in.abort){
            break;
        }
        if (in.event.kind == InputEventKind_KeyStroke){
            code = in.event.key.code;
            is_dead_key = event_is_dead_key(&in.event);
        }
        else{



            leave_current_input_unhandled(app);
        }
    }
}



CUSTOM_COMMAND(display_text_input, "/home/sam/.bin/4coder/custom/4coder_examples.cpp", 137, Normal)
CUSTOM_DOC("Example of to_writable and leave_current_input_unhandled")
{






    Query_Bar_Group group(app);
    Query_Bar bar = {};
    bar.prompt = SCu8("Weird String: ");
    if (!start_query_bar(app, &bar, 0)){
        return;
    }

    u8 buffer[256];
    u64 size = 0;

    for (;;){
        User_Input in = get_next_input(app, EventPropertyGroup_Any, EventProperty_Escape);
        if (in.abort){
            break;
        }

        String_Const_u8 in_string = to_writable(&in);
        if (in_string.size > 0){
            size = (((in_string.size)<(sizeof(buffer)))?(in_string.size):(sizeof(buffer)));
            block_copy(buffer, in_string.str, size);
            bar.string = SCu8(buffer, size);
        }
        else if (in.event.kind == InputEventKind_KeyStroke){



            leave_current_input_unhandled(app);
        }
    }
}



CUSTOM_COMMAND(string_repeat, "/home/sam/.bin/4coder/custom/4coder_examples.cpp", 179, Normal)
CUSTOM_DOC("Example of query_user_string and query_user_number")
{
    Query_Bar_Group group(app);
    Query_Bar string_bar = {};
    string_bar.prompt = SCu8("String: ");
    u8 string_buffer[((1) << 10)];
    string_bar.string.str = string_buffer;
    string_bar.string_capacity = sizeof(string_buffer);
    Query_Bar number_bar = {};
    number_bar.prompt = SCu8("Repeat Count: ");
    u8 number_buffer[((1) << 10)];
    number_bar.string.str = number_buffer;
    number_bar.string_capacity = sizeof(number_buffer);

    if (query_user_string(app, &string_bar)){
        if (string_bar.string.size > 0){
            if (query_user_number(app, &number_bar)){
                if (number_bar.string.size > 0){
                    i32 repeats = (i32)string_to_integer(number_bar.string, 10);
                    repeats = (((repeats)<(1000))?(repeats):(1000));
                    Scratch_Block scratch(app);
                    String_Const_u8 msg = push_stringf(scratch, "%.*s\n", (i32)(string_bar.string).size, (char*)(string_bar.string).str);
                    for (i32 i = 0; i < repeats; i += 1){
                        print_message(app, msg);
                    }
                }
            }
        }
    }
}


CUSTOM_COMMAND(test_the_new_api, "/home/sam/.bin/4coder/custom/4coder_examples.cpp", 212, Normal)
CUSTOM_DOC("If you are reading this I forgot to delete this test, please let me know")
{
    Query_Bar_Group group(app);
    Query_Bar bar = {};
    bar.prompt = SCu8("Testing ... ");
    if (!start_query_bar(app, &bar, 0)){
        return;
    }

    Input_Event events[10];
    i32 count = 0;

    User_Input in = {};

    for (;;) {
        in = get_next_input(app, EventProperty_AnyKey, 0);
        if (in.abort){
            return;
        }
  events[count] = in.event;
  count += 1;
  if (!event_is_dead_key(&in.event)) {
   break;
  }
    }

    u64 codepoints[10] = {};
    i32 index = 0;

    for (Input_Event event_text = event_next_text_event(&in.event);
   event_text.kind != InputEventKind_None;
         event_text = event_next_text_event(&event_text)){
        String_Const_u8 writable = to_writable(&event_text);
  if (writable.size) {
   codepoints[index] = utf8_consume(writable.str, writable.size).codepoint;
   index += 1;
  }
    }

    Scratch_Block scratch(app);
    for (i32 i = 0; i < count; i += 1){
        String_Const_u8 string = stringize_keyboard_event(scratch, &events[i]);
        print_message(app, string);
    }

    for (i32 i = 0; i < index; i += 1){
        String_Const_u8 string = push_u8_stringf(scratch, "%llu\n", codepoints[i]);
        print_message(app, string);
    }

}
# 131 "/home/sam/.bin/4coder/custom/4coder_default_include.cpp" 2

# 1 "/home/sam/.bin/4coder/custom/4coder_default_hooks.cpp" 1






CUSTOM_COMMAND(default_startup, "/home/sam/.bin/4coder/custom/4coder_default_hooks.cpp", 7, Normal)
CUSTOM_DOC("Default command for responding to a startup event") {
  Profile_Scope_Block profile_block_9 ((app), SCu8((u8*)("default startup"), (u64)(sizeof("default startup") - 1)), SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_default_hooks.cpp" ":" "9" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_default_hooks.cpp" ":" "9" ":") - 1)));
  User_Input input = get_current_input(app);
  if (match_core_code(&input, CoreCode_Startup)) {
    String_Const_u8_Array file_names = input.event.core.file_names;
    load_themes_default_folder(app);
    default_4coder_initialize(app, file_names);
    default_4coder_side_by_side_panels(app, file_names);
    if (global_config.automatically_load_project) {
      load_project(app);
    }
  }
}

CUSTOM_COMMAND(default_try_exit, "/home/sam/.bin/4coder/custom/4coder_default_hooks.cpp", 22, Normal)
CUSTOM_DOC("Default command for responding to a try-exit event") {
  User_Input input = get_current_input(app);
  if (match_core_code(&input, CoreCode_TryExit)) {
    b32 do_exit = true;
    if (!allow_immediate_close_without_checking_for_changes) {
      b32 has_unsaved_changes = false;
      for (Buffer_ID buffer = get_buffer_next(app, 0, Access_Always);
           buffer != 0; buffer = get_buffer_next(app, buffer, Access_Always)) {
        Dirty_State dirty = buffer_get_dirty_state(app, buffer);
        if ((((dirty)&(DirtyState_UnsavedChanges))!=0)) {
          has_unsaved_changes = true;
          break;
        }
      }
      if (has_unsaved_changes) {
        View_ID view = get_active_view(app, Access_Always);
        do_exit = do_4coder_close_user_check(app, view);
      }
    }
    if (do_exit) {
      hard_exit(app);
    }
  }
}

CUSTOM_COMMAND(default_view_input_handler, "/home/sam/.bin/4coder/custom/4coder_default_hooks.cpp", 48, Normal)
CUSTOM_DOC("Input consumption loop for default view behavior") {
  Scratch_Block scratch(app);
  default_input_handler_init(app, scratch);

  View_ID view = get_this_ctx_view(app, Access_Always);
  Managed_Scope scope = view_get_managed_scope(app, view);

  for (;;) {

    User_Input input = get_next_input(app, EventPropertyGroup_Any, 0);
    if (input.abort) {
      break;
    }

    Profile_Scope_Block view_input_profile ((app), SCu8((u8*)("before view input"), (u64)(sizeof("before view input") - 1)), SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_default_hooks.cpp" ":" "63" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_default_hooks.cpp" ":" "63" ":") - 1)));


    Event_Property event_properties = get_event_properties(&input.event);
    if (suppressing_mouse &&
        (event_properties & EventPropertyGroup_AnyMouseEvent) != 0) {
      continue;
    }


    Command_Map_ID map_id = default_get_map_id(app, view);


    Command_Binding binding =
        map_get_binding_recursive(&framework_mapping, map_id, &input.event);
    if (binding.custom == 0) {
      leave_current_input_unhandled(app);
      continue;
    }


    default_pre_command(app, scope);
    ((view_input_profile).close_now());
    binding.custom(app);
    Profile_Scope_Block profile_block_87 ((app), SCu8((u8*)("after view input"), (u64)(sizeof("after view input") - 1)), SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_default_hooks.cpp" ":" "87" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_default_hooks.cpp" ":" "87" ":") - 1)));
    default_post_command(app, scope);
  }
}

static void code_index_update_tick(Application_Links *app) {
  Scratch_Block scratch(app);
  for (Buffer_Modified_Node *node = global_buffer_modified_set.first; node != 0;
       node = node->next) {
    Temp_Memory_Block temp(scratch);
    Buffer_ID buffer_id = node->buffer;

    String_Const_u8 contents = push_whole_buffer(app, scratch, buffer_id);
    Token_Array tokens = get_token_array_from_buffer(app, buffer_id);
    if (tokens.count == 0) {
      continue;
    }

    Arena arena = make_arena_system(((16) << 10));
    Code_Index_File *index = ((Code_Index_File*)linalloc_wrap_zero(linalloc_push((&arena), sizeof(Code_Index_File)*(1), SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_default_hooks.cpp" ":" "106" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_default_hooks.cpp" ":" "106" ":") - 1)))));
    index->buffer = buffer_id;

    Generic_Parse_State state = {};
    generic_parse_init(app, &arena, contents, &tokens, &state);



    state.do_cpp_parse = true;
    generic_parse_full_input_breaks(index, &state, max_i32);

    code_index_lock();
    code_index_set_file(buffer_id, arena, index);
    code_index_unlock();
    buffer_clear_layout_cache(app, buffer_id);
  }

  buffer_modified_set_clear();
}

static void default_tick(Application_Links *app, Frame_Info frame_info) {
  code_index_update_tick(app);
  if (tick_all_fade_ranges(app, frame_info.animation_dt)) {
    animate_in_n_milliseconds(app, 0);
  }
}

static Rect_f32 default_buffer_region(Application_Links *app, View_ID view_id,
                                        Rect_f32 region) {
  Buffer_ID buffer = view_get_buffer(app, view_id, Access_Always);
  Face_ID face_id = get_face_id(app, buffer);
  Face_Metrics metrics = get_face_metrics(app, face_id);
  f32 line_height = metrics.line_height;
  f32 digit_advance = metrics.decimal_digit_advance;


  region = rect_inner(region, 3.f);


  b64 showing_file_bar = false;
  if (view_get_setting(app, view_id, ViewSetting_ShowFileBar,
                       &showing_file_bar) &&
      showing_file_bar) {
    Rect_f32_Pair pair = layout_file_bar_on_top(region, line_height);
    region = pair.max;
  }


  {
    Query_Bar *space[32];
    Query_Bar_Ptr_Array query_bars = {};
    query_bars.ptrs = space;
    if (get_active_query_bars(app, view_id, ((sizeof(space))/(sizeof(*space))), &query_bars)) {
      Rect_f32_Pair pair =
          layout_query_bar_on_top(region, line_height, query_bars.count);
      region = pair.max;
    }
  }


  if (show_fps_hud) {
    Rect_f32_Pair pair = layout_fps_hud_on_bottom(region, line_height);
    region = pair.min;
  }


  if (global_config.show_line_number_margins) {
    Rect_f32_Pair pair =
        layout_line_number_margin(app, buffer, region, digit_advance);
    region = pair.max;
  }

  return (region);
}

static void recursive_nest_highlight(Application_Links *app,
                                       Text_Layout_ID layout_id,
                                       Range_i64 range,
                                       Code_Index_Nest_Ptr_Array *array,
                                       i32 counter) {
  Code_Index_Nest **ptr = array->ptrs;
  Code_Index_Nest **ptr_end = ptr + array->count;

  for (; ptr < ptr_end; ptr += 1) {
    Code_Index_Nest *nest = *ptr;
    if (!nest->is_closed) {
      break;
    }
    if (range.first <= nest->close.max) {
      break;
    }
  }

  ARGB_Color argb = finalize_color(defcolor_text_cycle, counter);

  for (; ptr < ptr_end; ptr += 1) {
    Code_Index_Nest *nest = *ptr;
    if (range.max <= nest->open.min) {
      break;
    }

    paint_text_color(app, layout_id, nest->open, argb);
    if (nest->is_closed) {
      paint_text_color(app, layout_id, nest->close, argb);
    }
    recursive_nest_highlight(app, layout_id, range, &nest->nest_array,
                             counter + 1);
  }
}

static void recursive_nest_highlight(Application_Links *app,
                                       Text_Layout_ID layout_id,
                                       Range_i64 range, Code_Index_File *file) {
  recursive_nest_highlight(app, layout_id, range, &file->nest_array, 0);
}

static void default_render_buffer(Application_Links *app, View_ID view_id,
                                    Face_ID face_id, Buffer_ID buffer,
                                    Text_Layout_ID text_layout_id,
                                    Rect_f32 rect) {
  Profile_Scope_Block profile_block_226 ((app), SCu8((u8*)("render buffer"), (u64)(sizeof("render buffer") - 1)), SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_default_hooks.cpp" ":" "226" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_default_hooks.cpp" ":" "226" ":") - 1)));

  View_ID active_view = get_active_view(app, Access_Always);
  b32 is_active_view = (active_view == view_id);
  Rect_f32 prev_clip = draw_set_clip(app, rect);

  Range_i64 visible_range = text_layout_get_visible_range(app, text_layout_id);


  Face_Metrics metrics = get_face_metrics(app, face_id);
  f32 cursor_roundness =
      metrics.normal_advance * global_config.cursor_roundness;
  f32 mark_thickness = (f32)global_config.mark_thickness;


  Token_Array token_array = get_token_array_from_buffer(app, buffer);
  if (token_array.tokens != 0) {
    draw_cpp_token_colors(app, text_layout_id, &token_array);


    if (global_config.use_comment_keyword) {
      Comment_Highlight_Pair pairs[] = {
          {SCu8((u8*)("NOTE"), (u64)(sizeof("NOTE") - 1)), finalize_color(defcolor_comment_pop, 0)},
          {SCu8((u8*)("TODO"), (u64)(sizeof("TODO") - 1)), finalize_color(defcolor_comment_pop, 1)},
      };
      draw_comment_highlights(app, buffer, text_layout_id, &token_array, pairs,
                              ((sizeof(pairs))/(sizeof(*pairs))));
    }
  } else {
    paint_text_color_fcolor(app, text_layout_id, visible_range,
                            fcolor_id(defcolor_text_default));
  }

  i64 cursor_pos = view_correct_cursor(app, view_id);
  view_correct_mark(app, view_id);


  if (global_config.use_scope_highlight) {
    Color_Array colors = finalize_color_array(defcolor_back_cycle);
    draw_scope_highlight(app, buffer, text_layout_id, cursor_pos, colors.vals,
                         colors.count);
  }

  if (global_config.use_error_highlight || global_config.use_jump_highlight) {

    String_Const_u8 name = SCu8((u8*)("*compilation*"), (u64)(sizeof("*compilation*") - 1));
    Buffer_ID compilation_buffer = get_buffer_by_name(app, name, Access_Always);
    if (global_config.use_error_highlight) {
      draw_jump_highlights(app, buffer, text_layout_id, compilation_buffer,
                           fcolor_id(defcolor_highlight_junk));
    }


    if (global_config.use_jump_highlight) {
      Buffer_ID jump_buffer = get_locked_jump_buffer(app);
      if (jump_buffer != compilation_buffer) {
        draw_jump_highlights(app, buffer, text_layout_id, jump_buffer,
                             fcolor_id(defcolor_highlight_white));
      }
    }
  }


  if (global_config.use_paren_helper) {
    Color_Array colors = finalize_color_array(defcolor_text_cycle);
    draw_paren_highlight(app, buffer, text_layout_id, cursor_pos, colors.vals,
                         colors.count);
  }


  if (global_config.highlight_line_at_cursor && is_active_view) {
    i64 line_number = get_line_number_from_pos(app, buffer, cursor_pos);
    draw_line_highlight(app, text_layout_id, line_number,
                        fcolor_id(defcolor_highlight_cursor_line));
  }


  b64 show_whitespace = false;
  view_get_setting(app, view_id, ViewSetting_ShowWhitespace, &show_whitespace);
  if (show_whitespace) {
    if (token_array.tokens == 0) {
      draw_whitespace_highlight(app, buffer, text_layout_id, cursor_roundness);
    } else {
      draw_whitespace_highlight(app, text_layout_id, &token_array,
                                cursor_roundness);
    }
  }


  switch (fcoder_mode) {
  case FCoderMode_Original: {
    draw_original_4coder_style_cursor_mark_highlight(
        app, view_id, is_active_view, buffer, text_layout_id, cursor_roundness,
        mark_thickness);
  } break;
  case FCoderMode_NotepadLike: {
    draw_notepad_style_cursor_highlight(app, view_id, buffer, text_layout_id,
                                        cursor_roundness);
  } break;
  }


  paint_fade_ranges(app, text_layout_id, buffer);


  draw_text_layout_default(app, text_layout_id);

  draw_set_clip(app, prev_clip);
}

static Rect_f32 default_draw_query_bars(Application_Links *app,
                                          Rect_f32 region, View_ID view_id,
                                          Face_ID face_id) {
  Face_Metrics face_metrics = get_face_metrics(app, face_id);
  f32 line_height = face_metrics.line_height;

  Query_Bar *space[32];
  Query_Bar_Ptr_Array query_bars = {};
  query_bars.ptrs = space;
  if (get_active_query_bars(app, view_id, ((sizeof(space))/(sizeof(*space))), &query_bars)) {
    for (i32 i = 0; i < query_bars.count; i += 1) {
      Rect_f32_Pair pair = layout_query_bar_on_top(region, line_height, 1);
      draw_query_bar(app, query_bars.ptrs[i], face_id, pair.min);
      region = pair.max;
    }
  }
  return (region);
}

static void default_render_caller(Application_Links *app,
                                    Frame_Info frame_info, View_ID view_id) {
  Profile_Scope_Block profile_block_357 ((app), SCu8((u8*)("default render caller"), (u64)(sizeof("default render caller") - 1)), SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_default_hooks.cpp" ":" "357" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_default_hooks.cpp" ":" "357" ":") - 1)));
  View_ID active_view = get_active_view(app, Access_Always);
  b32 is_active_view = (active_view == view_id);

  Rect_f32 region = draw_background_and_margin(app, view_id, is_active_view);
  Rect_f32 prev_clip = draw_set_clip(app, region);

  Buffer_ID buffer = view_get_buffer(app, view_id, Access_Always);
  Face_ID face_id = get_face_id(app, buffer);
  Face_Metrics face_metrics = get_face_metrics(app, face_id);
  f32 line_height = face_metrics.line_height;
  f32 digit_advance = face_metrics.decimal_digit_advance;


  b64 showing_file_bar = false;
  if (view_get_setting(app, view_id, ViewSetting_ShowFileBar,
                       &showing_file_bar) &&
      showing_file_bar) {
    Rect_f32_Pair pair = layout_file_bar_on_top(region, line_height);
    draw_file_bar(app, view_id, buffer, face_id, pair.min);
    region = pair.max;
  }

  Buffer_Scroll scroll = view_get_buffer_scroll(app, view_id);

  Buffer_Point_Delta_Result delta =
      delta_apply(app, view_id, frame_info.animation_dt, scroll);
  if (!block_match((&scroll.position), (&delta.point), sizeof(*(&scroll.position)))) {
    block_copy((&scroll.position), (&delta.point), sizeof(*(&scroll.position)));
    view_set_buffer_scroll(app, view_id, scroll,
                           SetBufferScroll_NoCursorChange);
  }
  if (delta.still_animating) {
    animate_in_n_milliseconds(app, 0);
  }


  region = default_draw_query_bars(app, region, view_id, face_id);


  if (show_fps_hud) {
    Rect_f32_Pair pair = layout_fps_hud_on_bottom(region, line_height);
    draw_fps_hud(app, frame_info, face_id, pair.max);
    region = pair.min;
    animate_in_n_milliseconds(app, 1000);
  }


  Rect_f32 line_number_rect = {};
  if (global_config.show_line_number_margins) {
    Rect_f32_Pair pair =
        layout_line_number_margin(app, buffer, region, digit_advance);
    line_number_rect = pair.min;
    region = pair.max;
  }


  Buffer_Point buffer_point = scroll.position;
  Text_Layout_ID text_layout_id =
      text_layout_create(app, buffer, region, buffer_point);


  if (global_config.show_line_number_margins) {
    draw_line_number_margin(app, view_id, buffer, face_id, text_layout_id,
                            line_number_rect);
  }


  default_render_buffer(app, view_id, face_id, buffer, text_layout_id, region);

  text_layout_free(app, text_layout_id);
  draw_set_clip(app, prev_clip);
}

static void default_whole_screen_render_caller(Application_Links *app,
                                                 Frame_Info frame_info) {
# 452 "/home/sam/.bin/4coder/custom/4coder_default_hooks.cpp"
}

i32 default_view_adjust(Application_Links *app) {


  return (0);
}

void default_buffer_name_resolution(Application_Links *app, Buffer_Name_Conflict_Entry *conflicts, i32 conflict_count) {
  Profile_Scope_Block profile_block_461 ((app), SCu8((u8*)("default buffer name resolution"), (u64)(sizeof("default buffer name resolution") - 1)), SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_default_hooks.cpp" ":" "461" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_default_hooks.cpp" ":" "461" ":") - 1)));
  if (conflict_count > 1) {

    Scratch_Block scratch(app);

    i32 *unresolved = ((i32*)linalloc_wrap_unintialized(linalloc_push((scratch), sizeof(i32)*(conflict_count), SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_default_hooks.cpp" ":" "466" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_default_hooks.cpp" ":" "466" ":") - 1)))));
    i32 unresolved_count = conflict_count;
    for (i32 i = 0; i < conflict_count; ++i) {
      unresolved[i] = i;
    }


    i32 x = 0;
    for (;;) {

      ++x;
      for (i32 i = 0; i < unresolved_count; ++i) {
        i32 conflict_index = unresolved[i];
        Buffer_Name_Conflict_Entry *conflict = &conflicts[conflict_index];

        u64 size = conflict->base_name.size;
        size = (((size)<(conflict->unique_name_capacity))?(size):(conflict->unique_name_capacity));
        conflict->unique_name_len_in_out = size;
        block_copy(conflict->unique_name_in_out, conflict->base_name.str, size);

        if (conflict->file_name.str != 0) {
          Temp_Memory_Block temp(scratch);
          String_Const_u8 uniqueifier = {};

          String_Const_u8 file_name =
              string_remove_last_folder(conflict->file_name);
          if (file_name.size > 0) {
            file_name = string_chop(file_name, 1);
            u8 *end = file_name.str + file_name.size;
            b32 past_the_end = false;
            for (i32 j = 0; j < x; ++j) {
              file_name = string_remove_last_folder(file_name);
              if (j + 1 < x) {
                file_name = string_chop(file_name, 1);
              }
              if (file_name.size == 0) {
                if (j + 1 < x) {
                  past_the_end = true;
                }
                break;
              }
            }
            u8 *start = file_name.str + file_name.size;

            uniqueifier = SCu8(start, end);
            if (past_the_end) {
              uniqueifier = push_u8_stringf(scratch, "%.*s~%d",
                                            (i32)(uniqueifier).size, (char*)(uniqueifier).str, i);
            }
          } else {
            uniqueifier = push_u8_stringf(scratch, "%d", i);
          }

          String_u8 builder = Su8(conflict->unique_name_in_out,
                                  conflict->unique_name_len_in_out,
                                  conflict->unique_name_capacity);
          string_append(&builder, SCu8((u8*)(" <"), (u64)(sizeof(" <") - 1)));
          string_append(&builder, uniqueifier);
          string_append(&builder, SCu8((u8*)(">"), (u64)(sizeof(">") - 1)));
          conflict->unique_name_len_in_out = builder.size;
        }
      }


      b32 has_conflicts = false;
      for (i32 i = 0; i < unresolved_count; ++i) {
        i32 conflict_index = unresolved[i];
        Buffer_Name_Conflict_Entry *conflict = &conflicts[conflict_index];
        String_Const_u8 conflict_name = SCu8(conflict->unique_name_in_out,
                                             conflict->unique_name_len_in_out);

        b32 hit_conflict = false;
        if (conflict->file_name.str != 0) {
          for (i32 j = 0; j < unresolved_count; ++j) {
            if (i == j)
              continue;

            i32 conflict_j_index = unresolved[j];
            Buffer_Name_Conflict_Entry *conflict_j =
                &conflicts[conflict_j_index];

            String_Const_u8 conflict_name_j =
                SCu8(conflict_j->unique_name_in_out,
                     conflict_j->unique_name_len_in_out);

            if (string_match(conflict_name, conflict_name_j)) {
              hit_conflict = true;
              break;
            }
          }
        }

        if (hit_conflict) {
          has_conflicts = true;
        } else {
          --unresolved_count;
          unresolved[i] = unresolved[unresolved_count];
          --i;
        }
      }

      if (!has_conflicts) {
        break;
      }
    }
  }
}

static void parse_async__inner(Async_Context *actx, Buffer_ID buffer_id,
                                 String_Const_u8 contents, Token_Array *tokens,
                                 i32 limit_factor) {
  Application_Links *app = actx->app;
  Profile_Block profile_block_578 ((app), SCu8((u8*)("async parse"), (u64)(sizeof("async parse") - 1)), SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_default_hooks.cpp" ":" "578" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_default_hooks.cpp" ":" "578" ":") - 1)));

  Arena arena = make_arena_system(((16) << 10));
  Code_Index_File *index = ((Code_Index_File*)linalloc_wrap_zero(linalloc_push((&arena), sizeof(Code_Index_File)*(1), SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_default_hooks.cpp" ":" "581" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_default_hooks.cpp" ":" "581" ":") - 1)))));
  index->buffer = buffer_id;

  Generic_Parse_State state = {};
  generic_parse_init(app, &arena, contents, tokens, &state);

  b32 canceled = false;

  for (;;) {
    if (generic_parse_full_input_breaks(index, &state, limit_factor)) {
      break;
    }
    if (async_check_canceled(actx)) {
      canceled = true;
      break;
    }
  }

  if (!canceled) {
    acquire_global_frame_mutex(app);
    code_index_lock();
    code_index_set_file(buffer_id, arena, index);
    code_index_unlock();
    buffer_clear_layout_cache(app, buffer_id);
    release_global_frame_mutex(app);
  } else {
    linalloc_clear(&arena);
  }
}

static void do_full_lex_async__inner(Async_Context *actx,
                                       Buffer_ID buffer_id) {
  Application_Links *app = actx->app;
  Profile_Scope_Block profile_block_614 ((app), SCu8((u8*)("async lex"), (u64)(sizeof("async lex") - 1)), SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_default_hooks.cpp" ":" "614" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_default_hooks.cpp" ":" "614" ":") - 1)));
  Scratch_Block scratch(app);

  String_Const_u8 contents = {};
  {
    Profile_Block profile_block_619 ((app), SCu8((u8*)("async lex contents (before mutex)"), (u64)(sizeof("async lex contents (before mutex)") - 1)), SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_default_hooks.cpp" ":" "619" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_default_hooks.cpp" ":" "619" ":") - 1)));
    acquire_global_frame_mutex(app);
    Profile_Block profile_block_621 ((app), SCu8((u8*)("async lex contents (after mutex)"), (u64)(sizeof("async lex contents (after mutex)") - 1)), SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_default_hooks.cpp" ":" "621" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_default_hooks.cpp" ":" "621" ":") - 1)));
    contents = push_whole_buffer(app, scratch, buffer_id);
    release_global_frame_mutex(app);
  }

  i32 limit_factor = 10000;

  Token_List list = {};
  b32 canceled = false;

  Lex_State_Cpp state = {};
  lex_full_input_cpp_init(&state, contents);
  for (;;) {
    Profile_Block profile_block_634 ((app), SCu8((u8*)("async lex block"), (u64)(sizeof("async lex block") - 1)), SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_default_hooks.cpp" ":" "634" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_default_hooks.cpp" ":" "634" ":") - 1)));
    if (lex_full_input_cpp_breaks(scratch, &list, &state, limit_factor)) {
      break;
    }
    if (async_check_canceled(actx)) {
      canceled = true;
      break;
    }
  }

  if (!canceled) {
    Profile_Block profile_block_645 ((app), SCu8((u8*)("async lex save results (before mutex)"), (u64)(sizeof("async lex save results (before mutex)") - 1)), SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_default_hooks.cpp" ":" "645" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_default_hooks.cpp" ":" "645" ":") - 1)));
    acquire_global_frame_mutex(app);
    Profile_Block profile_block_647 ((app), SCu8((u8*)("async lex save results (after mutex)"), (u64)(sizeof("async lex save results (after mutex)") - 1)), SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_default_hooks.cpp" ":" "647" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_default_hooks.cpp" ":" "647" ":") - 1)));
    Managed_Scope scope = buffer_get_managed_scope(app, buffer_id);
    if (scope != 0) {
      Base_Allocator *allocator = managed_scope_allocator(app, scope);
      Token_Array *tokens_ptr =
          ((Token_Array*)managed_scope_get_attachment((app), (scope), (attachment_tokens), sizeof(Token_Array)));
      base_free(allocator, tokens_ptr->tokens);
      Token_Array tokens = {};
      tokens.tokens = (Token*)(base_allocate__inner((allocator), sizeof(Token)*(list.total_count), (SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_default_hooks.cpp" ":" "655" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_default_hooks.cpp" ":" "655" ":") - 1)))).data);
      tokens.count = list.total_count;
      tokens.max = list.total_count;
      token_fill_memory_from_list(tokens.tokens, &list);
      block_copy((tokens_ptr), (&tokens), sizeof(*(tokens_ptr)));
    }
    buffer_mark_as_modified(buffer_id);
    release_global_frame_mutex(app);
  }
}

static void do_full_lex_async(Async_Context *actx, Data data) {
  if (data.size == sizeof(Buffer_ID)) {
    Buffer_ID buffer = *(Buffer_ID *)data.data;
    do_full_lex_async__inner(actx, buffer);
  }
}

i32 default_begin_buffer(Application_Links *app, Buffer_ID buffer_id) {
  Profile_Scope_Block profile_block_674 ((app), SCu8((u8*)("begin buffer"), (u64)(sizeof("begin buffer") - 1)), SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_default_hooks.cpp" ":" "674" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_default_hooks.cpp" ":" "674" ":") - 1)));

  Scratch_Block scratch(app);

  b32 treat_as_code = false;
  String_Const_u8 file_name = push_buffer_file_name(app, scratch, buffer_id);
  if (file_name.size > 0) {
    String_Const_u8_Array extensions = global_config.code_exts;
    String_Const_u8 ext = string_file_extension(file_name);
    for (i32 i = 0; i < extensions.count; ++i) {
      if (string_match(ext, extensions.strings[i])) {

        if (string_match(ext, SCu8((u8*)("cpp"), (u64)(sizeof("cpp") - 1))) ||
            string_match(ext, SCu8((u8*)("h"), (u64)(sizeof("h") - 1))) ||
            string_match(ext, SCu8((u8*)("c"), (u64)(sizeof("c") - 1))) ||
            string_match(ext, SCu8((u8*)("hpp"), (u64)(sizeof("hpp") - 1))) ||
            string_match(ext, SCu8((u8*)("cc"), (u64)(sizeof("cc") - 1)))) {
          treat_as_code = true;
        }
# 746 "/home/sam/.bin/4coder/custom/4coder_default_hooks.cpp"
        break;
      }
    }
  }

  Command_Map_ID map_id = (treat_as_code) ? (mapid_code) : (mapid_file);
  Managed_Scope scope = buffer_get_managed_scope(app, buffer_id);
  Command_Map_ID *map_id_ptr =
      ((Command_Map_ID*)managed_scope_get_attachment((app), (scope), (buffer_map_id), sizeof(Command_Map_ID)));
  *map_id_ptr = map_id;

  Line_Ending_Kind setting = guess_line_ending_kind_from_buffer(app, buffer_id);
  Line_Ending_Kind *eol_setting =
      ((Line_Ending_Kind*)managed_scope_get_attachment((app), (scope), (buffer_eol_setting), sizeof(Line_Ending_Kind)));
  *eol_setting = setting;


  b32 wrap_lines = true;
  b32 use_lexer = false;
  if (treat_as_code) {
    wrap_lines = global_config.enable_code_wrapping;
    use_lexer = true;
  }

  String_Const_u8 buffer_name = push_buffer_base_name(app, scratch, buffer_id);
  if (buffer_name.size > 0 && buffer_name.str[0] == '*' &&
      buffer_name.str[buffer_name.size - 1] == '*') {
    wrap_lines = global_config.enable_output_wrapping;
  }

  if (use_lexer) {
    Profile_Block profile_block_777 ((app), SCu8((u8*)("begin buffer kick off lexer"), (u64)(sizeof("begin buffer kick off lexer") - 1)), SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_default_hooks.cpp" ":" "777" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_default_hooks.cpp" ":" "777" ":") - 1)));
    Async_Task *lex_task_ptr =
        ((Async_Task*)managed_scope_get_attachment((app), (scope), (buffer_lex_task), sizeof(Async_Task)));
    *lex_task_ptr = async_task_no_dep(&global_async_system, do_full_lex_async,
                                      make_data((&buffer_id), sizeof(*(&buffer_id))));
  }

  {
    b32 *wrap_lines_ptr = ((b32*)managed_scope_get_attachment((app), (scope), (buffer_wrap_lines), sizeof(b32)));
    *wrap_lines_ptr = wrap_lines;
  }

  if (use_lexer) {
    buffer_set_layout(app, buffer_id, layout_virt_indent_index_generic);
  } else {
    if (treat_as_code) {
      buffer_set_layout(app, buffer_id, layout_virt_indent_literal_generic);
    } else {
      buffer_set_layout(app, buffer_id, layout_generic);
    }
  }


  return (0);
}

i32 default_new_file(Application_Links *app, Buffer_ID buffer_id) {
  Scratch_Block scratch(app);
  String_Const_u8 file_name = push_buffer_base_name(app, scratch, buffer_id);
  if (!string_match(string_postfix(file_name, 2), SCu8((u8*)(".h"), (u64)(sizeof(".h") - 1)))) {
    return (0);
  }

  List_String_Const_u8 guard_list = {};
  for (u64 i = 0; i < file_name.size; ++i) {
    u8 c[2] = {};
    u64 c_size = 1;
    u8 ch = file_name.str[i];
    if ('A' <= ch && ch <= 'Z') {
      c_size = 2;
      c[0] = '_';
      c[1] = ch;
    } else if ('0' <= ch && ch <= '9') {
      c[0] = ch;
    } else if ('a' <= ch && ch <= 'z') {
      c[0] = ch - ('a' - 'A');
    } else {
      c[0] = '_';
    }
    String_Const_u8 part = push_string_copy(scratch, SCu8(c, c_size));
    string_list_push(scratch, &guard_list, part);
  }
  String_Const_u8 guard = string_list_flatten(scratch, guard_list);

  Date_Time date_time = system_now_date_time_universal();
  date_time = system_local_date_time_from_universal(&date_time);
  String_Const_u8 date_string =
      date_time_format(scratch, "month day yyyy h:mimi ampm", &date_time);

  Buffer_Insertion insert =
      begin_buffer_insertion_at_buffered(app, buffer_id, 0, scratch, ((16) << 10));
  insertf(&insert,
          "/* date = %.*s */\n"
          "\n",
          (i32)(date_string).size, (char*)(date_string).str);
  insertf(&insert,
          "#ifndef %.*s\n"
          "#define %.*s\n"
          "\n"
          "#endif //%.*s\n",
          (i32)(guard).size, (char*)(guard).str, (i32)(guard).size, (char*)(guard).str, (i32)(guard).size, (char*)(guard).str);
  end_buffer_insertion(&insert);

  return (0);
}

i32 default_file_save(Application_Links *app, Buffer_ID buffer_id) {

  Profile_Scope_Block profile_block_855 ((app), SCu8((u8*)("default file save"), (u64)(sizeof("default file save") - 1)), SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_default_hooks.cpp" ":" "855" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_default_hooks.cpp" ":" "855" ":") - 1)));

  b32 is_virtual = global_config.enable_virtual_whitespace;
  if (global_config.automatically_indent_text_on_save && is_virtual) {
    auto_indent_buffer(app, buffer_id, buffer_range(app, buffer_id));
  }

  Managed_Scope scope = buffer_get_managed_scope(app, buffer_id);
  Line_Ending_Kind *eol =
      ((Line_Ending_Kind*)managed_scope_get_attachment((app), (scope), (buffer_eol_setting), sizeof(Line_Ending_Kind)));
  switch (*eol) {
  case LineEndingKind_LF: {
    rewrite_lines_to_lf(app, buffer_id);
  } break;
  case LineEndingKind_CRLF: {
    rewrite_lines_to_crlf(app, buffer_id);
  } break;
  }


  return (0);
}

i32 default_buffer_edit_range(Application_Links *app, Buffer_ID buffer_id, Range_i64 new_range, Range_Cursor old_cursor_range) {

  Profile_Scope_Block profile_block_880 ((app), SCu8((u8*)("default edit range"), (u64)(sizeof("default edit range") - 1)), SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_default_hooks.cpp" ":" "880" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_default_hooks.cpp" ":" "880" ":") - 1)));

  Range_i64 old_range =
      Ii64(old_cursor_range.min.pos, old_cursor_range.max.pos);

  buffer_shift_fade_ranges(buffer_id, old_range.max,
                           (new_range.max - old_range.max));

  {
    code_index_lock();
    Code_Index_File *file = code_index_get_file(buffer_id);
    if (file != 0) {
      code_index_shift(file, old_range, range_size(new_range));
    }
    code_index_unlock();
  }

  i64 insert_size = range_size(new_range);
  i64 text_shift = replace_range_shift(old_range, insert_size);

  Scratch_Block scratch(app);

  Managed_Scope scope = buffer_get_managed_scope(app, buffer_id);
  Async_Task *lex_task_ptr =
      ((Async_Task*)managed_scope_get_attachment((app), (scope), (buffer_lex_task), sizeof(Async_Task)));

  Base_Allocator *allocator = managed_scope_allocator(app, scope);
  b32 do_full_relex = false;

  if (async_task_is_running_or_pending(&global_async_system, *lex_task_ptr)) {
    async_task_cancel(app, &global_async_system, *lex_task_ptr);
    buffer_unmark_as_modified(buffer_id);
    do_full_relex = true;
    *lex_task_ptr = 0;
  }

  Token_Array *ptr =
      ((Token_Array*)managed_scope_get_attachment((app), (scope), (attachment_tokens), sizeof(Token_Array)));
  if (ptr != 0 && ptr->tokens != 0) {
    Profile_Block profile_attempt_resync ((app), SCu8((u8*)("attempt resync"), (u64)(sizeof("attempt resync") - 1)), SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_default_hooks.cpp" ":" "919" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_default_hooks.cpp" ":" "919" ":") - 1)));

    i64 token_index_first = token_relex_first(ptr, old_range.first, 1);
    i64 token_index_resync_guess =
        token_relex_resync(ptr, old_range.one_past_last, 16);

    if (token_index_resync_guess - token_index_first >= 4000) {
      do_full_relex = true;
    } else {
      Token *token_first = ptr->tokens + token_index_first;
      Token *token_resync = ptr->tokens + token_index_resync_guess;

      Range_i64 relex_range =
          Ii64(token_first->pos,
               token_resync->pos + token_resync->size + text_shift);
      String_Const_u8 partial_text =
          push_buffer_range(app, scratch, buffer_id, relex_range);

      Token_List relex_list = lex_full_input_cpp(scratch, partial_text);
      if (relex_range.one_past_last < buffer_get_size(app, buffer_id)) {
        token_drop_eof(&relex_list);
      }

      Token_Relex relex =
          token_relex(relex_list, relex_range.first - text_shift, ptr->tokens,
                      token_index_first, token_index_resync_guess);

      ((profile_attempt_resync).close_now());

      if (!relex.successful_resync) {
        do_full_relex = true;
      } else {
        Profile_Block profile_block_951 ((app), SCu8((u8*)("apply resync"), (u64)(sizeof("apply resync") - 1)), SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_default_hooks.cpp" ":" "951" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_default_hooks.cpp" ":" "951" ":") - 1)));

        i64 token_index_resync = relex.first_resync_index;

        Range_i64 head = Ii64(0, token_index_first);
        Range_i64 replaced = Ii64(token_index_first, token_index_resync);
        Range_i64 tail = Ii64(token_index_resync, ptr->count);
        i64 resynced_count =
            (token_index_resync_guess + 1) - token_index_resync;
        i64 relexed_count = relex_list.total_count - resynced_count;
        i64 tail_shift =
            relexed_count - (token_index_resync - token_index_first);

        i64 new_tokens_count = ptr->count + tail_shift;
        Token *new_tokens = (Token*)(base_allocate__inner((allocator), sizeof(Token)*(new_tokens_count), (SCu8((u8*)("/home/sam/.bin/4coder/custom/4coder_default_hooks.cpp" ":" "965" ":"), (u64)(sizeof("/home/sam/.bin/4coder/custom/4coder_default_hooks.cpp" ":" "965" ":") - 1)))).data);

        Token *old_tokens = ptr->tokens;
        block_copy_array_shift__inner((new_tokens),(old_tokens),sizeof(*(new_tokens)),(head),(0));
        token_fill_memory_from_list(new_tokens + replaced.first, &relex_list,
                                    relexed_count);
        for (i64 i = 0, index = replaced.first; i < relexed_count;
             i += 1, index += 1) {
          new_tokens[index].pos += relex_range.first;
        }
        for (i64 i = tail.first; i < tail.one_past_last; i += 1) {
          old_tokens[i].pos += text_shift;
        }
        block_copy_array_shift__inner((new_tokens),(ptr->tokens),sizeof(*(new_tokens)),(tail),(tail_shift));

        base_free(allocator, ptr->tokens);

        ptr->tokens = new_tokens;
        ptr->count = new_tokens_count;
        ptr->max = new_tokens_count;

        buffer_mark_as_modified(buffer_id);
      }
    }
  }

  if (do_full_relex) {
    *lex_task_ptr = async_task_no_dep(&global_async_system, do_full_lex_async,
                                      make_data((&buffer_id), sizeof(*(&buffer_id))));
  }


  return (0);
}

i32 default_end_buffer(Application_Links *app, Buffer_ID buffer_id) {
  Managed_Scope scope = buffer_get_managed_scope(app, buffer_id);
  Async_Task *lex_task_ptr =
      ((Async_Task*)managed_scope_get_attachment((app), (scope), (buffer_lex_task), sizeof(Async_Task)));
  if (lex_task_ptr != 0) {
    async_task_cancel(app, &global_async_system, *lex_task_ptr);
  }
  buffer_unmark_as_modified(buffer_id);
  code_index_lock();
  code_index_erase_file(buffer_id);
  code_index_unlock();

  return (0);
}

static void default_view_change_buffer(Application_Links *app,
                                         View_ID view_id,
                                         Buffer_ID old_buffer_id,
                                         Buffer_ID new_buffer_id) {
  Managed_Scope scope = view_get_managed_scope(app, view_id);
  Buffer_ID *prev_buffer_id =
      ((Buffer_ID*)managed_scope_get_attachment((app), (scope), (view_previous_buffer), sizeof(Buffer_ID)));
  if (prev_buffer_id != 0) {
    *prev_buffer_id = old_buffer_id;
  }
}

static void set_all_default_hooks(Application_Links *app) {
  set_custom_hook((app),(HookID_BufferViewerUpdate),(Void_Func*)(default_view_adjust));

  set_custom_hook((app),(HookID_ViewEventHandler),(Void_Func*)(default_view_input_handler));
  set_custom_hook((app),(HookID_Tick),(Void_Func*)(default_tick));

  set_custom_hook((app),(HookID_WholeScreenRenderCaller),(Void_Func*)(default_whole_screen_render_caller))
                                                     ;

  set_custom_hook((app),(HookID_DeltaRule),(Void_Func*)(fixed_time_cubic_delta));
  set_custom_hook_memory_size(
      app, HookID_DeltaRule,
      delta_ctx_size(fixed_time_cubic_delta_memory_size));

  set_custom_hook((app),(HookID_BufferNameResolver),(Void_Func*)(default_buffer_name_resolution))
                                                 ;

  set_custom_hook((app),(HookID_BeginBuffer),(Void_Func*)(default_begin_buffer));
  set_custom_hook((app),(HookID_EndBuffer),(Void_Func*)(end_buffer_close_jump_list));
  set_custom_hook((app),(HookID_NewFile),(Void_Func*)(default_new_file));
  set_custom_hook((app),(HookID_SaveFile),(Void_Func*)(default_file_save));
  set_custom_hook((app),(HookID_BufferEditRange),(Void_Func*)(default_buffer_edit_range));
  set_custom_hook((app),(HookID_BufferRegion),(Void_Func*)(default_buffer_region));
  set_custom_hook((app),(HookID_ViewChangeBuffer),(Void_Func*)(default_view_change_buffer));

  set_custom_hook((app),(HookID_Layout),(Void_Func*)(layout_unwrapped));




}
# 133 "/home/sam/.bin/4coder/custom/4coder_default_include.cpp" 2
# 10 "4coder_sam.cpp" 2

# 1 "lib/external/4coder-clearfeld/packages/relative_line_number_mode/relative_line_number_mode.cpp" 1
static b32 use_relative_line_number_mode = false;

static void
draw_relative_line_number_margin(Application_Links *app, View_ID view_id, Buffer_ID buffer, Face_ID face_id, Text_Layout_ID text_layout_id, Rect_f32 margin)
{
    Profile_Scope_Block profile_block_6 ((app), SCu8((u8*)("clearfeld - draw relative line number margin"), (u64)(sizeof("clearfeld - draw relative line number margin") - 1)), SCu8((u8*)("lib/external/4coder-clearfeld/packages/relative_line_number_mode/relative_line_number_mode.cpp" ":" "6" ":"), (u64)(sizeof("lib/external/4coder-clearfeld/packages/relative_line_number_mode/relative_line_number_mode.cpp" ":" "6" ":") - 1)));

    Scratch_Block scratch(app);
    FColor line_color = fcolor_id(defcolor_line_numbers_text);

    Rect_f32 prev_clip = draw_set_clip(app, margin);
    draw_rectangle_fcolor(app, margin, 0.f, fcolor_id(defcolor_line_numbers_back));

    Range_i64 visible_range = text_layout_get_visible_range(app, text_layout_id);
    i64 line_count = buffer_get_line_count(app, buffer);
    i64 line_count_digit_count = digit_count_from_integer(line_count, 10);

    Buffer_Cursor cursor_top = view_compute_cursor(app, view_id, seek_pos(visible_range.min));
    i64 top_line = cursor_top.line;

    FColor current_line_color = fcolor_id(defcolor_cursor);

    i64 cursor_line = view_get_cursor_pos(app, view_id);
    Buffer_Cursor cursor_current_line = view_compute_cursor(app, view_id, seek_pos(cursor_line));
    cursor_line = cursor_current_line.line;

    Buffer_Cursor cursor = view_compute_cursor(app, view_id, seek_pos(visible_range.first));
    i64 line_number = cursor.line;

    i64 below_count = cursor_line - top_line;
    i64 above_count = 1;

    Buffer_Cursor cursor_opl = view_compute_cursor(app, view_id, seek_pos(visible_range.one_past_last));
    i64 one_past_last_line_number = cursor_opl.line + 1;

    for (;line_number < one_past_last_line_number &&
          line_number < line_count;)
    {
        Range_f32 line_y = text_layout_line_on_screen(app, text_layout_id, line_number);
        Vec2_f32 p = V2f32(margin.x0, line_y.min);
        Temp_Memory_Block temp(scratch);
# 50 "lib/external/4coder-clearfeld/packages/relative_line_number_mode/relative_line_number_mode.cpp"
        Fancy_String *string;
        if(line_number < cursor_line) {
            string = push_fancy_stringf(scratch, 0, line_color, "%*lld",
                                        line_count_digit_count, below_count);
            --below_count;
        } else if(line_number > cursor_line) {
            string = push_fancy_stringf(scratch, 0, line_color, "%*lld",
                                        line_count_digit_count, above_count);
            ++above_count;
        } else {
   string = push_fancy_stringf(scratch, 0, current_line_color, "%*lld",
                                        line_count_digit_count, line_number);
        }

        draw_fancy_string(app, face_id, fcolor_zero(), string, p);
        line_number += 1;
    }

    draw_set_clip(app, prev_clip);
}

CUSTOM_COMMAND(toggle_relative_line_number_mode, "lib/external/4coder-clearfeld/packages/relative_line_number_mode/relative_line_number_mode.cpp", 71, Normal)
CUSTOM_DOC("Toggle relative line numbers.")
{
    use_relative_line_number_mode = !use_relative_line_number_mode;
    if(use_relative_line_number_mode) {
        log_string(app, SCu8((u8*)("Toggle: relative_line_number_mode - on\n"), (u64)(sizeof("Toggle: relative_line_number_mode - on\n") - 1)));
    } else {
        log_string(app, SCu8((u8*)("Toggle: relative_line_number_mode - off\n"), (u64)(sizeof("Toggle: relative_line_number_mode - off\n") - 1)));
    }
}
# 12 "4coder_sam.cpp" 2

# 1 "lib/external/4coder-vimmish/4coder_vimmish.cpp" 1
# 63 "lib/external/4coder-vimmish/4coder_vimmish.cpp"
# 1 "lib/external/4coder-vimmish/clearfeld_windmove.cpp" 1
enum windmove_directions {
    windmove_up,
    windmove_left,
    windmove_down,
    windmove_right
};

void
windmove_to_panel(Application_Links* app, u8 direction, b32 swap_on_move)
{
    View_ID view_id = get_active_view(app, Access_Always);
    Buffer_ID cur_buffer = view_get_buffer(app, view_id, Access_Always);

    Panel_ID original_panel = view_get_panel(app, view_id);
    Rect_f32 original_rect = view_get_screen_rect(app, view_id);

    Panel_ID current_panel = original_panel;

    Side preferred_side = (direction == windmove_up || direction == windmove_left ? Side_Min : Side_Max);
    b32 should_move_horizontal = (direction == windmove_left || direction == windmove_right);

    Panel_ID move_top_node = 0;
    if(panel_get_parent(app, original_panel) != 0) {
        while(move_top_node == 0) {
            Panel_ID parent = panel_get_parent(app, current_panel);
            if(!parent) {
                break;
            }

            Panel_ID min_panel = panel_get_child(app, parent, Side_Min);
            Panel_ID max_panel = panel_get_child(app, parent, Side_Max);

            b32 is_on_wrong_side_of_split = ((current_panel == min_panel && preferred_side == Side_Min) ||
                                             (current_panel == max_panel && preferred_side == Side_Max));

            b32 is_wrong_split = false;

            if(!is_on_wrong_side_of_split) {
                Panel_ID min_search = min_panel;
                while(!panel_is_leaf(app, min_search)) {
                    min_search = panel_get_child(app, min_search, Side_Min);
                }

                Panel_ID max_search = max_panel;
                while(!panel_is_leaf(app, max_search)) {
                    max_search = panel_get_child(app, max_search, Side_Min);
                }

                View_ID min_search_view_id = panel_get_view(app, min_search, Access_Always);
                View_ID max_search_view_id = panel_get_view(app, max_search, Access_Always);

                Rect_f32 min_origin_rect = view_get_screen_rect(app, min_search_view_id);
                Rect_f32 max_origin_rect = view_get_screen_rect(app, max_search_view_id);

                b32 is_vertical = (min_origin_rect.x0 != max_origin_rect.x0 && min_origin_rect.y0 == max_origin_rect.y0);
                b32 is_horizontal = (min_origin_rect.y0 != max_origin_rect.y0 && min_origin_rect.x0 == max_origin_rect.x0);

                if(should_move_horizontal && is_horizontal || !should_move_horizontal && is_vertical) {
                    is_wrong_split = true;
                }
            }

            if(is_on_wrong_side_of_split || is_wrong_split) {
                current_panel = parent;
            } else {
                move_top_node = parent;
            }
        }
    }

    if(move_top_node != 0) {
        current_panel = panel_get_child(app, move_top_node, preferred_side);

        while(!panel_is_leaf(app, current_panel)) {
            Panel_ID min_panel = panel_get_child(app, current_panel, Side_Min);
            Panel_ID max_panel = panel_get_child(app, current_panel, Side_Max);

            Panel_ID min_search = min_panel;
            while(!panel_is_leaf(app, min_search)) {
                min_search = panel_get_child(app, min_search, Side_Min);
            }

            Panel_ID max_search = max_panel;
            while(!panel_is_leaf(app, max_search)) {
                max_search = panel_get_child(app, max_search, Side_Min);
            }

            Rect_f32 min_origin_rect = view_get_screen_rect(app, panel_get_view(app, min_search, Access_Always));
            Rect_f32 max_origin_rect = view_get_screen_rect(app, panel_get_view(app, max_search, Access_Always));

            b32 is_vertical = (min_origin_rect.x0 != max_origin_rect.x0 && min_origin_rect.y0 == max_origin_rect.y0);
            b32 is_horizontal = (min_origin_rect.y0 != max_origin_rect.y0 && min_origin_rect.x0 == max_origin_rect.x0);

            if(!should_move_horizontal && is_horizontal || should_move_horizontal && is_vertical) {
                if(preferred_side == Side_Min) {
                    current_panel = max_panel;
                } else {
                    current_panel = min_panel;
                }
            } else {
                f32 dist_from_min = 0;
                f32 dist_from_max = 0;

                if(should_move_horizontal) {
                    dist_from_min = original_rect.y0 - min_origin_rect.y0;
                    dist_from_max = original_rect.y0 - max_origin_rect.y0;
                } else {
                    dist_from_min = original_rect.x0 - min_origin_rect.x0;
                    dist_from_max = original_rect.x0 - max_origin_rect.x0;
                }

                if(dist_from_max < 0 || dist_from_min < dist_from_max) {
                    current_panel = min_panel;
                } else {
                    current_panel = max_panel;
                }
            }
        }

        View_ID target_view = panel_get_view(app, current_panel, Access_Always);
        view_set_active(app, target_view);

        if(swap_on_move) {
            Buffer_ID target_buffer = view_get_buffer(app, target_view, Access_Always);
            view_set_buffer(app, target_view, cur_buffer, Access_Always);
            view_set_buffer(app, view_id, target_buffer, Access_Always);
        }
    }
}

CUSTOM_COMMAND(windmove_panel_up, "lib/external/4coder-vimmish/clearfeld_windmove.cpp", 131, Normal)
CUSTOM_DOC("Move up from the active view.")
{
    windmove_to_panel(app, windmove_up, false);
}

CUSTOM_COMMAND(windmove_panel_down, "lib/external/4coder-vimmish/clearfeld_windmove.cpp", 137, Normal)
CUSTOM_DOC("Move down from the active view.")
{
    windmove_to_panel(app, windmove_down, false);
}

CUSTOM_COMMAND(windmove_panel_left, "lib/external/4coder-vimmish/clearfeld_windmove.cpp", 143, Normal)
CUSTOM_DOC("Move left from the active view.")
{
    windmove_to_panel(app, windmove_left, false);
}

CUSTOM_COMMAND(windmove_panel_right, "lib/external/4coder-vimmish/clearfeld_windmove.cpp", 149, Normal)
CUSTOM_DOC("Move right from the active view.")
{
    windmove_to_panel(app, windmove_right, false);
}

CUSTOM_COMMAND(windmove_panel_swap_up, "lib/external/4coder-vimmish/clearfeld_windmove.cpp", 155, Normal)
CUSTOM_DOC("Swap buffer up from the active view.")
{
    windmove_to_panel(app, windmove_up, true);
}

CUSTOM_COMMAND(windmove_panel_swap_down, "lib/external/4coder-vimmish/clearfeld_windmove.cpp", 161, Normal)
CUSTOM_DOC("Swap buffer down from the active view.")
{
    windmove_to_panel(app, windmove_down, true);
}

CUSTOM_COMMAND(windmove_panel_swap_left, "lib/external/4coder-vimmish/clearfeld_windmove.cpp", 167, Normal)
CUSTOM_DOC("Swap buffer left from the active view.")
{
    windmove_to_panel(app, windmove_left, true);
}

CUSTOM_COMMAND(windmove_panel_swap_right, "lib/external/4coder-vimmish/clearfeld_windmove.cpp", 173, Normal)
CUSTOM_DOC("Swap buffer right from the active view.")
{
    windmove_to_panel(app, windmove_right, true);
}
# 64 "lib/external/4coder-vimmish/4coder_vimmish.cpp" 2
# 185 "lib/external/4coder-vimmish/4coder_vimmish.cpp"
CUSTOM_ID(command_map, vim_mapid_normal);
CUSTOM_ID(command_map, vim_mapid_visual);
CUSTOM_ID(attachment, vim_view_attachment);
CUSTOM_ID(attachment, vim_buffer_insert_map_id);





CUSTOM_ID(colors, defcolor_vim_bar_normal);
CUSTOM_ID(colors, defcolor_vim_bar_insert);
CUSTOM_ID(colors, defcolor_vim_bar_visual);
CUSTOM_ID(colors, defcolor_vim_bar_recording_macro);
CUSTOM_ID(colors, defcolor_vim_cursor_normal);
CUSTOM_ID(colors, defcolor_vim_cursor_insert);
CUSTOM_ID(colors, defcolor_vim_cursor_visual);
CUSTOM_ID(colors, defcolor_vim_character_highlight);





typedef Table_u64_u64 Vim_Binding_Map;
static Vim_Binding_Map vim_map_normal;
static Vim_Binding_Map vim_map_visual;
static Vim_Binding_Map vim_map_text_objects;
static Vim_Binding_Map vim_map_operator_pending;





static b32
vim_character_is_newline(char c) {
    return c == '\r' || c == '\n';
}

static void
printf_message(Application_Links* app, char* fmt, ...) {
    Scratch_Block scratch(app);
    va_list args;
    
# 226 "lib/external/4coder-vimmish/4coder_vimmish.cpp" 3 4
   __builtin_va_start(
# 226 "lib/external/4coder-vimmish/4coder_vimmish.cpp"
   args
# 226 "lib/external/4coder-vimmish/4coder_vimmish.cpp" 3 4
   ,
# 226 "lib/external/4coder-vimmish/4coder_vimmish.cpp"
   fmt
# 226 "lib/external/4coder-vimmish/4coder_vimmish.cpp" 3 4
   )
# 226 "lib/external/4coder-vimmish/4coder_vimmish.cpp"
                      ;
    print_message(app, push_stringfv(scratch, fmt, args));
    
# 228 "lib/external/4coder-vimmish/4coder_vimmish.cpp" 3 4
   __builtin_va_end(
# 228 "lib/external/4coder-vimmish/4coder_vimmish.cpp"
   args
# 228 "lib/external/4coder-vimmish/4coder_vimmish.cpp" 3 4
   )
# 228 "lib/external/4coder-vimmish/4coder_vimmish.cpp"
               ;
}

enum Vim_DynString_Mode {
    VimDynString_Compact,
    VimDynString_Generous,
};

static void
vim_string_copy_dynamic(Base_Allocator* alloc,
                        String_u8* dest,
                        String_Const_u8 source,
                        Vim_DynString_Mode mode = VimDynString_Compact)
{
    u64 new_cap = 0;

    if (dest->cap < source.size) {
        if (mode == VimDynString_Generous) {
            new_cap = 2*source.size;
        } else {
            do{ if (!(mode == VimDynString_Compact)) { (*((i32*)0) = 0xA11E); } }while(0);
            new_cap = source.size;
        }
    }

    if (new_cap) {
        new_cap = (((256)>(new_cap))?(256):(new_cap));
        if (new_cap != dest->cap) {
            if (dest->str) {
                base_free(alloc, dest->str);
            }

            Data memory = base_allocate__inner((alloc), (new_cap), SCu8((u8*)("lib/external/4coder-vimmish/4coder_vimmish.cpp" ":" "260" ":"), (u64)(sizeof("lib/external/4coder-vimmish/4coder_vimmish.cpp" ":" "260" ":") - 1)));
            dest->str = (u8*)memory.data;
            dest->cap = memory.size;
        }
    }

    do{ if (!(dest->cap >= source.size)) { (*((i32*)0) = 0xA11E); } }while(0);

    dest->size = source.size;
    block_copy(dest->str, source.str, source.size);
}

static String_Const_u8
vim_string_append_dynamic(Base_Allocator* alloc,
                          String_u8* dest,
                          String_Const_u8 source,
                          Vim_DynString_Mode mode = VimDynString_Compact)
{
    u64 result_size = dest->size + source.size;

    u64 new_cap = 0;

    if (dest->cap < source.size) {
        if (mode == VimDynString_Generous) {
            new_cap = 2*source.size;
        } else {
            do{ if (!(mode == VimDynString_Compact)) { (*((i32*)0) = 0xA11E); } }while(0);
            new_cap = source.size;
        }
    }

    if (new_cap) {
        new_cap = (((256)>(new_cap))?(256):(new_cap));

        if (new_cap != dest->cap) {
            Data memory = base_allocate__inner((alloc), (new_cap), SCu8((u8*)("lib/external/4coder-vimmish/4coder_vimmish.cpp" ":" "295" ":"), (u64)(sizeof("lib/external/4coder-vimmish/4coder_vimmish.cpp" ":" "295" ":") - 1)));

            if (dest->str) {
                block_copy(memory.data, dest->str, dest->size);
                base_free(alloc, dest->str);
            }

            dest->str = (u8*)memory.data;
            dest->cap = memory.size;
        }
    }

    do{ if (!(dest->cap >= result_size)) { (*((i32*)0) = 0xA11E); } }while(0);

    u8* append_dest = dest->str + dest->size;

    dest->size = result_size;
    block_copy(append_dest, source.str, source.size);

    String_Const_u8 result = SCu8(append_dest, source.size);
    return result;
}

static void
vim_string_free(Base_Allocator* alloc, String_u8* string) {
    if (string->str) {
        base_free(alloc, string->str);
    }
    block_zero((string), sizeof(*(string)));
}

static String_Const_u8
vim_push_string_buffer(u32 buffer_size, u32* buffer_used, u8* buffer, String_Const_u8 str) {
    String_Const_u8 result = SCu8();
    do{ if (!(*buffer_used <= buffer_size)) { (*((i32*)0) = 0xA11E); } }while(0);
    u32 size_left = (buffer_size - *buffer_used);
    if (size_left) {
        u32 push_size = (((size_left)<((u32)str.size))?(size_left):((u32)str.size));
        u8* push_location = buffer + *buffer_used;
        block_copy(push_location, str.str, push_size);
        result = SCu8(push_location, push_size);
        *buffer_used += push_size;
    }
    return result;
}

enum Vim_Mode {
    VimMode_Normal,
    VimMode_Insert,
    VimMode_VisualInsert,
    VimMode_Visual,
    VimMode_VisualLine,
    VimMode_VisualBlock,
};

static b32
is_vim_insert_mode(Vim_Mode mode) {
    b32 result = ((mode == VimMode_Insert) ||
                  (mode == VimMode_VisualInsert));
    return result;
}

static b32 is_vim_visual_mode(Vim_Mode mode) {
    b32 result = ((mode == VimMode_Visual) ||
                  (mode == VimMode_VisualLine) ||
                  (mode == VimMode_VisualBlock));
    return result;
}

enum Vim_Selection_Kind {
    VimSelectionKind_None = 0,

    VimSelectionKind_Range,
    VimSelectionKind_Line,
    VimSelectionKind_Block,
};

struct Vim_Visual_Selection {
    Vim_Selection_Kind kind;
    i64 first_line, one_past_last_line;
    i64 first_col, one_past_last_col;
};

enum VimRegisterFlag {
    VimRegisterFlag_FromBlockCopy = 0x1,
    VimRegisterFlag_Append = 0x2,
    VimRegisterFlag_ReadOnly = 0x4,
};

struct Vim_Register {
    u32 flags;
    String_u8 string;
};

enum Vim_Search_Flag {
    VimSearchFlag_CaseSensitive = 0x1,
    VimSearchFlag_WholeWord = 0x2,
};

static u32 vim_search_mode_cycle[] = {
    0,
    VimSearchFlag_CaseSensitive,
    VimSearchFlag_WholeWord,
    VimSearchFlag_CaseSensitive|VimSearchFlag_WholeWord,
};

static String_Const_u8 vim_search_mode_prompt_forward[] = {
    SCu8((u8*)("I-Search: "), (u64)(sizeof("I-Search: ") - 1)),
    SCu8((u8*)("I-Search (Case Sensitive): "), (u64)(sizeof("I-Search (Case Sensitive): ") - 1)),
    SCu8((u8*)("I-Search (Whole Word): "), (u64)(sizeof("I-Search (Whole Word): ") - 1)),
    SCu8((u8*)("I-Search (Case Sensitive, Whole Word): "), (u64)(sizeof("I-Search (Case Sensitive, Whole Word): ") - 1)),
};

static String_Const_u8 vim_search_mode_prompt_reverse[] = {
    SCu8((u8*)("Reverse-I-Search: "), (u64)(sizeof("Reverse-I-Search: ") - 1)),
    SCu8((u8*)("Reverse-I-Search (Case Sensitive): "), (u64)(sizeof("Reverse-I-Search (Case Sensitive): ") - 1)),
    SCu8((u8*)("Reverse-I-Search (Whole Word): "), (u64)(sizeof("Reverse-I-Search (Whole Word): ") - 1)),
    SCu8((u8*)("Reverse-I-Search (Case Sensitive, Whole Word): "), (u64)(sizeof("Reverse-I-Search (Case Sensitive, Whole Word): ") - 1)),
};

struct Vim_Insert_Node {
    Vim_Insert_Node* next;
    i64 rel_line, rel_col;
    String_Const_u8 text_forward;
    String_Const_u8 text_backward;
};

struct Vim_Abbreviation {
    Vim_Abbreviation* next;
    String_Const_u8 match;
    String_Const_u8 replacement;
};

enum Vim_Range_Style {
    VimRangeStyle_Exclusive,
    VimRangeStyle_Inclusive,
    VimRangeStyle_Linewise,
};

enum Vim_Motion_Flag {
    VimMotionFlag_SetPreferredX = 0x2,
    VimMotionFlag_IsJump = 0x4,
    VimMotionFlag_VisualBlockForceToLineEnd = 0x8,
    VimMotionFlag_AlwaysSeek = 0x10,
    VimMotionFlag_LogJumpPostSeek = 0x20,
    VimMotionFlag_IgnoreMotionCount = 0x40,
    VimMotionFlag_InvalidMotion = 0x80,
};

struct Vim_Motion_Result {
    Range_i64 range_;
    i64 seek_pos;
    u32 flags;
    Vim_Range_Style style;
};

static Vim_Motion_Result
vim_motion(i64 pos) {
    Vim_Motion_Result result = {};
    result.seek_pos = pos;
    result.style = VimRangeStyle_Exclusive;
    return result;
}

static Vim_Motion_Result
vim_motion_inclusive(i64 pos) {
    Vim_Motion_Result result = {};
    result.seek_pos = pos;
    result.style = VimRangeStyle_Inclusive;
    return result;
}

static Vim_Motion_Result
vim_motion_linewise(i64 pos) {
    Vim_Motion_Result result = {};
    result.seek_pos = pos;
    result.style = VimRangeStyle_Linewise;
    return result;
}

enum Vim_Text_Object_Flag {
    VimTextObjectFlag_IgnoreMotionCount = 0x40,
};

struct Vim_Text_Object_Result {
    Range_i64 range;
    Vim_Range_Style style;
    u32 flags;
};

static Vim_Text_Object_Result
vim_text_object(i64 pos) {
    Vim_Text_Object_Result result = {};
    result.range = Ii64(pos, pos);
    result.style = VimRangeStyle_Exclusive;
    return result;
}

static Vim_Text_Object_Result
vim_text_object_inclusive(i64 pos) {
    Vim_Text_Object_Result result = {};
    result.range = Ii64(pos, pos);
    result.style = VimRangeStyle_Inclusive;
    return result;
}

static Vim_Text_Object_Result
vim_text_object_linewise(i64 pos) {
    Vim_Text_Object_Result result = {};
    result.range = Ii64(pos, pos);
    result.style = VimRangeStyle_Linewise;
    return result;
}


typedef Vim_Motion_Result Vim_Motion(Application_Links* app, View_ID view, Buffer_ID buffer, i64 start_pos, i32 motion_count, b32 motion_count_was_set);


typedef Vim_Text_Object_Result Vim_Text_Object(Application_Links* app, View_ID view, Buffer_ID buffer, i64 start_pos, i32 motion_count, b32 motion_count_was_set);


typedef void Vim_Operator(Application_Links* app, struct Vim_Operator_State* state, View_ID view, Buffer_ID buffer, Vim_Visual_Selection selection, i32 count, b32 count_was_set);

enum Vim_Operator_Flag {
    VimOpFlag_QueryMotion = 0x1,
    VimOpFlag_ChangeBehaviour = 0x2,
};

struct Vim_Operator_State {
    Application_Links* app;

    View_ID view;
    Buffer_ID buffer;

    i32 op_count;
    Vim_Operator* op;

    i32 motion_count;
    b32 motion_count_was_set;
    Vim_Motion* motion;
    Vim_Text_Object* text_object;

    Vim_Visual_Selection selection;
    Range_i64 total_range;
};

enum Vim_Command_Rep_Kind {
    VimCommandRep_None,
    VimCommandRep_Operator,
    VimCommandRep_4CoderCommand,
};

struct Vim_Writable_Node {
    Vim_Writable_Node* next;
    String_Const_u8 writable;
};

struct Vim_Command_Rep {
    Vim_Command_Rep_Kind kind;
    i32 count;
    b32 count_was_set;

    union {
        struct {
            i32 motion_count;
            b32 motion_count_was_set;
            Vim_Motion* motion;
            Vim_Text_Object* text_object;
            Vim_Visual_Selection selection;
            Vim_Register* reg;
            Vim_Operator* op;
        };
        Custom_Command_Function* fcoder_command;
    };

    Vim_Writable_Node* first_writable;
    Vim_Writable_Node* last_writable;

    u32 writable_buffer_used;
    u8 writable_buffer[((2) << 10)];
};

enum Vim_Modifier {
    VimModifier_Control = 0x1,
    VimModifier_Alt = 0x2,
    VimModifier_Shift = 0x4,
    VimModifier_Command = 0x8,
};

struct Vim_Key {
    u32 kc;
    u32 mods;
};

static u64
vim_key_code_hash(Vim_Key key) {
    u64 result = 0;
    if (key.kc) {
        result = ((u64)key.kc) | (((u64)key.mods) << 16);
    }
    return result;
}

struct Vim_Key_Sequence {
    i32 count;
    Vim_Key keys[8];
};

static u32
key_code_to_vim_modifier(Key_Code mod) {
    switch (mod) {
        case KeyCode_Control: return VimModifier_Control;
        case KeyCode_Alt: return VimModifier_Alt;
        case KeyCode_Shift: return VimModifier_Shift;
        case KeyCode_Command: return VimModifier_Command;
    }
    return 0;
}

static Key_Code
vim_modifier_to_key_code(u32 mod) {
    switch (mod) {
        case VimModifier_Control: return KeyCode_Control;
        case VimModifier_Alt: return KeyCode_Alt;
        case VimModifier_Shift: return KeyCode_Shift;
        case VimModifier_Command: return KeyCode_Command;
    }
    return 0;
}

static Input_Modifier_Set_Fixed
vim_modifiers_to_input_modifier_set_fixed(u32 mods) {
    Input_Modifier_Set_Fixed result = {};
    i32 shift_count = 0;
    while (mods) {
        Key_Code kc = vim_modifier_to_key_code((mods & 1) << shift_count);
        if (kc) {
            result.mods[result.count++] = kc;
        }
        mods = mods >> 1;
        shift_count++;
    }
    return result;
}

static u32
input_modifier_set_to_vim_modifiers_internal(i32 count, Key_Code* mods) {
    u32 result = 0;
    for (i32 mod_index = 0; mod_index < count; mod_index++) {
        result |= key_code_to_vim_modifier(mods[mod_index]);
    }
    return result;
}

static u32
input_modifier_set_to_vim_modifiers(Input_Modifier_Set mods) {
    u32 result = input_modifier_set_to_vim_modifiers_internal(mods.count, mods.mods);
    return result;
}

static u32
input_modifier_set_fixed_to_vim_modifiers(Input_Modifier_Set_Fixed mods) {
    u32 result = input_modifier_set_to_vim_modifiers_internal(mods.count, mods.mods);
    return result;
}

static Vim_Key
vim_key(Key_Code kc,
        Key_Code mod1 = 0,
        Key_Code mod2 = 0,
        Key_Code mod3 = 0,
        Key_Code mod4 = 0,
        Key_Code mod5 = 0,
        Key_Code mod6 = 0,
        Key_Code mod7 = 0,
        Key_Code mod8 = 0)
{
    Input_Modifier_Set_Fixed mods = {};
    if (mod1) mods.mods[mods.count++] = mod1;
    if (mod2) mods.mods[mods.count++] = mod2;
    if (mod3) mods.mods[mods.count++] = mod3;
    if (mod4) mods.mods[mods.count++] = mod4;
    if (mod5) mods.mods[mods.count++] = mod5;
    if (mod6) mods.mods[mods.count++] = mod6;
    if (mod7) mods.mods[mods.count++] = mod7;
    if (mod8) mods.mods[mods.count++] = mod8;

    Vim_Key result = {};
    result.kc = kc;
    result.mods = input_modifier_set_fixed_to_vim_modifiers(mods);

    return result;
}

static Vim_Key_Sequence
vim_key_sequence(Vim_Key key1,
                 Vim_Key key2 = {},
                 Vim_Key key3 = {},
                 Vim_Key key4 = {},
                 Vim_Key key5 = {},
                 Vim_Key key6 = {},
                 Vim_Key key7 = {},
                 Vim_Key key8 = {})
{
    Vim_Key_Sequence result = {};
    result.keys[result.count++] = key1;
    if (key2.kc) result.keys[result.count++] = key2;
    if (key3.kc) result.keys[result.count++] = key3;
    if (key4.kc) result.keys[result.count++] = key4;
    if (key5.kc) result.keys[result.count++] = key5;
    if (key6.kc) result.keys[result.count++] = key6;
    if (key7.kc) result.keys[result.count++] = key7;
    if (key8.kc) result.keys[result.count++] = key8;
    return result;
}

static b32
vim_append_key_to_sequence(Vim_Key_Sequence* seq, Vim_Key key) {
    b32 result = false;
    if (seq->count < ((sizeof(seq->keys))/(sizeof(*seq->keys)))) {
        result = true;
        seq->keys[seq->count++] = key;
    }
    return result;
}

struct Vim_Global_State {
    Arena arena;
    Heap heap;
    Base_Allocator alloc;

    Vim_Mode mode;

    Buffer_Cursor insert_cursor;
    i32 insert_history_index;
    b32 insert_sequence;
    i64 insert_sequence_pos;
    i64 insert_sequence_start_pos;
    u8 prev_insert_char;

    b32 visual_block_force_to_line_end;
    b32 right_justify_visual_insert;
    Range_i64 visual_insert_line_range;

    Vim_Insert_Node* first_insert_node;
    Vim_Insert_Node* last_insert_node;
    Vim_Insert_Node* first_free_insert_node;

    Vim_Abbreviation* first_abbreviation;

    b32 current_key_is_retired;
    b32 process_text_input_from_dead_key;
    Vim_Key current_key;
    Vim_Key_Sequence current_key_sequence;

    Vim_Writable_Node* first_free_writable;
    Vim_Writable_Node* current_queued_writable;

    union {
        Tiny_Jump all_marks[26 + 26];
        struct {
            Tiny_Jump lower_marks[26];
            Tiny_Jump upper_marks[26];
        };
    };

    union {
        Vim_Register alphanumeric_registers[26 + 10];
        struct {
            Vim_Register alpha_registers[26];
            Vim_Register numeric_registers[10];
        };
    };

    Vim_Register unnamed_register;
    Vim_Register clipboard_register;
    Vim_Register last_search_register;
    Vim_Register* active_register;

    u8 most_recent_macro_register;
    u8 recording_macro_register;
    b32 played_macro;
    i64 current_macro_start_pos;
    i64 command_start_pos;
    History_Group macro_history;

    b32 executing_queried_motion;

    Vim_Command_Rep* next_command_rep;
    Vim_Command_Rep* command_rep;
    b32 command_in_progress;
    b32 playing_back_command;
    History_Group command_history;

    b32 search_show_highlight;
    u32 search_flags;
    Scan_Direction search_direction;
    u32 search_mode_index;

    b32 character_seek_show_highlight;
    Scan_Direction character_seek_highlight_dir;
    u8 most_recent_character_seek_storage[8];
    String_u8 most_recent_character_seek;
    Scan_Direction most_recent_character_seek_dir;
    u32 most_recent_character_seek_flags;

    b32 capture_queries_into_chord_bar;
    u8 chord_bar_storage[64];
    String_u8 chord_bar;

    i32 definition_stack_count;
    i32 definition_stack_cursor;
    Tiny_Jump definition_stack[16];

    u8 echo_string_storage[256];
    String_u8 echo_string;
    FColor echo_color;

    u32 insert_node_buffer_used;
    u8 insert_node_buffer[((4) << 10)];
};

static Vim_Global_State vim_state;

static Vim_Register*
vim_get_register(u8 register_char) {
    Vim_Register* result = 0;

    b32 append = false;
    if (character_is_lower(register_char)) {
        result = vim_state.alpha_registers + (register_char - 'a');
    } else if (character_is_upper(register_char)) {
        result = vim_state.alpha_registers + (register_char - 'A');
        append = true;
    } else if (register_char >= '0' && register_char <= '9') {
        result = vim_state.numeric_registers + (register_char - '0');
    } else if (register_char == '*' || register_char == '+') {

        result = &vim_state.clipboard_register;
    } else if (register_char == '/') {
        result = &vim_state.last_search_register;
    } else if (register_char == '"') {
        result = &vim_state.unnamed_register;
    }

    if (result) {
        if (append) result->flags |= VimRegisterFlag_Append;
        else result->flags &= ~VimRegisterFlag_Append;
    }

    return result;
}

static b32
vim_write_register(Application_Links* app,
                   Vim_Register* reg,
                   String_Const_u8 string,
                   b32 from_block_copy = false)
{
    b32 result = true;

    if (reg) {
        if ((((reg->flags)&(VimRegisterFlag_ReadOnly))!=0)) {
            result = false;
        } else {
            if (from_block_copy) {
                reg->flags |= VimRegisterFlag_FromBlockCopy;
            } else {
                reg->flags &= ~VimRegisterFlag_FromBlockCopy;
            }

            if ((((reg->flags)&(VimRegisterFlag_Append))!=0)) {
                vim_string_append_dynamic(&vim_state.alloc, &reg->string, string);
            } else {
                vim_string_copy_dynamic(&vim_state.alloc, &reg->string, string);
            }
            if (reg == &vim_state.clipboard_register) {
                reg->flags &= ~VimRegisterFlag_FromBlockCopy;
                clipboard_post(0, reg->string.string);
            }
            if (reg == &vim_state.last_search_register) {
                vim_state.search_show_highlight = true;
            }
        }
    } else {
        result = false;
    }

    return result;
}

static String_Const_u8
vim_read_register(Application_Links* app, Vim_Register* reg) {
    String_Const_u8 result = SCu8();

    if (reg) {
        if (reg == &vim_state.clipboard_register) {
            Scratch_Block scratch(app);
            clipboard_update_history_from_system(app, 0);
            String_Const_u8 clipboard = push_clipboard_index(scratch, 0, 0);
            vim_string_copy_dynamic(&vim_state.alloc, &reg->string, clipboard);
        }

        result = reg->string.string;
    }

    return result;
}

static Vim_Writable_Node*
vim_push_writable(String_Const_u8 writable) {
    if (!vim_state.first_free_writable) {
        vim_state.first_free_writable = ((Vim_Writable_Node*)linalloc_wrap_unintialized(linalloc_push((&vim_state.arena), sizeof(Vim_Writable_Node)*(1), SCu8((u8*)("lib/external/4coder-vimmish/4coder_vimmish.cpp" ":" "907" ":"), (u64)(sizeof("lib/external/4coder-vimmish/4coder_vimmish.cpp" ":" "907" ":") - 1)))));
        vim_state.first_free_writable->next = 0;
    }
    Vim_Writable_Node* node = vim_state.first_free_writable;
    ((vim_state.first_free_writable)=(vim_state.first_free_writable)=(vim_state.first_free_writable)->next);

    Vim_Command_Rep* rep = vim_state.next_command_rep;
    node->writable = vim_push_string_buffer(((sizeof(rep->writable_buffer))/(sizeof(*rep->writable_buffer))), &rep->writable_buffer_used, rep->writable_buffer, writable);

    do{ if((node)){if((rep->first_writable)){(rep->last_writable)->next=(node);}else{(rep->first_writable)=(node);}(rep->last_writable)=(node);(rep->last_writable)->next=0;} }while(0);

    return node;
}

static void
vim_echo_varargs(Application_Links* app, char* fmt, va_list args) {
    Scratch_Block scratch(app);

    String_Const_u8 formatted = push_u8_stringfv(scratch, fmt, args);

    vim_state.echo_string.size = 0;
    string_append(&vim_state.echo_string, formatted);
}

static void
vim_echo(Application_Links* app, char* fmt, ...) {
    va_list args;
    
# 934 "lib/external/4coder-vimmish/4coder_vimmish.cpp" 3 4
   __builtin_va_start(
# 934 "lib/external/4coder-vimmish/4coder_vimmish.cpp"
   args
# 934 "lib/external/4coder-vimmish/4coder_vimmish.cpp" 3 4
   ,
# 934 "lib/external/4coder-vimmish/4coder_vimmish.cpp"
   fmt
# 934 "lib/external/4coder-vimmish/4coder_vimmish.cpp" 3 4
   )
# 934 "lib/external/4coder-vimmish/4coder_vimmish.cpp"
                      ;
    vim_state.echo_color = fcolor_id(defcolor_text_default);
    vim_echo_varargs(app, fmt, args);
    
# 937 "lib/external/4coder-vimmish/4coder_vimmish.cpp" 3 4
   __builtin_va_end(
# 937 "lib/external/4coder-vimmish/4coder_vimmish.cpp"
   args
# 937 "lib/external/4coder-vimmish/4coder_vimmish.cpp" 3 4
   )
# 937 "lib/external/4coder-vimmish/4coder_vimmish.cpp"
               ;
}

static void
vim_echo_alert(Application_Links* app, char* fmt, ...) {
    va_list args;
    
# 943 "lib/external/4coder-vimmish/4coder_vimmish.cpp" 3 4
   __builtin_va_start(
# 943 "lib/external/4coder-vimmish/4coder_vimmish.cpp"
   args
# 943 "lib/external/4coder-vimmish/4coder_vimmish.cpp" 3 4
   ,
# 943 "lib/external/4coder-vimmish/4coder_vimmish.cpp"
   fmt
# 943 "lib/external/4coder-vimmish/4coder_vimmish.cpp" 3 4
   )
# 943 "lib/external/4coder-vimmish/4coder_vimmish.cpp"
                      ;
    vim_state.echo_color = fcolor_id(defcolor_pop1);
    vim_echo_varargs(app, fmt, args);
    
# 946 "lib/external/4coder-vimmish/4coder_vimmish.cpp" 3 4
   __builtin_va_end(
# 946 "lib/external/4coder-vimmish/4coder_vimmish.cpp"
   args
# 946 "lib/external/4coder-vimmish/4coder_vimmish.cpp" 3 4
   )
# 946 "lib/external/4coder-vimmish/4coder_vimmish.cpp"
               ;
}

static void
vim_echo_error(Application_Links* app, char* fmt, ...) {
    va_list args;
    
# 952 "lib/external/4coder-vimmish/4coder_vimmish.cpp" 3 4
   __builtin_va_start(
# 952 "lib/external/4coder-vimmish/4coder_vimmish.cpp"
   args
# 952 "lib/external/4coder-vimmish/4coder_vimmish.cpp" 3 4
   ,
# 952 "lib/external/4coder-vimmish/4coder_vimmish.cpp"
   fmt
# 952 "lib/external/4coder-vimmish/4coder_vimmish.cpp" 3 4
   )
# 952 "lib/external/4coder-vimmish/4coder_vimmish.cpp"
                      ;
    vim_state.echo_color = fcolor_id(defcolor_pop2);
    vim_echo_varargs(app, fmt, args);
    
# 955 "lib/external/4coder-vimmish/4coder_vimmish.cpp" 3 4
   __builtin_va_end(
# 955 "lib/external/4coder-vimmish/4coder_vimmish.cpp"
   args
# 955 "lib/external/4coder-vimmish/4coder_vimmish.cpp" 3 4
   )
# 955 "lib/external/4coder-vimmish/4coder_vimmish.cpp"
               ;
}

struct Vim_View_Attachment {
    Buffer_ID most_recent_known_buffer;
    i64 most_recent_known_pos;

    Buffer_ID previous_buffer;
    i64 pos_in_previous_buffer;

    b32 dont_log_this_buffer_jump;

    i32 jump_history_first;
    i32 jump_history_one_past_last;
    i32 jump_history_cursor;
    Tiny_Jump jump_history[100];
};

static void
vim_delete_jump_history_at_index(Application_Links* app, Vim_View_Attachment* vim_view, i32 jump_index) {
    if (jump_index >= vim_view->jump_history_first && jump_index < vim_view->jump_history_one_past_last) {
        i32 jumps_left = vim_view->jump_history_one_past_last - jump_index;

        vim_view->jump_history_one_past_last--;
        vim_view->jump_history_cursor = (((vim_view->jump_history_cursor)<(vim_view->jump_history_one_past_last))?(vim_view->jump_history_cursor):(vim_view->jump_history_one_past_last));

        if (jumps_left > 1) {

            for (i32 shift = 0; shift < jumps_left - 1; shift++) {
                i32 shift_index = jump_index + shift;
                ((vim_view->jump_history)[(shift_index)%((sizeof(vim_view->jump_history))/(sizeof(*vim_view->jump_history)))]) = ((vim_view->jump_history)[(shift_index + 1)%((sizeof(vim_view->jump_history))/(sizeof(*vim_view->jump_history)))]);
            }
        }
    }
}

static void
vim_delete_jump_history_at_index(Application_Links* app, i32 jump_index) {
    View_ID view = get_active_view(app, Access_Always);
    Managed_Scope scope = view_get_managed_scope(app, view);
    Vim_View_Attachment* vim_view = ((Vim_View_Attachment*)managed_scope_get_attachment((app), (scope), (vim_view_attachment), sizeof(Vim_View_Attachment)));
    vim_delete_jump_history_at_index(app, vim_view, jump_index);
}

static void
vim_log_jump_history_internal(Application_Links* app, View_ID view, Buffer_ID buffer, Vim_View_Attachment* vim_view, i64 pos) {
    Profile_Scope_Block profile_block_1001 ((app), SCu8((u8*)("[vim] log jump history"), (u64)(sizeof("[vim] log jump history") - 1)), SCu8((u8*)("lib/external/4coder-vimmish/4coder_vimmish.cpp" ":" "1001" ":"), (u64)(sizeof("lib/external/4coder-vimmish/4coder_vimmish.cpp" ":" "1001" ":") - 1)));
    i64 line = get_line_number_from_pos(app, buffer, pos);

    Scratch_Block scratch(app);
    for (i32 jump_index = vim_view->jump_history_first; jump_index < vim_view->jump_history_one_past_last; jump_index++) {
        Tiny_Jump test_jump = ((vim_view->jump_history)[(jump_index)%((sizeof(vim_view->jump_history))/(sizeof(*vim_view->jump_history)))]);
        if (test_jump.buffer == buffer) {
            i64 test_line = get_line_number_from_pos(app, buffer, test_jump.pos);
            if (test_line == line) {
                vim_delete_jump_history_at_index(app, vim_view, jump_index);
                break;
            }
        }
    }

    Tiny_Jump jump;
    jump.buffer = buffer;
    jump.pos = pos;

    ((vim_view->jump_history)[(vim_view->jump_history_cursor++)%((sizeof(vim_view->jump_history))/(sizeof(*vim_view->jump_history)))]) = jump;

    vim_view->jump_history_one_past_last = vim_view->jump_history_cursor;
    i32 unsafe_index = vim_view->jump_history_one_past_last - ((sizeof(vim_view->jump_history))/(sizeof(*vim_view->jump_history)));
    vim_view->jump_history_first = (((0)>((((vim_view->jump_history_first)>(unsafe_index))?(vim_view->jump_history_first):(unsafe_index))))?(0):((((vim_view->jump_history_first)>(unsafe_index))?(vim_view->jump_history_first):(unsafe_index))));
}

static void
vim_log_jump_history(Application_Links* app) {
    View_ID view = get_active_view(app, Access_Always);
    Managed_Scope scope = view_get_managed_scope(app, view);
    Vim_View_Attachment* vim_view = ((Vim_View_Attachment*)managed_scope_get_attachment((app), (scope), (vim_view_attachment), sizeof(Vim_View_Attachment)));

    Buffer_ID buffer = view_get_buffer(app, view, Access_Always);
    i64 pos = view_get_cursor_pos(app, view);

    vim_log_jump_history_internal(app, view, buffer, vim_view, pos);
}

CUSTOM_COMMAND(vim_step_back_jump_history, "lib/external/4coder-vimmish/4coder_vimmish.cpp", 1039, Normal) {
    View_ID view = get_active_view(app, Access_Always);
    Managed_Scope scope = view_get_managed_scope(app, view);
    Vim_View_Attachment* vim_view = ((Vim_View_Attachment*)managed_scope_get_attachment((app), (scope), (vim_view_attachment), sizeof(Vim_View_Attachment)));

    if (vim_view->jump_history_cursor > vim_view->jump_history_first) {
        if (vim_view->jump_history_cursor == vim_view->jump_history_one_past_last) {
            i32 pre_jump_cursor = vim_view->jump_history_cursor;
            vim_log_jump_history(app);
            vim_view->jump_history_cursor = pre_jump_cursor;
        }

        Tiny_Jump jump = ((vim_view->jump_history)[(--vim_view->jump_history_cursor)%((sizeof(vim_view->jump_history))/(sizeof(*vim_view->jump_history)))]);
        jump_to_location(app, view, jump.buffer, jump.pos);

        vim_view->dont_log_this_buffer_jump = true;
    }
}

CUSTOM_COMMAND(vim_step_forward_jump_history, "lib/external/4coder-vimmish/4coder_vimmish.cpp", 1058, Normal) {
    View_ID view = get_active_view(app, Access_Always);
    Managed_Scope scope = view_get_managed_scope(app, view);
    Vim_View_Attachment* vim_view = ((Vim_View_Attachment*)managed_scope_get_attachment((app), (scope), (vim_view_attachment), sizeof(Vim_View_Attachment)));

    if (vim_view->jump_history_cursor + 1 < vim_view->jump_history_one_past_last) {
        Tiny_Jump jump = ((vim_view->jump_history)[(++vim_view->jump_history_cursor)%((sizeof(vim_view->jump_history))/(sizeof(*vim_view->jump_history)))]);
        jump_to_location(app, view, jump.buffer, jump.pos);

        vim_view->dont_log_this_buffer_jump = true;
    }
}

static Vim_Key
vim_get_key_from_input(User_Input in) {
    Vim_Key key = {};
    if (in.event.kind == InputEventKind_KeyStroke) {
        key.kc = in.event.key.code;
        key.mods = input_modifier_set_to_vim_modifiers(in.event.key.modifiers);
    }
    return key;
}

enum Vim_Binding_Kind {
    VimBindingKind_None,

    VimBindingKind_Map,
    VimBindingKind_Motion,
    VimBindingKind_TextObject,
    VimBindingKind_Operator,
    VimBindingKind_4CoderCommand,
};

enum Vim_Binding_Flag {
    VimBindingFlag_IsRepeatable = 0x1,
    VimBindingFlag_WriteOnly = 0x2,
    VimBindingFlag_TextCommand = VimBindingFlag_IsRepeatable|VimBindingFlag_WriteOnly,
};

struct Vim_Key_Binding {
    Vim_Binding_Kind kind;
    String_Const_u8 description;
    u32 flags;
    union {
        Vim_Text_Object* text_object;
        void* generic;
        Vim_Binding_Map* map;
        Vim_Motion* motion;
        Vim_Operator* op;
        Custom_Command_Function* fcoder_command;
    };
};

static Vim_Binding_Map
vim_make_binding_map(u32 slot_count) {
    Vim_Binding_Map result = make_table_u64_u64__inner((&vim_state.alloc),(slot_count),SCu8((u8*)("lib/external/4coder-vimmish/4coder_vimmish.cpp" ":" "1113" ":"), (u64)(sizeof("lib/external/4coder-vimmish/4coder_vimmish.cpp" ":" "1113" ":") - 1)));
    return result;
}

static Vim_Binding_Map*
vim_new_binding_map(u32 slot_count) {
    Vim_Binding_Map* result = ((Vim_Binding_Map*)linalloc_wrap_unintialized(linalloc_push((&vim_state.arena), sizeof(Vim_Binding_Map)*(1), SCu8((u8*)("lib/external/4coder-vimmish/4coder_vimmish.cpp" ":" "1119" ":"), (u64)(sizeof("lib/external/4coder-vimmish/4coder_vimmish.cpp" ":" "1119" ":") - 1)))));
    *result = vim_make_binding_map(slot_count);
    return result;
}

static void
vim_add_parent_binding_map(Vim_Binding_Map* dest, Vim_Binding_Map* source) {
    for (u32 slot_index = 0; slot_index < source->slot_count; slot_index++) {
        u64 key = source->keys[slot_index];
        u64 value = source->vals[slot_index];
        if (value) {
            Vim_Key_Binding* source_bind = (Vim_Key_Binding*)(void*)(((u8*)0) + value);
            Vim_Key_Binding* dest_bind = 0;
            if (!table_read(dest, key, (u64*)&dest_bind)) {
                dest_bind = ((Vim_Key_Binding*)linalloc_wrap_zero(linalloc_push((&vim_state.arena), sizeof(Vim_Key_Binding)*(1), SCu8((u8*)("lib/external/4coder-vimmish/4coder_vimmish.cpp" ":" "1133" ":"), (u64)(sizeof("lib/external/4coder-vimmish/4coder_vimmish.cpp" ":" "1133" ":") - 1)))));
            }

            if (source_bind->kind == VimBindingKind_Map) {
                if (dest_bind->kind != VimBindingKind_Map || !dest_bind->map) {
                    dest_bind->map = vim_new_binding_map(8);
                }
                vim_add_parent_binding_map(dest_bind->map, source_bind->map);
            } else {
                dest_bind->generic = source_bind->generic;
            }

            dest_bind->kind = source_bind->kind;
            dest_bind->description = source_bind->description;
            dest_bind->flags = source_bind->flags;

            table_insert(dest, key, ((u8*)(dest_bind) - (u8*)(0)));
        }
    }
}

static Vim_Key_Binding*
vim_make_or_retrieve_binding_internal(Vim_Binding_Map* map, Vim_Key key, b32 make_if_doesnt_exist) {
    do{ if (!(map)) { (*((i32*)0) = 0xA11E); } }while(0);

    Vim_Key_Binding* result = 0;

    u64 hash = vim_key_code_hash(key);

    u64 location = 0;
    if (table_read(map, hash, &location)) {
        result = (Vim_Key_Binding*)(void*)(((u8*)0) + location);
    }

    if (!result && make_if_doesnt_exist) {
        result = ((Vim_Key_Binding*)linalloc_wrap_zero(linalloc_push((&vim_state.arena), sizeof(Vim_Key_Binding)*(1), SCu8((u8*)("lib/external/4coder-vimmish/4coder_vimmish.cpp" ":" "1168" ":"), (u64)(sizeof("lib/external/4coder-vimmish/4coder_vimmish.cpp" ":" "1168" ":") - 1)))));
        table_insert(map, hash, ((u8*)(result) - (u8*)(0)));
    }

    return result;
}

static Vim_Key_Binding*
vim_retrieve_binding(Vim_Binding_Map* map, Vim_Key key) {
    return vim_make_or_retrieve_binding_internal(map, key, false);
}

static Vim_Key_Binding*
vim_make_or_retrieve_binding(Vim_Binding_Map* map, Vim_Key key) {
    return vim_make_or_retrieve_binding_internal(map, key, true);
}

static void
vim_append_chord_bar(String_Const_u8 string, u32 vim_mods) {
    String_Const_u8 append_string = string;
    if (string_match(string, SCu8((u8*)(" "), (u64)(sizeof(" ") - 1)))) {
        append_string = SCu8((u8*)("<Space>"), (u64)(sizeof("<Space>") - 1));
    }
    if ((((vim_mods)&(VimModifier_Alt))!=0)) {
        string_append(&vim_state.chord_bar, SCu8((u8*)("M-"), (u64)(sizeof("M-") - 1)));
    }
    if ((((vim_mods)&(VimModifier_Control))!=0)) {
        string_append_character(&vim_state.chord_bar, '^');
    }
    string_append(&vim_state.chord_bar, append_string);
}

static User_Input
vim_get_next_keystroke(Application_Links* app) {
    User_Input in = {};
    do {
        in = get_next_input(app, EventProperty_AnyKey, EventProperty_Escape|EventProperty_ViewActivation|EventProperty_Exit);
        if (in.abort) break;
    } while (key_code_to_vim_modifier(in.event.key.code));
    return in;
}


static User_Input
vim_get_next_input(Application_Links *app, Event_Property use_flags, Event_Property abort_flags){
    User_Input in = {};
    if (use_flags != 0){
        for (;;){
            in = get_next_input_raw(app);
            if (in.abort){
                break;
            }
            Event_Property event_flags = get_event_properties(&in.event);
            if ((event_flags & abort_flags) != 0){
                in.abort = true;
                leave_current_input_unhandled(app);
                break;
            }
            if ((event_flags & use_flags) != 0){
                break;
            }
            leave_current_input_unhandled(app);
        }
    }
    return(in);
}

static String_Const_u8
vim_get_next_writable(Application_Links* app) {
    String_Const_u8 result = SCu8();

    if (vim_state.playing_back_command) {
        do{ if (!(vim_state.current_queued_writable)) { (*((i32*)0) = 0xA11E); } }while(0);
        result = vim_state.current_queued_writable->writable;
        ((vim_state.current_queued_writable)=(vim_state.current_queued_writable)=(vim_state.current_queued_writable)->next);
    } else {
        i32 input_to_process_count = (vim_state.process_text_input_from_dead_key ? 2 : 1);
        for (i32 i = 0; i < input_to_process_count; ++i) {
            User_Input in = vim_get_next_input(app, EventProperty_TextInsert, EventProperty_Escape|EventProperty_ViewActivation|EventProperty_Exit);
            result = to_writable(&in);
            if (vim_state.command_in_progress) {
                vim_push_writable(result);
            }
            if (vim_state.capture_queries_into_chord_bar) {
                vim_append_chord_bar(result, 0);
            }
        }
        vim_state.process_text_input_from_dead_key = false;
    }

    return result;
}

static b32
vim_keystroke_is_dead_key(User_Input in) {
    b32 result = false;
# 1276 "lib/external/4coder-vimmish/4coder_vimmish.cpp"
    return result;
}

enum Vim_Query_Mode {
    VimQuery_CurrentInput,
    VimQuery_NextInput,
};

static Vim_Key
vim_get_key_from_input_query(Application_Links* app, Vim_Query_Mode mode) {
    Vim_Key result = {};

    User_Input in = {};
    if (mode == VimQuery_CurrentInput) {
        in = get_current_input(app);
    } else if (mode == VimQuery_NextInput) {
        in = vim_get_next_input(app, EventProperty_AnyKey, EventProperty_Escape|EventProperty_ViewActivation|EventProperty_Exit);
    } else {
        (*((i32*)0) = 0xA11E);
    }

    if (in.abort) {
        return result;
    }

    if (in.event.kind == InputEventKind_KeyStroke) {
        while (key_code_to_vim_modifier(in.event.key.code)) {
            in = vim_get_next_input(app, EventProperty_AnyKey, EventProperty_Escape|EventProperty_ViewActivation|EventProperty_Exit);
            if (in.abort) {
                return result;
            }
        }

        result.kc = in.event.key.code;
        result.mods = input_modifier_set_to_vim_modifiers(in.event.key.modifiers);

        if (vim_state.capture_queries_into_chord_bar) {

            if (in.event.key.first_dependent_text) {
                vim_append_chord_bar(in.event.key.first_dependent_text->text.string, result.mods);
            }
        }

        if (vim_keystroke_is_dead_key(in)) {
            vim_state.process_text_input_from_dead_key = true;
        }
    }

    return result;
}

static Vim_Key
vim_get_key_from_current_input(Application_Links* app) {
    return vim_get_key_from_input_query(app, VimQuery_CurrentInput);
}

static Vim_Key
vim_get_current_key(Application_Links* app) {
    if (vim_state.current_key_is_retired) {
        vim_state.current_key_is_retired = false;
        vim_state.current_key = vim_get_key_from_input_query(app, VimQuery_NextInput);
    }
    return vim_state.current_key;
}

static void
vim_retire_key() {
    if (!vim_state.current_key_is_retired) {
        vim_state.current_key_is_retired = true;
        vim_append_key_to_sequence(&vim_state.current_key_sequence, vim_state.current_key);
    } else {
        (*((i32*)0) = 0xA11E);
    }
}

static Vim_Key
vim_get_next_key(Application_Links* app) {
    vim_retire_key();
    return vim_get_current_key(app);
}

static void
vim_begin_query(Application_Links* app, Vim_Query_Mode mode) {
    vim_state.capture_queries_into_chord_bar = true;
    vim_state.current_key_sequence.count = 0;
    vim_state.current_key_is_retired = false;
    vim_state.current_key = vim_get_key_from_input_query(app, mode);
    vim_state.current_queued_writable = vim_state.command_rep->first_writable;
}

static void
vim_end_query() {
    vim_state.capture_queries_into_chord_bar = false;
    vim_state.chord_bar.size = 0;
}

static void
vim_print_bind(Application_Links* app, Vim_Key_Binding* bind) {
    if (bind && bind->description.size) {
        if (get_current_input_is_virtual(app)) {
            print_message(app, SCu8((u8*)("    "), (u64)(sizeof("    ") - 1)));
        }
        print_message(app, bind->description);
        if (bind->kind == VimBindingKind_Map) {
            print_message(app, SCu8((u8*)(" -> "), (u64)(sizeof(" -> ") - 1)));
        } else {
            print_message(app, SCu8((u8*)("\n"), (u64)(sizeof("\n") - 1)));
        }
    }
}





static i64
vim_query_number(Application_Links* app, b32 handle_sign = false) {
    i64 result = 0;
    Vim_Key key = vim_get_current_key(app);

    if (key.mods) {
        return result;
    }

    i64 sign = 1;
    if (handle_sign && key.kc == KeyCode_Minus) {
        sign = -1;
        key = vim_get_next_key(app);
    }

    if (key.mods) {
        return result;
    }

    if (key.kc != KeyCode_0) {
        for (;;) {
            u32 digit = key.kc - KeyCode_0;
            if (digit >= 0 && digit <= 9) {

                if (result > (max_i64 / 10 - digit)) {
                    result = max_i64;
                } else if (result < (min_i64 / 10 + digit)) {
                    result = min_i64;
                } else {
                    result = 10*result + sign*(i32)digit;
                }
                key = vim_get_next_key(app);
            } else {
                break;
            }
        }
    }

    return result;
}

static b32
vim_keys_are_equal(Vim_Key a, Vim_Key b) {
    b32 result = (a.kc == b.kc && a.mods == b.mods);
    return result;
}


static Vim_Text_Object(vim_text_object_line);

static Vim_Key_Binding*
vim_query_binding(Application_Links* app, Vim_Binding_Map* map, b32 line_object_on_repeat_input) {

    static Vim_Key_Binding vim_text_object_line_bind = {
        VimBindingKind_TextObject,
        SCu8((u8*)("vim_text_object_line (from key repeat)"), (u64)(sizeof("vim_text_object_line (from key repeat)") - 1)),
        0,
        vim_text_object_line
    };

    Vim_Key_Sequence prev_seq = vim_state.current_key_sequence;
    Vim_Key key = vim_get_current_key(app);
    Vim_Key previous_final_key = prev_seq.keys[prev_seq.count - 1];
    if (line_object_on_repeat_input && (prev_seq.count > 0) && vim_keys_are_equal(key, previous_final_key)) {
        vim_retire_key();



        return &vim_text_object_line_bind;
    }

    Vim_Key_Binding* bind = vim_retrieve_binding(map, key);





    i32 prev_seq_index = 0;
    b32 matches_previous_sequence = (line_object_on_repeat_input && (prev_seq.count > 0) && vim_keys_are_equal(key, prev_seq.keys[prev_seq_index++]));
    while (bind && bind->kind == VimBindingKind_Map) {
        key = vim_get_next_key(app);

        if (matches_previous_sequence) {
            matches_previous_sequence = vim_keys_are_equal(key, prev_seq.keys[prev_seq_index++]);
            if (matches_previous_sequence && (prev_seq_index == prev_seq.count)) {
                vim_retire_key();



                return &vim_text_object_line_bind;
            }
        }

        bind = vim_retrieve_binding(bind->map, key);

        if (!bind) {
            break;
        }




    }

    if (bind) {
        vim_retire_key();
    }

    return bind;
}

CUSTOM_COMMAND(vim_register, "lib/external/4coder-vimmish/4coder_vimmish.cpp", 1502, Normal) {




}

static Vim_Register*
vim_query_and_set_register(Application_Links* app, Vim_Binding_Map* map) {
    Vim_Register* result = 0;
    Vim_Key key = vim_get_current_key(app);
    Vim_Key_Binding* bind = vim_retrieve_binding(map, key);
    if (bind && (bind->fcoder_command == vim_register)) {
        String_Const_u8 reg_str = vim_get_next_writable(app);
        if (reg_str.size) {
            char reg_char = reg_str.str[0];

            result = vim_get_register(reg_char);
        }

        if (result) {
            vim_state.active_register = result;
            vim_retire_key();




        }
    }
    return result;
}

static void
vim_begin_macro(Application_Links* app, u8 reg_char) {
    if (vim_state.recording_macro_register) {
        return;
    }

    Vim_Register* reg = vim_get_register(reg_char);
    b32 reg_is_alphanumeric = (reg >= vim_state.alphanumeric_registers) &&
        (reg < vim_state.alphanumeric_registers + ((sizeof(vim_state.alphanumeric_registers))/(sizeof(*vim_state.alphanumeric_registers))));
    if (reg && reg_is_alphanumeric) {
        vim_state.recording_macro_register = reg_char;

        Buffer_ID buffer = get_keyboard_log_buffer(app);
        Buffer_Cursor cursor = buffer_compute_cursor(app, buffer, seek_pos(buffer_get_size(app, buffer)));
        vim_state.current_macro_start_pos = cursor.pos;
    }
}

static void
vim_end_macro(Application_Links* app) {
    if (!vim_state.recording_macro_register) {
        return;
    }

    Vim_Register* reg = vim_get_register(vim_state.recording_macro_register);
    b32 reg_is_alphanumeric = (reg >= vim_state.alphanumeric_registers) &&
        (reg < vim_state.alphanumeric_registers + ((sizeof(vim_state.alphanumeric_registers))/(sizeof(*vim_state.alphanumeric_registers))));
    vim_state.recording_macro_register = 0;
    if (reg && reg_is_alphanumeric) {
        Buffer_ID buffer = get_keyboard_log_buffer(app);

        i64 end_macro_pos = vim_state.command_start_pos;
        Range_i64 range = Ii64(vim_state.current_macro_start_pos, end_macro_pos);

        Scratch_Block scratch(app);
        String_Const_u8 macro_string = push_buffer_range(app, scratch, buffer, range);

        vim_write_register(app, reg, macro_string);
    }
}

CUSTOM_COMMAND(vim_record_macro, "lib/external/4coder-vimmish/4coder_vimmish.cpp", 1575, Normal) {
    View_ID view = get_active_view(app, Access_ReadWriteVisible);
    Buffer_ID buffer = view_get_buffer(app, view, Access_ReadWriteVisible);

    if (!buffer_exists(app, buffer)) return;

    if (vim_state.recording_macro_register) {
        vim_end_macro(app);
    } else {
        String_Const_u8 reg_str = vim_get_next_writable(app);
        if (reg_str.size) {
            char reg_char = reg_str.str[0];

            vim_begin_macro(app, reg_char);
        }
    }
}

CUSTOM_COMMAND(vim_replay_macro, "lib/external/4coder-vimmish/4coder_vimmish.cpp", 1593, Normal) {
    View_ID view = get_active_view(app, Access_ReadWriteVisible);
    Buffer_ID buffer = view_get_buffer(app, view, Access_ReadWriteVisible);
    if (!buffer_exists(app, buffer)) {
        return;
    }

    String_Const_u8 reg_str = vim_get_next_writable(app);
    if (reg_str.size) {
        char reg_char = reg_str.str[0];
        if (reg_char == '@') {
            reg_char = vim_state.most_recent_macro_register;
        }

        Vim_Register* reg = vim_get_register(reg_char);
        if (reg) {
            String_Const_u8 macro_string = vim_read_register(app, reg);
            if (vim_state.recording_macro_register) {
                u8 rec_reg_char = character_to_upper(vim_state.recording_macro_register);
                vim_end_macro(app);
                Vim_Register* rec_reg = vim_get_register(rec_reg_char);
                vim_write_register(app, rec_reg, macro_string);
                vim_begin_macro(app, rec_reg_char);
            }
            keyboard_macro_play(app, macro_string);

            vim_state.most_recent_macro_register = reg_char;
            vim_state.played_macro = true;
            vim_state.macro_history = history_group_begin(app, buffer);
        }
    }
}

CUSTOM_COMMAND(vim_view_move_line_to_top, "lib/external/4coder-vimmish/4coder_vimmish.cpp", 1626, Normal)
CUSTOM_DOC("[vim] move current line to the top of the view") {
    View_ID view = get_active_view(app, Access_ReadVisible);

    i64 pos = view_get_cursor_pos(app, view);
    Buffer_Cursor cursor = view_compute_cursor(app, view, seek_pos(pos));

    Buffer_Scroll scroll = view_get_buffer_scroll(app, view);
    scroll.target.line_number = cursor.line;
    scroll.target.pixel_shift.y = 0.f;
    view_set_buffer_scroll(app, view, scroll, SetBufferScroll_NoCursorChange);
}

CUSTOM_COMMAND(vim_view_move_line_to_bottom, "lib/external/4coder-vimmish/4coder_vimmish.cpp", 1639, Normal)
CUSTOM_DOC("[vim] move current line to the bottom of the view") {
    View_ID view = get_active_view(app, Access_ReadVisible);

    Rect_f32 region = view_get_buffer_region(app, view);

    i64 pos = view_get_cursor_pos(app, view);
    Buffer_Cursor cursor = view_compute_cursor(app, view, seek_pos(pos));

    Buffer_Scroll scroll = view_get_buffer_scroll(app, view);
    scroll.target.line_number = cursor.line - 1;
    scroll.target.pixel_shift.y = -region.p1.y;
    view_set_buffer_scroll(app, view, scroll, SetBufferScroll_NoCursorChange);
}

CUSTOM_COMMAND(vim_set_mark, "lib/external/4coder-vimmish/4coder_vimmish.cpp", 1654, Normal) {



    View_ID view = get_active_view(app, Access_ReadWriteVisible);
    Buffer_ID buffer = view_get_buffer(app, view, Access_ReadWriteVisible);

    if (!buffer_exists(app, buffer)) return;

    String_Const_u8 str = vim_get_next_writable(app);
    if (str.size) {
        u8 mark_char = str.str[0];
        Tiny_Jump* mark = 0;
        if (character_is_lower(mark_char)) {
            mark = vim_state.lower_marks + (mark_char - 'a');
        } else if (character_is_upper(mark_char)) {
            mark = vim_state.upper_marks + (mark_char - 'A');
        }
        if (mark) {
            mark->buffer = buffer;
            mark->pos = view_get_cursor_pos(app, view);
        } else {
            vim_echo_error(app, "Unknown mark '%c'", mark_char);
        }
    }
}

static void
vim_go_to_mark_internal(Application_Links* app, b32 reduced_jump_history) {

    View_ID view = get_active_view(app, Access_ReadWriteVisible);
    Buffer_ID buffer = view_get_buffer(app, view, Access_ReadWriteVisible);

    if (!buffer_exists(app, buffer)) return;

    String_Const_u8 str = vim_get_next_writable(app);
    if (str.size) {
        u8 mark_char = str.str[0];
        Tiny_Jump* mark = 0;
        b32 upper_mark = false;
        if (character_is_lower(mark_char)) {
            mark = vim_state.lower_marks + (mark_char - 'a');
        } else if (character_is_upper(mark_char)) {
            upper_mark = true;
            mark = vim_state.upper_marks + (mark_char - 'A');
        }
        if (mark) {
            if (upper_mark || mark->buffer == buffer) {
                if (!reduced_jump_history || mark->buffer == buffer) {
                    vim_log_jump_history(app);
                }
                jump_to_location(app, view, mark->buffer, mark->pos);
            }
        } else {
            vim_echo_error(app, "Unknown mark '%c'", mark_char);
        }
    }
}

CUSTOM_COMMAND(vim_go_to_mark, "lib/external/4coder-vimmish/4coder_vimmish.cpp", 1713, Normal) {
    vim_go_to_mark_internal(app, false);
}

CUSTOM_COMMAND(vim_go_to_mark_less_history, "lib/external/4coder-vimmish/4coder_vimmish.cpp", 1717, Normal) {
    vim_go_to_mark_internal(app, true);
}

static Vim_Visual_Selection
vim_get_selection(Application_Links* app, View_ID view, Buffer_ID buffer) {
    Vim_Visual_Selection selection = {};

    if (is_vim_visual_mode(vim_state.mode)) {
        Buffer_Cursor first = buffer_compute_cursor(app, buffer, seek_pos(view_get_cursor_pos(app, view)));
        Buffer_Cursor last = buffer_compute_cursor(app, buffer, seek_pos(view_get_mark_pos(app, view)));
        if (first.pos > last.pos) {
            do { Buffer_Cursor hidden_temp_1729 = first; first = last; last = hidden_temp_1729; } while(0);
        }
        selection.first_line = first.line;
        selection.first_col = first.col;
        selection.one_past_last_line = last.line;
        selection.one_past_last_col = last.col;

        switch (vim_state.mode) {
            case VimMode_Visual: {
                selection.kind = VimSelectionKind_Range;
            } break;

            case VimMode_VisualLine: {
                selection.kind = VimSelectionKind_Line;
                selection.first_col = 1;
                selection.one_past_last_col = max_i32;
            } break;

            case VimMode_VisualBlock: {
                selection.kind = VimSelectionKind_Block;
                if (selection.first_line > selection.one_past_last_line) {
                    do { i64 hidden_temp_1750 = selection.first_line; selection.first_line = selection.one_past_last_line; selection.one_past_last_line = hidden_temp_1750; } while(0);
                }
                if (selection.first_col > selection.one_past_last_col) {
                    do { i64 hidden_temp_1753 = selection.first_col; selection.first_col = selection.one_past_last_col; selection.one_past_last_col = hidden_temp_1753; } while(0);
                }
                if (vim_state.visual_block_force_to_line_end) {
                    selection.one_past_last_col = max_i32;
                }
            } break;
        }

        selection.one_past_last_line++;
        selection.one_past_last_col++;
    }

    return selection;
}

static b32
vim_selection_consume_line(Application_Links* app, Buffer_ID buffer, Vim_Visual_Selection* selection, Range_i64* out_range, b32 inclusive) {
    b32 result = false;

    if (selection->kind == VimSelectionKind_Block) {
        if (selection->first_line < selection->one_past_last_line) {
            *out_range = Ii64(buffer_compute_cursor(app, buffer, seek_line_col(selection->first_line, selection->first_col)).pos,
                              buffer_compute_cursor(app, buffer, seek_line_col(selection->first_line, selection->one_past_last_col + (inclusive ? 0 : -1))).pos);
            selection->first_line++;
            result = true;
        }
    } else if (selection->kind == VimSelectionKind_Line && inclusive) {
        if (!(selection->first_line == selection->one_past_last_line && selection->first_col == selection->one_past_last_col)) {
            Buffer_Cursor min_cursor = buffer_compute_cursor(app, buffer, seek_line_col(selection->first_line, selection->first_col));
            Buffer_Cursor max_cursor = buffer_compute_cursor(app, buffer, seek_line_col(selection->one_past_last_line, 1));
            *out_range = Ii64(min_cursor.pos, max_cursor.pos);
            selection->first_line = selection->one_past_last_line;
            selection->first_col = selection->one_past_last_col;
            result = true;
        }
    } else {
        if (!(selection->first_line == selection->one_past_last_line && selection->first_col == selection->one_past_last_col)) {
            Buffer_Cursor min_cursor = buffer_compute_cursor(app, buffer, seek_line_col(selection->first_line, selection->first_col));
            Buffer_Cursor max_cursor = buffer_compute_cursor(app, buffer, seek_line_col(selection->one_past_last_line - 1, selection->one_past_last_col + (inclusive ? 0 : -1)));
            *out_range = Ii64(min_cursor.pos, max_cursor.pos);
            selection->first_line = selection->one_past_last_line;
            selection->first_col = selection->one_past_last_col;
            result = true;
        }
    }

    return result;
}

static void
vim_rel_move(Application_Links* app, Buffer_Seek seek) {
    View_ID view = get_active_view(app, Access_ReadVisible);
    i64 pos = view_get_cursor_pos(app, view);
    Buffer_Cursor cursor = view_compute_cursor(app, view, seek_pos(pos));
    if (seek.type == buffer_seek_pos) {
        pos = view_compute_cursor(app, view, seek_pos(cursor.pos + seek.pos)).pos;
    } else {
        do{ if (!(seek.type == buffer_seek_line_col)) { (*((i32*)0) = 0xA11E); } }while(0);
        pos = view_compute_cursor(app, view, seek_line_col(cursor.line + seek.line, cursor.col + seek.col)).pos;
    }
    view_set_cursor_and_preferred_x(app, view, seek_pos(pos));
}

static Vim_Insert_Node*
vim_add_insert_node_from_record(Application_Links* app, Buffer_ID buffer, Record_Info record, Buffer_Cursor insert_cursor) {
    if (vim_state.insert_node_buffer_used == ((sizeof(vim_state.insert_node_buffer))/(sizeof(*vim_state.insert_node_buffer)))) {
        return 0;
    }

    if (!vim_state.first_free_insert_node) {
        vim_state.first_free_insert_node = ((Vim_Insert_Node*)linalloc_wrap_unintialized(linalloc_push((&vim_state.arena), sizeof(Vim_Insert_Node)*(1), SCu8((u8*)("lib/external/4coder-vimmish/4coder_vimmish.cpp" ":" "1823" ":"), (u64)(sizeof("lib/external/4coder-vimmish/4coder_vimmish.cpp" ":" "1823" ":") - 1)))));
        vim_state.first_free_insert_node->next = 0;
    }
    Vim_Insert_Node* node = vim_state.first_free_insert_node;
    ((vim_state.first_free_insert_node)=(vim_state.first_free_insert_node)=(vim_state.first_free_insert_node)->next);

    Buffer_Cursor cursor = buffer_compute_cursor(app, buffer, seek_pos(record.single_first));

    node->rel_line = cursor.line - insert_cursor.line;
    node->rel_col = cursor.col - insert_cursor.col;

    String_Const_u8 fwd = record.single_string_forward;
    String_Const_u8 bck = record.single_string_backward;

    node->text_forward = vim_push_string_buffer(((sizeof(vim_state.insert_node_buffer))/(sizeof(*vim_state.insert_node_buffer))), &vim_state.insert_node_buffer_used, vim_state.insert_node_buffer, fwd);
    node->text_backward = vim_push_string_buffer(((sizeof(vim_state.insert_node_buffer))/(sizeof(*vim_state.insert_node_buffer))), &vim_state.insert_node_buffer_used, vim_state.insert_node_buffer, bck);

    do{ if((node)){if((vim_state.first_insert_node)){(vim_state.last_insert_node)->next=(node);}else{(vim_state.first_insert_node)=(node);}(vim_state.last_insert_node)=(node);(vim_state.last_insert_node)->next=0;} }while(0);

    return node;
}


static void
vim_add_abbreviation_(String_Const_u8 match, String_Const_u8 replacement) {
    Vim_Abbreviation* abbreviation = ((Vim_Abbreviation*)linalloc_wrap_unintialized(linalloc_push((&vim_state.arena), sizeof(Vim_Abbreviation)*(1), SCu8((u8*)("lib/external/4coder-vimmish/4coder_vimmish.cpp" ":" "1848" ":"), (u64)(sizeof("lib/external/4coder-vimmish/4coder_vimmish.cpp" ":" "1848" ":") - 1)))));
    ((abbreviation)->next=(vim_state.first_abbreviation),(vim_state.first_abbreviation)=(abbreviation));
    abbreviation->match = match;
    abbreviation->replacement = replacement;
}

static void
vim_apply_abbreviations_for_range(Application_Links* app, View_ID view, Range_i64 word_range) {
    Profile_Scope_Block profile_block_1856 ((app), SCu8((u8*)("[vim] apply abbreviations for range"), (u64)(sizeof("[vim] apply abbreviations for range") - 1)), SCu8((u8*)("lib/external/4coder-vimmish/4coder_vimmish.cpp" ":" "1856" ":"), (u64)(sizeof("lib/external/4coder-vimmish/4coder_vimmish.cpp" ":" "1856" ":") - 1)));
    Buffer_ID buffer = view_get_buffer(app, view, Access_ReadWriteVisible);

    if (buffer_exists(app, buffer)) {
        Scratch_Block scratch(app);
        String_Const_u8 word = push_buffer_range(app, scratch, buffer, word_range);


        for (Vim_Abbreviation* abbreviation = vim_state.first_abbreviation; abbreviation; abbreviation = abbreviation->next) {
            if (string_match(word, abbreviation->match)) {
                buffer_replace_range(app, buffer, word_range, abbreviation->replacement);
                view_set_cursor_and_preferred_x(app, view, seek_pos(word_range.min + abbreviation->replacement.size));
            }
        }
    }
}

static void
vim_begin_command(Application_Links* app,
                  Buffer_ID buffer,
                  Vim_Key_Binding* bind,
                  i32 count,
                  i32 count_was_set,
                  Vim_Visual_Selection selection)
{
    if (!vim_state.command_in_progress) {

        if ((((bind->flags)&(VimBindingFlag_IsRepeatable))!=0)) {
            vim_state.command_history = history_group_begin(app, buffer);
            vim_state.command_in_progress = true;

            Vim_Command_Rep* rep = vim_state.next_command_rep;


            if (rep->first_writable && rep->last_writable) {
                rep->last_writable->next = vim_state.first_free_writable;
                vim_state.first_free_writable = rep->first_writable;
                rep->first_writable = rep->last_writable = 0;
            }
            rep->writable_buffer_used = 0;

            rep->count = count;
            rep->count_was_set = count_was_set;

            Vim_Visual_Selection local_selection = selection;
            local_selection.one_past_last_line -= local_selection.first_line;
            local_selection.one_past_last_col -= local_selection.first_col;
            local_selection.first_line = 0;
            local_selection.first_col = 0;

            rep->selection = local_selection;

            switch (bind->kind) {
                case VimBindingKind_Operator: {
                    rep->kind = VimCommandRep_Operator;
                    rep->reg = vim_state.active_register;
                    rep->op = bind->op;
                } break;
                case VimBindingKind_4CoderCommand: {
                    rep->kind = VimCommandRep_4CoderCommand;
                    rep->fcoder_command = bind->fcoder_command;
                } break;
            }
        }
    }
}

static void
vim_end_command(Application_Links* app, b32 command_was_complete) {
    if (vim_state.command_in_progress) {
        history_group_end(vim_state.command_history);
        vim_state.command_in_progress = false;
        if (command_was_complete) {
            do { Vim_Command_Rep* hidden_temp_1929 = vim_state.command_rep; vim_state.command_rep = vim_state.next_command_rep; vim_state.next_command_rep = hidden_temp_1929; } while(0);
        }
    }
}

static void
vim_select_mapid_for_mode(Application_Links* app, Buffer_ID buffer, Vim_Mode mode) {
    Managed_Scope buffer_scope = buffer_get_managed_scope(app, buffer);
    Command_Map_ID* map_id_ptr = ((Command_Map_ID*)managed_scope_get_attachment((app), (buffer_scope), (buffer_map_id), sizeof(Command_Map_ID)));
    Command_Map_ID* insert_map_id_ptr = ((Command_Map_ID*)managed_scope_get_attachment((app), (buffer_scope), (vim_buffer_insert_map_id), sizeof(Command_Map_ID)));

    switch (mode) {
        case VimMode_Normal: {
            *map_id_ptr = vim_mapid_normal;
        } break;
        case VimMode_Insert:
        case VimMode_VisualInsert: {
            u32 access_flags = buffer_get_access_flags(app, buffer);
            if ((((access_flags)&(Access_Write))!=0)) {
                do{ if (!(*insert_map_id_ptr)) { (*((i32*)0) = 0xA11E); } }while(0);
                *map_id_ptr = *insert_map_id_ptr;
            } else {
                *map_id_ptr = mapid_file;
            }
        } break;
        case VimMode_Visual:
        case VimMode_VisualLine:
        case VimMode_VisualBlock: {
            *map_id_ptr = vim_mapid_visual;
        } break;
    }
}

static void
vim_enter_mode(Application_Links* app, Vim_Mode mode, b32 append = false) {
    u32 access_flags = Access_ReadVisible;
    if (is_vim_insert_mode(mode)) {
        access_flags |= Access_Write;
    }

    View_ID view = get_active_view(app, access_flags);
    Buffer_ID buffer = view_get_buffer(app, view, access_flags);
    if (!buffer_exists(app, buffer)) {
        return;
    }
# 1989 "lib/external/4coder-vimmish/4coder_vimmish.cpp"
    switch (mode) {
        case VimMode_Normal: {
            b32 did_insert = false;
            if (is_vim_insert_mode(vim_state.mode)) {
                vim_state.prev_insert_char = 0;

                if (vim_state.insert_sequence) {
                    vim_apply_abbreviations_for_range(app, view, Ii64(vim_state.insert_sequence_start_pos, vim_state.insert_sequence_pos));
                    vim_state.insert_sequence = false;
                }

                vim_rel_move(app, seek_line_col(0, -1));

                History_Record_Index insert_history_index = vim_state.insert_history_index;
                History_Record_Index current_history_index = buffer_history_get_current_state_index(app, buffer);

                if (insert_history_index < current_history_index) {
                    did_insert = true;

                    vim_state.first_free_insert_node = vim_state.first_insert_node;
                    vim_state.first_insert_node = vim_state.last_insert_node = 0;
                    vim_state.insert_node_buffer_used = 0;

                    History_Record_Index first_valid_history_index = insert_history_index + 1;


                    buffer_history_merge_record_range(app, buffer, first_valid_history_index, current_history_index, RecordMergeFlag_StateInRange_MoveStateForward);
                    current_history_index = buffer_history_get_current_state_index(app, buffer);

                    for (i32 history_index = first_valid_history_index; history_index <= current_history_index; history_index++) {
                        Record_Info record = buffer_history_get_record_info(app, buffer, history_index);
                        if (record.kind == RecordKind_Group) {
                            for (i32 sub_index = 0; sub_index < record.group_count; sub_index++) {
                                Record_Info sub_record = buffer_history_get_group_sub_record(app, buffer, history_index, sub_index);
                                vim_add_insert_node_from_record(app, buffer, sub_record, vim_state.insert_cursor);
                            }
                        } else {
                            vim_add_insert_node_from_record(app, buffer, record, vim_state.insert_cursor);
                        }
                    }
                }
            }

            if (vim_state.mode == VimMode_VisualInsert && did_insert) {
                b32 nodes_occupy_first_line = true;
                for (Vim_Insert_Node* node = vim_state.first_insert_node; node; node = node->next) {
                    if (node->rel_line != 0) {
                        nodes_occupy_first_line = false;
                        break;
                    }
                }

                History_Group history = history_group_begin(app, buffer);
                --history.first;
                if (nodes_occupy_first_line) {
                    Range_i64 line_range = vim_state.visual_insert_line_range;
                    for (i64 line = line_range.first + 1; line < line_range.one_past_last; line++) {
                        Buffer_Cursor line_end_cursor = buffer_compute_cursor(app, buffer, seek_line_col(line, max_i64));

                        i64 col_adjust = 0;
                        if (vim_state.right_justify_visual_insert) {
                            col_adjust = line_end_cursor.col - vim_state.insert_cursor.col;
                        }

                        for (Vim_Insert_Node* node = vim_state.first_insert_node; node; node = node->next) {
                            i64 col = vim_state.insert_cursor.col + node->rel_col + col_adjust;
                            Buffer_Cursor abs_cursor = buffer_compute_cursor(app, buffer, seek_line_col(line, col));

                            if (vim_state.right_justify_visual_insert || (line_end_cursor.col >= abs_cursor.col)) {
                                Range_i64 replace_range = Ii64_size(abs_cursor.pos, node->text_backward.size);
                                buffer_replace_range(app, buffer, replace_range, node->text_forward);
                            }
                        }
                    }
                }
                history_group_end(history);
            }

            vim_state.most_recent_character_seek.size = 0;
            vim_state.command_rep = vim_state.next_command_rep;
        } break;

        case VimMode_VisualInsert: {
            Vim_Visual_Selection selection = vim_get_selection(app, view, buffer);
            vim_state.visual_insert_line_range = Ii64(selection.first_line, selection.one_past_last_line);

            if (append) {
                if (selection.kind == VimSelectionKind_Block) {
                    vim_state.right_justify_visual_insert = vim_state.visual_block_force_to_line_end;
                    view_set_cursor_and_preferred_x(app, view, seek_line_col(selection.first_line, selection.one_past_last_col));
                } else {
                    vim_state.right_justify_visual_insert = true;
                    view_set_cursor_and_preferred_x(app, view, seek_line_col(selection.first_line, max_i64));
                }
            } else {
                vim_state.right_justify_visual_insert = false;
                view_set_cursor_and_preferred_x(app, view, seek_line_col(selection.first_line, selection.first_col));

            }
        } case VimMode_Insert: {
            vim_state.insert_history_index = buffer_history_get_current_state_index(app, buffer);
            vim_state.insert_cursor = buffer_compute_cursor(app, buffer, seek_pos(view_get_cursor_pos(app, view)));
            vim_state.character_seek_show_highlight = false;
        } break;

        case VimMode_Visual:
        case VimMode_VisualLine:
        case VimMode_VisualBlock: {

        } break;
    }

    vim_select_mapid_for_mode(app, buffer, mode);
    vim_state.mode = mode;
}

CUSTOM_COMMAND(vim_enter_normal_mode_escape, "lib/external/4coder-vimmish/4coder_vimmish.cpp", 2105, Normal) {
    b32 end_command = false;
    if (is_vim_insert_mode(vim_state.mode)) {
        end_command = true;
    }
    vim_enter_mode(app, VimMode_Normal);
    if (end_command) {
        vim_end_command(app, true);
    }
}

CUSTOM_COMMAND(vim_enter_normal_mode, "lib/external/4coder-vimmish/4coder_vimmish.cpp", 2116, Normal) {
    vim_enter_mode(app, VimMode_Normal);
}

CUSTOM_COMMAND(vim_enter_insert_mode, "lib/external/4coder-vimmish/4coder_vimmish.cpp", 2120, Normal) {
    vim_enter_mode(app, VimMode_Insert);
}

static void
vim_enter_visual_insert_mode_internal(Application_Links* app, b32 append) {
    View_ID view = get_active_view(app, Access_ReadWriteVisible);
    Buffer_ID buffer = view_get_buffer(app, view, Access_ReadWriteVisible);

    if (!buffer_exists(app, buffer)) {
        return;
    }

    Vim_Visual_Selection selection = vim_get_selection(app, view, buffer);
    if (selection.kind == VimSelectionKind_None || selection.kind == VimSelectionKind_Range) {
        vim_enter_mode(app, VimMode_Insert);
    } else {
        vim_enter_mode(app, VimMode_VisualInsert, append);
    }
}

CUSTOM_COMMAND(vim_enter_visual_insert_mode, "lib/external/4coder-vimmish/4coder_vimmish.cpp", 2141, Normal) {
    vim_enter_visual_insert_mode_internal(app, false);
}

CUSTOM_COMMAND(vim_enter_visual_append_mode, "lib/external/4coder-vimmish/4coder_vimmish.cpp", 2145, Normal) {
    vim_enter_visual_insert_mode_internal(app, true);
}

CUSTOM_COMMAND(vim_enter_insert_sol_mode, "lib/external/4coder-vimmish/4coder_vimmish.cpp", 2149, Normal) {
    vim_enter_mode(app, VimMode_Insert);
    seek_beginning_of_line(app);
}

CUSTOM_COMMAND(vim_enter_append_mode, "lib/external/4coder-vimmish/4coder_vimmish.cpp", 2154, Normal) {
    vim_rel_move(app, seek_line_col(0, 1));
    vim_enter_mode(app, VimMode_Insert);
}

CUSTOM_COMMAND(vim_enter_append_eol_mode, "lib/external/4coder-vimmish/4coder_vimmish.cpp", 2159, Normal) {
    seek_end_of_line(app);
    vim_enter_mode(app, VimMode_Insert);
}

CUSTOM_COMMAND(vim_toggle_visual_mode, "lib/external/4coder-vimmish/4coder_vimmish.cpp", 2164, Normal) {
    View_ID view = get_active_view(app, Access_ReadVisible);
    Buffer_ID buffer = view_get_buffer(app, view, Access_ReadVisible);

    if (!buffer_exists(app, buffer)) {
        return;
    }

    if (!is_vim_visual_mode(vim_state.mode)) {
        i64 pos = view_get_cursor_pos(app, view);
        view_set_mark(app, view, seek_pos(pos));
    }

    if (vim_state.mode == VimMode_Visual) {
        vim_enter_mode(app, VimMode_Normal);
    } else {
        vim_enter_mode(app, VimMode_Visual);
    }
}

CUSTOM_COMMAND(vim_toggle_visual_line_mode, "lib/external/4coder-vimmish/4coder_vimmish.cpp", 2184, Normal) {
    View_ID view = get_active_view(app, Access_ReadVisible);
    Buffer_ID buffer = view_get_buffer(app, view, Access_ReadVisible);

    if (!buffer_exists(app, buffer)) {
        return;
    }

    if (!is_vim_visual_mode(vim_state.mode)) {
        i64 pos = view_get_cursor_pos(app, view);
        view_set_mark(app, view, seek_pos(pos));
    }

    if (vim_state.mode == VimMode_VisualLine) {
        vim_enter_mode(app, VimMode_Normal);
    } else {
        vim_enter_mode(app, VimMode_VisualLine);
    }
}

CUSTOM_COMMAND(vim_toggle_visual_block_mode, "lib/external/4coder-vimmish/4coder_vimmish.cpp", 2204, Normal) {
    View_ID view = get_active_view(app, Access_ReadVisible);
    Buffer_ID buffer = view_get_buffer(app, view, Access_ReadVisible);

    if (!buffer_exists(app, buffer)) {
        return;
    }

    if (!is_vim_visual_mode(vim_state.mode)) {
        i64 pos = view_get_cursor_pos(app, view);
        view_set_mark(app, view, seek_pos(pos));
        vim_state.visual_block_force_to_line_end = false;
    }

    if (vim_state.mode == VimMode_VisualBlock) {
        vim_enter_mode(app, VimMode_Normal);
    } else {
        vim_enter_mode(app, VimMode_VisualBlock);
    }
}

static void
vim_set_selection(Application_Links* app, View_ID view, Vim_Visual_Selection selection) {
    if (selection.kind) {
        if (!is_vim_visual_mode(vim_state.mode)) {
            switch (selection.kind) {
                case VimSelectionKind_Range: {
                    vim_toggle_visual_mode(app);
                } break;
                case VimSelectionKind_Line: {
                    vim_toggle_visual_line_mode(app);
                } break;
                case VimSelectionKind_Block: {
                    vim_toggle_visual_block_mode(app);
                } break;
            }
        }
        view_set_mark(app, view, seek_line_col(selection.first_line, selection.first_col));
        view_set_cursor_and_preferred_x(app, view, seek_line_col(selection.one_past_last_line - 1, selection.one_past_last_col - 1));
    }
}

static Range_i64
vim_apply_range_style(Application_Links* app,
                      View_ID view,
                      Buffer_ID buffer,
                      Range_i64 range,
                      Vim_Range_Style style)
{
    Range_i64 result = range;
# 2268 "lib/external/4coder-vimmish/4coder_vimmish.cpp"
    switch (style) {
        case VimRangeStyle_Inclusive: {
            result.max = view_set_pos_by_character_delta(app, view, result.max, 1);
        } break;

        case VimRangeStyle_Linewise: {

            Range_i64 line_range = get_line_range_from_pos_range(app, buffer, range);
            result = Ii64(get_line_start_pos(app, buffer, line_range.min), get_line_end_pos(app, buffer, line_range.max));
            if (buffer_get_char(app, buffer, result.max) == '\r') result.max++;
            if (buffer_get_char(app, buffer, result.max) == '\n') result.max++;
        } break;
    }
    return result;
}

static Vim_Motion_Result
vim_execute_motion(Application_Links* app,
                   View_ID view,
                   Buffer_ID buffer,
                   Vim_Motion* motion,
                   i64 start_pos,
                   i32 count,
                   b32 count_was_set)
{
    if (count < 0) count = 1;
    Vim_Motion_Result result = vim_motion(start_pos);
    for (i32 i = 0; i < count; ++i) {
        result = motion(app, view, buffer, result.seek_pos, count, count_was_set);
        if ((((result.flags)&(VimMotionFlag_IgnoreMotionCount))!=0)) {
            break;
        }
    }
    result.range_ = vim_apply_range_style(app, view, buffer, Ii64(start_pos, result.seek_pos), result.style);
    return result;
}

static Vim_Text_Object_Result
vim_execute_text_object(Application_Links* app,
                        View_ID view,
                        Buffer_ID buffer,
                        Vim_Text_Object* text_object,
                        i64 start_pos,
                        i32 count,
                        b32 count_was_set)
{
    if (count < 0) count = 1;
    Vim_Text_Object_Result result = vim_text_object(start_pos);
    i64 pos = start_pos;
    result.range = Ii64_neg_inf;
    for (i32 i = 0; i < count; ++i) {

        Vim_Text_Object_Result inner = text_object(app, view, buffer, pos, count, count_was_set);
        Range_i64 new_range = range_union(inner.range, result.range);
        result = inner;
        result.range = new_range;
        pos = result.range.max;
        if ((((result.flags)&(VimTextObjectFlag_IgnoreMotionCount))!=0)) {
            break;
        }
    }

    result.range = vim_apply_range_style(app, view, buffer, result.range, result.style);
    return result;
}

static Range_i64
vim_seek_motion_result(Application_Links* app, View_ID view, Buffer_ID buffer, Vim_Motion_Result mr) {
    i64 old_pos = view_get_cursor_pos(app, view);
    i64 new_pos = mr.seek_pos;

    Range_i64 result = mr.range_;

    i64 old_line = get_line_number_from_pos(app, buffer, old_pos);
    i64 new_line = get_line_number_from_pos(app, buffer, new_pos);

    if ((((mr.flags)&(VimMotionFlag_IsJump))!=0) && !(((mr.flags)&(VimMotionFlag_LogJumpPostSeek))!=0)) {
        if (old_line != new_line) {
            vim_log_jump_history(app);
        }
    }

    if ((((mr.flags)&(VimMotionFlag_SetPreferredX))!=0)) {
        view_set_cursor_and_preferred_x(app, view, seek_pos(new_pos));
    } else {
        view_set_cursor(app, view, seek_pos(new_pos));
    }

    if ((((mr.flags)&(VimMotionFlag_IsJump))!=0) && (((mr.flags)&(VimMotionFlag_LogJumpPostSeek))!=0)) {
        vim_log_jump_history(app);
    }

    return result;
}

static Vim_Binding_Map*
vim_get_map_for_mode(Vim_Mode mode) {
    Vim_Binding_Map* map = 0;
    if (is_vim_visual_mode(mode)) {
        map = &vim_map_visual;
    } else if (mode == VimMode_Normal) {
        map = &vim_map_normal;
    }
    return map;
}

static void
vim_select_range(Application_Links* app, View_ID view, Range_i64 range) {
    view_set_mark(app, view, seek_pos(range.min));
    view_set_cursor(app, view, seek_pos(range.max - 1));
}

static
Vim_Motion_Result vim_motion_left(Application_Links* app, View_ID view, Buffer_ID buffer, i64 start_pos, i32 motion_count, b32 motion_count_was_set) {
    Vim_Motion_Result result = vim_motion(start_pos);
    Buffer_Cursor cursor = buffer_compute_cursor(app, buffer, seek_pos(start_pos));
    result.seek_pos = buffer_compute_cursor(app, buffer, seek_line_col(cursor.line, (((1)>(cursor.col - 1))?(1):(cursor.col - 1)))).pos;
    result.flags |= VimMotionFlag_SetPreferredX;
    return result;
}

static
Vim_Motion_Result vim_motion_right(Application_Links* app, View_ID view, Buffer_ID buffer, i64 start_pos, i32 motion_count, b32 motion_count_was_set) {
    Vim_Motion_Result result = vim_motion(start_pos);
    Buffer_Cursor cursor = buffer_compute_cursor(app, buffer, seek_pos(start_pos));
    Buffer_Cursor eol_cursor = buffer_compute_cursor(app, buffer, seek_pos(get_line_end_pos_from_pos(app, buffer, start_pos)));
    result.seek_pos = buffer_compute_cursor(app, buffer, seek_line_col(cursor.line, (((cursor.col + 1)<(eol_cursor.col - 1))?(cursor.col + 1):(eol_cursor.col - 1)))).pos;
    result.flags |= VimMotionFlag_SetPreferredX;
    return result;
}

static
Vim_Motion_Result vim_motion_down(Application_Links* app, View_ID view, Buffer_ID buffer, i64 start_pos, i32 motion_count, b32 motion_count_was_set) {
    Vim_Motion_Result result = vim_motion_linewise(start_pos);
    Buffer_Cursor start_cursor = buffer_compute_cursor(app, buffer, seek_pos(start_pos));
    i64 target_line = start_cursor.line + 1;
    if (!is_valid_line(app, buffer, target_line)) {
        target_line = start_cursor.line;
    }
    f32 preferred_x = view_get_preferred_x(app, view);
    i64 end_pos = view_pos_at_relative_xy(app, view, target_line, V2f32(preferred_x, 0.0f));
    result.seek_pos = end_pos;
    return result;
}

static
Vim_Motion_Result vim_motion_up(Application_Links* app, View_ID view, Buffer_ID buffer, i64 start_pos, i32 motion_count, b32 motion_count_was_set) {
    Vim_Motion_Result result = vim_motion_linewise(start_pos);
    Buffer_Cursor start_cursor = buffer_compute_cursor(app, buffer, seek_pos(start_pos));
    i64 target_line = start_cursor.line - 1;
    if (!is_valid_line(app, buffer, target_line)) {
        target_line = start_cursor.line;
    }
    f32 preferred_x = view_get_preferred_x(app, view);
    i64 end_pos = view_pos_at_relative_xy(app, view, target_line, V2f32(preferred_x, 0.0f));
    result.seek_pos = end_pos;
    return result;

}




static i64
vim_boundary_word(Application_Links* app, Buffer_ID buffer, Side side, Scan_Direction direction, i64 pos) {
    i64 result = 0;
    if (direction == Scan_Forward) {
        result = (((buffer_seek_character_class_change_0_1(app, buffer, &character_predicate_alpha_numeric_underscore_utf8, direction, pos))<(buffer_seek_character_class_change_1_0(app, buffer, &character_predicate_alpha_numeric_underscore_utf8, direction, pos)))?(buffer_seek_character_class_change_0_1(app, buffer, &character_predicate_alpha_numeric_underscore_utf8, direction, pos)):(buffer_seek_character_class_change_1_0(app, buffer, &character_predicate_alpha_numeric_underscore_utf8, direction, pos)))
                                                                                                                                             ;
        result = (((result)<(buffer_seek_character_class_change_1_0(app, buffer, &character_predicate_whitespace, direction, pos)))?(result):(buffer_seek_character_class_change_1_0(app, buffer, &character_predicate_whitespace, direction, pos)));
    } else {
        result = (((buffer_seek_character_class_change_0_1(app, buffer, &character_predicate_alpha_numeric_underscore_utf8, direction, pos))>(buffer_seek_character_class_change_1_0(app, buffer, &character_predicate_alpha_numeric_underscore_utf8, direction, pos)))?(buffer_seek_character_class_change_0_1(app, buffer, &character_predicate_alpha_numeric_underscore_utf8, direction, pos)):(buffer_seek_character_class_change_1_0(app, buffer, &character_predicate_alpha_numeric_underscore_utf8, direction, pos)))
                                                                                                                                             ;
        result = (((result)>(buffer_seek_character_class_change_1_0(app, buffer, &character_predicate_whitespace, direction, pos)))?(result):(buffer_seek_character_class_change_1_0(app, buffer, &character_predicate_whitespace, direction, pos)));
    }

    return result;
}

static i64
vim_boundary_word_end(Application_Links* app, Buffer_ID buffer, Side side, Scan_Direction direction, i64 pos) {
    i64 result = 0;
    if (direction == Scan_Forward) {
        result = (((buffer_seek_character_class_change_1_0(app, buffer, &character_predicate_alpha_numeric_underscore_utf8, direction, pos))<(buffer_seek_character_class_change_0_1(app, buffer, &character_predicate_alpha_numeric_underscore_utf8, direction, pos)))?(buffer_seek_character_class_change_1_0(app, buffer, &character_predicate_alpha_numeric_underscore_utf8, direction, pos)):(buffer_seek_character_class_change_0_1(app, buffer, &character_predicate_alpha_numeric_underscore_utf8, direction, pos)))
                                                                                                                                             ;
        result = (((result)<(buffer_seek_character_class_change_0_1(app, buffer, &character_predicate_whitespace, direction, pos)))?(result):(buffer_seek_character_class_change_0_1(app, buffer, &character_predicate_whitespace, direction, pos)));
    } else {
        result = vim_boundary_word(app, buffer, side, direction, pos);
    }

    return result;
}

static i64
vim_boundary_whitespace(Application_Links *app, Buffer_ID buffer, Side side, Scan_Direction direction, i64 pos) {
    return(boundary_predicate(app, buffer, side, direction, pos, &character_predicate_whitespace));
}

static Vim_Motion_Result
vim_motion_word_internal(Application_Links* app, Buffer_ID buffer, Scan_Direction dir, i64 start_pos) {
    Vim_Motion_Result result = vim_motion(start_pos);

    Scratch_Block scratch(app);

    i64 end_pos = start_pos;

    if (dir == Scan_Forward) {
        if (line_is_valid_and_blank(app, buffer, get_line_number_from_pos(app, buffer, end_pos))) {
            i64 next_line = get_line_number_from_pos(app, buffer, end_pos) + 1;
            i64 next_line_start = get_pos_past_lead_whitespace_from_line_number(app, buffer, next_line);

            end_pos = next_line_start;
        } else {
            end_pos = scan(app, push_boundary_list__inner((scratch), vim_boundary_word, 0), buffer, Scan_Forward, end_pos);

            u8 c_at_cursor = buffer_get_char(app, buffer, end_pos);
            if (character_is_whitespace(c_at_cursor)) {
                end_pos = scan(app, push_boundary_list__inner((scratch), vim_boundary_whitespace, boundary_line, 0), buffer, Scan_Forward, end_pos);
            }
        }
    } else {
        if (line_is_valid_and_blank(app, buffer, get_line_number_from_pos(app, buffer, end_pos))) {
            i64 next_line = get_line_number_from_pos(app, buffer, end_pos) - 1;
            i64 next_line_end = get_line_end_pos(app, buffer, next_line);

            end_pos = next_line_end;
        } else {
            end_pos = scan(app, push_boundary_list__inner((scratch), vim_boundary_word, boundary_line, 0), buffer, Scan_Backward, end_pos);

            u8 c_at_cursor = buffer_get_char(app, buffer, end_pos);
            if (!vim_character_is_newline(c_at_cursor) && character_is_whitespace(c_at_cursor)) {
                end_pos = scan(app, push_boundary_list__inner((scratch), vim_boundary_word, boundary_line, 0), buffer, Scan_Backward, end_pos);
            }
        }
    }

    result.seek_pos = end_pos;
    result.flags |= VimMotionFlag_SetPreferredX;
# 2514 "lib/external/4coder-vimmish/4coder_vimmish.cpp"
    return result;
}

static
Vim_Motion_Result vim_motion_word(Application_Links* app, View_ID view, Buffer_ID buffer, i64 start_pos, i32 motion_count, b32 motion_count_was_set) {
    return vim_motion_word_internal(app, buffer, Scan_Forward, start_pos);
}

static
Vim_Motion_Result vim_motion_word_backward(Application_Links* app, View_ID view, Buffer_ID buffer, i64 start_pos, i32 motion_count, b32 motion_count_was_set) {
    return vim_motion_word_internal(app, buffer, Scan_Backward, start_pos);
}

static i64
vim_boundary_big_word(Application_Links* app, Buffer_ID buffer, Side side, Scan_Direction direction, i64 pos) {
    i64 result = buffer_seek_character_class_change_1_0(app, buffer, &character_predicate_whitespace, direction, pos);
    return result;
}

static
Vim_Motion_Result vim_motion_big_word(Application_Links* app, View_ID view, Buffer_ID buffer, i64 start_pos, i32 motion_count, b32 motion_count_was_set) {
    Vim_Motion_Result result = vim_motion(start_pos);
    Scratch_Block scratch(app);
    result.seek_pos = scan(app, push_boundary_list__inner((scratch), vim_boundary_big_word, 0), buffer, Scan_Forward, result.seek_pos);
    result.flags |= VimMotionFlag_SetPreferredX;
    return result;
}

static
Vim_Motion_Result vim_motion_big_word_backward(Application_Links* app, View_ID view, Buffer_ID buffer, i64 start_pos, i32 motion_count, b32 motion_count_was_set) {
    Vim_Motion_Result result = vim_motion(start_pos);
    Scratch_Block scratch(app);
    result.seek_pos = scan(app, push_boundary_list__inner((scratch), vim_boundary_big_word, 0), buffer, Scan_Backward, result.seek_pos);
    result.flags |= VimMotionFlag_SetPreferredX;
    return result;
}

static
Vim_Motion_Result vim_motion_word_end(Application_Links* app, View_ID view, Buffer_ID buffer, i64 start_pos, i32 motion_count, b32 motion_count_was_set) {
    Scratch_Block scratch(app);
    Vim_Motion_Result result = vim_motion(start_pos);
    result.seek_pos = scan(app, push_boundary_list__inner((scratch), vim_boundary_word_end, 0), buffer, Scan_Forward, start_pos + 1) - 1;
    if (character_is_whitespace(buffer_get_char(app, buffer, result.seek_pos))) {
        result.seek_pos = scan(app, push_boundary_list__inner((scratch), vim_boundary_word_end, 0), buffer, Scan_Forward, result.seek_pos + 1) - 1;
    }
    result.flags |= VimMotionFlag_SetPreferredX;
    result.style = VimRangeStyle_Inclusive;
    return result;
}

static
Vim_Motion_Result vim_motion_buffer_start_or_goto_line(Application_Links* app, View_ID view, Buffer_ID buffer, i64 start_pos, i32 motion_count, b32 motion_count_was_set) {
    Vim_Motion_Result result = vim_motion_linewise(start_pos);

    if (motion_count_was_set) {
        Buffer_Cursor start_cursor = buffer_compute_cursor(app, buffer, seek_pos(start_pos));
        result.seek_pos = buffer_compute_cursor(app, buffer, seek_line_col(motion_count, start_cursor.col)).pos;
    } else {
        result.seek_pos = 0;
    }

    result.flags |= VimMotionFlag_IsJump|VimMotionFlag_SetPreferredX;

    return result;
}

static
Vim_Motion_Result vim_motion_buffer_end_or_goto_line(Application_Links* app, View_ID view, Buffer_ID buffer, i64 start_pos, i32 motion_count, b32 motion_count_was_set) {
    Vim_Motion_Result result = vim_motion_linewise(start_pos);

    if (motion_count_was_set) {
        Buffer_Cursor start_cursor = buffer_compute_cursor(app, buffer, seek_pos(start_pos));
        result.seek_pos = buffer_compute_cursor(app, buffer, seek_line_col(motion_count, start_cursor.col)).pos;
    } else {
        result.seek_pos = buffer_get_size(app, buffer);
    }

    result.flags |= VimMotionFlag_IsJump|VimMotionFlag_SetPreferredX;

    return result;
}

static Vim_Motion_Result
vim_motion_line_side_textual(Application_Links* app, View_ID view, Buffer_ID buffer, Scan_Direction dir, i64 start_pos) {
    Vim_Motion_Result result = vim_motion(start_pos);

    i64 line_side = get_line_side_pos_from_pos(app, buffer, start_pos, dir == Scan_Forward ? Side_Max : Side_Min);

    result.seek_pos = line_side;
    result.flags |= VimMotionFlag_SetPreferredX;

    return result;
}

static
Vim_Motion_Result vim_motion_line_start_textual(Application_Links* app, View_ID view, Buffer_ID buffer, i64 start_pos, i32 motion_count, b32 motion_count_was_set) {
    return vim_motion_line_side_textual(app, view, buffer, Scan_Backward, start_pos);
}

static
Vim_Motion_Result vim_motion_line_end_textual(Application_Links* app, View_ID view, Buffer_ID buffer, i64 start_pos, i32 motion_count, b32 motion_count_was_set) {
    Vim_Motion_Result result = vim_motion_line_side_textual(app, view, buffer, Scan_Forward, start_pos);
    result.flags |= VimMotionFlag_VisualBlockForceToLineEnd;
    return result;
}

static Vim_Motion_Result
vim_motion_scope_internal(Application_Links* app,
                          View_ID view,
                          Buffer_ID buffer,
                          i64 start_pos,
                          i32 motion_count,
                          b32 motion_count_was_set,
                          b32 unlimited_lookahead)
{


    Vim_Motion_Result result = vim_motion_inclusive(start_pos);
    result.flags |= (VimMotionFlag_IsJump|
                     VimMotionFlag_SetPreferredX);

    Token_Array token_array = get_token_array_from_buffer(app, buffer);
    if (token_array.count > 0) {
        Token_Base_Kind opening_token = TokenBaseKind_EOF;
        Range_i64 line_range = get_line_pos_range(app, buffer, get_line_number_from_pos(app, buffer, start_pos));
        Token_Iterator_Array it = token_iterator_pos(0, &token_array, start_pos);

        b32 scan_forward = true;
        while (opening_token == TokenBaseKind_EOF) {
            Token* token = token_it_read(&it);

            if (!token) {
                break;
            }

            if (unlimited_lookahead || range_contains_inclusive(line_range, token->pos + token->size)) {
                if (token->kind == TokenBaseKind_ScopeOpen ||
                    token->kind == TokenBaseKind_ParentheticalOpen ||
                    token->kind == TokenBaseKind_ScopeClose ||
                    token->kind == TokenBaseKind_ParentheticalClose)
                {
                    opening_token = token->kind;
                } else {
                    scan_forward ? token_it_inc(&it) : token_it_dec(&it);
                }
            } else {
                if (opening_token == TokenBaseKind_EOF && scan_forward) {
                    scan_forward = false;
                    token_it_dec(&it);
                } else {
                    break;
                }
            }
        }

        if (opening_token != TokenBaseKind_EOF) {
            scan_forward = (opening_token == TokenBaseKind_ScopeOpen || opening_token == TokenBaseKind_ParentheticalOpen);

            Token_Base_Kind closing_token = TokenBaseKind_EOF;
            if (opening_token == TokenBaseKind_ParentheticalOpen) closing_token = TokenBaseKind_ParentheticalClose;
            if (opening_token == TokenBaseKind_ParentheticalClose) closing_token = TokenBaseKind_ParentheticalOpen;
            if (opening_token == TokenBaseKind_ScopeOpen) closing_token = TokenBaseKind_ScopeClose;
            if (opening_token == TokenBaseKind_ScopeClose) closing_token = TokenBaseKind_ScopeOpen;

            i32 scope_depth = 1;
            for (;;) {
                b32 tokens_left = scan_forward ? token_it_inc(&it) : token_it_dec(&it);
                if (tokens_left) {
                    Token* token = token_it_read(&it);

                    if (token->kind == opening_token) {
                        scope_depth++;
                    } else if (token->kind == closing_token) {
                        scope_depth--;
                    }

                    if (scope_depth == 0) {
                        i64 end_pos = token->pos;
                        if (scan_forward) {
                            end_pos += token->size - 1;
                        }

                        result.seek_pos = end_pos;

                        break;
                    }
                } else {
                    break;
                }
            }
        }
    }

    return result;
}

static
Vim_Motion_Result vim_motion_scope(Application_Links* app, View_ID view, Buffer_ID buffer, i64 start_pos, i32 motion_count, b32 motion_count_was_set) {
    return vim_motion_scope_internal(app, view, buffer, start_pos, motion_count, motion_count_was_set, false);
}

static
Vim_Motion_Result vim_motion_scope_unlimited_lookahead(Application_Links* app, View_ID view, Buffer_ID buffer, i64 start_pos, i32 motion_count, b32 motion_count_was_set) {
    return vim_motion_scope_internal(app, view, buffer, start_pos, motion_count, motion_count_was_set, true);
}

static
Vim_Text_Object_Result vim_text_object_line(Application_Links* app, View_ID view, Buffer_ID buffer, i64 start_pos, i32 motion_count, b32 motion_count_was_set) {
    Vim_Text_Object_Result result = vim_text_object_linewise(start_pos);
    return result;
}

static
Vim_Text_Object_Result vim_text_object_inner_line(Application_Links* app, View_ID view, Buffer_ID buffer, i64 start_pos, i32 motion_count, b32 motion_count_was_set) {
    Vim_Text_Object_Result result = vim_text_object(start_pos);
    result.range.min = get_pos_past_lead_whitespace(app, buffer, start_pos);
    result.range.max = get_line_end_pos_from_pos(app, buffer, start_pos);
    return result;
}

static b32
vim_find_surrounding_nest(Application_Links *app,
                          Buffer_ID buffer,
                          i64 pos,
                          Find_Nest_Flag flags,
                          Range_i64 *out,
                          b32 inner)
{
    b32 result = false;
    Range_i64 range = {};

    u32 min_flags = flags|FindNest_Balanced;
    u32 max_flags = flags|FindNest_Balanced|FindNest_EndOfToken;
    if (inner) {
        do { u32 hidden_temp_2748 = min_flags; min_flags = max_flags; max_flags = hidden_temp_2748; } while(0);
    }

    if (find_nest_side(app, buffer, pos, min_flags, Scan_Backward, NestDelim_Open, &range.start) &&
        find_nest_side(app, buffer, range.start, max_flags, Scan_Forward, NestDelim_Close, &range.end))
    {
        if (inner && range_size(range) > 0) {
            range.max--;
        }
        *out = range;
        result = true;
    }

    return result;
}

static Vim_Text_Object_Result
vim_text_object_inner_nest_internal(Application_Links* app,
                                    View_ID view,
                                    Buffer_ID buffer,
                                    i64 start_pos,
                                    Find_Nest_Flag flags,
                                    b32 leave_inner_line,
                                    b32 select_inner_block)
{

    Vim_Text_Object_Result result = vim_text_object(start_pos);

    if (find_surrounding_nest(app, buffer, start_pos, flags, &result.range)) {
        i64 min = result.range.min;
        i64 max = result.range.max;
        i64 min_inner = result.range.min + 1;
        i64 max_inner = result.range.max - 1;
        i64 min_line = get_line_number_from_pos(app, buffer, min);
        i64 max_line = get_line_number_from_pos(app, buffer, max);
        result.range = Ii64(min_inner, max_inner);
        if (min_line != max_line) {
            Scratch_Block scratch(app);
            String_Const_u8 left_of_max = push_buffer_range(app, scratch, buffer, Ii64(get_line_start_pos(app, buffer, max_line), max_inner));
            if (!leave_inner_line && (!left_of_max.size || string_find_first_non_whitespace(left_of_max) == left_of_max.size)) {
                result.range.max = get_line_start_pos(app, buffer, max_line);
            }
            if ((max_line - 1) > min_line) {
                if (select_inner_block) {
                    result.range.min = get_line_start_pos(app, buffer, min_line + 1);
                } else if (leave_inner_line) {
                    result.range.min = get_pos_past_lead_whitespace_from_line_number(app, buffer, min_line + 1);
                }
            }
        }
    }

    return result;
}





static
Vim_Text_Object_Result vim_text_object_inner_scope_delete(Application_Links* app, View_ID view, Buffer_ID buffer, i64 start_pos, i32 motion_count, b32 motion_count_was_set) {
    return vim_text_object_inner_nest_internal(app, view, buffer, start_pos, FindNest_Scope, false, false);
}

static
Vim_Text_Object_Result vim_text_object_inner_scope(Application_Links* app, View_ID view, Buffer_ID buffer, i64 start_pos, i32 motion_count, b32 motion_count_was_set) {
    return vim_text_object_inner_nest_internal(app, view, buffer, start_pos, FindNest_Scope, false, true);
}





static
Vim_Text_Object_Result vim_text_object_inner_paren_delete(Application_Links* app, View_ID view, Buffer_ID buffer, i64 start_pos, i32 motion_count, b32 motion_count_was_set) {
    return vim_text_object_inner_nest_internal(app, view, buffer, start_pos, FindNest_Paren, true, false);
}

static
Vim_Text_Object_Result vim_text_object_inner_paren(Application_Links* app, View_ID view, Buffer_ID buffer, i64 start_pos, i32 motion_count, b32 motion_count_was_set) {
    return vim_text_object_inner_nest_internal(app, view, buffer, start_pos, FindNest_Paren, false, true);
}

static
Vim_Text_Object_Result vim_text_object_inner_double_quotes(Application_Links* app, View_ID view, Buffer_ID buffer, i64 start_pos, i32 motion_count, b32 motion_count_was_set) {
    Vim_Text_Object_Result result = vim_text_object(start_pos);
    result.range = enclose_pos_inside_quotes(app, buffer, start_pos);
    return result;
}

static i64
vim_boundary_inside_single_quotes(Application_Links *app,
                                  Buffer_ID buffer,
                                  Side side,
                                  Scan_Direction direction,
                                  i64 pos)
{
    static Character_Predicate predicate = {};
    static b32 first_call = true;
    if (first_call) {
        first_call = false;
        predicate = character_predicate_from_character((u8)'\'');
        predicate = character_predicate_not(&predicate);
    }
    return boundary_predicate(app, buffer, side, direction, pos, &predicate);
}

static Range_i64
enclose_pos_inside_single_quotes(Application_Links *app, Buffer_ID buffer, i64 pos) {
    return enclose_boundary(app, buffer, Ii64(pos), vim_boundary_inside_single_quotes);
}

static
Vim_Text_Object_Result vim_text_object_inner_single_quotes(Application_Links* app, View_ID view, Buffer_ID buffer, i64 start_pos, i32 motion_count, b32 motion_count_was_set) {
    Vim_Text_Object_Result result = vim_text_object(start_pos);
    result.range = enclose_pos_inside_single_quotes(app, buffer, start_pos);
    return result;
}

static
Vim_Text_Object_Result vim_text_object_inner_word(Application_Links* app, View_ID view, Buffer_ID buffer, i64 start_pos, i32 motion_count, b32 motion_count_was_set) {
    Vim_Text_Object_Result result = vim_text_object(start_pos);
    result.range = enclose_boundary(app, buffer, Ii64(start_pos + 1), vim_boundary_word);
    return result;
}

enum Vim_Character_Seek_Flag {
    VimCharacterSeek_Pair = 0x1,
    VimCharacterSeek_Till = 0x2,
    VimCharacterSeek_CaseSensitive = 0x4,
    VimCharacterSeek_Repeat = 0x8,
};

static i64
vim_character_seek(Application_Links* app,
                   View_ID view,
                   Buffer_ID buffer,
                   i64 start_pos,
                   String_Const_u8 target,
                   Scan_Direction dir,
                   u32 flags)
{
    i64 result = start_pos;

    b32 till = (((flags)&(VimCharacterSeek_Till))!=0);
    b32 case_sensitive = (((flags)&(VimCharacterSeek_CaseSensitive))!=0);

    b32 new_input = true;
    if (!target.size) {
        new_input = false;
        target = vim_state.most_recent_character_seek.string;
    }

    if (target.size) {
        i64 seek_pos = start_pos;
        for (;;) {
            String_Match match = buffer_seek_string(app, buffer, target, dir, seek_pos + (till ? dir : 0));
            if (match.buffer != buffer) {
                break;
            }
            if (!case_sensitive || (((match.flags)&(StringMatch_CaseSensitive))!=0)) {
                if (dir == Scan_Forward) {
                    result = match.range.min + (till ? -1 : 0);
                } else {
                    result = match.range.max - 1 + (till ? target.size : 0);
                }
                break;
            }
            if (case_sensitive) {

                seek_pos = match.range.min;
            }
        }

        if (new_input) {
            if (!vim_state.most_recent_character_seek.cap) {
                vim_state.most_recent_character_seek = Su8(vim_state.most_recent_character_seek_storage, 0, ((sizeof(vim_state.most_recent_character_seek_storage))/(sizeof(*vim_state.most_recent_character_seek_storage))));
            }
            block_copy(vim_state.most_recent_character_seek.str, target.str, (((vim_state.most_recent_character_seek.cap)<(target.size))?(vim_state.most_recent_character_seek.cap):(target.size)));
            vim_state.most_recent_character_seek.size = target.size;

            vim_state.character_seek_highlight_dir = dir;
            vim_state.most_recent_character_seek_dir = dir;
            vim_state.most_recent_character_seek_flags = flags;
        }
    }

    return result;
}

static Vim_Motion_Result vim_motion_repeat_character_seek_same_direction(Application_Links* app, View_ID view, Buffer_ID buffer, i64 start_pos, i32 motion_count, b32 motion_count_was_set);
static Vim_Motion_Result vim_motion_repeat_character_seek_reverse_direction(Application_Links* app, View_ID view, Buffer_ID buffer, i64 start_pos, i32 motion_count, b32 motion_count_was_set);

static Vim_Motion_Result
vim_motion_character_seek_internal(Application_Links* app,
                                   View_ID view,
                                   Buffer_ID buffer,
                                   i32 motion_count,
                                   i64 start_pos,
                                   Scan_Direction dir,
                                   u32 flags)
{
    Vim_Motion_Result result = vim_motion(start_pos);
    result.style = (dir == Scan_Forward) ? VimRangeStyle_Inclusive : VimRangeStyle_Exclusive;
    result.flags |= VimMotionFlag_SetPreferredX|
        VimMotionFlag_IsJump|
        VimMotionFlag_LogJumpPostSeek|
        VimMotionFlag_IgnoreMotionCount;

    u8 target_storage[8];
    String_u8 target = Su8(target_storage, 0, ((sizeof(target_storage))/(sizeof(*target_storage))));

    if ((((flags)&(VimCharacterSeek_Repeat))!=0)) {
        target = vim_state.most_recent_character_seek;
    } else {
        string_append(&target, vim_get_next_writable(app));
        if ((((flags)&(VimCharacterSeek_Pair))!=0)) {
            string_append(&target, vim_get_next_writable(app));
        }
    }

    vim_state.character_seek_show_highlight = !vim_state.executing_queried_motion;

    result.seek_pos = vim_character_seek(app, view, buffer, start_pos, target.string, dir, flags);
    for (i32 i = 1; i < motion_count; ++i) {
        result = vim_motion_repeat_character_seek_same_direction(app, view, buffer, result.seek_pos, 1, false);
    }

    return result;
}

static
Vim_Motion_Result vim_motion_find_character(Application_Links* app, View_ID view, Buffer_ID buffer, i64 start_pos, i32 motion_count, b32 motion_count_was_set) {
    Vim_Motion_Result result = vim_motion_character_seek_internal(app, view, buffer, motion_count, start_pos, Scan_Forward, 0);
    return result;
}

static
Vim_Motion_Result vim_motion_to_character(Application_Links* app, View_ID view, Buffer_ID buffer, i64 start_pos, i32 motion_count, b32 motion_count_was_set) {
    Vim_Motion_Result result = vim_motion_character_seek_internal(app, view, buffer, motion_count, start_pos, Scan_Forward, VimCharacterSeek_Till);
    return result;
}

static
Vim_Motion_Result vim_motion_find_character_backward(Application_Links* app, View_ID view, Buffer_ID buffer, i64 start_pos, i32 motion_count, b32 motion_count_was_set) {
    Vim_Motion_Result result = vim_motion_character_seek_internal(app, view, buffer, motion_count, start_pos, Scan_Backward, 0);
    return result;
}

static
Vim_Motion_Result vim_motion_to_character_backward(Application_Links* app, View_ID view, Buffer_ID buffer, i64 start_pos, i32 motion_count, b32 motion_count_was_set) {
    Vim_Motion_Result result = vim_motion_character_seek_internal(app, view, buffer, motion_count, start_pos, Scan_Backward, VimCharacterSeek_Till);
    return result;
}

static
Vim_Motion_Result vim_motion_find_character_pair(Application_Links* app, View_ID view, Buffer_ID buffer, i64 start_pos, i32 motion_count, b32 motion_count_was_set) {
    Vim_Motion_Result result = vim_motion_character_seek_internal(app, view, buffer, motion_count, start_pos, Scan_Forward, VimCharacterSeek_Pair);
    return result;
}

static
Vim_Motion_Result vim_motion_find_character_pair_backward(Application_Links* app, View_ID view, Buffer_ID buffer, i64 start_pos, i32 motion_count, b32 motion_count_was_set) {
    Vim_Motion_Result result = vim_motion_character_seek_internal(app, view, buffer, motion_count, start_pos, Scan_Backward, VimCharacterSeek_Pair);
    return result;
}

static
Vim_Motion_Result vim_motion_find_character_case_sensitive(Application_Links* app, View_ID view, Buffer_ID buffer, i64 start_pos, i32 motion_count, b32 motion_count_was_set) {
    Vim_Motion_Result result = vim_motion_character_seek_internal(app, view, buffer, motion_count, start_pos, Scan_Forward, VimCharacterSeek_CaseSensitive);
    return result;
}

static
Vim_Motion_Result vim_motion_to_character_case_sensitive(Application_Links* app, View_ID view, Buffer_ID buffer, i64 start_pos, i32 motion_count, b32 motion_count_was_set) {
    Vim_Motion_Result result = vim_motion_character_seek_internal(app, view, buffer, motion_count, start_pos, Scan_Forward, VimCharacterSeek_Till|VimCharacterSeek_CaseSensitive);
    return result;
}

static
Vim_Motion_Result vim_motion_find_character_backward_case_sensitive(Application_Links* app, View_ID view, Buffer_ID buffer, i64 start_pos, i32 motion_count, b32 motion_count_was_set) {
    Vim_Motion_Result result = vim_motion_character_seek_internal(app, view, buffer, motion_count, start_pos, Scan_Backward, VimCharacterSeek_CaseSensitive);
    return result;
}

static
Vim_Motion_Result vim_motion_to_character_backward_case_sensitive(Application_Links* app, View_ID view, Buffer_ID buffer, i64 start_pos, i32 motion_count, b32 motion_count_was_set) {
    Vim_Motion_Result result = vim_motion_character_seek_internal(app, view, buffer, motion_count, start_pos, Scan_Backward, VimCharacterSeek_Till|VimCharacterSeek_CaseSensitive);
    return result;
}

static
Vim_Motion_Result vim_motion_find_character_pair_case_sensitive(Application_Links* app, View_ID view, Buffer_ID buffer, i64 start_pos, i32 motion_count, b32 motion_count_was_set) {
    Vim_Motion_Result result = vim_motion_character_seek_internal(app, view, buffer, motion_count, start_pos, Scan_Forward, VimCharacterSeek_Pair|VimCharacterSeek_CaseSensitive);
    return result;
}

static
Vim_Motion_Result vim_motion_find_character_pair_backward_case_sensitive(Application_Links* app, View_ID view, Buffer_ID buffer, i64 start_pos, i32 motion_count, b32 motion_count_was_set) {
    Vim_Motion_Result result = vim_motion_character_seek_internal(app, view, buffer, motion_count, start_pos, Scan_Backward, VimCharacterSeek_Pair|VimCharacterSeek_CaseSensitive);
    return result;
}

static
Vim_Motion_Result vim_motion_repeat_character_seek_same_direction(Application_Links* app, View_ID view, Buffer_ID buffer, i64 start_pos, i32 motion_count, b32 motion_count_was_set) {
    Scan_Direction dir = vim_state.most_recent_character_seek_dir;
    vim_state.character_seek_show_highlight = !vim_state.executing_queried_motion;
    vim_state.character_seek_highlight_dir = dir;
    Vim_Motion_Result result = vim_motion_character_seek_internal(app, view, buffer, motion_count, start_pos, dir, vim_state.most_recent_character_seek_flags|VimCharacterSeek_Repeat);
    return result;
}

static
Vim_Motion_Result vim_motion_repeat_character_seek_reverse_direction(Application_Links* app, View_ID view, Buffer_ID buffer, i64 start_pos, i32 motion_count, b32 motion_count_was_set) {

    Scan_Direction original_dir = vim_state.most_recent_character_seek_dir;
    Scan_Direction dir = -original_dir;
    vim_state.character_seek_show_highlight = !vim_state.executing_queried_motion;
    vim_state.character_seek_highlight_dir = dir;
    Vim_Motion_Result result = vim_motion_character_seek_internal(app, view, buffer, motion_count, start_pos, dir, vim_state.most_recent_character_seek_flags|VimCharacterSeek_Repeat);
    vim_state.most_recent_character_seek_dir = original_dir;
    return result;
}

static i64
vim_seek_blank_line(Application_Links *app, Scan_Direction direction, Position_Within_Line position) {
    View_ID view = get_active_view(app, Access_ReadVisible);
    Buffer_ID buffer = view_get_buffer(app, view, Access_ReadVisible);
    i64 pos = view_get_cursor_pos(app, view);
    i64 new_pos = get_pos_of_blank_line_grouped(app, buffer, direction, pos);
    switch (position) {
        case PositionWithinLine_SkipLeadingWhitespace: {
            new_pos = get_pos_past_lead_whitespace(app, buffer, new_pos);
        } break;
        case PositionWithinLine_End: {
            new_pos = get_line_side_pos_from_pos(app, buffer, new_pos, Side_Max);
        } break;
    }
    new_pos = view_get_character_legal_pos_from_pos(app, view, new_pos);
    return new_pos;
}

static
Vim_Motion_Result vim_motion_to_empty_line_up(Application_Links* app, View_ID view, Buffer_ID buffer, i64 start_pos, i32 motion_count, b32 motion_count_was_set) {

    Vim_Motion_Result result = vim_motion(start_pos);
    result.seek_pos = vim_seek_blank_line(app, Scan_Backward, PositionWithinLine_Start);
    return result;
}

static
Vim_Motion_Result vim_motion_to_empty_line_down(Application_Links* app, View_ID view, Buffer_ID buffer, i64 start_pos, i32 motion_count, b32 motion_count_was_set) {
    Vim_Motion_Result result = vim_motion(start_pos);
    result.seek_pos = vim_seek_blank_line(app, Scan_Forward, PositionWithinLine_Start);
    return result;
}

static
Vim_Motion_Result vim_motion_prior_to_empty_line_up(Application_Links* app, View_ID view, Buffer_ID buffer, i64 start_pos, i32 motion_count, b32 motion_count_was_set) {
    Vim_Motion_Result result = vim_motion(start_pos);
    result.seek_pos = vim_seek_blank_line(app, Scan_Backward, PositionWithinLine_Start);

    Range_i64 line_range = get_line_range_from_pos_range(app, buffer, Ii64(start_pos, result.seek_pos));
    if (line_range.min != line_range.max) {
        result.seek_pos = get_line_start_pos(app, buffer, line_range.min + 1);
    }

    return result;
}

static
Vim_Motion_Result vim_motion_prior_to_empty_line_down(Application_Links* app, View_ID view, Buffer_ID buffer, i64 start_pos, i32 motion_count, b32 motion_count_was_set) {
    Vim_Motion_Result result = vim_motion(start_pos);
    result.seek_pos = vim_seek_blank_line(app, Scan_Forward, PositionWithinLine_Start);

    Range_i64 line_range = get_line_range_from_pos_range(app, buffer, Ii64(start_pos, result.seek_pos));
    if (line_range.min != line_range.max) {
        result.seek_pos = get_line_end_pos(app, buffer, line_range.max - 1);
    }

    return result;
}

static Range_i64
vim_search_once_internal(Application_Links* app,
                         View_ID view,
                         Buffer_ID buffer,
                         Scan_Direction direction,
                         i64 pos,
                         String_Const_u8 query,
                         u32 flags,
                         b32 wrapped = false)
{
    Range_i64 result = Ii64();

    b32 found_match = false;
    i64 buffer_size = buffer_get_size(app, buffer);
    switch (direction) {
        case Scan_Forward: {
            i64 new_pos = 0;
            if ((((flags)&(VimSearchFlag_CaseSensitive))!=0)) {
                seek_string_forward(app, buffer, pos - 1, 0, query, &new_pos);
            } else {
                seek_string_insensitive_forward(app, buffer, pos - 1, 0, query, &new_pos);
            }
            if (new_pos < buffer_size) {
                result = Ii64(new_pos, new_pos + query.size);
                found_match = true;
            }
        } break;

        case Scan_Backward: {
            i64 new_pos = 0;
            if ((((flags)&(VimSearchFlag_CaseSensitive))!=0)) {
                seek_string_backward(app, buffer, pos + 1, 0, query, &new_pos);
            } else {
                seek_string_insensitive_backward(app, buffer, pos + 1, 0, query, &new_pos);
            }
            if (new_pos >= 0) {
                result = Ii64(new_pos, new_pos + query.size);
                found_match = true;
            }
        } break;
    }

    if (found_match && (((flags)&(VimSearchFlag_WholeWord))!=0)) {
        Range_i64 enclosing_word = enclose_alpha_numeric_underscore_utf8(app, buffer, result);
        if (enclosing_word.min != result.min || enclosing_word.max != result.max) {
            found_match = false;
            result = Ii64();
        }
    }

    if (!wrapped && !found_match) {
        switch (direction) {
            case Scan_Forward: { result = vim_search_once_internal(app, view, buffer, direction, 0, query, flags, true); } break;
            case Scan_Backward: { result = vim_search_once_internal(app, view, buffer, direction, buffer_size, query, flags, true); } break;
        }
    }

    return result;
}

static void
vim_search_once(Application_Links* app,
                View_ID view,
                Buffer_ID buffer,
                Scan_Direction direction,
                i64 pos,
                String_Const_u8 query,
                u32 flags,
                b32 log_jump,
                b32 always_jump)
{
    Range_i64 range = vim_search_once_internal(app, view, buffer, direction, pos, query, flags);
    i64 jump_target = pos;
    if (range_size(range) > 0) {
        jump_target = range.min;
        if (log_jump) {
            vim_log_jump_history(app);
            if (!always_jump) {
                view_set_cursor_and_preferred_x(app, view, seek_pos(jump_target));
            }
        }
    }
    if (always_jump) {
        view_set_cursor_and_preferred_x(app, view, seek_pos(jump_target));
    }
}

static void
vim_isearch_internal(Application_Links* app,
                     View_ID view,
                     Buffer_ID buffer,
                     Scan_Direction start_scan,
                     i64 first_pos,
                     String_Const_u8 query_init,
                     b32 search_immediately,
                     u32 mode_index)
{
    Scan_Direction scan = start_scan;
    i64 pos = first_pos;

    do{ if (!(mode_index < ((sizeof(vim_search_mode_cycle))/(sizeof(*vim_search_mode_cycle))))) { (*((i32*)0) = 0xA11E); } }while(0);
    vim_state.search_mode_index = mode_index;
    vim_state.search_flags = vim_search_mode_cycle[vim_state.search_mode_index];

    if (search_immediately) {
        vim_write_register(app, &vim_state.last_search_register, query_init);
        vim_search_once(app, view, buffer, scan, pos, query_init, vim_state.search_flags, true, false);
    } else {
        Query_Bar_Group group(app);
        Query_Bar bar = {};
        if (!start_query_bar(app, &bar, 0)) {
            return;
        }

        u8 bar_string_space[256];
        bar.string = SCu8(bar_string_space, query_init.size);
        block_copy(bar.string.str, query_init.str, query_init.size);

        User_Input in = {};
        for (;;) {
            if (scan == Scan_Forward) {
                bar.prompt = vim_search_mode_prompt_forward[vim_state.search_mode_index];
            } else if (scan == Scan_Backward) {
                bar.prompt = vim_search_mode_prompt_reverse[vim_state.search_mode_index];
            }

            in = get_next_input(app, EventPropertyGroup_AnyKeyboardEvent, EventProperty_Escape|EventProperty_ViewActivation|EventProperty_Exit);
            if (in.abort) {
                break;
            }

            String_Const_u8 string = to_writable(&in);

            b32 string_change = false;
            if (match_key_code(&in, KeyCode_Tab)) {
                vim_state.search_mode_index++;
                if (vim_state.search_mode_index >= ((sizeof(vim_search_mode_cycle))/(sizeof(*vim_search_mode_cycle)))) {
                    vim_state.search_mode_index = 0;
                }
                vim_state.search_flags = vim_search_mode_cycle[vim_state.search_mode_index];
                continue;
            } else if (match_key_code(&in, KeyCode_Return)) {
                Input_Modifier_Set* mods = &in.event.key.modifiers;
                if (has_modifier(mods, KeyCode_Control)) {
                    bar.string = vim_read_register(app, &vim_state.last_search_register);
                    string_change = true;
                } else {
                    Managed_Scope scope = view_get_managed_scope(app, view);
                    Vim_View_Attachment* vim_view = ((Vim_View_Attachment*)managed_scope_get_attachment((app), (scope), (vim_view_attachment), sizeof(Vim_View_Attachment)));
                    vim_log_jump_history_internal(app, view, buffer, vim_view, first_pos);
                    vim_write_register(app, &vim_state.last_search_register, bar.string);
                    break;
                }
            } else if (string.str != 0 && string.size > 0) {
                String_u8 bar_string = Su8(bar.string, sizeof(bar_string_space));
                string_append(&bar_string, string);
                bar.string = bar_string.string;
                string_change = true;
            } else if (match_key_code(&in, KeyCode_Backspace)) {
                if (is_unmodified_key(&in.event)) {
                    u64 old_bar_string_size = bar.string.size;
                    bar.string = backspace_utf8(bar.string);
                    string_change = (bar.string.size < old_bar_string_size);
                } else if (has_modifier(&in.event.key.modifiers, KeyCode_Control)) {
                    if (bar.string.size > 0) {
                        string_change = true;
                        bar.string.size = 0;
                    }
                }
            }

            if (string_change) {
                vim_write_register(app, &vim_state.last_search_register, bar.string);
            }




            b32 do_scan_action = false;
            b32 do_scroll_wheel = false;
            Scan_Direction change_scan = scan;
            if (!string_change) {
                if (match_key_code(&in, KeyCode_PageDown) || match_key_code(&in, KeyCode_Down)) {
                    change_scan = Scan_Forward;
                    do_scan_action = true;
                }
                if (match_key_code(&in, KeyCode_PageUp) || match_key_code(&in, KeyCode_Up)) {
                    change_scan = Scan_Backward;
                    do_scan_action = true;
                }
            }

            if (string_change) {
                vim_search_once(app, view, buffer, scan, pos, bar.string, vim_state.search_flags, false, true);
            } else if (do_scan_action) {
                vim_search_once(app, view, buffer, change_scan, pos, bar.string, vim_state.search_flags, false, true);
            } else if (do_scroll_wheel) {
                mouse_wheel_scroll(app);
            } else {
                leave_current_input_unhandled(app);
            }
        }

        if (in.abort) {
            vim_write_register(app, &vim_state.last_search_register, SCu8());
            view_set_cursor_and_preferred_x(app, view, seek_pos(first_pos));
        }
    }
}

CUSTOM_COMMAND(vim_isearch, "lib/external/4coder-vimmish/4coder_vimmish.cpp", 3341, Normal) {
    View_ID view = get_active_view(app, Access_ReadVisible);
    Buffer_ID buffer = view_get_buffer(app, view, Access_ReadVisible);
    if (!buffer_exists(app, buffer)) {
        return;
    }

    vim_state.search_direction = Scan_Forward;
    vim_isearch_internal(app, view, buffer, vim_state.search_direction, view_get_cursor_pos(app, view) + vim_state.search_direction, SCu8(), false, 0);
}

CUSTOM_COMMAND(vim_isearch_backward, "lib/external/4coder-vimmish/4coder_vimmish.cpp", 3352, Normal) {
    View_ID view = get_active_view(app, Access_ReadVisible);
    Buffer_ID buffer = view_get_buffer(app, view, Access_ReadVisible);
    if (!buffer_exists(app, buffer)) {
        return;
    }

    vim_state.search_direction = Scan_Backward;
    vim_isearch_internal(app, view, buffer, vim_state.search_direction, view_get_cursor_pos(app, view) - vim_state.search_direction, SCu8(), false, 0);
}

static void
vim_isearch_repeat_internal(Application_Links* app, Scan_Direction repeat_direction, b32 skip_at_cursor) {
    View_ID view = get_active_view(app, Access_ReadVisible);
    Buffer_ID buffer = view_get_buffer(app, view, Access_ReadVisible);
    if (!buffer_exists(app, buffer)) {
        return;
    }

    Scan_Direction search_direction = vim_state.search_direction*repeat_direction;
    i64 start_pos = view_get_cursor_pos(app, view);
    if (skip_at_cursor) {
        start_pos += search_direction;
    }

    String_Const_u8 last_search = vim_read_register(app, &vim_state.last_search_register);
    Range_i64 range = vim_search_once_internal(app, view, buffer, search_direction, start_pos, last_search, vim_state.search_flags);

    if (range_size(range) > 0) {
        vim_log_jump_history(app);
        view_set_cursor_and_preferred_x(app, view, seek_pos(range.min));
        vim_state.search_show_highlight = true;
    }
}

CUSTOM_COMMAND(vim_isearch_repeat_forward, "lib/external/4coder-vimmish/4coder_vimmish.cpp", 3387, Normal) {
    vim_isearch_repeat_internal(app, Scan_Forward, true);
}

CUSTOM_COMMAND(vim_isearch_repeat_backward, "lib/external/4coder-vimmish/4coder_vimmish.cpp", 3391, Normal) {
    vim_isearch_repeat_internal(app, Scan_Backward, true);
}

static void
vim_isearch_selection_internal(Application_Links* app, Scan_Direction dir) {
    View_ID view = get_active_view(app, Access_ReadVisible);
    Buffer_ID buffer = view_get_buffer(app, view, Access_ReadVisible);
    if (!buffer_exists(app, buffer)) {
        return;
    }

    Range_i64 range;
    Vim_Visual_Selection selection = vim_get_selection(app, view, buffer);
    if (selection.kind != VimSelectionKind_Block && vim_selection_consume_line(app, buffer, &selection, &range, true)) {
        Scratch_Block scratch(app);
        String_Const_u8 query_init = push_buffer_range(app, scratch, buffer, range);

        vim_state.search_direction = dir;
        vim_isearch_internal(app, view, buffer, vim_state.search_direction, range.min, query_init, true, 3);
    }

    vim_enter_normal_mode(app);
}

CUSTOM_COMMAND(vim_isearch_selection, "lib/external/4coder-vimmish/4coder_vimmish.cpp", 3416, Normal) {
    vim_isearch_selection_internal(app, Scan_Forward);
}

CUSTOM_COMMAND(vim_reverse_isearch_selection, "lib/external/4coder-vimmish/4coder_vimmish.cpp", 3420, Normal) {
    vim_isearch_selection_internal(app, Scan_Backward);
}

CUSTOM_COMMAND(vim_isearch_word_under_cursor, "lib/external/4coder-vimmish/4coder_vimmish.cpp", 3424, Normal) {
    View_ID view = get_active_view(app, Access_ReadVisible);
    Buffer_ID buffer = view_get_buffer(app, view, Access_ReadVisible);

    Range_i64 range_under_cursor = enclose_pos_alpha_numeric_underscore_utf8(app, buffer, view_get_cursor_pos(app, view));

    Scratch_Block scratch(app);
    String_Const_u8 under_cursor = push_buffer_range(app, scratch, buffer, range_under_cursor);

    vim_state.search_direction = Scan_Forward;
    if (under_cursor.size) {
        vim_isearch_internal(app, view, buffer, vim_state.search_direction, range_under_cursor.min + vim_state.search_direction, under_cursor, true, 3);
    }
}

CUSTOM_COMMAND(vim_reverse_isearch_word_under_cursor, "lib/external/4coder-vimmish/4coder_vimmish.cpp", 3439, Normal) {
    View_ID view = get_active_view(app, Access_ReadVisible);
    Buffer_ID buffer = view_get_buffer(app, view, Access_ReadVisible);

    Range_i64 range_under_cursor = enclose_pos_alpha_numeric_underscore_utf8(app, buffer, view_get_cursor_pos(app, view));

    Scratch_Block scratch(app);
    String_Const_u8 under_cursor = push_buffer_range(app, scratch, buffer, range_under_cursor);

    vim_state.search_direction = Scan_Backward;
    if (under_cursor.size) {
        vim_isearch_internal(app, view, buffer, vim_state.search_direction, range_under_cursor.min + vim_state.search_direction, under_cursor, true, true);
    }
}



CUSTOM_COMMAND(noh, "lib/external/4coder-vimmish/4coder_vimmish.cpp", 3456, Normal) {
    vim_state.character_seek_show_highlight = false;
    vim_state.search_show_highlight = false;
}

enum Vim_Comment_Style {
    VimCommentStyle_NoIndent,
    VimCommentStyle_RangeIndent,
    VimCommentStyle_FullIndent,
};

enum Vim_Toggle_Comment_Mode {
    VimToggleComment_Auto,
    VimToggleComment_Comment,
    VimToggleComment_Uncomment,
};

static String_Const_u8 vim_cpp_line_comment = SCu8((u8*)("//"), (u64)(sizeof("//") - 1));

static b32
vim_line_comment_starts_at_position(Application_Links *app, Buffer_ID buffer, i64 pos, String_Const_u8 token) {
    b32 result = false;

    Scratch_Block scratch(app);
    String_Const_u8 text = push_buffer_range(app, scratch, buffer, Ii64(pos, pos + token.size));
    if (string_match(token, text)) {
        result = true;
    }

    return result;
}

static void
vim_toggle_line_comment_range(Application_Links* app,
                              Buffer_ID buffer,
                              Range_i64 line_range,
                              String_Const_u8 comment_token,
                              b32 comment_empty_lines,
                              Vim_Comment_Style style,
                              Vim_Toggle_Comment_Mode mode)
{
    Scratch_Block scratch(app);
    String_Const_u8 comment_token_with_space = push_u8_stringf(scratch, "%.*s ", (i32)(comment_token).size, (char*)(comment_token).str);

    if (range_size(line_range) == 0) {
        line_range.one_past_last++;
    }

    i64 lowest_comment_col = max_i64;
    Vim_Toggle_Comment_Mode detected_mode = VimToggleComment_Comment;
    for (i64 line = line_range.first; line < line_range.one_past_last; line++) {
        i64 line_start_pos = get_line_start_pos(app, buffer, line);
        i64 line_comment_pos = get_pos_past_lead_whitespace_from_line_number(app, buffer, line);
        i64 line_comment_col = (line_comment_pos - line_start_pos);

        if (!line_is_blank(app, buffer, line)) {
            lowest_comment_col = (((lowest_comment_col)<(line_comment_col))?(lowest_comment_col):(line_comment_col));
        }

        if (vim_line_comment_starts_at_position(app, buffer, line_comment_pos, comment_token)) {
            detected_mode = VimToggleComment_Uncomment;
        }
    }

    if (mode == VimToggleComment_Auto) {
        mode = detected_mode;
    }

    for (i64 line = line_range.first; line < line_range.one_past_last; line++) {
        i64 line_start_pos = get_line_start_pos(app, buffer, line);
        i64 line_comment_pos = get_pos_past_lead_whitespace_from_line_number(app, buffer, line);
        i64 line_comment_col = (line_comment_pos - line_start_pos);

        String_Const_u8 line_string = push_buffer_line(app, scratch, buffer, line);
        b32 line_is_empty = (string_find_first_non_whitespace(line_string) == line_string.size);

        if (mode == VimToggleComment_Comment) {
            if (comment_empty_lines || !line_is_empty) {
                i64 insert_col = 1;
                switch (style) {
                    case VimCommentStyle_NoIndent: {
                        insert_col += 0;
                    } break;

                    case VimCommentStyle_RangeIndent: {
                        insert_col += lowest_comment_col;
                    } break;

                    case VimCommentStyle_FullIndent: {
                        insert_col += line_comment_col;
                    } break;

                    default: {
                        (*((i32*)0) = 0xA11E);
                    } break;
                }
                Buffer_Cursor insert_cursor = buffer_compute_cursor(app, buffer, seek_line_col(line, insert_col));
                buffer_replace_range(app, buffer, Ii64(insert_cursor.pos), comment_token_with_space);
            }
        } else {
            do{ if (!(mode == VimToggleComment_Uncomment)) { (*((i32*)0) = 0xA11E); } }while(0);
            if (!line_is_empty && vim_line_comment_starts_at_position(app, buffer, line_comment_pos, comment_token)) {
                String_Const_u8 post_comment_string = string_skip(line_string, line_comment_col + comment_token.size);
                u64 spaces_post_comment = string_find_first_non_whitespace(post_comment_string);
                buffer_replace_range(app, buffer, Ii64_size(line_comment_pos, comment_token.size + (((1)<(spaces_post_comment))?(1):(spaces_post_comment))), SCu8());
            }
        }
    }
}

static void
vim_toggle_line_comment_internal(Application_Links* app,
                                 View_ID view,
                                 Buffer_ID buffer,
                                 Vim_Visual_Selection selection,
                                 i32 count,
                                 b32 comment_empty_lines,
                                 Vim_Comment_Style style,
                                 Vim_Toggle_Comment_Mode mode)
{
    i64 line = get_line_number_from_pos(app, buffer, view_get_cursor_pos(app, view));
    Range_i64 line_range = Ii64(line, line + count);

    if (selection.kind) {
        line_range = Ii64(selection.first_line, selection.one_past_last_line);
    }

    vim_toggle_line_comment_range(app, buffer, line_range, vim_cpp_line_comment, comment_empty_lines, style, mode);
}

static
void vim_toggle_line_comment_no_indent_style(Application_Links* app, struct Vim_Operator_State* state, View_ID view, Buffer_ID buffer, Vim_Visual_Selection selection, i32 count, b32 count_was_set) {
    Vim_Comment_Style style = VimCommentStyle_NoIndent;
    Vim_Toggle_Comment_Mode mode = VimToggleComment_Auto;

    b32 comment_empty_lines = false;
    vim_toggle_line_comment_internal(app, view, buffer, selection, count, comment_empty_lines, style, mode);
}

static
void vim_toggle_line_comment_range_indent_style(Application_Links* app, struct Vim_Operator_State* state, View_ID view, Buffer_ID buffer, Vim_Visual_Selection selection, i32 count, b32 count_was_set) {
    Vim_Comment_Style style = VimCommentStyle_RangeIndent;
    Vim_Toggle_Comment_Mode mode = VimToggleComment_Auto;

    b32 comment_empty_lines = false;
    vim_toggle_line_comment_internal(app, view, buffer, selection, count, comment_empty_lines, style, mode);
}

static
void vim_toggle_line_comment_full_indent_style(Application_Links* app, struct Vim_Operator_State* state, View_ID view, Buffer_ID buffer, Vim_Visual_Selection selection, i32 count, b32 count_was_set) {
    Vim_Comment_Style style = VimCommentStyle_FullIndent;
    Vim_Toggle_Comment_Mode mode = VimToggleComment_Auto;

    b32 comment_empty_lines = false;
    vim_toggle_line_comment_internal(app, view, buffer, selection, count, comment_empty_lines, style, mode);
}

static void
vim_write_text(Application_Links *app, String_Const_u8 insert) {

    if (insert.str != 0 && insert.size > 0){
        View_ID view = get_active_view(app, Access_ReadWriteVisible);
        if_view_has_highlighted_range_delete_range(app, view);

        i64 pos = view_get_cursor_pos(app, view);
        pos = view_get_character_legal_pos_from_pos(app, view, pos);

        Buffer_ID buffer = view_get_buffer(app, view, Access_ReadWriteVisible);

        if (buffer_replace_range(app, buffer, Ii64(pos), insert)) {
            view_set_cursor_and_preferred_x(app, view, seek_pos(pos + insert.size));
        }
    }
}

static void
vim_write_text_and_auto_indent_internal(Application_Links* app, String_Const_u8 insert) {
    Profile_Scope_Block profile_block_3633 ((app), SCu8((u8*)("write and auto indent"), (u64)(sizeof("write and auto indent") - 1)), SCu8((u8*)("lib/external/4coder-vimmish/4coder_vimmish.cpp" ":" "3633" ":"), (u64)(sizeof("lib/external/4coder-vimmish/4coder_vimmish.cpp" ":" "3633" ":") - 1)));
    if (insert.str != 0 && insert.size > 0){
        b32 do_auto_indent = false;
        for (u64 i = 0; !do_auto_indent && i < insert.size; i += 1){
            switch (insert.str[i]){
                case ';': case ':':
                case '{': case '}':
                case '(': case ')':
                case '[': case ']':
                case '#':
                case '\n': case '\t':
                {
                    do_auto_indent = true;
                }break;
            }
        }
        if (do_auto_indent){
            View_ID view = get_active_view(app, Access_ReadWriteVisible);
            Buffer_ID buffer = view_get_buffer(app, view, Access_ReadWriteVisible);
            Range_i64 pos = {};
            pos.min = view_get_cursor_pos(app, view);
            write_text(app, insert);
            pos.max= view_get_cursor_pos(app, view);
            auto_indent_buffer(app, buffer, pos, 0);
            move_past_lead_whitespace(app, view, buffer);
        }
        else{
            write_text(app, insert);
        }
    }
}

static void
vim_write_text_and_auto_indent_internal_experimental(Application_Links* app, String_Const_u8 insert, i64 reference_line = -1) {



    if (insert.str != 0 && insert.size > 0) {
        b32 do_auto_indent = false;
        b32 preprocessor = false;
        b32 open_new_line = false;
        for (u64 i = 0; !do_auto_indent && i < insert.size; i += 1) {
            switch (insert.str[i]) {

                case '}':
                case ':': {
                    do_auto_indent = true;
                } break;

                case '\n': {
                    do_auto_indent = true;
                    open_new_line = true;
                } break;

                case '#': {
                    do_auto_indent = true;
                    preprocessor = true;
                } break;
            }
        }
        View_ID view = get_active_view(app, Access_ReadWriteVisible);
        Buffer_ID buffer = view_get_buffer(app, view, Access_ReadWriteVisible);
        if (do_auto_indent) {
            Range_i64 pos = {};
            pos.min = view_get_cursor_pos(app, view);
            i64 line = reference_line;
            if (line < 1) {
                line = get_line_number_from_pos(app, buffer, pos.min);
            }
            Scratch_Block scratch(app);
            String_Const_u8 line_string = push_buffer_line(app, scratch, buffer, line);
            vim_write_text(app, insert);
            pos.max = view_get_cursor_pos(app, view);

            if (open_new_line || preprocessor) {


                i64 first_non_whitespace = string_find_first_non_whitespace(line_string);
                String_Const_u8 indent_string = string_prefix(line_string, first_non_whitespace);
                String_Const_u8 remainder_string = string_postfix(line_string, line_string.size - first_non_whitespace);
                if (open_new_line) {
                    b32 full_auto_indent = false;
                    if (!line_string.size || indent_string.size == line_string.size || line_string.str[0] == '#') {
                        full_auto_indent = true;
                    } else {
                        b32 line_contains_open_scope = false;
                        u8 last_char_on_line = 0;
                        for (u8* c = line_string.str + line_string.size - 1; c > line_string.str; --c) {
                            if (character_is_alpha_numeric(*c)) {
                                last_char_on_line = *c;
                                break;
                            }
                        }
                        switch (line_string.str[line_string.size - 1]) {
                            case '{':
                            case '[':
                            case '(': {
                                line_contains_open_scope = true;
                            } break;
                        }
                        if (line_contains_open_scope) {
                            full_auto_indent = true;
                        }
                    }

                    if (full_auto_indent) {
                        auto_indent_buffer(app, buffer, pos);
                    } else {
                        i64 new_line = get_line_number_from_pos(app, buffer, pos.max);
                        i64 new_line_start_pos = get_line_start_pos(app, buffer, new_line);
                        buffer_replace_range(app, buffer, Ii64(new_line_start_pos), indent_string);

                        if (string_match(vim_cpp_line_comment, string_prefix(remainder_string, vim_cpp_line_comment.size))) {
                            vim_toggle_line_comment_range(app, buffer, Ii64(new_line), vim_cpp_line_comment, true, VimCommentStyle_FullIndent, VimToggleComment_Comment);
                        }

                    }
                } else {
                    do{ if (!(preprocessor)) { (*((i32*)0) = 0xA11E); } }while(0);
                    i64 line_start = get_line_start_pos(app, buffer, line);
                    buffer_replace_range(app, buffer, Ii64_size(line_start, indent_string.size), SCu8());
                }
                seek_end_of_textual_line(app);
            } else {
                auto_indent_buffer(app, buffer, pos);
                move_past_lead_whitespace(app, view, buffer);
            }
        } else {
            vim_write_text(app, insert);
        }
    }
}

CUSTOM_COMMAND(vim_move_line_down, "lib/external/4coder-vimmish/4coder_vimmish.cpp", 3766, Normal) {
    View_ID view = get_active_view(app, Access_ReadWriteVisible);
    Buffer_ID buffer = view_get_buffer(app, view, Access_ReadWriteVisible);

    if (!buffer_exists(app, buffer)) {
        return;
    }

    i64 line = get_line_number_from_pos(app, buffer, view_get_cursor_pos(app, view));
    move_line(app, buffer, line, Scan_Forward);
    move_down_textual(app);
}

CUSTOM_COMMAND(vim_move_up_textual, "lib/external/4coder-vimmish/4coder_vimmish.cpp", 3779, Normal)
CUSTOM_DOC("[vim] Moves up to the next line of actual text, regardless of line wrapping.")
{
    View_ID view = get_active_view(app, Access_ReadWriteVisible);
    i64 pos = view_get_cursor_pos(app, view);

    Buffer_Cursor cursor = view_compute_cursor(app, view, seek_pos(pos));
    i64 next_line = cursor.line - 1;
    view_set_cursor_and_preferred_x(app, view, seek_line_col(next_line, 1));
}

CUSTOM_COMMAND(vim_move_line_up, "lib/external/4coder-vimmish/4coder_vimmish.cpp", 3790, Normal) {
    View_ID view = get_active_view(app, Access_ReadWriteVisible);
    Buffer_ID buffer = view_get_buffer(app, view, Access_ReadWriteVisible);

    if (!buffer_exists(app, buffer)) {
        return;
    }

    i64 line = get_line_number_from_pos(app, buffer, view_get_cursor_pos(app, view));
    move_line(app, buffer, line, Scan_Backward);
    vim_move_up_textual(app);
}

static
Vim_Text_Object_Result vim_text_object_isearch_repeat_forward(Application_Links* app, View_ID view, Buffer_ID buffer, i64 start_pos, i32 motion_count, b32 motion_count_was_set) {
    Vim_Text_Object_Result result = vim_text_object(start_pos);

    i64 pos = view_get_cursor_pos(app, view);

    String_Const_u8 last_search = vim_read_register(app, &vim_state.last_search_register);
    result.range = vim_search_once_internal(app, view, buffer, vim_state.search_direction, pos, last_search, vim_state.search_flags);

    vim_state.search_show_highlight = true;

    return result;
}

static
Vim_Text_Object_Result vim_text_object_isearch_repeat_backward(Application_Links* app, View_ID view, Buffer_ID buffer, i64 start_pos, i32 motion_count, b32 motion_count_was_set) {
    Vim_Text_Object_Result result = vim_text_object(start_pos);

    i64 pos = view_get_cursor_pos(app, view);

    String_Const_u8 last_search = vim_read_register(app, &vim_state.last_search_register);
    result.range = vim_search_once_internal(app, view, buffer, -vim_state.search_direction, pos, last_search, vim_state.search_flags);

    vim_state.search_show_highlight = true;

    return result;
}

static
Vim_Motion_Result vim_motion_page_top(Application_Links* app, View_ID view, Buffer_ID buffer, i64 start_pos, i32 motion_count, b32 motion_count_was_set) {
    Vim_Motion_Result result = vim_motion_linewise(start_pos);

    i64 pos = view_get_cursor_pos(app, view);
    Buffer_Cursor start_cursor = view_compute_cursor(app, view, seek_pos(pos));

    Buffer_Scroll scroll = view_get_buffer_scroll(app, view);

    i64 line = scroll.position.line_number;
    Buffer_Cursor target_cursor = view_compute_cursor(app, view, seek_line_col(line, start_cursor.col));

    result.seek_pos = target_cursor.pos;
    return result;
}

static
Vim_Motion_Result vim_motion_page_mid(Application_Links* app, View_ID view, Buffer_ID buffer, i64 start_pos, i32 motion_count, b32 motion_count_was_set) {
    Vim_Motion_Result result = vim_motion_linewise(start_pos);

    i64 pos = view_get_cursor_pos(app, view);
    Buffer_Cursor cursor = view_compute_cursor(app, view, seek_pos(pos));

    Rect_f32 region = view_get_buffer_region(app, view);
    Vec2_f32 p = (region.p1 - region.p0) * .5f;

    i64 target_pos = view_pos_from_xy(app, view, p);
    Buffer_Cursor target_cursor = view_compute_cursor(app, view, seek_pos(target_pos));
    target_cursor = view_compute_cursor(app, view, seek_line_col(target_cursor.line, cursor.col));

    result.seek_pos = target_cursor.pos;
    return result;
}

static
Vim_Motion_Result vim_motion_page_bottom(Application_Links* app, View_ID view, Buffer_ID buffer, i64 start_pos, i32 motion_count, b32 motion_count_was_set) {
    Vim_Motion_Result result = vim_motion_linewise(start_pos);

    i64 pos = view_get_cursor_pos(app, view);
    Buffer_Cursor cursor = view_compute_cursor(app, view, seek_pos(pos));

    Rect_f32 region = view_get_buffer_region(app, view);
    Vec2_f32 p = region.p1 - region.p0;

    i64 target_pos = view_pos_from_xy(app, view, p);
    Buffer_Cursor target_cursor = view_compute_cursor(app, view, seek_pos(target_pos));
    target_cursor = view_compute_cursor(app, view, seek_line_col(target_cursor.line, cursor.col));

    result.seek_pos = target_cursor.pos;
    return result;
}

static b32
vim_get_operator_range(Vim_Operator_State* state, Range_i64* out_range, u32 flags = 0) {
    Application_Links* app = state->app;
    View_ID view = state->view;
    Buffer_ID buffer = state->buffer;

    b32 result = false;
    Range_i64 range = Ii64();

    if (state->op_count > 0) {
        result = true;
        if (state->selection.kind) {
            result = vim_selection_consume_line(app, buffer, &state->selection, &range, true);
            b32 trim_newlines = false;
            if (state->selection.kind == VimSelectionKind_Line) {
                trim_newlines = (((flags)&(VimOpFlag_ChangeBehaviour))!=0);
            } else if (state->selection.kind == VimSelectionKind_Block) {
                trim_newlines = true;
                if (result) {
                    state->op_count++;
                }
            }
            if (trim_newlines) {
                b32 did_trim = false;
                while (vim_character_is_newline(buffer_get_char(app, buffer, range.one_past_last - 1))) {
                    range.one_past_last = view_set_pos_by_character_delta(app, view, range.one_past_last, -1);
                    did_trim = true;
                }
                if (did_trim) {
                    ++range.one_past_last;
                }
            }
        } else if ((((flags)&(VimOpFlag_QueryMotion))!=0)) {
            if (!state->motion && !state->text_object) {
                i64 count_query = vim_query_number(app);
                state->motion_count = (i32)(((1)>(count_query))?(1):(((256)<(count_query))?(256):(count_query)));
                state->motion_count_was_set = (count_query != 0);

                Vim_Key_Binding* query = vim_query_binding(app, &vim_map_operator_pending, true);
                if (query) {
                    if (query->kind == VimBindingKind_Motion) {
                        state->motion = query->motion;
                    } else if (query->kind == VimBindingKind_TextObject) {
                        state->text_object = query->text_object;
                    }
                }

                Vim_Command_Rep* rep = vim_state.next_command_rep;
                if (rep->kind == VimCommandRep_Operator) {
                    rep->motion_count = state->motion_count;
                    rep->motion_count_was_set = state->motion_count_was_set;
                    rep->motion = state->motion;
                    rep->text_object = state->text_object;
                }
            }

            if (state->motion) {
                if ((((flags)&(VimOpFlag_ChangeBehaviour))!=0)) {

                    if (state->motion == vim_motion_word) state->motion = vim_motion_word_end;
                    else if (state->motion == vim_motion_to_empty_line_up) state->motion = vim_motion_prior_to_empty_line_up;
                    else if (state->motion == vim_motion_to_empty_line_down) state->motion = vim_motion_prior_to_empty_line_down;
                    else if (state->motion == vim_motion_to_empty_line_down) state->motion = vim_motion_prior_to_empty_line_down;
                }

                i64 pos = view_get_cursor_pos(app, view);

                vim_state.executing_queried_motion = true;
                Vim_Motion_Result mr = vim_execute_motion(app, view, buffer, state->motion, pos, state->motion_count, state->motion_count_was_set);
                vim_state.executing_queried_motion = false;
                range = mr.range_;

                if ((((mr.flags)&(VimMotionFlag_InvalidMotion))!=0)) {
                    result = false;
                }
                if ((((mr.flags)&(VimMotionFlag_AlwaysSeek))!=0)) {
                    vim_seek_motion_result(app, view, buffer, mr);
                }
            } else if (state->text_object) {
                i64 pos = view_get_cursor_pos(app, view);

                vim_state.executing_queried_motion = true;
                Vim_Text_Object_Result tor = vim_execute_text_object(app, view, buffer, state->text_object, pos, state->motion_count, state->motion_count_was_set);
                vim_state.executing_queried_motion = false;

                range = tor.range;
            } else {
                result = false;
            }
        } else {
            i64 pos = view_get_cursor_pos(app, view);
            range = Ii64(pos, view_set_pos_by_character_delta(app, view, pos, 1));
        }

        if (result) {
            state->total_range = range_union(state->total_range, range);
        }

        state->op_count--;
    }

    if (out_range) *out_range = range;
    return result;
}

static String_Const_u8
vim_cut_range(Application_Links* app, Arena* arena, View_ID view, Buffer_ID buffer, Range_i64 range) {
    String_Const_u8 result = push_buffer_range(app, arena, buffer, range);
    buffer_replace_range(app, buffer, range, SCu8());
    return result;
}

CUSTOM_COMMAND(vim_new_line_below, "lib/external/4coder-vimmish/4coder_vimmish.cpp", 3995, Normal) {
    View_ID view = get_active_view(app, Access_ReadWriteVisible);
    Buffer_ID buffer = view_get_buffer(app, view, Access_ReadWriteVisible);

    i64 pos = view_get_cursor_pos(app, view);
    i64 line = get_line_number_from_pos(app, buffer, pos);

    seek_end_of_textual_line(app);




    (void)line;
    vim_write_text_and_auto_indent_internal(app, SCu8((u8*)("\n"), (u64)(sizeof("\n") - 1)));

    vim_enter_insert_mode(app);
}

CUSTOM_COMMAND(vim_new_line_above, "lib/external/4coder-vimmish/4coder_vimmish.cpp", 4013, Normal) {
    View_ID view = get_active_view(app, Access_ReadWriteVisible);
    Buffer_ID buffer = view_get_buffer(app, view, Access_ReadWriteVisible);

    i64 pos = view_get_cursor_pos(app, view);
    i64 line = get_line_number_from_pos(app, buffer, pos);

    seek_beginning_of_textual_line(app);
    move_left(app);




    (void)line;
    vim_write_text_and_auto_indent_internal(app, SCu8((u8*)("\n"), (u64)(sizeof("\n") - 1)));

    vim_enter_insert_mode(app);
}

enum Vim_DCY {
    VimDCY_Delete,
    VimDCY_Change,
    VimDCY_Yank,
};

static void
vim_delete_change_or_yank(Application_Links* app,
                          Vim_Operator_State* state,
                          View_ID view,
                          Buffer_ID buffer,
                          Vim_Visual_Selection selection,
                          i32 count,
                          Vim_DCY mode,
                          Vim_Operator* op,
                          b32 query_motion,
                          Vim_Motion* motion = 0)
{

    Managed_Scope scope = buffer_get_managed_scope(app, buffer);
    Line_Ending_Kind* eol_setting = ((Line_Ending_Kind*)managed_scope_get_attachment((app), (scope), (buffer_eol_setting), sizeof(Line_Ending_Kind)));
    String_Const_u8 eol = (*eol_setting == LineEndingKind_CRLF ? SCu8("\r\n") : SCu8("\n"));

    b32 insert_final_newline = false;
    i64 prev_line = 0;

    b32 did_act = false;
    Range_i64 range = {};

    u32 op_flags = query_motion ? VimOpFlag_QueryMotion : 0;
    if (mode == VimDCY_Change) op_flags |= VimOpFlag_ChangeBehaviour;

    Scratch_Block scratch(app);
    List_String_Const_u8 yank_string_list = {};

    i64 cursor_start_pos = view_get_cursor_pos(app, view);
    Range_i64 total_line_range = Ii64_neg_inf;

    if (motion) {
        state->motion = motion;
    }

    while (vim_get_operator_range(state, &range, op_flags)) {
        Range_i64 line_range = get_line_range_from_pos_range(app, buffer, range);
        total_line_range = range_union(total_line_range, line_range);

        if (!did_act && range_size(range) > 0) {
            did_act = true;
        }

        i64 line = line_range.min;
        if (prev_line && prev_line != line && mode != VimDCY_Yank) {
            insert_final_newline = true;
            string_list_push(scratch, &yank_string_list, eol);
        }

        String_Const_u8 yank_string = SCu8();

        if (mode == VimDCY_Delete || mode == VimDCY_Change) {
            yank_string = vim_cut_range(app, scratch, view, buffer, range);
        } else {
            yank_string = push_buffer_range(app, scratch, buffer, range);
            vim_rel_move(app, seek_line_col(1, 0));
        }

        string_list_push(scratch, &yank_string_list, yank_string);

        prev_line = line;
    }

    if (insert_final_newline) {
        string_list_push(scratch, &yank_string_list, eol);
    }

    b32 from_block_copy = (selection.kind == VimSelectionKind_Block);

    String_Const_u8 yank_string;
    if (from_block_copy) {
        yank_string = string_list_flatten(scratch, yank_string_list, eol, StringSeparator_AfterLast, StringFill_NoTerminate);
    } else {
        yank_string = string_list_flatten(scratch, yank_string_list, StringFill_NoTerminate);
    }

    if (yank_string.size) {
        vim_write_register(app, vim_state.active_register, yank_string, from_block_copy);
    }

    b32 set_cursor = true;
    if (mode == VimDCY_Change && did_act) {
        if (selection.kind == VimSelectionKind_Line || selection.kind == VimSelectionKind_Block) {
            set_cursor = false;
            if (selection.kind == VimSelectionKind_Line) {
                auto_indent_line_at_cursor(app);
            }
            vim_enter_visual_insert_mode(app);
        } else {

            if (state->text_object == vim_text_object_inner_scope ||
                state->text_object == vim_text_object_inner_paren ||
                state->text_object == vim_text_object_line)
            {
                set_cursor = false;
                if ((state->text_object == vim_text_object_line) ||
                    (total_line_range.min != total_line_range.max))
                {
                    vim_new_line_above(app);
                }
            } else {

                if (mode != VimDCY_Yank) {
                    view_set_cursor_and_preferred_x(app, view, seek_pos(state->total_range.min));
                }
            }
            vim_enter_insert_mode(app);
        }
    }

    if (set_cursor && did_act && mode != VimDCY_Yank) {
        view_set_cursor_and_preferred_x(app, view, seek_pos(state->total_range.min));
    } else if (mode == VimDCY_Yank) {
        view_set_cursor_and_preferred_x(app, view, seek_pos(cursor_start_pos));
    }
}

static
void vim_delete(Application_Links* app, struct Vim_Operator_State* state, View_ID view, Buffer_ID buffer, Vim_Visual_Selection selection, i32 count, b32 count_was_set) {
    vim_delete_change_or_yank(app, state, view, buffer, selection, count, VimDCY_Delete, vim_delete, true);
}

static
void vim_delete_character(Application_Links* app, struct Vim_Operator_State* state, View_ID view, Buffer_ID buffer, Vim_Visual_Selection selection, i32 count, b32 count_was_set) {


    vim_delete_change_or_yank(app, state, view, buffer, selection, count, VimDCY_Delete, vim_delete_character, false);
}

static
void vim_change(Application_Links* app, struct Vim_Operator_State* state, View_ID view, Buffer_ID buffer, Vim_Visual_Selection selection, i32 count, b32 count_was_set) {
    vim_delete_change_or_yank(app, state, view, buffer, selection, count, VimDCY_Change, vim_change, true);
}

static
void vim_yank(Application_Links* app, struct Vim_Operator_State* state, View_ID view, Buffer_ID buffer, Vim_Visual_Selection selection, i32 count, b32 count_was_set) {
    vim_delete_change_or_yank(app, state, view, buffer, selection, count, VimDCY_Yank, vim_yank, true);
}

static
void vim_delete_eol(Application_Links* app, struct Vim_Operator_State* state, View_ID view, Buffer_ID buffer, Vim_Visual_Selection selection, i32 count, b32 count_was_set) {
    vim_delete_change_or_yank(app, state, view, buffer, selection, count, VimDCY_Delete, vim_delete, false, vim_motion_line_end_textual);
}

static
void vim_change_eol(Application_Links* app, struct Vim_Operator_State* state, View_ID view, Buffer_ID buffer, Vim_Visual_Selection selection, i32 count, b32 count_was_set) {
    vim_delete_change_or_yank(app, state, view, buffer, selection, count, VimDCY_Change, vim_change, false, vim_motion_line_end_textual);
}

static
void vim_yank_eol(Application_Links* app, struct Vim_Operator_State* state, View_ID view, Buffer_ID buffer, Vim_Visual_Selection selection, i32 count, b32 count_was_set) {


    vim_delete_change_or_yank(app, state, view, buffer, selection, count, VimDCY_Yank, vim_yank, false, vim_motion_line_end_textual);
}

static
void vim_replace(Application_Links* app, struct Vim_Operator_State* state, View_ID view, Buffer_ID buffer, Vim_Visual_Selection selection, i32 count, b32 count_was_set) {
    String_Const_u8 replace_char = vim_get_next_writable(app);

    Range_i64 range = {};
    while (vim_get_operator_range(state, &range)) {
        for (i64 replace_cursor = range.min; replace_cursor < range.max; replace_cursor++) {
            buffer_replace_range(app, buffer, Ii64(replace_cursor, view_set_pos_by_character_delta(app, view, replace_cursor, 1)), replace_char);
        }
    }
}

static void
vim_paste_internal(Application_Links* app, b32 post_cursor) {
    View_ID view = get_active_view(app, Access_ReadWriteVisible);

    String_Const_u8 paste_string = vim_read_register(app, vim_state.active_register);

    if (paste_string.size > 0) {
        Scratch_Block scratch(app);

        Buffer_ID buffer = view_get_buffer(app, view, Access_ReadWriteVisible);
        History_Group history = history_group_begin(app, buffer);

        Vim_Visual_Selection selection = vim_get_selection(app, view, buffer);

        b32 do_block_paste = (((vim_state.active_register->flags)&(VimRegisterFlag_FromBlockCopy))!=0) || (selection.kind == VimSelectionKind_Block);

        if (do_block_paste) {

            Line_Ending_Kind eol_kind = string_guess_line_ending_kind(paste_string);
            String_Const_u8 newline_needle = SCu8("\n");
            switch (eol_kind) {
                case LineEndingKind_CRLF: { newline_needle = SCu8((u8*)("\r\n"), (u64)(sizeof("\r\n") - 1)); } break;
                case LineEndingKind_LF: { newline_needle = SCu8((u8*)("\n"), (u64)(sizeof("\n") - 1)); } break;
            }

            List_String_Const_u8 paste_lines = string_split_needle(scratch, paste_string, newline_needle);
            List_String_Const_u8 replaced_string_list = {};

            u64 longest_line_size = 0;
            u32 newline_count = 0;
            for (Node_String_Const_u8* line = paste_lines.first; line; line = line->next) {
                longest_line_size = (((longest_line_size)>(line->string.size))?(longest_line_size):(line->string.size));
                if (string_match(line->string, newline_needle)) {
                    newline_count++;
                }
            }

            if (selection.kind == VimSelectionKind_None) {
                Buffer_Cursor cursor = buffer_compute_cursor(app, buffer, seek_pos(view_get_cursor_pos(app, view)));
                selection.kind = VimSelectionKind_Block;
                selection.first_line = cursor.line;
                selection.one_past_last_line = cursor.line + (((1)>(newline_count))?(1):(newline_count));
                selection.first_col = selection.one_past_last_col = cursor.col + (post_cursor ? 1 : 0);
            }

            i64 visual_block_line_count = (selection.one_past_last_line - selection.first_line);

            i64 post_paste_pos = buffer_compute_cursor(app, buffer, seek_line_col(selection.first_line, selection.first_col)).pos;
            b32 replaces_something = selection.first_col != selection.one_past_last_col;

            Node_String_Const_u8* line = paste_lines.first;

            Range_i64 replace_range = {};
            while (vim_selection_consume_line(app, buffer, &selection, &replace_range, true)) {
                if (replaces_something) {
                    String_Const_u8 replaced_string = push_buffer_range(app, scratch, buffer, replace_range);
                    string_list_push(scratch, &replaced_string_list, replaced_string);
                    if (visual_block_line_count > 0) {
                        string_list_push(scratch, &replaced_string_list, newline_needle);
                    }
                }

                while (line && string_match(line->string, newline_needle)) {
                    line = line->next;
                }

                i64 line_number = get_line_number_from_pos(app, buffer, replace_range.first);
                Buffer_Cursor line_end_cursor = buffer_compute_cursor(app, buffer, seek_line_col(line_number, -1));

                i32 pad_front = 0;
                if (selection.first_col > line_end_cursor.col) {
                    pad_front = (i32)(selection.first_col - line_end_cursor.col) + 1;
                }

                Range_i64 tail_range = Ii64(replace_range.min, line_end_cursor.pos);
                String_Const_u8 tail = push_buffer_range(app, scratch, buffer, tail_range);

                b32 tail_contains_non_whitespace_characters = false;
                for (u64 character_index = 0; character_index < tail.size; character_index++) {
                    u8 c = tail.str[character_index];
                    if (!character_is_whitespace(c)) {
                        tail_contains_non_whitespace_characters = true;
                        break;
                    }
                }

                String_Const_u8 line_string = SCu8();

                if (line) {
                    line_string = line->string;
                    line = line->next;

                    if (pad_front || tail_contains_non_whitespace_characters) {
                        do{ if (!(line_string.size <= longest_line_size)) { (*((i32*)0) = 0xA11E); } }while(0);
                        i32 pad_back = (i32)(longest_line_size - line_string.size);
                        line_string = push_u8_stringf(scratch, "%*s%.*s%*s", pad_front, "", (i32)(line_string).size, (char*)(line_string).str, pad_back, "");
                    }
                } else {
                    if (tail_contains_non_whitespace_characters) {
                        i32 pad_spaces = (i32)longest_line_size;
                        line_string = push_u8_stringf(scratch, "%*s", pad_spaces, "");
                    }
                }

                buffer_replace_range(app, buffer, replace_range, line_string);

                ARGB_Color argb = fcolor_resolve(fcolor_id(defcolor_paste));

                buffer_post_fade(app, buffer, 0.667f, Ii64_size(replace_range.min, paste_string.size), argb);
            }
            view_set_cursor_and_preferred_x(app, view, seek_pos(post_paste_pos));
            String_Const_u8 replaced_string = string_list_flatten(scratch, replaced_string_list, StringFill_NoTerminate);
            if (replaced_string.size) {
                vim_write_register(app, vim_state.active_register, replaced_string);
            }
        } else {
            b32 contains_newlines = false;
            for (u64 character_index = 0; character_index < paste_string.size; character_index++) {
                if (vim_character_is_newline(paste_string.str[character_index])) {
                    contains_newlines = true;
                    break;
                }
            }

            Buffer_Cursor cursor = buffer_compute_cursor(app, buffer, seek_pos(view_get_cursor_pos(app, view)));
            if (post_cursor && contains_newlines) {
                view_set_cursor(app, view, seek_line_col(cursor.line + 1, 1));
            }

            cursor = buffer_compute_cursor(app, buffer, seek_pos(view_get_cursor_pos(app, view)));
            if (post_cursor && !contains_newlines) {
                cursor = buffer_compute_cursor(app, buffer, seek_line_col(cursor.line, cursor.col + 1));
            }

            Range_i64 replace_range = Ii64(cursor.pos);
            if (selection.kind) {
                vim_selection_consume_line(app, buffer, &selection, &replace_range, true);
            }

            String_Const_u8 replaced_string = push_buffer_range(app, scratch, buffer, replace_range);
            buffer_replace_range(app, buffer, replace_range, paste_string);
            if (contains_newlines) {
                i64 new_pos = get_pos_past_lead_whitespace(app, buffer, replace_range.min);
                view_set_cursor_and_preferred_x(app, view, seek_pos(new_pos));
            } else {
                view_set_cursor_and_preferred_x(app, view, seek_pos(replace_range.min + paste_string.size - 1));
            }

            auto_indent_buffer(app, buffer, Ii64_size(cursor.pos, paste_string.size - (contains_newlines ? 1 : 0)));


            if (replaced_string.size) {
                vim_write_register(app, vim_state.active_register, replaced_string);
            }

            ARGB_Color argb = fcolor_resolve(fcolor_id(defcolor_paste));

            buffer_post_fade(app, buffer, 0.667f, Ii64_size(view_get_cursor_pos(app, view), paste_string.size), argb);
        }

        history_group_end(history);
    }
}

static
void vim_paste(Application_Links* app, struct Vim_Operator_State* state, View_ID view, Buffer_ID buffer, Vim_Visual_Selection selection, i32 count, b32 count_was_set) {
    vim_paste_internal(app, true);
}

static
void vim_paste_pre_cursor(Application_Links* app, struct Vim_Operator_State* state, View_ID view, Buffer_ID buffer, Vim_Visual_Selection selection, i32 count, b32 count_was_set) {
    vim_paste_internal(app, false);
}

static
void vim_lowercase(Application_Links* app, struct Vim_Operator_State* state, View_ID view, Buffer_ID buffer, Vim_Visual_Selection selection, i32 count, b32 count_was_set) {
    Range_i64 range = {};
    while (vim_get_operator_range(state, &range, VimOpFlag_QueryMotion)) {
        Scratch_Block scratch(app);
        String_Const_u8 string = push_buffer_range(app, scratch, buffer, range);

        string_mod_lower(string);

        buffer_replace_range(app, buffer, range, string);
    }
}

static
void vim_uppercase(Application_Links* app, struct Vim_Operator_State* state, View_ID view, Buffer_ID buffer, Vim_Visual_Selection selection, i32 count, b32 count_was_set) {
    Range_i64 range = {};
    while (vim_get_operator_range(state, &range, VimOpFlag_QueryMotion)) {
        Scratch_Block scratch(app);
        String_Const_u8 string = push_buffer_range(app, scratch, buffer, range);

        string_mod_upper(string);

        buffer_replace_range(app, buffer, range, string);
    }
}

static
void vim_auto_indent(Application_Links* app, struct Vim_Operator_State* state, View_ID view, Buffer_ID buffer, Vim_Visual_Selection selection, i32 count, b32 count_was_set) {
    Range_i64 range = {};
    while (vim_get_operator_range(state, &range, VimOpFlag_QueryMotion)) {
        auto_indent_buffer(app, buffer, range);
    }
}

static void
vim_shift_indentation_of_line(Application_Links* app, Buffer_ID buffer, i64 line, Scan_Direction dir) {

    i32 indent_width = global_config.indent_width;

    Scratch_Block scratch(app);
    String_Const_u8 line_text = push_buffer_line(app, scratch, buffer, line);

    i64 line_start = get_line_start_pos(app, buffer, line);

    if (dir == Scan_Backward) {
        i32 characters_to_remove = 0;
        if (string_get_character(line_text, 0) == '\t') {
            characters_to_remove = 1;
        } else {
            while (characters_to_remove < indent_width && string_get_character(line_text, characters_to_remove) == ' ') {
                characters_to_remove++;
            }
        }
        buffer_replace_range(app, buffer, Ii64_size(line_start, characters_to_remove), SCu8());
    } else if (dir == Scan_Forward) {
        if (global_config.indent_with_tabs){
            buffer_replace_range(app, buffer, Ii64(line_start), SCu8((u8*)("\t"), (u64)(sizeof("\t") - 1)));
        } else {
            u8* str = ((u8*)linalloc_wrap_unintialized(linalloc_push((scratch), sizeof(u8)*(indent_width), SCu8((u8*)("lib/external/4coder-vimmish/4coder_vimmish.cpp" ":" "4439" ":"), (u64)(sizeof("lib/external/4coder-vimmish/4coder_vimmish.cpp" ":" "4439" ":") - 1)))));
            block_fill_u8(str, indent_width, ' ');
            buffer_replace_range(app, buffer, Ii64(line_start), SCu8(str, indent_width));
        }
    } else {
        (*((i32*)0) = 0xA11E);
    }
}

static
void vim_indent(Application_Links* app, struct Vim_Operator_State* state, View_ID view, Buffer_ID buffer, Vim_Visual_Selection selection, i32 count, b32 count_was_set) {
    Range_i64 range = {};
    while (vim_get_operator_range(state, &range, VimOpFlag_QueryMotion)) {
        Range_i64 line_range = get_line_range_from_pos_range(app, buffer, range);
        if (range_size(line_range) == 0) {
            line_range.max++;
        }
        for (i64 line = line_range.min; line < line_range.max; line++) {
            vim_shift_indentation_of_line(app, buffer, line, Scan_Forward);
        }
    }
}

static
void vim_outdent(Application_Links* app, struct Vim_Operator_State* state, View_ID view, Buffer_ID buffer, Vim_Visual_Selection selection, i32 count, b32 count_was_set) {
    Range_i64 range = {};
    while (vim_get_operator_range(state, &range, VimOpFlag_QueryMotion)) {
        Range_i64 line_range = get_line_range_from_pos_range(app, buffer, range);
        if (range_size(line_range) == 0) {
            line_range.max++;
        }
        for (i64 line = line_range.min; line < line_range.max; line++) {
            vim_shift_indentation_of_line(app, buffer, line, Scan_Backward);
        }
    }
}

static b32
vim_align_range(Application_Links* app,
                Buffer_ID buffer,
                Range_i64 line_range,
                Range_i64 col_range,
                String_Const_u8 align_target,
                b32 align_after_target)
{
    if (col_range.min == 0 && col_range.max == 0) {
        col_range = Ii64(1, max_i64);
    }

    if (string_match(align_target, SCu8((u8*)(" "), (u64)(sizeof(" ") - 1)))) {
        align_after_target = true;
    }

    Scratch_Block scratch(app);
    u32 align_cursor_count = 0;
    Buffer_Cursor* align_cursors = ((Buffer_Cursor*)linalloc_wrap_unintialized(linalloc_push((scratch), sizeof(Buffer_Cursor)*(range_size(line_range)), SCu8((u8*)("lib/external/4coder-vimmish/4coder_vimmish.cpp" ":" "4494" ":"), (u64)(sizeof("lib/external/4coder-vimmish/4coder_vimmish.cpp" ":" "4494" ":") - 1)))));
    Buffer_Cursor furthest_align_cursor = { -1, -1, -1 };

    b32 found_align_target = false;
    b32 did_align = false;

    for (i64 line = line_range.min; line < line_range.max; ++line) {
        Range_i64 col_pos_range = Ii64(buffer_compute_cursor(app, buffer, seek_line_col(line, col_range.min)).pos,
                                       buffer_compute_cursor(app, buffer, seek_line_col(line, col_range.max)).pos);
        i64 first_non_whitespace = get_pos_past_lead_whitespace_from_line_number(app, buffer, line);
        i64 line_end = get_line_end_pos(app, buffer, line);
        Range_i64 seek_range = range_intersect(Ii64(first_non_whitespace, line_end), col_pos_range);

        i64 align_pos = -1;
        String_Match match = buffer_seek_string(app, buffer, align_target, Scan_Forward, seek_range.min);
        if (match.buffer == buffer && (((match.flags)&(StringMatch_CaseSensitive))!=0)) {
            if (align_after_target) {
                i64 range_delta = range_size(match.range) - 1;
                match.range.min += range_delta;
                match.range.max += range_delta;
                match = buffer_seek_character_class(app, buffer, &character_predicate_non_whitespace, Scan_Forward, match.range.first);
            }

            if (match.range.first < seek_range.max) {
                align_pos = match.range.first;
            }
        }

        if (align_pos != -1) {
            Buffer_Cursor align_cursor = buffer_compute_cursor(app, buffer, seek_pos(align_pos));
            align_cursors[align_cursor_count++] = align_cursor;

            found_align_target = true;

            if (furthest_align_cursor.col != -1) {
                if (align_cursor.col != furthest_align_cursor.col) {

                    did_align = true;
                }
            }

            if (align_cursor.col > furthest_align_cursor.col) {
                furthest_align_cursor = align_cursor;
            }
        }
    }

    if (did_align) {
        History_Group history = history_group_begin(app, buffer);
        for (i64 i = 0; i < align_cursor_count; ++i) {
            Buffer_Cursor align_cursor = align_cursors[i];


            align_cursor = buffer_compute_cursor(app, buffer, seek_line_col(align_cursor.line, align_cursor.col));

            if (!align_after_target) {
                i64 line_end = get_line_end_pos(app, buffer, align_cursor.line);
                i64 post_target = align_cursor.pos + align_target.size;
                String_Match match = buffer_seek_character_class(app, buffer, &character_predicate_non_whitespace, Scan_Forward, post_target);
                if (match.buffer == buffer && match.range.max < line_end) {
                    buffer_replace_range(app, buffer, Ii64(post_target + 1, match.range.min), SCu8());
                }
            }

            i64 col_delta = furthest_align_cursor.col - align_cursor.col;
            if (col_delta > 0) {
                String_Const_u8 align_string = push_u8_stringf(scratch, "%*s", col_delta, "");
                buffer_replace_range(app, buffer, Ii64(align_cursor.pos), align_string);
            }
        }
        history_group_end(history);
    } else if (found_align_target) {
        did_align |= vim_align_range(app, buffer, line_range, Ii64(furthest_align_cursor.col + 1, col_range.max), align_target, align_after_target);
    }

    return did_align;
}

static String_Const_u8
vim_query_string(Application_Links* app, char* flavour_text) {
    static u8 buffer[256];
    String_Const_u8 result = SCu8();
    if (vim_state.playing_back_command) {
        do{ if (!(vim_state.current_queued_writable)) { (*((i32*)0) = 0xA11E); } }while(0);
        result = vim_state.current_queued_writable->writable;
        ((vim_state.current_queued_writable)=(vim_state.current_queued_writable)=(vim_state.current_queued_writable)->next);
    } else {
        result = get_query_string(app, flavour_text, buffer, sizeof(buffer));
        if (vim_state.command_in_progress) {
            vim_push_writable(result);
        }
    }
    return result;
}

static void
vim_align_internal(Application_Links* app,
                   Vim_Operator_State* state,
                   View_ID view,
                   Buffer_ID buffer,
                   Vim_Visual_Selection selection,
                   i32 count,
                   b32 align_right,
                   b32 query_full_string)
{
    if (selection.kind == VimSelectionKind_Block || selection.kind == VimSelectionKind_Line) {
        String_Const_u8 align_target = SCu8();
        if (query_full_string) {
            align_target = vim_query_string(app, "Align Target: ");
        } else {
            align_target = vim_get_next_writable(app);
        }
        Range_i64 line_range = Ii64(selection.first_line, selection.one_past_last_line);
        Range_i64 col_range = Ii64(selection.first_col , selection.one_past_last_col );
        for (i32 i = 0; i < count; i++) {
            vim_align_range(app, buffer, line_range, col_range, align_target, align_right);
        }
    } else {
        String_Const_u8 align_target = SCu8();
        Range_i64 range = {};
        while (vim_get_operator_range(state, &range, VimOpFlag_QueryMotion)) {
            if (!align_target.size) {
                if (query_full_string) {
                    align_target = vim_query_string(app, "Align Target: ");
                } else {
                    align_target = vim_get_next_writable(app);
                }
            }
            Range_i64 line_range = get_line_range_from_pos_range(app, buffer, range);
            Range_i64 col_range = Ii64();
            vim_align_range(app, buffer, line_range, col_range, align_target, align_right);
        }
    }
}

static
void vim_align(Application_Links* app, struct Vim_Operator_State* state, View_ID view, Buffer_ID buffer, Vim_Visual_Selection selection, i32 count, b32 count_was_set) {
    vim_align_internal(app, state, view, buffer, selection, count, false, false);
}

static
void vim_align_right(Application_Links* app, struct Vim_Operator_State* state, View_ID view, Buffer_ID buffer, Vim_Visual_Selection selection, i32 count, b32 count_was_set) {
    vim_align_internal(app, state, view, buffer, selection, count, true, false);
}

static
void vim_align_string(Application_Links* app, struct Vim_Operator_State* state, View_ID view, Buffer_ID buffer, Vim_Visual_Selection selection, i32 count, b32 count_was_set) {
    vim_align_internal(app, state, view, buffer, selection, count, false, true);
}

static
void vim_align_string_right(Application_Links* app, struct Vim_Operator_State* state, View_ID view, Buffer_ID buffer, Vim_Visual_Selection selection, i32 count, b32 count_was_set) {
    vim_align_internal(app, state, view, buffer, selection, count, true, true);
}

static void
vim_join_line_internal(Application_Links* app, Buffer_ID buffer, i64 line) {
    i64 next_line = line + 1;
    if (is_valid_line(app, buffer, next_line)) {
        vim_toggle_line_comment_range(app, buffer, Ii64(next_line), vim_cpp_line_comment, false, VimCommentStyle_RangeIndent, VimToggleComment_Uncomment);
        i64 line_end_pos = get_line_end_pos(app, buffer, line);
        i64 join_pos = get_pos_past_lead_whitespace_from_line_number(app, buffer, next_line);

        i64 char_at_lhs_pos = line_end_pos;
        char char_at_lhs = buffer_get_char(app, buffer, char_at_lhs_pos);
        while (vim_character_is_newline(char_at_lhs)) {
            --char_at_lhs_pos;
            char_at_lhs = buffer_get_char(app, buffer, char_at_lhs_pos);
        }

        char char_at_rhs = buffer_get_char(app, buffer, join_pos);

        b32 add_space = ((char_at_lhs != '(') &&
                         (char_at_rhs != ')'));

        buffer_replace_range(app, buffer, Ii64(line_end_pos, join_pos), (add_space ? SCu8(" ") : SCu8("")));
    }
}

static
void vim_join_line(Application_Links* app, struct Vim_Operator_State* state, View_ID view, Buffer_ID buffer, Vim_Visual_Selection selection, i32 count, b32 count_was_set) {
    if (selection.kind) {
        Range_i64 range = {};
        while (vim_get_operator_range(state, &range)) {
            Range_i64 line_range = get_line_range_from_pos_range(app, buffer, range);
            for (i64 line_index = 0; line_index < (((1)>(range_size(line_range) - 1))?(1):(range_size(line_range) - 1)); line_index++) {
                vim_join_line_internal(app, buffer, line_range.min);
            }
        }
    } else {
        i64 line = get_line_number_from_pos(app, buffer, view_get_cursor_pos(app, view));
        vim_join_line_internal(app, buffer, line);
    }
}

static void
vim_miblo_internal(Application_Links* app,
                   Buffer_ID buffer,
                   Range_i64 range,
                   i64 delta,
                   i64* rolling_delta = 0)
{

    for (i64 scan_pos = range.min; scan_pos <= range.max;) {
        Miblo_Number_Info number = {};
        if (get_numeric_at_cursor(app, buffer, scan_pos, &number)) {
            Scratch_Block scratch(app);
            if (rolling_delta) *rolling_delta += delta;
            String_Const_u8 str = push_u8_stringf(scratch, "%lld", number.x + (rolling_delta ? *rolling_delta : delta));
            buffer_replace_range(app, buffer, number.range, str);
            scan_pos = number.range.max;
        } else {
            scan_pos++;
        }
    }
}

static
void vim_miblo_increment(Application_Links* app, struct Vim_Operator_State* state, View_ID view, Buffer_ID buffer, Vim_Visual_Selection selection, i32 count, b32 count_was_set) {
    Range_i64 range = {};
    while (vim_get_operator_range(state, &range)) {
        vim_miblo_internal(app, buffer, range, 1);
    }
}

static
void vim_miblo_decrement(Application_Links* app, struct Vim_Operator_State* state, View_ID view, Buffer_ID buffer, Vim_Visual_Selection selection, i32 count, b32 count_was_set) {
    Range_i64 range = {};
    while (vim_get_operator_range(state, &range)) {
        vim_miblo_internal(app, buffer, range, -1);
    }
}

static
void vim_miblo_increment_sequence(Application_Links* app, struct Vim_Operator_State* state, View_ID view, Buffer_ID buffer, Vim_Visual_Selection selection, i32 count, b32 count_was_set) {
    i64 rolling_delta = 0;
    Range_i64 range = {};
    while (vim_get_operator_range(state, &range)) {
        vim_miblo_internal(app, buffer, range, 1, &rolling_delta);
    }
}

static
void vim_miblo_decrement_sequence(Application_Links* app, struct Vim_Operator_State* state, View_ID view, Buffer_ID buffer, Vim_Visual_Selection selection, i32 count, b32 count_was_set) {
    i64 rolling_delta = 0;
    Range_i64 range = {};
    while (vim_get_operator_range(state, &range)) {
        vim_miblo_internal(app, buffer, range, -1, &rolling_delta);
    }
}

CUSTOM_COMMAND(vim_repeat_command, "lib/external/4coder-vimmish/4coder_vimmish.cpp", 4745, Normal) {
    View_ID view = get_active_view(app, Access_ReadWriteVisible);
    View_ID buffer = view_get_buffer(app, view, Access_ReadWriteVisible);

    History_Group rep_history = history_group_begin(app, buffer);

    if (!buffer_exists(app, buffer)) return;

    vim_state.playing_back_command = true;





    Vim_Command_Rep* rep = vim_state.command_rep;

    Vim_Visual_Selection selection = rep->selection;

    if (selection.kind) {
        Buffer_Cursor cursor = buffer_compute_cursor(app, buffer, seek_pos(view_get_cursor_pos(app, view)));
        selection.first_line += cursor.line;
        selection.first_col += cursor.col;
        selection.one_past_last_line += cursor.line;
        selection.one_past_last_col += cursor.col;

        vim_set_selection(app, view, selection);
        selection = vim_get_selection(app, view, buffer);
    }

    switch (rep->kind) {
        case VimCommandRep_Operator: {
            Vim_Operator_State op_state = {};
            op_state.app = app;
            op_state.view = view;
            op_state.buffer = buffer;
            op_state.op_count = rep->count;
            op_state.op = rep->op;
            op_state.motion_count = rep->motion_count;
            op_state.motion = rep->motion;
            op_state.text_object = rep->text_object;
            op_state.selection = selection;
            op_state.total_range = Ii64_neg_inf;

            vim_state.active_register = rep->reg;
            rep->op(app, &op_state, view, buffer, selection, rep->count, rep->count_was_set);
            vim_state.active_register = &vim_state.unnamed_register;
        } break;

        case VimCommandRep_4CoderCommand: {
            for (i32 i = 0; i < (((rep->count)<(256))?(rep->count):(256)); i++) {
                rep->fcoder_command(app);
            }
        } break;
    }

    if (is_vim_insert_mode(vim_state.mode)) {
        Buffer_Cursor cursor = buffer_compute_cursor(app, buffer, seek_pos(view_get_cursor_pos(app, view)));
        i64 end_pos = cursor.pos;
        Scratch_Block scratch(app);
        for (Vim_Insert_Node* node = vim_state.first_insert_node; node; node = node->next) {
            i64 col = cursor.col + node->rel_col;
            Buffer_Cursor insert_cursor = buffer_compute_cursor(app, buffer, seek_line_col(cursor.line, col));
            Range_i64 replace_range = Ii64_size(insert_cursor.pos, node->text_backward.size);
            buffer_replace_range(app, buffer, replace_range, node->text_forward);
            end_pos = insert_cursor.pos + node->text_forward.size;
        }
        view_set_cursor_and_preferred_x(app, view, seek_pos(end_pos));
    }

    if (is_vim_visual_mode(vim_state.mode)) {
        view_set_cursor_and_preferred_x(app, view, seek_line_col(selection.first_line, selection.first_col));
    }

    vim_enter_normal_mode(app);

    vim_state.playing_back_command = false;

    history_group_end(rep_history);
}

static b32
vim_split_window_internal(Application_Links* app, View_ID view, Dimension dim) {
    b32 result = false;

    Buffer_ID buffer = view_get_buffer(app, view, Access_ReadVisible);
    Panel_ID panel = view_get_panel(app, view);
    if (panel) {
        panel_split(app, panel, dim);
        Panel_ID new_panel = panel_get_child(app, panel, Side_Max);
        if (new_panel) {
            View_ID new_panel_view = panel_get_view(app, new_panel, Access_ReadVisible);
            view_set_buffer(app, new_panel_view, buffer, 0);
            result = true;
        }
        Panel_ID old_panel = panel_get_child(app, panel, Side_Min);
        if (old_panel) {
            View_ID old_panel_view = panel_get_view(app, old_panel, Access_ReadVisible);
            view_set_active(app, old_panel_view);
        }
    }

    return result;
}

CUSTOM_COMMAND(vim_split_window_horizontal, "lib/external/4coder-vimmish/4coder_vimmish.cpp", 4849, Normal) {
    View_ID view = get_active_view(app, Access_ReadVisible);
    vim_split_window_internal(app, view, Dimension_Y);
}

CUSTOM_COMMAND(vim_split_window_vertical, "lib/external/4coder-vimmish/4coder_vimmish.cpp", 4854, Normal) {
    View_ID view = get_active_view(app, Access_ReadVisible);
    vim_split_window_internal(app, view, Dimension_X);
}

CUSTOM_COMMAND(vim_open_file_in_quotes_in_same_window, "lib/external/4coder-vimmish/4coder_vimmish.cpp", 4859, Normal)
CUSTOM_DOC("[vim] Reads a filename from surrounding '\"' characters and attempts to open the corresponding file in the same window.")
{
    View_ID view = get_active_view(app, Access_ReadVisible);
    Buffer_ID buffer = view_get_buffer(app, view, Access_ReadVisible);
    if (buffer_exists(app, buffer)){
        Scratch_Block scratch(app);

        i64 pos = view_get_cursor_pos(app, view);

        Range_i64 range = enclose_pos_inside_quotes(app, buffer, pos);

        String_Const_u8 quoted_name = push_buffer_range(app, scratch, buffer, range);

        String_Const_u8 file_name = push_buffer_file_name(app, scratch, buffer);
        String_Const_u8 path = string_remove_last_folder(file_name);

        if (character_is_slash(string_get_character(path, path.size - 1))) {
            path = string_chop(path, 1);
        }

        String_Const_u8 new_file_name = push_u8_stringf(scratch, "%.*s/%.*s", (i32)(path).size, (char*)(path).str, (i32)(quoted_name).size, (char*)(quoted_name).str);

        if (view_open_file(app, view, new_file_name, true)){
            view_set_active(app, view);
        }
    }
}

CUSTOM_COMMAND(vim_undo, "lib/external/4coder-vimmish/4coder_vimmish.cpp", 4888, Normal)
CUSTOM_DOC("[vim] Advances backwards through the undo history of the current buffer.")
{

    View_ID view = get_active_view(app, Access_ReadWriteVisible);
    Buffer_ID buffer = view_get_buffer(app, view, Access_ReadWriteVisible);
    History_Record_Index current = buffer_history_get_current_state_index(app, buffer);
    if (current > 0) {
        Record_Info record = buffer_history_get_record_info(app, buffer, current);
        i64 new_position = record.single_first;
        if (record.kind == RecordKind_Group) {
            Record_Info sub_record = buffer_history_get_group_sub_record(app, buffer, current, 0);
            new_position = sub_record.single_first;
        }
        buffer_history_set_current_state_index(app, buffer, current - 1);
        view_set_cursor_and_preferred_x(app, view, seek_pos(new_position));
    }
}

CUSTOM_COMMAND(vim_redo, "lib/external/4coder-vimmish/4coder_vimmish.cpp", 4907, Normal)
CUSTOM_DOC("[vim] Advances forwards through the undo history of the current buffer.")
{

    View_ID view = get_active_view(app, Access_ReadWriteVisible);
    Buffer_ID buffer = view_get_buffer(app, view, Access_ReadWriteVisible);
    History_Record_Index current = buffer_history_get_current_state_index(app, buffer);
    History_Record_Index max_index = buffer_history_get_max_record_index(app, buffer);
    if (current < max_index) {
        History_Record_Index index = current + 1;
        Record_Info record = buffer_history_get_record_info(app, buffer, index);
        i64 new_position = record.single_first;
        if (record.kind == RecordKind_Group) {
            Record_Info sub_record = buffer_history_get_group_sub_record(app, buffer, index, 0);
            new_position = sub_record.single_first;
        }
        buffer_history_set_current_state_index(app, buffer, index);
        view_set_cursor_and_preferred_x(app, view, seek_pos(new_position));
    }
}

CUSTOM_COMMAND(vim_page_up, "lib/external/4coder-vimmish/4coder_vimmish.cpp", 4928, Normal) {



    page_up(app);
}

CUSTOM_COMMAND(vim_page_down, "lib/external/4coder-vimmish/4coder_vimmish.cpp", 4935, Normal) {



    page_down(app);
}

CUSTOM_COMMAND(vim_half_page_up, "lib/external/4coder-vimmish/4coder_vimmish.cpp", 4942, Normal) {
    vim_log_jump_history(app);
    View_ID view = get_active_view(app, Access_ReadVisible);
    f32 page_jump = 0.5f*get_page_jump(app, view);
    move_vertical_pixels(app, -page_jump);
}

CUSTOM_COMMAND(vim_half_page_down, "lib/external/4coder-vimmish/4coder_vimmish.cpp", 4949, Normal) {
    vim_log_jump_history(app);
    View_ID view = get_active_view(app, Access_ReadVisible);
    f32 page_jump = 0.5f*get_page_jump(app, view);
    move_vertical_pixels(app, page_jump);
}

CUSTOM_COMMAND(vim_previous_buffer, "lib/external/4coder-vimmish/4coder_vimmish.cpp", 4956, Normal) {
    View_ID view = get_active_view(app, Access_Always);
    Managed_Scope scope = view_get_managed_scope(app, view);
    Vim_View_Attachment* vim_view = ((Vim_View_Attachment*)managed_scope_get_attachment((app), (scope), (vim_view_attachment), sizeof(Vim_View_Attachment)));

    Buffer_ID buffer = vim_view->previous_buffer;

    if (buffer_exists(app, buffer)) {
        i64 pos = vim_view->pos_in_previous_buffer;

        do { Buffer_ID hidden_temp_4966 = vim_view->previous_buffer; vim_view->previous_buffer = vim_view->most_recent_known_buffer; vim_view->most_recent_known_buffer = hidden_temp_4966; } while(0);
        do { i64 hidden_temp_4967 = vim_view->pos_in_previous_buffer; vim_view->pos_in_previous_buffer = vim_view->most_recent_known_pos; vim_view->most_recent_known_pos = hidden_temp_4967; } while(0);

        jump_to_location(app, view, buffer, pos);
    }
}

CUSTOM_COMMAND(vim_jump_to_definition_under_cursor, "lib/external/4coder-vimmish/4coder_vimmish.cpp", 4973, Normal) {
    View_ID view = get_active_view(app, Access_ReadVisible);
    Buffer_ID buffer = view_get_buffer(app, view, Access_ReadVisible);

    if (buffer_exists(app, buffer)) {
        vim_state.definition_stack_count = 0;

        Range_i64 under_cursor = enclose_pos_alpha_numeric_underscore_utf8(app, buffer, view_get_cursor_pos(app, view));

        Scratch_Block scratch(app);
        String_Const_u8 name = push_buffer_range(app, scratch, buffer, under_cursor);

        for (Buffer_ID search_buffer = get_buffer_next(app, 0, Access_Always);
             search_buffer;
             search_buffer = get_buffer_next(app, search_buffer, Access_Always))
        {
            Code_Index_File* file = code_index_get_file(search_buffer);
            if (file) {
                for (i32 i = 0; i < file->note_array.count; i++) {
                    Code_Index_Note* note = file->note_array.ptrs[i];
                    if (string_match(note->text, name)) {
                        Tiny_Jump jump;
                        jump.buffer = search_buffer;
                        jump.pos = note->pos.first;
                        vim_state.definition_stack[vim_state.definition_stack_count++] = jump;
                        if (vim_state.definition_stack_count >= ((sizeof(vim_state.definition_stack))/(sizeof(*vim_state.definition_stack)))) {
                            break;
                        }
                    }
                }
            }
        }

        if (vim_state.definition_stack_count > 0) {
            vim_state.definition_stack_cursor = 0;
            Tiny_Jump first_jump = vim_state.definition_stack[vim_state.definition_stack_cursor];
            vim_log_jump_history(app);
            jump_to_location(app, view, first_jump.buffer, first_jump.pos);
        }
    }
}

CUSTOM_COMMAND(vim_cycle_definitions_forward, "lib/external/4coder-vimmish/4coder_vimmish.cpp", 5015, Normal)
CUSTOM_DOC("Jump to next definition")
{
    View_ID view = get_active_view(app, Access_ReadVisible);
    Tiny_Jump jump = vim_state.definition_stack[++vim_state.definition_stack_cursor % vim_state.definition_stack_count];
    vim_log_jump_history(app);
    jump_to_location(app, view, jump.buffer, jump.pos);
}

CUSTOM_COMMAND(vim_cycle_definitions_backward, "lib/external/4coder-vimmish/4coder_vimmish.cpp", 5024, Normal)
CUSTOM_DOC("Jump to previous definition")
{
    View_ID view = get_active_view(app, Access_ReadVisible);
    Tiny_Jump jump = vim_state.definition_stack[--vim_state.definition_stack_cursor % vim_state.definition_stack_count];
    vim_log_jump_history(app);
    jump_to_location(app, view, jump.buffer, jump.pos);
}

CUSTOM_COMMAND(q, "lib/external/4coder-vimmish/4coder_vimmish.cpp", 5033, Normal)
CUSTOM_DOC("[vim] Closes the current panel, or 4coder if this is the last panel.")
{
    View_ID view = get_active_view(app, Access_Always);
    View_ID first_view = get_view_next(app, 0, Access_Always);
    if (get_view_next(app, first_view, Access_Always)) {
        view_close(app, view);
    } else {
        exit_4coder(app);
    }
}

CUSTOM_COMMAND(w, "lib/external/4coder-vimmish/4coder_vimmish.cpp", 5045, Normal)
CUSTOM_DOC("[vim] Saves the current buffer.")
{
    View_ID view = get_active_view(app, Access_Always);
    Buffer_ID buffer = view_get_buffer(app, view, Access_Always);
    Scratch_Block scratch(app);
    String_Const_u8 file_name = push_buffer_file_name(app, scratch, buffer);
    vim_echo(app, "Wrote file '%.*s' to disk.", (i32)(file_name).size, (char*)(file_name).str);

    save(app);
}

CUSTOM_COMMAND(wq, "lib/external/4coder-vimmish/4coder_vimmish.cpp", 5057, Normal)
CUSTOM_DOC("[vim] Saves the current buffer and closes the current panel, or 4coder if this is the last panel.")
{
    View_ID view = get_active_view(app, Access_Always);
    Buffer_ID buffer = view_get_buffer(app, view, Access_Always);
    Scratch_Block scratch(app);
    String_Const_u8 file_name = push_buffer_file_name(app, scratch, buffer);
    vim_echo(app, "Wrote file '%.*s' to disk.", (i32)(file_name).size, (char*)(file_name).str);

    save(app);
    q(app);
}

CUSTOM_COMMAND(qa, "lib/external/4coder-vimmish/4coder_vimmish.cpp", 5070, Normal)
CUSTOM_DOC("[vim] Closes 4coder.")
{
    exit_4coder(app);
}

CUSTOM_COMMAND(wqa, "lib/external/4coder-vimmish/4coder_vimmish.cpp", 5076, Normal)
CUSTOM_DOC("[vim] Saves all buffers and closes 4coder.")
{
    save_all_dirty_buffers(app);
    qa(app);
}

CUSTOM_COMMAND(e, "lib/external/4coder-vimmish/4coder_vimmish.cpp", 5083, Normal)
CUSTOM_DOC("[vim] Interactively open or create a new file.")
{
    interactive_open_or_new(app);
}

CUSTOM_COMMAND(b, "lib/external/4coder-vimmish/4coder_vimmish.cpp", 5089, Normal)
CUSTOM_DOC("[vim] Interactively switch to an open buffer.")
{
    interactive_switch_buffer(app);
}

CUSTOM_COMMAND(ta, "lib/external/4coder-vimmish/4coder_vimmish.cpp", 5095, Normal)
CUSTOM_DOC("[vim] Open jump-to-definition lister.")
{
    jump_to_definition(app);
}

CUSTOM_COMMAND(vim_start_mouse_select, "lib/external/4coder-vimmish/4coder_vimmish.cpp", 5101, Normal)
CUSTOM_DOC("[vim] Sets the cursor position and mark to the mouse position and enters normal mode.")
{
    View_ID view = get_active_view(app, Access_ReadVisible);

    Mouse_State mouse = get_mouse_state(app);
    i64 pos = view_pos_from_xy(app, view, V2f32(mouse.p));






    vim_enter_normal_mode(app);

    view_set_cursor_and_preferred_x(app, view, seek_pos(pos));
    view_set_mark(app, view, seek_pos(pos));
}

CUSTOM_COMMAND(vim_mouse_drag, "lib/external/4coder-vimmish/4coder_vimmish.cpp", 5120, Normal)
CUSTOM_DOC("[vim] If the mouse left button is pressed, sets the cursor position to the mouse position, and enables the preferred visual mode.")
{
    View_ID view = get_active_view(app, Access_ReadVisible);

    Mouse_State mouse = get_mouse_state(app);
    if (mouse.l) {
        i64 pos = view_pos_from_xy(app, view, V2f32(mouse.p));





        i64 mark_pos = view_get_mark_pos(app, view);
        if (pos != mark_pos) {

            if (!is_vim_visual_mode(vim_state.mode)) {
                do{ if (!(is_vim_visual_mode(VimMode_Visual))) { (*((i32*)0) = 0xA11E); } }while(0);
                vim_enter_mode(app, VimMode_Visual);
            }
            view_set_cursor_and_preferred_x(app, view, seek_pos(pos));
        }
    }

    no_mark_snap_to_cursor(app, view);
}

CUSTOM_COMMAND(vim_write_text_abbrev_and_auto_indent, "lib/external/4coder-vimmish/4coder_vimmish.cpp", 5147, Normal)
CUSTOM_DOC("[vim] Inserts text and auto-indents the line on which the cursor sits if any of the text contains 'layout punctuation' such as ;:{}()[]# and new lines, and substitutes words according to the abbreviations added with the vim_add_abbreviation function.")
{
    Profile_Scope_Block profile_block_5150 ((app), SCu8((u8*)("[vim] write, abbrev, and auto indent"), (u64)(sizeof("[vim] write, abbrev, and auto indent") - 1)), SCu8((u8*)("lib/external/4coder-vimmish/4coder_vimmish.cpp" ":" "5150" ":"), (u64)(sizeof("lib/external/4coder-vimmish/4coder_vimmish.cpp" ":" "5150" ":") - 1)));

    View_ID view = get_active_view(app, Access_ReadWriteVisible);


    i64 pos = view_get_cursor_pos(app, view);

    if (vim_state.insert_sequence) {
        if (pos != vim_state.insert_sequence_pos) {
            vim_state.insert_sequence = false;
        }
    }

    User_Input in = get_current_input(app);
    String_Const_u8 insert = to_writable(&in);

    if (sizeof("jk") >= 3) {
        u8 this_char = insert.size > 0 ? insert.str[0] : 0;
        u8 prev_char = vim_state.prev_insert_char;
        vim_state.prev_insert_char = this_char;
        if (this_char &&
            prev_char == "jk"[0] &&
            this_char == "jk"[1])
        {
            backspace_char(app);
            vim_enter_normal_mode_escape(app);
            return;
        }
    }

    if (insert.str != 0 && insert.size > 0) {
        b32 do_abbrev = false;
        for (u64 i = 0; i < insert.size; i += 1) {
            if (!character_is_alpha_numeric(insert.str[i])) {
                do_abbrev = true;
                break;
            }
        }

        if (do_abbrev) {
            if (vim_state.insert_sequence) {
                vim_apply_abbreviations_for_range(app, view, Ii64(vim_state.insert_sequence_start_pos, vim_state.insert_sequence_pos));
                vim_state.insert_sequence = false;
            }
        } else if (!vim_state.insert_sequence) {
            vim_state.insert_sequence = true;
            vim_state.insert_sequence_pos = vim_state.insert_sequence_start_pos = pos;
        }
    }




    vim_write_text_and_auto_indent_internal(app, insert);

    vim_state.insert_sequence_pos = view_get_cursor_pos(app, view);
}

CUSTOM_COMMAND(vim_backspace_char, "lib/external/4coder-vimmish/4coder_vimmish.cpp", 5208, Normal) {
    backspace_char(app);

    View_ID view = get_active_view(app, Access_ReadWriteVisible);

    vim_state.insert_sequence_pos = view_get_cursor_pos(app, view);
}

static Vim_Key_Binding* vim_add_binding(Vim_Binding_Map* map, Vim_Key_Sequence binding_sequence, b32 clear = true) {
    Vim_Key_Binding* result = 0;

    if (binding_sequence.count > 0) {
        Vim_Key key1 = binding_sequence.keys[0];
        result = vim_make_or_retrieve_binding(map, key1);

        for (i32 key_index = 1; key_index < binding_sequence.count; key_index++) {
            Vim_Key next_key = binding_sequence.keys[key_index];
            if (result->kind != VimBindingKind_Map) {
                result->kind = VimBindingKind_Map;
                result->map = vim_new_binding_map(8);
            }

            result = vim_make_or_retrieve_binding(result->map, next_key);
        }
    }

    if (result && clear) {
        block_zero((result), sizeof(*(result)));
    }

    return result;
}


static Vim_Key_Binding*
vim_bind_motion_(Vim_Binding_Map* map, Vim_Motion* motion, String_Const_u8 description, Vim_Key_Sequence sequence) {
    Vim_Key_Binding* bind = vim_add_binding(map, sequence);
    bind->kind = VimBindingKind_Motion;
    bind->description = description;
    bind->motion = motion;
    return bind;
}


static Vim_Key_Binding*
vim_bind_text_object_(Vim_Binding_Map* map, Vim_Text_Object* text_object, String_Const_u8 description, Vim_Key_Sequence sequence) {
    Vim_Key_Binding* bind = vim_add_binding(map, sequence);
    bind->kind = VimBindingKind_TextObject;
    bind->description = description;
    bind->text_object = text_object;
    return bind;
}


static Vim_Key_Binding*
vim_bind_operator_(Vim_Binding_Map* map, Vim_Operator* op, String_Const_u8 description, Vim_Key_Sequence sequence) {
    Vim_Key_Binding* bind = vim_add_binding(map, sequence);
    bind->kind = VimBindingKind_Operator;
    bind->description = description;
    bind->flags |= VimBindingFlag_IsRepeatable|VimBindingFlag_WriteOnly;
    bind->op = op;
    return bind;
}


static Vim_Key_Binding*
vim_bind_fcoder_command_(Vim_Binding_Map* map, Custom_Command_Function* fcoder_command, String_Const_u8 description, Vim_Key_Sequence sequence) {
    Vim_Key_Binding* bind = vim_add_binding(map, sequence);
    bind->kind = VimBindingKind_4CoderCommand;
    bind->description = description;
    bind->fcoder_command = fcoder_command;
    return bind;
}


static Vim_Key_Binding*
vim_bind_text_command_(Vim_Binding_Map* map, Custom_Command_Function* fcoder_command, String_Const_u8 description, Vim_Key_Sequence sequence) {
    Vim_Key_Binding* bind = vim_bind_fcoder_command_(map, fcoder_command, description, sequence);
    bind->flags |= VimBindingFlag_IsRepeatable|VimBindingFlag_WriteOnly;
    return bind;
}


static Vim_Key_Binding*
vim_bind_(Vim_Binding_Map* map, Vim_Motion* motion, String_Const_u8 description, Vim_Key_Sequence sequence) {
    return vim_bind_motion_(map, motion, description, sequence);
}

static Vim_Key_Binding*
vim_bind_(Vim_Binding_Map* map, Vim_Text_Object* text_object, String_Const_u8 description, Vim_Key_Sequence sequence) {
    return vim_bind_text_object_(map, text_object, description, sequence);
}

static Vim_Key_Binding*
vim_bind_(Vim_Binding_Map* map, Vim_Operator* op, String_Const_u8 description, Vim_Key_Sequence sequence) {
    return vim_bind_operator_(map, op, description, sequence);
}

static Vim_Key_Binding*
vim_bind_(Vim_Binding_Map* map, Custom_Command_Function* fcoder_command, String_Const_u8 description, Vim_Key_Sequence sequence) {
    return vim_bind_fcoder_command_(map, fcoder_command, description, sequence);
}


static Vim_Key_Binding*
vim_name_bind_(Vim_Binding_Map* map, String_Const_u8 description, Vim_Key_Sequence sequence) {
    Vim_Key_Binding* bind = vim_add_binding(map, sequence, false);
    bind->description = description;
    return bind;
}


static void
vim_unbind_(Vim_Binding_Map* map, Vim_Key_Sequence sequence) {
    Vim_Key_Binding* bind = 0;
    for (i32 key_index = 0; key_index < sequence.count; key_index++) {
        Vim_Key key = sequence.keys[key_index];
        bind = vim_retrieve_binding(map, key);

        do{ if (!(bind)) { (*((i32*)0) = 0xA11E); } }while(0);

        if (bind && bind->kind == VimBindingKind_Map) {
            map = bind->map;
        } else {
            break;
        }
    }
    if (bind && bind->kind) {
        block_zero((bind), sizeof(*(bind)));
    }
}

static Vim_Binding_Map*
vim_select_map_(Application_Links* app, Vim_Binding_Map* map) {
    if (!map->allocator) {
        *map = vim_make_binding_map(32);
    }
    return map;
}
# 5359 "lib/external/4coder-vimmish/4coder_vimmish.cpp"
static void
vim_draw_character_block_selection(Application_Links* app,
                                   Buffer_ID buffer,
                                   Text_Layout_ID layout,
                                   Range_i64 range,
                                   f32 roundness,
                                   ARGB_Color color)
{
    if (range.first < range.one_past_last) {
        i64 i = range.first;
        Rect_f32 first_rect = text_layout_character_on_screen(app, layout, i);
        first_rect.y0 -= 1.0f;
        first_rect.y1 += 1.0f;
        i += 1;
        Range_f32 y = rect_range_y(first_rect);
        Range_f32 x = rect_range_x(first_rect);
        for (; i < range.one_past_last; i += 1) {
            i64 line = get_line_number_from_pos(app, buffer, i);
            if (!line_is_blank(app, buffer, line) && vim_character_is_newline(buffer_get_char(app, buffer, i))) {
                continue;
            }
            Rect_f32 rect = text_layout_character_on_screen(app, layout, i);
            rect.y0 -= 1.0f;
            rect.y1 += 1.0f;
            if (rect.x0 < rect.x1 && rect.y0 < rect.y1){
                Range_f32 new_y = rect_range_y(rect);
                Range_f32 new_x = rect_range_x(rect);
                b32 joinable = false;
                if (new_y == y && (range_overlap(x, new_x) || x.max == new_x.min || new_x.max == x.min)) {
                    joinable = true;
                }

                if (!joinable) {
                    Rect_f32 rect_to_draw = Rf32(x, y);
                    draw_rectangle(app, rect_to_draw, roundness, color);
                    y = new_y;
                    x = new_x;
                } else {
                    x = range_union(x, new_x);
                }
            }
        }
        draw_rectangle(app, Rf32(x, y), roundness, color);
    }
}

static void
vim_draw_character_block_selection(Application_Links *app,
                                   Buffer_ID buffer,
                                   Text_Layout_ID layout,
                                   Range_i64 range,
                                   f32 roundness,
                                   FColor color)
{
    ARGB_Color argb = fcolor_resolve(color);
    vim_draw_character_block_selection(app, buffer, layout, range, roundness, argb);
}

static void
vim_draw_cursor(Application_Links *app,
                View_ID view,
                b32 is_active_view,
                Buffer_ID buffer,
                Text_Layout_ID text_layout_id,
                f32 roundness,
                f32 outline_thickness,
                Vim_Mode mode)
{
    Managed_ID cursor_color = defcolor_cursor;
# 5448 "lib/external/4coder-vimmish/4coder_vimmish.cpp"
    i32 cursor_sub_id = default_cursor_sub_id();

    i64 cursor_pos = view_get_cursor_pos(app, view);
    if (is_active_view) {
        if (is_vim_insert_mode(mode)) {
            draw_character_i_bar(app, text_layout_id, cursor_pos, fcolor_id(cursor_color, cursor_sub_id));
        } else {
            Range_i64 visible_range = text_layout_get_visible_range(app, text_layout_id);
            Vim_Visual_Selection selection = vim_get_selection(app, view, buffer);

            if (selection.kind) {
                Range_i64 range = {};
                while (vim_selection_consume_line(app, buffer, &selection, &range, true)) {

                    range = range_intersect(range, visible_range);
                    vim_draw_character_block_selection(app, buffer, text_layout_id, range, roundness, fcolor_id(defcolor_highlight));
                    paint_text_color_fcolor(app, text_layout_id, range, fcolor_id(defcolor_at_highlight));
                }
            }

            vim_draw_character_block_selection(app, buffer, text_layout_id, Ii64(cursor_pos, cursor_pos + 1), roundness, fcolor_id(cursor_color, cursor_sub_id));
            paint_text_color_pos(app, text_layout_id, cursor_pos, fcolor_id(defcolor_at_cursor));
        }
    } else {

    }
}

static void
vim_render_buffer(Application_Links *app,
                  View_ID view_id,
                  Face_ID face_id,
                  Buffer_ID buffer,
                  Text_Layout_ID text_layout_id,
                  Rect_f32 rect)
{
    Profile_Scope_Block profile_block_5484 ((app), SCu8((u8*)("render buffer"), (u64)(sizeof("render buffer") - 1)), SCu8((u8*)("lib/external/4coder-vimmish/4coder_vimmish.cpp" ":" "5484" ":"), (u64)(sizeof("lib/external/4coder-vimmish/4coder_vimmish.cpp" ":" "5484" ":") - 1)));

    View_ID active_view = get_active_view(app, Access_Always);
    b32 is_active_view = (active_view == view_id);
    Rect_f32 prev_clip = draw_set_clip(app, rect);


    Token_Array token_array = get_token_array_from_buffer(app, buffer);
    if (token_array.tokens != 0){
        draw_cpp_token_colors(app, text_layout_id, &token_array);


        if (global_config.use_comment_keyword){
            Comment_Highlight_Pair pairs[] = {
                { SCu8((u8*)("NOTE"), (u64)(sizeof("NOTE") - 1)), finalize_color(defcolor_comment_pop, 0) },
                { SCu8((u8*)("TODO"), (u64)(sizeof("TODO") - 1)), finalize_color(defcolor_comment_pop, 1) },
            };
            draw_comment_highlights(app, buffer, text_layout_id, &token_array, pairs, ((sizeof(pairs))/(sizeof(*pairs))));
        }
    }
    else{
        Range_i64 visible_range = text_layout_get_visible_range(app, text_layout_id);
        paint_text_color_fcolor(app, text_layout_id, visible_range, fcolor_id(defcolor_text_default));
    }

    i64 cursor_pos = view_correct_cursor(app, view_id);
    view_correct_mark(app, view_id);


    if (global_config.use_scope_highlight){
        Color_Array colors = finalize_color_array(defcolor_back_cycle);
        draw_scope_highlight(app, buffer, text_layout_id, cursor_pos, colors.vals, colors.count);
    }

    if (global_config.use_error_highlight || global_config.use_jump_highlight){

        String_Const_u8 name = SCu8((u8*)("*compilation*"), (u64)(sizeof("*compilation*") - 1));
        Buffer_ID compilation_buffer = get_buffer_by_name(app, name, Access_Always);
        if (global_config.use_error_highlight){
            draw_jump_highlights(app, buffer, text_layout_id, compilation_buffer, fcolor_id(defcolor_highlight_junk));
        }


        if (global_config.use_jump_highlight){
            Buffer_ID jump_buffer = get_locked_jump_buffer(app);
            if (jump_buffer != compilation_buffer){
                draw_jump_highlights(app, buffer, text_layout_id, jump_buffer, fcolor_id(defcolor_highlight_white));
            }
        }
    }


    if (global_config.use_paren_helper){
        Color_Array colors = finalize_color_array(defcolor_text_cycle);
        draw_paren_highlight(app, buffer, text_layout_id, cursor_pos, colors.vals, colors.count);
    }


    if (!is_vim_visual_mode(vim_state.mode) && global_config.highlight_line_at_cursor && is_active_view){
        i64 line_number = get_line_number_from_pos(app, buffer, cursor_pos);
        draw_line_highlight(app, text_layout_id, line_number, fcolor_id(defcolor_highlight_cursor_line));
    }


    Face_Metrics metrics = get_face_metrics(app, face_id);
    f32 cursor_roundness = (metrics.normal_advance*0.5f)*0.9f;
    f32 mark_thickness = 2.0f;

    Range_i64 visible_range = text_layout_get_visible_range(app, text_layout_id);

    if (vim_state.search_show_highlight) {

        i64 pos = visible_range.min;
        while (pos < visible_range.max) {
            Range_i64 highlight_range = vim_search_once_internal(app, view_id, buffer, Scan_Forward, pos, vim_state.last_search_register.string.string, vim_state.search_flags, true);
            if (!range_size(highlight_range)) {
                break;
            }
            vim_draw_character_block_selection(app, buffer, text_layout_id, highlight_range, cursor_roundness, fcolor_id(defcolor_highlight_white));
            pos = highlight_range.max;
        }
    }


    if (is_active_view && vim_state.character_seek_show_highlight) {

        i64 pos = view_get_cursor_pos(app, view_id);
        while (range_contains(visible_range, pos)) {
            i64 seek_pos = vim_character_seek(app, view_id, buffer, pos, SCu8(), vim_state.character_seek_highlight_dir, vim_state.most_recent_character_seek_flags);
            if (seek_pos == pos) {
                break;
            }
            Range_i64 range = Ii64_size(seek_pos, vim_state.most_recent_character_seek.size);



            FColor highlight_color = fcolor_id(defcolor_highlight);

            vim_draw_character_block_selection(app, buffer, text_layout_id, range, cursor_roundness, highlight_color);
            paint_text_color_fcolor(app, text_layout_id, range, fcolor_id(defcolor_at_highlight));
            pos = seek_pos;
        }
    }



    vim_draw_cursor(app, view_id, is_active_view, buffer, text_layout_id, cursor_roundness, mark_thickness, vim_state.mode);


    paint_fade_ranges(app, text_layout_id, buffer);


    draw_text_layout_default(app, text_layout_id);

    draw_set_clip(app, prev_clip);
}

static void
vim_draw_echo_bar(Application_Links *app, Face_ID face_id, Rect_f32 bar) {
    Face_Metrics face_metrics = get_face_metrics(app, face_id);
    f32 digit_advance = face_metrics.decimal_digit_advance;

    draw_rectangle(app, bar, 0.0f, fcolor_resolve(fcolor_id(defcolor_back)));
    draw_string_oriented(app, face_id, fcolor_resolve(vim_state.echo_color), vim_state.echo_string.string, bar.p0 + V2f32(2.0f, 2.0f), 0, V2f32(1, 0));





    f32 step_back = 16*digit_advance;
    draw_string_oriented(app, face_id, fcolor_resolve(fcolor_id(defcolor_text_default)), vim_state.chord_bar.string, V2f32(bar.x1 - step_back, bar.y0 + 2.0f), 0, V2f32(1, 0));
}

static void
vim_whole_screen_render_caller(Application_Links *app, Frame_Info frame_info) {
# 5630 "lib/external/4coder-vimmish/4coder_vimmish.cpp"
}

static Rect_f32
vim_draw_background_and_margin(Application_Links *app,
                               View_ID view,
                               ARGB_Color margin,
                               ARGB_Color back,
                               f32 width,
                               f32 echo_bar_height)
{
    Rect_f32 region = global_get_screen_rectangle(app);
    Rect_f32 view_rect = view_get_screen_rect(app, view);



    Rect_f32 inner = rect_inner(view_rect, width);
# 5655 "lib/external/4coder-vimmish/4coder_vimmish.cpp"
    draw_rectangle(app, inner, 0.f, back);
    if (width > 0.f) {
        draw_margin(app, view_rect, inner, margin);
    }
    return inner;




}

static Rect_f32
vim_draw_background_and_margin(Application_Links *app, View_ID view, b32 is_active_view, f32 echo_bar_height) {



    FColor margin_color = get_panel_margin_color(is_active_view ? UIHighlight_Active : UIHighlight_None);

    return vim_draw_background_and_margin(app, view, fcolor_resolve(margin_color), fcolor_resolve(fcolor_id(defcolor_back)), 3.0f, echo_bar_height);
}

static void vim_draw_file_bar(Application_Links *app, View_ID view_id, Buffer_ID buffer, Face_ID face_id, Rect_f32 bar) {
    Scratch_Block scratch(app);

    Managed_Scope scope = buffer_get_managed_scope(app, buffer);

    Managed_ID bar_color = defcolor_bar;
# 5706 "lib/external/4coder-vimmish/4coder_vimmish.cpp"
    draw_rectangle(app, bar, 0.f, fcolor_resolve(fcolor_id(bar_color)));

    FColor base_color = fcolor_id(defcolor_base);
    FColor pop2_color = fcolor_id(defcolor_pop2);

    i64 cursor_position = view_get_cursor_pos(app, view_id);
    Buffer_Cursor cursor = view_compute_cursor(app, view_id, seek_pos(cursor_position));

    Fancy_Line list = {};
    String_Const_u8 unique_name = push_buffer_unique_name(app, scratch, buffer);
    push_fancy_string(scratch, &list, base_color, unique_name);
    push_fancy_stringf(scratch, &list, base_color, " - Row: %3.lld Col: %3.lld -", cursor.line, cursor.col);

    Line_Ending_Kind *eol_setting = ((Line_Ending_Kind*)managed_scope_get_attachment((app), (scope), (buffer_eol_setting), sizeof(Line_Ending_Kind)))
                                                                      ;
    switch (*eol_setting){
        case LineEndingKind_Binary:
        {
            push_fancy_string(scratch, &list, base_color, SCu8((u8*)(" bin"), (u64)(sizeof(" bin") - 1)));
        }break;

        case LineEndingKind_LF:
        {
            push_fancy_string(scratch, &list, base_color, SCu8((u8*)(" lf"), (u64)(sizeof(" lf") - 1)));
        }break;

        case LineEndingKind_CRLF:
        {
            push_fancy_string(scratch, &list, base_color, SCu8((u8*)(" crlf"), (u64)(sizeof(" crlf") - 1)));
        }break;
    }

    u8 space[3];
    {
        Dirty_State dirty = buffer_get_dirty_state(app, buffer);
        String_u8 str = Su8(space, 0, 3);
        if (dirty != 0){
            string_append(&str, SCu8((u8*)(" "), (u64)(sizeof(" ") - 1)));
        }
        if ((((dirty)&(DirtyState_UnsavedChanges))!=0)){
            string_append(&str, SCu8((u8*)("*"), (u64)(sizeof("*") - 1)));
        }
        if ((((dirty)&(DirtyState_UnloadedChanges))!=0)){
            string_append(&str, SCu8((u8*)("!"), (u64)(sizeof("!") - 1)));
        }
        push_fancy_string(scratch, &list, pop2_color, str.string);
    }

    View_ID active_view = get_active_view(app, Access_Always);
    b32 is_active_view = (active_view == view_id);

    if (is_active_view) {

        if (vim_state.echo_string.size) {
            push_fancy_string(scratch, &list, vim_state.echo_color, SCu8((u8*)("   << "), (u64)(sizeof("   << ") - 1)));
            push_fancy_string(scratch, &list, vim_state.echo_color, vim_state.echo_string.string);
            push_fancy_string(scratch, &list, vim_state.echo_color, SCu8((u8*)(" >> "), (u64)(sizeof(" >> ") - 1)));
        }

        if (vim_state.recording_macro_register) {
            push_fancy_stringf(scratch, &list, pop2_color, "   recording @%c", vim_state.recording_macro_register);
        }
        push_fancy_stringf(scratch, &list, base_color, "   %.*s", (i32)(vim_state.chord_bar).size, (char*)(vim_state.chord_bar).str);
    }

    Vec2_f32 p = bar.p0 + V2f32(2.f, 2.f);
    draw_fancy_line(app, face_id, fcolor_zero(), &list, p);
}

static void
vim_render_caller(Application_Links *app, Frame_Info frame_info, View_ID view_id) {
    Profile_Scope_Block profile_block_5777 ((app), SCu8((u8*)("default render caller"), (u64)(sizeof("default render caller") - 1)), SCu8((u8*)("lib/external/4coder-vimmish/4coder_vimmish.cpp" ":" "5777" ":"), (u64)(sizeof("lib/external/4coder-vimmish/4coder_vimmish.cpp" ":" "5777" ":") - 1)));
    View_ID active_view = get_active_view(app, Access_Always);
    b32 is_active_view = (active_view == view_id);

    Buffer_ID buffer = view_get_buffer(app, view_id, Access_Always);
    Face_ID face_id = get_face_id(app, buffer);
    Face_Metrics face_metrics = get_face_metrics(app, face_id);
    f32 line_height = face_metrics.line_height;
    f32 digit_advance = face_metrics.decimal_digit_advance;

    Rect_f32 region = vim_draw_background_and_margin(app, view_id, is_active_view, line_height + 2.0f);
    Rect_f32 prev_clip = draw_set_clip(app, region);


    b64 showing_file_bar = false;
    if (view_get_setting(app, view_id, ViewSetting_ShowFileBar, &showing_file_bar) && showing_file_bar){





        Rect_f32_Pair pair = layout_file_bar_on_top(region, line_height);
        vim_draw_file_bar(app, view_id, buffer, face_id, pair.min);
        region = pair.max;

    }

    Buffer_Scroll scroll = view_get_buffer_scroll(app, view_id);

    Buffer_Point_Delta_Result delta = delta_apply(app, view_id,
                                                  frame_info.animation_dt, scroll);
    if (!block_match((&scroll.position), (&delta.point), sizeof(*(&scroll.position)))){
        block_copy((&scroll.position), (&delta.point), sizeof(*(&scroll.position)));
        view_set_buffer_scroll(app, view_id, scroll, SetBufferScroll_NoCursorChange);
    }
    if (delta.still_animating){
        animate_in_n_milliseconds(app, 0);
    }


    {
        Query_Bar *space[32];
        Query_Bar_Ptr_Array query_bars = {};
        query_bars.ptrs = space;
        if (get_active_query_bars(app, view_id, ((sizeof(space))/(sizeof(*space))), &query_bars)){
            for (i32 i = 0; i < query_bars.count; i += 1){
                Rect_f32_Pair pair = layout_query_bar_on_top(region, line_height, 1);
                draw_query_bar(app, query_bars.ptrs[i], face_id, pair.min);
                region = pair.max;
            }
        }
    }


    if (show_fps_hud){
        Rect_f32_Pair pair = layout_fps_hud_on_bottom(region, line_height);
        draw_fps_hud(app, frame_info, face_id, pair.max);
        region = pair.min;
        animate_in_n_milliseconds(app, 1000);
    }


    Rect_f32 line_number_rect = {};
    if (global_config.show_line_number_margins){
        Rect_f32_Pair pair = layout_line_number_margin(app, buffer, region, digit_advance);
        line_number_rect = pair.min;
        region = pair.max;
    }


    Buffer_Point buffer_point = scroll.position;
    Text_Layout_ID text_layout_id = text_layout_create(app, buffer, region, buffer_point);


    if (global_config.show_line_number_margins){
        draw_line_number_margin(app, view_id, buffer, face_id, text_layout_id, line_number_rect);
    }


    vim_render_buffer(app, view_id, face_id, buffer, text_layout_id, region);

    text_layout_free(app, text_layout_id);
    draw_set_clip(app, prev_clip);
}

i32 vim_begin_buffer(Application_Links *app, Buffer_ID buffer_id) {
    default_begin_buffer(app, buffer_id);

    Managed_Scope scope = buffer_get_managed_scope(app, buffer_id);
    Command_Map_ID* map_id_ptr = ((Command_Map_ID*)managed_scope_get_attachment((app), (scope), (buffer_map_id), sizeof(Command_Map_ID)));
    Command_Map_ID* insert_map_id_ptr = ((Command_Map_ID*)managed_scope_get_attachment((app), (scope), (vim_buffer_insert_map_id), sizeof(Command_Map_ID)));
    *insert_map_id_ptr = *map_id_ptr;
    *map_id_ptr = vim_mapid_normal;

    static b32 warned_virtual_whitespace = false;
    if (!warned_virtual_whitespace && global_config.enable_virtual_whitespace) {
        vim_echo_alert(app, "Warning: Virtual Whitespace is not yet properly supported by 4coder_vimmish.");
        warned_virtual_whitespace = true;
    }

    return 0;
}

static void
vim_tick(Application_Links *app, Frame_Info frame_info) {
    default_tick(app, frame_info);

    Profile_Scope_Block profile_block_5884 ((app), SCu8((u8*)("[vim] tick"), (u64)(sizeof("[vim] tick") - 1)), SCu8((u8*)("lib/external/4coder-vimmish/4coder_vimmish.cpp" ":" "5884" ":"), (u64)(sizeof("lib/external/4coder-vimmish/4coder_vimmish.cpp" ":" "5884" ":") - 1)));

    if (vim_state.played_macro) {
        vim_state.played_macro = false;
        history_group_end(vim_state.macro_history);
    }

    View_ID active_view = get_active_view(app, Access_Always);
    View_ID active_buffer = view_get_buffer(app, active_view, Access_Always);
    u32 active_access_flags = buffer_get_access_flags(app, active_buffer);
    if (!(((active_access_flags)&(Access_Write))!=0) && is_vim_insert_mode(vim_state.mode)) {
        vim_enter_normal_mode_escape(app);
    }

    for (View_ID view = get_view_next(app, 0, Access_ReadVisible); view; view = get_view_next(app, view, Access_ReadVisible)) {
        Buffer_ID buffer = view_get_buffer(app, view, Access_ReadVisible);
        if (buffer_exists(app, buffer)) {
            Managed_Scope view_scope = view_get_managed_scope(app, view);
            Vim_View_Attachment* vim_view = ((Vim_View_Attachment*)managed_scope_get_attachment((app), (view_scope), (vim_view_attachment), sizeof(Vim_View_Attachment)));

            vim_select_mapid_for_mode(app, buffer, vim_state.mode);

            Buffer_Cursor cursor = buffer_compute_cursor(app, buffer, seek_pos(view_get_cursor_pos(app, view)));

            if (vim_state.mode == VimMode_VisualBlock && vim_state.visual_block_force_to_line_end) {
                view_set_cursor_and_preferred_x(app, view, seek_line_col(cursor.line, max_i64));
            } else if (!is_vim_insert_mode(vim_state.mode)) {
                while (cursor.col > 1 && vim_character_is_newline(buffer_get_char(app, buffer, cursor.pos))) {
                    cursor = buffer_compute_cursor(app, buffer, seek_line_col(cursor.line, cursor.col - 1));
                    view_set_cursor(app, view, seek_pos(cursor.pos));
                }
            }

            if (vim_view->most_recent_known_buffer &&
                vim_view->most_recent_known_buffer != buffer)
            {
                vim_state.insert_sequence = false;
                if (vim_view->dont_log_this_buffer_jump) {
                    vim_view->dont_log_this_buffer_jump = false;
                } else {
                    vim_log_jump_history_internal(app, view, vim_view->most_recent_known_buffer, vim_view, vim_view->most_recent_known_pos);
                }
                vim_view->previous_buffer = vim_view->most_recent_known_buffer;
                vim_view->pos_in_previous_buffer = vim_view->most_recent_known_pos;
            }

            vim_view->most_recent_known_buffer = buffer;
            vim_view->most_recent_known_pos = cursor.pos;
        }
    }
}

static b32
vim_handle_input(Application_Links* app, Buffer_ID buffer, View_ID view) {
    b32 result = false;

    i32 op_count = 1;
    b32 op_count_was_set = false;
    Vim_Key_Binding* vim_bind = 0;
    if (!is_vim_insert_mode(vim_state.mode)) {
        Vim_Binding_Map* map = vim_get_map_for_mode(vim_state.mode);

        if (map && map->allocator) {
            vim_begin_query(app, VimQuery_CurrentInput);

            vim_query_and_set_register(app, map);

            op_count = 1;
            op_count_was_set = false;
            if (!is_vim_insert_mode(vim_state.mode)) {
                i64 queried_number = vim_query_number(app);
                op_count = (i32)(((1)>(queried_number))?(1):(((max_i32)<(queried_number))?(max_i32):(queried_number)));
                op_count_was_set = (queried_number != 0);
            }

            vim_query_and_set_register(app, map);

            vim_bind = vim_query_binding(app, map, false);
        }
    }

    if (vim_bind) {
        result = true;
        Vim_Visual_Selection selection = vim_get_selection(app, view, buffer);

        if ((((vim_bind->flags)&(VimBindingFlag_WriteOnly))!=0)) {
            u32 buffer_flags = buffer_get_access_flags(app, buffer);
            if (!(((buffer_flags)&(Access_Write))!=0)) {
                return result;
            }
        }

        vim_begin_command(app, buffer, vim_bind, op_count, op_count_was_set, selection);

        switch (vim_bind->kind) {
            case VimBindingKind_Motion: {
                vim_state.character_seek_show_highlight = false;

                Vim_Motion_Result mr = vim_execute_motion(app, view, buffer, vim_bind->motion, view_get_cursor_pos(app, view), op_count, op_count_was_set);
                vim_seek_motion_result(app, view, buffer, mr);

                if ((((mr.flags)&(VimMotionFlag_SetPreferredX))!=0)) {
                    vim_state.visual_block_force_to_line_end = (((mr.flags)&(VimMotionFlag_VisualBlockForceToLineEnd))!=0);
                }
            } break;

            case VimBindingKind_TextObject: {
                vim_state.character_seek_show_highlight = false;

                Vim_Text_Object_Result tor = vim_execute_text_object(app, view, buffer, vim_bind->text_object, view_get_cursor_pos(app, view), op_count, op_count_was_set);

                Vim_Mode new_mode = VimMode_Visual;
                if (tor.style == VimRangeStyle_Linewise) {
                    new_mode = VimMode_VisualLine;
                }

                if (vim_state.mode != new_mode) {
                    vim_enter_mode(app, new_mode);
                }

                vim_select_range(app, view, tor.range);
            } break;

            case VimBindingKind_Operator: {
                Vim_Operator_State op_state = {};
                op_state.app = app;
                op_state.view = view;
                op_state.buffer = buffer;
                op_state.op_count = op_count;
                op_state.op = vim_bind->op;
                op_state.motion_count = 1;
                op_state.selection = selection;
                op_state.total_range = Ii64_neg_inf;

                vim_bind->op(app, &op_state, view, buffer, selection, op_count, op_count_was_set);
            } break;

            case VimBindingKind_4CoderCommand: {
                for (i32 i = 0; i < (((op_count)<(256))?(op_count):(256)); i++) {
                    vim_bind->fcoder_command(app);
                }
            } break;
        }

        view = get_active_view(app, Access_ReadVisible);
        buffer = view_get_buffer(app, view, Access_ReadVisible);

        if (vim_bind->kind == VimBindingKind_Operator) {
            if (is_vim_visual_mode(vim_state.mode)) {
                view_set_cursor_and_preferred_x(app, view, seek_line_col(selection.first_line, selection.first_col));
                vim_enter_normal_mode(app);
            }
        }

        if (vim_state.mode == VimMode_Normal) {
            vim_end_command(app, true);
        }

        vim_state.active_register = &vim_state.unnamed_register;
    }

    vim_end_query();

    return result;
}

CUSTOM_COMMAND(vim_default_view_handler, "lib/external/4coder-vimmish/4coder_vimmish.cpp", 6050, Normal)
CUSTOM_DOC("[vim] Input consumption loop for view behavior")
{
    Thread_Context *tctx = get_thread_context(app);
    Scratch_Block scratch(tctx);

    {
        View_ID view = get_this_ctx_view(app, Access_Always);
        String_Const_u8 name = push_u8_stringf(scratch, "view %d", view);

        Profile_Global_List *list = get_core_profile_list(app);
        profile_thread_set_name((tctx), (list), (name));

        View_Context ctx = view_current_context(app, view);
        ctx.mapping = &framework_mapping;
        ctx.map_id = mapid_global;
        view_alter_context(app, view, &ctx);
    }

    for (;;) {

        {
            Buffer_ID keyboard_log_buffer = get_keyboard_log_buffer(app);
            Buffer_Cursor cursor = buffer_compute_cursor(app, keyboard_log_buffer, seek_pos(buffer_get_size(app, keyboard_log_buffer)));
            vim_state.command_start_pos = cursor.pos;
        }


        User_Input input = get_next_input(app, EventPropertyGroup_Any, 0);
        Profile_Scope_Block view_input_profile ((app), SCu8((u8*)("[vim] before view input"), (u64)(sizeof("[vim] before view input") - 1)), SCu8((u8*)("lib/external/4coder-vimmish/4coder_vimmish.cpp" ":" "6079" ":"), (u64)(sizeof("lib/external/4coder-vimmish/4coder_vimmish.cpp" ":" "6079" ":") - 1)));
        if (input.abort) {
            break;
        }

        Event_Property event_properties = get_event_properties(&input.event);

        if (suppressing_mouse && (event_properties & EventPropertyGroup_AnyMouseEvent) != 0){
            continue;
        }

        View_ID view = get_this_ctx_view(app, Access_Always);
        Managed_Scope view_scope = view_get_managed_scope(app, view);

        Buffer_ID buffer = view_get_buffer(app, view, Access_Always);
        Managed_Scope buffer_scope = buffer_get_managed_scope(app, buffer);

        Command_Map_ID* map_id_ptr = ((Command_Map_ID*)managed_scope_get_attachment((app), (buffer_scope), (buffer_map_id), sizeof(Command_Map_ID)));
        if (*map_id_ptr == 0) {
            *map_id_ptr = mapid_file;
        }
        Command_Map_ID map_id = *map_id_ptr;

        b32 vim_binding_handled = vim_handle_input(app, buffer, view);

        if (!vim_binding_handled) {
            Command_Binding binding = map_get_binding_recursive(&framework_mapping, map_id, &input.event);
            if (binding.custom == 0) {



                leave_current_input_unhandled(app);
            } else {

                Rewrite_Type *next_rewrite = ((Rewrite_Type*)managed_scope_get_attachment((app), (view_scope), (view_next_rewrite_loc), sizeof(Rewrite_Type)));
                *next_rewrite = Rewrite_None;
                if (fcoder_mode == FCoderMode_NotepadLike) {
                    for (View_ID view_it = get_view_next(app, 0, Access_Always);
                         view_it != 0;
                         view_it = get_view_next(app, view_it, Access_Always))
                    {
                        Managed_Scope scope_it = view_get_managed_scope(app, view_it);
                        b32 *snap_mark_to_cursor = ((b32*)managed_scope_get_attachment((app), (scope_it), (view_snap_mark_to_cursor), sizeof(b32)));
                        *snap_mark_to_cursor = true;
                    }
                }

                ((view_input_profile).close_now());


                binding.custom(app);


                Profile_Scope_Block profile_block_6132 ((app), SCu8((u8*)("after view input"), (u64)(sizeof("after view input") - 1)), SCu8((u8*)("lib/external/4coder-vimmish/4coder_vimmish.cpp" ":" "6132" ":"), (u64)(sizeof("lib/external/4coder-vimmish/4coder_vimmish.cpp" ":" "6132" ":") - 1)));

                next_rewrite = ((Rewrite_Type*)managed_scope_get_attachment((app), (view_scope), (view_next_rewrite_loc), sizeof(Rewrite_Type)));
                if (next_rewrite != 0) {
                    Rewrite_Type *rewrite = ((Rewrite_Type*)managed_scope_get_attachment((app), (view_scope), (view_rewrite_loc), sizeof(Rewrite_Type)));
                    *rewrite = *next_rewrite;
                    if (fcoder_mode == FCoderMode_NotepadLike) {
                        for (View_ID view_it = get_view_next(app, 0, Access_Always);
                             view_it != 0;
                             view_it = get_view_next(app, view_it, Access_Always))
                        {
                            Managed_Scope scope_it = view_get_managed_scope(app, view_it);
                            b32 *snap_mark_to_cursor = ((b32*)managed_scope_get_attachment((app), (scope_it), (view_snap_mark_to_cursor), sizeof(b32)));
                            if (*snap_mark_to_cursor) {
                                i64 pos = view_get_cursor_pos(app, view_it);
                                view_set_mark(app, view_it, seek_pos(pos));
                            }
                        }
                    }
                }
            }
        }
    }
}

i32 vim_default_buffer_edit_range(Application_Links *app, Buffer_ID buffer_id, Range_i64 new_range, Range_Cursor old_cursor_range) {
    default_buffer_edit_range(app, buffer_id, new_range, old_cursor_range);

    Profile_Scope_Block profile_block_6160 ((app), SCu8((u8*)("[vim] buffer edit range"), (u64)(sizeof("[vim] buffer edit range") - 1)), SCu8((u8*)("lib/external/4coder-vimmish/4coder_vimmish.cpp" ":" "6160" ":"), (u64)(sizeof("lib/external/4coder-vimmish/4coder_vimmish.cpp" ":" "6160" ":") - 1)));

    Range_i64 old_range = Ii64(old_cursor_range.min.pos, old_cursor_range.max.pos);
    Range_i64 old_line_range = Ii64(old_cursor_range.min.line, old_cursor_range.max.line);
# 6175 "lib/external/4coder-vimmish/4coder_vimmish.cpp"
    i64 insert_size = range_size(new_range);
    i64 text_shift = replace_range_shift(old_range, insert_size);

    for (u32 mark_index = 0; mark_index < ((sizeof(vim_state.all_marks))/(sizeof(*vim_state.all_marks))); mark_index++) {
        Tiny_Jump* mark = vim_state.all_marks + mark_index;
        if (mark->buffer == buffer_id) {


            if (new_range.min < mark->pos) {
                mark->pos += text_shift;
            }
        }
    }

    for (View_ID view = get_view_next(app, 0, Access_Read); view; view = get_view_next(app, view, Access_Read)) {
        Managed_Scope scope = view_get_managed_scope(app, view);
        Vim_View_Attachment* vim_view = ((Vim_View_Attachment*)managed_scope_get_attachment((app), (scope), (vim_view_attachment), sizeof(Vim_View_Attachment)));
        for (i32 jump_index = vim_view->jump_history_first; jump_index < vim_view->jump_history_one_past_last; jump_index++) {
            Tiny_Jump* jump = vim_view->jump_history + (jump_index % ((sizeof(vim_view->jump_history))/(sizeof(*vim_view->jump_history))));
            if (jump->buffer == buffer_id) {
                if (text_shift < 0 && range_size(old_line_range) > 0 && range_contains(old_range, jump->pos)) {
                    vim_delete_jump_history_at_index(app, vim_view, jump_index);
                } else if (new_range.min < jump->pos) {
                    jump->pos += text_shift;
                }
            }
        }
    }

    return 0;
}

static void
vim_set_default_colors(Application_Links *app) {

    do{ if (!(global_theme_arena.base_allocator)) { (*((i32*)0) = 0xA11E); } }while(0);

    Arena* arena = &global_theme_arena;

    active_color_table.arrays[defcolor_vim_bar_normal] = make_colors(arena, 0xFF888888);
    active_color_table.arrays[defcolor_vim_bar_insert] = make_colors(arena, 0xFF888888);
    active_color_table.arrays[defcolor_vim_bar_visual] = make_colors(arena, 0xFF888888);
    active_color_table.arrays[defcolor_vim_bar_recording_macro] = make_colors(arena, 0xFF888888);
    active_color_table.arrays[defcolor_vim_cursor_normal] = make_colors(arena, 0xFF00EE00, 0xFFEE7700);
    active_color_table.arrays[defcolor_vim_cursor_insert] = make_colors(arena, 0xFF00EE00, 0xFFEE7700);
    active_color_table.arrays[defcolor_vim_cursor_visual] = make_colors(arena, 0xFF00EE00, 0xFFEE7700);
    active_color_table.arrays[defcolor_vim_character_highlight] = make_colors(arena, 0xFFEE7700);
}





static void
vim_setup_default_mapping(Application_Links* app, Mapping *mapping, Vim_Key vim_leader) {
    Mapping *m = 0; Command_Map *map = 0;
    m = (mapping);





    map = mapping_get_or_make_map(m, (mapid_global));

    map_set_binding_l(m, map, default_startup, InputEventKind_Core, (CoreCode_Startup), 0);
    map_set_binding_l(m, map, default_try_exit, InputEventKind_Core, (CoreCode_TryExit), 0);
    map_set_binding_l(m, map, project_go_to_root_directory, InputEventKind_KeyStroke, (KeyCode_H), KeyCode_Control, 0);
    map_set_binding_l(m, map, toggle_fullscreen, InputEventKind_KeyStroke, (KeyCode_Alt), KeyCode_Return, 0);
    map_set_binding_l(m, map, save_all_dirty_buffers, InputEventKind_KeyStroke, (KeyCode_S), KeyCode_Control, KeyCode_Shift, 0);
    map_set_binding_l(m, map, change_to_build_panel, InputEventKind_KeyStroke, (KeyCode_Period), KeyCode_Alt, 0);
    map_set_binding_l(m, map, close_build_panel, InputEventKind_KeyStroke, (KeyCode_Comma), KeyCode_Alt, 0);
    map_set_binding_l(m, map, goto_next_jump, InputEventKind_KeyStroke, (KeyCode_N), KeyCode_Control, 0);
    map_set_binding_l(m, map, goto_prev_jump, InputEventKind_KeyStroke, (KeyCode_P), KeyCode_Control, 0);
    map_set_binding_l(m, map, build_in_build_panel, InputEventKind_KeyStroke, (KeyCode_M), KeyCode_Alt, 0);

    map_set_binding_l(m, map, goto_first_jump, InputEventKind_KeyStroke, (KeyCode_M), KeyCode_Alt, KeyCode_Shift, 0);
    map_set_binding_l(m, map, toggle_filebar, InputEventKind_KeyStroke, (KeyCode_B), KeyCode_Alt, 0);
    map_set_binding_l(m, map, execute_any_cli, InputEventKind_KeyStroke, (KeyCode_Z), KeyCode_Alt, 0);
    map_set_binding_l(m, map, execute_previous_cli, InputEventKind_KeyStroke, (KeyCode_Z), KeyCode_Alt, KeyCode_Shift, 0);
    map_set_binding_l(m, map, command_lister, InputEventKind_KeyStroke, (KeyCode_X), KeyCode_Alt, 0);
    map_set_binding_l(m, map, project_command_lister, InputEventKind_KeyStroke, (KeyCode_X), KeyCode_Alt, KeyCode_Shift, 0);
    map_set_binding_l(m, map, list_all_functions_current_buffer, InputEventKind_KeyStroke, (KeyCode_I), KeyCode_Control, KeyCode_Shift, 0);
    map_set_binding_l(m, map, project_fkey_command, InputEventKind_KeyStroke, (KeyCode_F1), 0);
    map_set_binding_l(m, map, project_fkey_command, InputEventKind_KeyStroke, (KeyCode_F2), 0);
    map_set_binding_l(m, map, project_fkey_command, InputEventKind_KeyStroke, (KeyCode_F3), 0);
    map_set_binding_l(m, map, project_fkey_command, InputEventKind_KeyStroke, (KeyCode_F4), 0);
    map_set_binding_l(m, map, project_fkey_command, InputEventKind_KeyStroke, (KeyCode_F5), 0);
    map_set_binding_l(m, map, project_fkey_command, InputEventKind_KeyStroke, (KeyCode_F6), 0);
    map_set_binding_l(m, map, project_fkey_command, InputEventKind_KeyStroke, (KeyCode_F7), 0);
    map_set_binding_l(m, map, project_fkey_command, InputEventKind_KeyStroke, (KeyCode_F8), 0);
    map_set_binding_l(m, map, project_fkey_command, InputEventKind_KeyStroke, (KeyCode_F9), 0);
    map_set_binding_l(m, map, project_fkey_command, InputEventKind_KeyStroke, (KeyCode_F12), 0);
    map_set_binding_l(m, map, project_fkey_command, InputEventKind_KeyStroke, (KeyCode_F13), 0);
    map_set_binding_l(m, map, project_fkey_command, InputEventKind_KeyStroke, (KeyCode_F14), 0);
    map_set_binding_l(m, map, project_fkey_command, InputEventKind_KeyStroke, (KeyCode_F15), 0);
    map_set_binding_l(m, map, project_fkey_command, InputEventKind_KeyStroke, (KeyCode_F16), 0);
    map_set_binding_l(m, map, exit_4coder, InputEventKind_KeyStroke, (KeyCode_F4), KeyCode_Alt, 0);
    map_set_binding_l(m, map, mouse_wheel_scroll, InputEventKind_MouseWheel, 0, 0);
    map_set_binding_l(m, map, mouse_wheel_change_face_size, InputEventKind_MouseWheel, 0, KeyCode_Control, 0);





    map = mapping_get_or_make_map(m, (mapid_file));
    map_set_parent(m, map, (mapid_global));

    map_set_binding_l(m, map, click_set_cursor_and_mark, InputEventKind_MouseButton, (MouseCode_Left), 0);
    map_set_binding_l(m, map, click_set_cursor, InputEventKind_MouseButtonRelease, (MouseCode_Left), 0);
    map_set_binding_l(m, map, click_set_cursor_and_mark, InputEventKind_Core, (CoreCode_ClickActivateView), 0);
    map_set_binding_l(m, map, click_set_cursor_if_lbutton, InputEventKind_MouseMove, 0, 0);

    map_set_binding_text_input(map, write_text_input);

    map_set_binding_l(m, map, delete_char, InputEventKind_KeyStroke, (KeyCode_Delete), 0);
    map_set_binding_l(m, map, backspace_char, InputEventKind_KeyStroke, (KeyCode_Backspace), 0);
    map_set_binding_l(m, map, move_up, InputEventKind_KeyStroke, (KeyCode_Up), 0);
    map_set_binding_l(m, map, move_down, InputEventKind_KeyStroke, (KeyCode_Down), 0);
    map_set_binding_l(m, map, move_left, InputEventKind_KeyStroke, (KeyCode_Left), 0);
    map_set_binding_l(m, map, move_right, InputEventKind_KeyStroke, (KeyCode_Right), 0);
    map_set_binding_l(m, map, seek_end_of_line, InputEventKind_KeyStroke, (KeyCode_End), 0);
    map_set_binding_l(m, map, seek_beginning_of_line, InputEventKind_KeyStroke, (KeyCode_Home), 0);
    map_set_binding_l(m, map, page_up, InputEventKind_KeyStroke, (KeyCode_PageUp), 0);
    map_set_binding_l(m, map, page_down, InputEventKind_KeyStroke, (KeyCode_PageDown), 0);
    map_set_binding_l(m, map, goto_beginning_of_file, InputEventKind_KeyStroke, (KeyCode_PageUp), KeyCode_Control, 0);
    map_set_binding_l(m, map, goto_end_of_file, InputEventKind_KeyStroke, (KeyCode_PageDown), KeyCode_Control, 0);
    map_set_binding_l(m, map, move_up_to_blank_line_end, InputEventKind_KeyStroke, (KeyCode_Up), KeyCode_Control, 0);
    map_set_binding_l(m, map, move_down_to_blank_line_end, InputEventKind_KeyStroke, (KeyCode_Down), KeyCode_Control, 0);
    map_set_binding_l(m, map, move_left_whitespace_boundary, InputEventKind_KeyStroke, (KeyCode_Left), KeyCode_Control, 0);
    map_set_binding_l(m, map, move_right_whitespace_boundary, InputEventKind_KeyStroke, (KeyCode_Right), KeyCode_Control, 0);
    map_set_binding_l(m, map, move_line_up, InputEventKind_KeyStroke, (KeyCode_Up), KeyCode_Alt, 0);
    map_set_binding_l(m, map, move_line_down, InputEventKind_KeyStroke, (KeyCode_Down), KeyCode_Alt, 0);
    map_set_binding_l(m, map, backspace_alpha_numeric_boundary, InputEventKind_KeyStroke, (KeyCode_Backspace), KeyCode_Control, 0);
    map_set_binding_l(m, map, delete_alpha_numeric_boundary, InputEventKind_KeyStroke, (KeyCode_Delete), KeyCode_Control, 0);
    map_set_binding_l(m, map, snipe_backward_whitespace_or_token_boundary, InputEventKind_KeyStroke, (KeyCode_Backspace), KeyCode_Alt, 0);
    map_set_binding_l(m, map, snipe_forward_whitespace_or_token_boundary, InputEventKind_KeyStroke, (KeyCode_Delete), KeyCode_Alt, 0);
    map_set_binding_l(m, map, set_mark, InputEventKind_KeyStroke, (KeyCode_Space), KeyCode_Control, 0);
    map_set_binding_l(m, map, copy, InputEventKind_KeyStroke, (KeyCode_C), KeyCode_Control, 0);
    map_set_binding_l(m, map, delete_range, InputEventKind_KeyStroke, (KeyCode_D), KeyCode_Control, 0);
    map_set_binding_l(m, map, delete_line, InputEventKind_KeyStroke, (KeyCode_D), KeyCode_Control, KeyCode_Shift, 0);
    map_set_binding_l(m, map, goto_line, InputEventKind_KeyStroke, (KeyCode_G), KeyCode_Control, 0);
    map_set_binding_l(m, map, paste_and_indent, InputEventKind_KeyStroke, (KeyCode_V), KeyCode_Control, 0);
    map_set_binding_l(m, map, paste_next_and_indent, InputEventKind_KeyStroke, (KeyCode_V), KeyCode_Control, KeyCode_Shift, 0);
    map_set_binding_l(m, map, cut, InputEventKind_KeyStroke, (KeyCode_X), KeyCode_Control, 0);
    map_set_binding_l(m, map, vim_redo, InputEventKind_KeyStroke, (KeyCode_Y), KeyCode_Control, 0);
    map_set_binding_l(m, map, vim_undo, InputEventKind_KeyStroke, (KeyCode_Z), KeyCode_Control, 0);
    map_set_binding_l(m, map, if_read_only_goto_position, InputEventKind_KeyStroke, (KeyCode_Return), 0);
    map_set_binding_l(m, map, if_read_only_goto_position_same_panel, InputEventKind_KeyStroke, (KeyCode_Return), KeyCode_Shift, 0);
    map_set_binding_l(m, map, view_jump_list_with_lister, InputEventKind_KeyStroke, (KeyCode_Period), KeyCode_Control, KeyCode_Shift, 0);
    map_set_binding_l(m, map, vim_enter_normal_mode_escape, InputEventKind_KeyStroke, (KeyCode_Escape), 0);





    map = mapping_get_or_make_map(m, (mapid_code));
    map_set_parent(m, map, (mapid_file));

    map_set_binding_l(m, map, click_set_cursor_and_mark, InputEventKind_MouseButton, (MouseCode_Left), 0);
    map_set_binding_l(m, map, click_set_cursor, InputEventKind_MouseButtonRelease, (MouseCode_Left), 0);
    map_set_binding_l(m, map, click_set_cursor_and_mark, InputEventKind_Core, (CoreCode_ClickActivateView), 0);
    map_set_binding_l(m, map, click_set_cursor_if_lbutton, InputEventKind_MouseMove, 0, 0);

    map_set_binding_text_input(map, vim_write_text_abbrev_and_auto_indent);

    map_set_binding_l(m, map, move_left_alpha_numeric_boundary, InputEventKind_KeyStroke, (KeyCode_Left), KeyCode_Control, 0);
    map_set_binding_l(m, map, move_right_alpha_numeric_boundary, InputEventKind_KeyStroke, (KeyCode_Right), KeyCode_Control, 0);
    map_set_binding_l(m, map, move_left_alpha_numeric_or_camel_boundary, InputEventKind_KeyStroke, (KeyCode_Left), KeyCode_Alt, 0);
    map_set_binding_l(m, map, move_right_alpha_numeric_or_camel_boundary, InputEventKind_KeyStroke, (KeyCode_Right), KeyCode_Alt, 0);
    map_set_binding_l(m, map, vim_backspace_char, InputEventKind_KeyStroke, (KeyCode_Backspace), 0);
    map_set_binding_l(m, map, comment_line_toggle, InputEventKind_KeyStroke, (KeyCode_Semicolon), KeyCode_Control, 0);
    map_set_binding_l(m, map, word_complete, InputEventKind_KeyStroke, (KeyCode_Tab), 0);

    map_set_binding_l(m, map, auto_indent_range, InputEventKind_KeyStroke, (KeyCode_Tab), KeyCode_Control, 0);
    map_set_binding_l(m, map, auto_indent_line_at_cursor, InputEventKind_KeyStroke, (KeyCode_Tab), KeyCode_Shift, 0);
    map_set_binding_l(m, map, word_complete_drop_down, InputEventKind_KeyStroke, (KeyCode_Tab), KeyCode_Shift, KeyCode_Control, 0);
    map_set_binding_l(m, map, write_block, InputEventKind_KeyStroke, (KeyCode_R), KeyCode_Alt, 0);
    map_set_binding_l(m, map, write_todo, InputEventKind_KeyStroke, (KeyCode_T), KeyCode_Alt, 0);
    map_set_binding_l(m, map, write_note, InputEventKind_KeyStroke, (KeyCode_Y), KeyCode_Alt, 0);
    map_set_binding_l(m, map, list_all_locations_of_type_definition, InputEventKind_KeyStroke, (KeyCode_D), KeyCode_Alt, 0);
    map_set_binding_l(m, map, list_all_locations_of_type_definition_of_identifier, InputEventKind_KeyStroke, (KeyCode_T), KeyCode_Alt, KeyCode_Shift, 0);
    map_set_binding_l(m, map, open_long_braces, InputEventKind_KeyStroke, (KeyCode_LeftBracket), KeyCode_Control, 0);
    map_set_binding_l(m, map, open_long_braces_semicolon, InputEventKind_KeyStroke, (KeyCode_LeftBracket), KeyCode_Control, KeyCode_Shift, 0);
    map_set_binding_l(m, map, open_long_braces_break, InputEventKind_KeyStroke, (KeyCode_RightBracket), KeyCode_Control, KeyCode_Shift, 0);
    map_set_binding_l(m, map, select_surrounding_scope, InputEventKind_KeyStroke, (KeyCode_LeftBracket), KeyCode_Alt, 0);
    map_set_binding_l(m, map, select_surrounding_scope_maximal, InputEventKind_KeyStroke, (KeyCode_LeftBracket), KeyCode_Alt, KeyCode_Shift, 0);
    map_set_binding_l(m, map, select_prev_scope_absolute, InputEventKind_KeyStroke, (KeyCode_RightBracket), KeyCode_Alt, 0);
    map_set_binding_l(m, map, select_prev_top_most_scope, InputEventKind_KeyStroke, (KeyCode_RightBracket), KeyCode_Alt, KeyCode_Shift, 0);
    map_set_binding_l(m, map, select_next_scope_absolute, InputEventKind_KeyStroke, (KeyCode_Quote), KeyCode_Alt, 0);
    map_set_binding_l(m, map, select_next_scope_after_current, InputEventKind_KeyStroke, (KeyCode_Quote), KeyCode_Alt, KeyCode_Shift, 0);
    map_set_binding_l(m, map, place_in_scope, InputEventKind_KeyStroke, (KeyCode_ForwardSlash), KeyCode_Alt, 0);
    map_set_binding_l(m, map, delete_current_scope, InputEventKind_KeyStroke, (KeyCode_Minus), KeyCode_Alt, 0);
    map_set_binding_l(m, map, if0_off, InputEventKind_KeyStroke, (KeyCode_I), KeyCode_Alt, 0);
    map_set_binding_l(m, map, open_file_in_quotes, InputEventKind_KeyStroke, (KeyCode_1), KeyCode_Alt, 0);
    map_set_binding_l(m, map, open_matching_file_cpp, InputEventKind_KeyStroke, (KeyCode_2), KeyCode_Alt, 0);
    map_set_binding_l(m, map, write_zero_struct, InputEventKind_KeyStroke, (KeyCode_0), KeyCode_Control, 0);





    map = mapping_get_or_make_map(m, (vim_mapid_normal));
    map_set_parent(m, map, (mapid_global));

    map_set_binding_l(m, map, vim_start_mouse_select, InputEventKind_MouseButton, (MouseCode_Left), 0);
    map_set_binding_l(m, map, click_set_cursor, InputEventKind_MouseButtonRelease, (MouseCode_Left), 0);
    map_set_binding_l(m, map, click_set_cursor_and_mark, InputEventKind_Core, (CoreCode_ClickActivateView), 0);
    map_set_binding_l(m, map, vim_mouse_drag, InputEventKind_MouseMove, 0, 0);





    map = mapping_get_or_make_map(m, (vim_mapid_visual));
    map_set_parent(m, map, (vim_mapid_normal));
# 6399 "lib/external/4coder-vimmish/4coder_vimmish.cpp"
    Vim_Binding_Map* vim_map = 0;





    vim_map = vim_select_map_(app, &vim_map_text_objects);

    vim_bind_(vim_map, vim_text_object_inner_scope, SCu8((u8*)("vim_text_object_inner_scope"), (u64)(sizeof("vim_text_object_inner_scope") - 1)), vim_key_sequence(vim_key(KeyCode_I), vim_key(KeyCode_LeftBracket, KeyCode_Shift)));
    vim_bind_(vim_map, vim_text_object_inner_scope, SCu8((u8*)("vim_text_object_inner_scope"), (u64)(sizeof("vim_text_object_inner_scope") - 1)), vim_key_sequence(vim_key(KeyCode_I), vim_key(KeyCode_RightBracket, KeyCode_Shift)));
    vim_bind_(vim_map, vim_text_object_inner_paren, SCu8((u8*)("vim_text_object_inner_paren"), (u64)(sizeof("vim_text_object_inner_paren") - 1)), vim_key_sequence(vim_key(KeyCode_I), vim_key(KeyCode_9, KeyCode_Shift)));
    vim_bind_(vim_map, vim_text_object_inner_paren, SCu8((u8*)("vim_text_object_inner_paren"), (u64)(sizeof("vim_text_object_inner_paren") - 1)), vim_key_sequence(vim_key(KeyCode_I), vim_key(KeyCode_0, KeyCode_Shift)));
    vim_bind_(vim_map, vim_text_object_inner_single_quotes, SCu8((u8*)("vim_text_object_inner_single_quotes"), (u64)(sizeof("vim_text_object_inner_single_quotes") - 1)), vim_key_sequence(vim_key(KeyCode_I), vim_key(KeyCode_Quote)));
    vim_bind_(vim_map, vim_text_object_inner_double_quotes, SCu8((u8*)("vim_text_object_inner_double_quotes"), (u64)(sizeof("vim_text_object_inner_double_quotes") - 1)), vim_key_sequence(vim_key(KeyCode_I), vim_key(KeyCode_Quote, KeyCode_Shift)));
    vim_bind_(vim_map, vim_text_object_inner_word, SCu8((u8*)("vim_text_object_inner_word"), (u64)(sizeof("vim_text_object_inner_word") - 1)), vim_key_sequence(vim_key(KeyCode_I), vim_key(KeyCode_W)));
    vim_bind_(vim_map, vim_text_object_isearch_repeat_forward, SCu8((u8*)("vim_text_object_isearch_repeat_forward"), (u64)(sizeof("vim_text_object_isearch_repeat_forward") - 1)), vim_key_sequence(vim_key(KeyCode_G), vim_key(KeyCode_N)));
    vim_bind_(vim_map, vim_text_object_isearch_repeat_backward, SCu8((u8*)("vim_text_object_isearch_repeat_backward"), (u64)(sizeof("vim_text_object_isearch_repeat_backward") - 1)), vim_key_sequence(vim_key(KeyCode_G), vim_key(KeyCode_N, KeyCode_Shift)));





    vim_map = vim_select_map_(app, &vim_map_operator_pending);
    vim_add_parent_binding_map(vim_map, &(vim_map_text_objects));

    vim_bind_(vim_map, vim_motion_left, SCu8((u8*)("vim_motion_left"), (u64)(sizeof("vim_motion_left") - 1)), vim_key_sequence(vim_key(KeyCode_H)));
    vim_bind_(vim_map, vim_motion_down, SCu8((u8*)("vim_motion_down"), (u64)(sizeof("vim_motion_down") - 1)), vim_key_sequence(vim_key(KeyCode_J)));
    vim_bind_(vim_map, vim_motion_up, SCu8((u8*)("vim_motion_up"), (u64)(sizeof("vim_motion_up") - 1)), vim_key_sequence(vim_key(KeyCode_K)));
    vim_bind_(vim_map, vim_motion_right, SCu8((u8*)("vim_motion_right"), (u64)(sizeof("vim_motion_right") - 1)), vim_key_sequence(vim_key(KeyCode_L)));
    vim_bind_(vim_map, vim_motion_left, SCu8((u8*)("vim_motion_left"), (u64)(sizeof("vim_motion_left") - 1)), vim_key_sequence(vim_key(KeyCode_Left)));
    vim_bind_(vim_map, vim_motion_down, SCu8((u8*)("vim_motion_down"), (u64)(sizeof("vim_motion_down") - 1)), vim_key_sequence(vim_key(KeyCode_Down)));
    vim_bind_(vim_map, vim_motion_up, SCu8((u8*)("vim_motion_up"), (u64)(sizeof("vim_motion_up") - 1)), vim_key_sequence(vim_key(KeyCode_Up)));
    vim_bind_(vim_map, vim_motion_right, SCu8((u8*)("vim_motion_right"), (u64)(sizeof("vim_motion_right") - 1)), vim_key_sequence(vim_key(KeyCode_Right)));
    vim_bind_(vim_map, vim_motion_to_empty_line_down, SCu8((u8*)("vim_motion_to_empty_line_down"), (u64)(sizeof("vim_motion_to_empty_line_down") - 1)), vim_key_sequence(vim_key(KeyCode_RightBracket, KeyCode_Shift)));
    vim_bind_(vim_map, vim_motion_to_empty_line_up, SCu8((u8*)("vim_motion_to_empty_line_up"), (u64)(sizeof("vim_motion_to_empty_line_up") - 1)), vim_key_sequence(vim_key(KeyCode_LeftBracket, KeyCode_Shift)));
    vim_bind_(vim_map, vim_motion_word, SCu8((u8*)("vim_motion_word"), (u64)(sizeof("vim_motion_word") - 1)), vim_key_sequence(vim_key(KeyCode_W)));
    vim_bind_(vim_map, vim_motion_big_word, SCu8((u8*)("vim_motion_big_word"), (u64)(sizeof("vim_motion_big_word") - 1)), vim_key_sequence(vim_key(KeyCode_W, KeyCode_Shift)));
    vim_bind_(vim_map, vim_motion_word_end, SCu8((u8*)("vim_motion_word_end"), (u64)(sizeof("vim_motion_word_end") - 1)), vim_key_sequence(vim_key(KeyCode_E)));
    vim_bind_(vim_map, vim_motion_word_backward, SCu8((u8*)("vim_motion_word_backward"), (u64)(sizeof("vim_motion_word_backward") - 1)), vim_key_sequence(vim_key(KeyCode_B)));
    vim_bind_(vim_map, vim_motion_big_word_backward, SCu8((u8*)("vim_motion_big_word_backward"), (u64)(sizeof("vim_motion_big_word_backward") - 1)), vim_key_sequence(vim_key(KeyCode_B, KeyCode_Shift)));
    vim_bind_(vim_map, vim_motion_line_start_textual, SCu8((u8*)("vim_motion_line_start_textual"), (u64)(sizeof("vim_motion_line_start_textual") - 1)), vim_key_sequence(vim_key(KeyCode_0)));
    vim_bind_(vim_map, vim_motion_line_start_textual, SCu8((u8*)("vim_motion_line_start_textual"), (u64)(sizeof("vim_motion_line_start_textual") - 1)), vim_key_sequence(vim_key(KeyCode_6, KeyCode_Shift)));
    vim_bind_(vim_map, vim_motion_line_end_textual, SCu8((u8*)("vim_motion_line_end_textual"), (u64)(sizeof("vim_motion_line_end_textual") - 1)), vim_key_sequence(vim_key(KeyCode_4, KeyCode_Shift)));
    vim_bind_(vim_map, vim_motion_scope, SCu8((u8*)("vim_motion_scope"), (u64)(sizeof("vim_motion_scope") - 1)), vim_key_sequence(vim_key(KeyCode_5, KeyCode_Shift)));
    vim_bind_(vim_map, vim_motion_buffer_start_or_goto_line, SCu8((u8*)("vim_motion_buffer_start_or_goto_line"), (u64)(sizeof("vim_motion_buffer_start_or_goto_line") - 1)), vim_key_sequence(vim_key(KeyCode_G), vim_key(KeyCode_G)));
    vim_bind_(vim_map, vim_motion_buffer_end_or_goto_line, SCu8((u8*)("vim_motion_buffer_end_or_goto_line"), (u64)(sizeof("vim_motion_buffer_end_or_goto_line") - 1)), vim_key_sequence(vim_key(KeyCode_G, KeyCode_Shift)));
    vim_bind_(vim_map, vim_motion_page_top, SCu8((u8*)("vim_motion_page_top"), (u64)(sizeof("vim_motion_page_top") - 1)), vim_key_sequence(vim_key(KeyCode_H, KeyCode_Shift)));
    vim_bind_(vim_map, vim_motion_page_mid, SCu8((u8*)("vim_motion_page_mid"), (u64)(sizeof("vim_motion_page_mid") - 1)), vim_key_sequence(vim_key(KeyCode_M, KeyCode_Shift)));
    vim_bind_(vim_map, vim_motion_page_bottom, SCu8((u8*)("vim_motion_page_bottom"), (u64)(sizeof("vim_motion_page_bottom") - 1)), vim_key_sequence(vim_key(KeyCode_L, KeyCode_Shift)));
    vim_bind_(vim_map, vim_motion_find_character_case_sensitive, SCu8((u8*)("vim_motion_find_character_case_sensitive"), (u64)(sizeof("vim_motion_find_character_case_sensitive") - 1)), vim_key_sequence(vim_key(KeyCode_F)));
    vim_bind_(vim_map, vim_motion_find_character_backward_case_sensitive, SCu8((u8*)("vim_motion_find_character_backward_case_sensitive"), (u64)(sizeof("vim_motion_find_character_backward_case_sensitive") - 1)), vim_key_sequence(vim_key(KeyCode_F, KeyCode_Shift)));
    vim_bind_(vim_map, vim_motion_to_character_case_sensitive, SCu8((u8*)("vim_motion_to_character_case_sensitive"), (u64)(sizeof("vim_motion_to_character_case_sensitive") - 1)), vim_key_sequence(vim_key(KeyCode_T)));
    vim_bind_(vim_map, vim_motion_to_character_backward_case_sensitive, SCu8((u8*)("vim_motion_to_character_backward_case_sensitive"), (u64)(sizeof("vim_motion_to_character_backward_case_sensitive") - 1)), vim_key_sequence(vim_key(KeyCode_T, KeyCode_Shift)));
    vim_bind_(vim_map, vim_motion_find_character_pair_case_sensitive, SCu8((u8*)("vim_motion_find_character_pair_case_sensitive"), (u64)(sizeof("vim_motion_find_character_pair_case_sensitive") - 1)), vim_key_sequence(vim_key(KeyCode_S)));
    vim_bind_(vim_map, vim_motion_find_character_pair_backward_case_sensitive, SCu8((u8*)("vim_motion_find_character_pair_backward_case_sensitive"), (u64)(sizeof("vim_motion_find_character_pair_backward_case_sensitive") - 1)), vim_key_sequence(vim_key(KeyCode_S, KeyCode_Shift)));
    vim_bind_(vim_map, vim_motion_repeat_character_seek_same_direction, SCu8((u8*)("vim_motion_repeat_character_seek_same_direction"), (u64)(sizeof("vim_motion_repeat_character_seek_same_direction") - 1)), vim_key_sequence(vim_key(KeyCode_Semicolon)));
    vim_bind_(vim_map, vim_motion_repeat_character_seek_reverse_direction, SCu8((u8*)("vim_motion_repeat_character_seek_reverse_direction"), (u64)(sizeof("vim_motion_repeat_character_seek_reverse_direction") - 1)), vim_key_sequence(vim_key(KeyCode_Comma)));





    vim_map = vim_select_map_(app, &vim_map_normal);
    vim_add_parent_binding_map(vim_map, &(vim_map_operator_pending));

    vim_bind_(vim_map, vim_register, SCu8((u8*)("vim_register"), (u64)(sizeof("vim_register") - 1)), vim_key_sequence(vim_key(KeyCode_Quote, KeyCode_Shift)));
    vim_bind_(vim_map, vim_change, SCu8((u8*)("vim_change"), (u64)(sizeof("vim_change") - 1)), vim_key_sequence(vim_key(KeyCode_C)));
    vim_bind_(vim_map, vim_change_eol, SCu8((u8*)("vim_change_eol"), (u64)(sizeof("vim_change_eol") - 1)), vim_key_sequence(vim_key(KeyCode_C, KeyCode_Shift)));
    vim_bind_(vim_map, vim_delete, SCu8((u8*)("vim_delete"), (u64)(sizeof("vim_delete") - 1)), vim_key_sequence(vim_key(KeyCode_D)));
    vim_bind_(vim_map, vim_delete_eol, SCu8((u8*)("vim_delete_eol"), (u64)(sizeof("vim_delete_eol") - 1)), vim_key_sequence(vim_key(KeyCode_D, KeyCode_Shift)));
    vim_bind_(vim_map, vim_delete_character, SCu8((u8*)("vim_delete_character"), (u64)(sizeof("vim_delete_character") - 1)), vim_key_sequence(vim_key(KeyCode_X)));
    vim_bind_(vim_map, vim_yank, SCu8((u8*)("vim_yank"), (u64)(sizeof("vim_yank") - 1)), vim_key_sequence(vim_key(KeyCode_Y)));
    vim_bind_(vim_map, vim_yank_eol, SCu8((u8*)("vim_yank_eol"), (u64)(sizeof("vim_yank_eol") - 1)), vim_key_sequence(vim_key(KeyCode_Y, KeyCode_Shift)));
    vim_bind_(vim_map, vim_paste, SCu8((u8*)("vim_paste"), (u64)(sizeof("vim_paste") - 1)), vim_key_sequence(vim_key(KeyCode_P)));
    vim_bind_(vim_map, vim_paste_pre_cursor, SCu8((u8*)("vim_paste_pre_cursor"), (u64)(sizeof("vim_paste_pre_cursor") - 1)), vim_key_sequence(vim_key(KeyCode_P, KeyCode_Shift)));
    vim_bind_(vim_map, vim_auto_indent, SCu8((u8*)("vim_auto_indent"), (u64)(sizeof("vim_auto_indent") - 1)), vim_key_sequence(vim_key(KeyCode_Equal)));
    vim_bind_(vim_map, vim_indent, SCu8((u8*)("vim_indent"), (u64)(sizeof("vim_indent") - 1)), vim_key_sequence(vim_key(KeyCode_Period, KeyCode_Shift)));
    vim_bind_(vim_map, vim_outdent, SCu8((u8*)("vim_outdent"), (u64)(sizeof("vim_outdent") - 1)), vim_key_sequence(vim_key(KeyCode_Comma, KeyCode_Shift)));
    vim_bind_(vim_map, vim_replace, SCu8((u8*)("vim_replace"), (u64)(sizeof("vim_replace") - 1)), vim_key_sequence(vim_key(KeyCode_R)));
    vim_bind_(vim_map, vim_new_line_below, SCu8((u8*)("vim_new_line_below"), (u64)(sizeof("vim_new_line_below") - 1)), vim_key_sequence(vim_key(KeyCode_O)))->flags |= VimBindingFlag_TextCommand;
    vim_bind_(vim_map, vim_new_line_above, SCu8((u8*)("vim_new_line_above"), (u64)(sizeof("vim_new_line_above") - 1)), vim_key_sequence(vim_key(KeyCode_O, KeyCode_Shift)))->flags |= VimBindingFlag_TextCommand;
    vim_bind_(vim_map, vim_join_line, SCu8((u8*)("vim_join_line"), (u64)(sizeof("vim_join_line") - 1)), vim_key_sequence(vim_key(KeyCode_J, KeyCode_Shift)));
    vim_bind_(vim_map, vim_align, SCu8((u8*)("vim_align"), (u64)(sizeof("vim_align") - 1)), vim_key_sequence(vim_key(KeyCode_G), vim_key(KeyCode_L)));
    vim_bind_(vim_map, vim_align_right, SCu8((u8*)("vim_align_right"), (u64)(sizeof("vim_align_right") - 1)), vim_key_sequence(vim_key(KeyCode_G), vim_key(KeyCode_L, KeyCode_Shift)));
    vim_bind_(vim_map, vim_align_string, SCu8((u8*)("vim_align_string"), (u64)(sizeof("vim_align_string") - 1)), vim_key_sequence(vim_key(KeyCode_G), vim_key(KeyCode_L, KeyCode_Control)));
    vim_bind_(vim_map, vim_align_string_right, SCu8((u8*)("vim_align_string_right"), (u64)(sizeof("vim_align_string_right") - 1)), vim_key_sequence(vim_key(KeyCode_G), vim_key(KeyCode_L, KeyCode_Shift, KeyCode_Control)));
    vim_bind_(vim_map, vim_lowercase, SCu8((u8*)("vim_lowercase"), (u64)(sizeof("vim_lowercase") - 1)), vim_key_sequence(vim_key(KeyCode_G), vim_key(KeyCode_U)));
    vim_bind_(vim_map, vim_uppercase, SCu8((u8*)("vim_uppercase"), (u64)(sizeof("vim_uppercase") - 1)), vim_key_sequence(vim_key(KeyCode_G), vim_key(KeyCode_U, KeyCode_Shift)));
    vim_bind_(vim_map, vim_miblo_increment, SCu8((u8*)("vim_miblo_increment"), (u64)(sizeof("vim_miblo_increment") - 1)), vim_key_sequence(vim_key(KeyCode_A, KeyCode_Control)));
    vim_bind_(vim_map, vim_miblo_decrement, SCu8((u8*)("vim_miblo_decrement"), (u64)(sizeof("vim_miblo_decrement") - 1)), vim_key_sequence(vim_key(KeyCode_X, KeyCode_Control)));
    vim_bind_(vim_map, vim_miblo_increment_sequence, SCu8((u8*)("vim_miblo_increment_sequence"), (u64)(sizeof("vim_miblo_increment_sequence") - 1)), vim_key_sequence(vim_key(KeyCode_G), vim_key(KeyCode_A, KeyCode_Control)));
    vim_bind_(vim_map, vim_miblo_decrement_sequence, SCu8((u8*)("vim_miblo_decrement_sequence"), (u64)(sizeof("vim_miblo_decrement_sequence") - 1)), vim_key_sequence(vim_key(KeyCode_G), vim_key(KeyCode_X, KeyCode_Control)));


    vim_bind_(vim_map, vim_enter_insert_mode, SCu8((u8*)("vim_enter_insert_mode"), (u64)(sizeof("vim_enter_insert_mode") - 1)), vim_key_sequence(vim_key(KeyCode_I)))->flags |= VimBindingFlag_TextCommand;
    vim_bind_(vim_map, vim_enter_insert_sol_mode, SCu8((u8*)("vim_enter_insert_sol_mode"), (u64)(sizeof("vim_enter_insert_sol_mode") - 1)), vim_key_sequence(vim_key(KeyCode_I, KeyCode_Shift)))->flags |= VimBindingFlag_TextCommand;
    vim_bind_(vim_map, vim_enter_append_mode, SCu8((u8*)("vim_enter_append_mode"), (u64)(sizeof("vim_enter_append_mode") - 1)), vim_key_sequence(vim_key(KeyCode_A)))->flags |= VimBindingFlag_TextCommand;
    vim_bind_(vim_map, vim_enter_append_eol_mode, SCu8((u8*)("vim_enter_append_eol_mode"), (u64)(sizeof("vim_enter_append_eol_mode") - 1)), vim_key_sequence(vim_key(KeyCode_A, KeyCode_Shift)))->flags |= VimBindingFlag_TextCommand;
    vim_bind_(vim_map, vim_toggle_visual_mode, SCu8((u8*)("vim_toggle_visual_mode"), (u64)(sizeof("vim_toggle_visual_mode") - 1)), vim_key_sequence(vim_key(KeyCode_V)));
    vim_bind_(vim_map, vim_toggle_visual_line_mode, SCu8((u8*)("vim_toggle_visual_line_mode"), (u64)(sizeof("vim_toggle_visual_line_mode") - 1)), vim_key_sequence(vim_key(KeyCode_V, KeyCode_Shift)));
    vim_bind_(vim_map, vim_toggle_visual_block_mode, SCu8((u8*)("vim_toggle_visual_block_mode"), (u64)(sizeof("vim_toggle_visual_block_mode") - 1)), vim_key_sequence(vim_key(KeyCode_V, KeyCode_Control)));

    vim_bind_(vim_map, change_active_panel, SCu8((u8*)("change_active_panel"), (u64)(sizeof("change_active_panel") - 1)), vim_key_sequence(vim_key(KeyCode_W, KeyCode_Control), vim_key(KeyCode_W)));
    vim_bind_(vim_map, change_active_panel, SCu8((u8*)("change_active_panel"), (u64)(sizeof("change_active_panel") - 1)), vim_key_sequence(vim_key(KeyCode_W, KeyCode_Control), vim_key(KeyCode_W, KeyCode_Control)));
    vim_bind_(vim_map, swap_panels, SCu8((u8*)("swap_panels"), (u64)(sizeof("swap_panels") - 1)), vim_key_sequence(vim_key(KeyCode_W, KeyCode_Control), vim_key(KeyCode_X)));
    vim_bind_(vim_map, swap_panels, SCu8((u8*)("swap_panels"), (u64)(sizeof("swap_panels") - 1)), vim_key_sequence(vim_key(KeyCode_W, KeyCode_Control), vim_key(KeyCode_X, KeyCode_Control)));
    vim_bind_(vim_map, windmove_panel_left, SCu8((u8*)("windmove_panel_left"), (u64)(sizeof("windmove_panel_left") - 1)), vim_key_sequence(vim_key(KeyCode_W, KeyCode_Control), vim_key(KeyCode_H)));
    vim_bind_(vim_map, windmove_panel_left, SCu8((u8*)("windmove_panel_left"), (u64)(sizeof("windmove_panel_left") - 1)), vim_key_sequence(vim_key(KeyCode_W, KeyCode_Control), vim_key(KeyCode_H, KeyCode_Control)));
    vim_bind_(vim_map, windmove_panel_down, SCu8((u8*)("windmove_panel_down"), (u64)(sizeof("windmove_panel_down") - 1)), vim_key_sequence(vim_key(KeyCode_W, KeyCode_Control), vim_key(KeyCode_J)));
    vim_bind_(vim_map, windmove_panel_down, SCu8((u8*)("windmove_panel_down"), (u64)(sizeof("windmove_panel_down") - 1)), vim_key_sequence(vim_key(KeyCode_W, KeyCode_Control), vim_key(KeyCode_J, KeyCode_Control)));
    vim_bind_(vim_map, windmove_panel_up, SCu8((u8*)("windmove_panel_up"), (u64)(sizeof("windmove_panel_up") - 1)), vim_key_sequence(vim_key(KeyCode_W, KeyCode_Control), vim_key(KeyCode_K)));
    vim_bind_(vim_map, windmove_panel_up, SCu8((u8*)("windmove_panel_up"), (u64)(sizeof("windmove_panel_up") - 1)), vim_key_sequence(vim_key(KeyCode_W, KeyCode_Control), vim_key(KeyCode_K, KeyCode_Control)));
    vim_bind_(vim_map, windmove_panel_right, SCu8((u8*)("windmove_panel_right"), (u64)(sizeof("windmove_panel_right") - 1)), vim_key_sequence(vim_key(KeyCode_W, KeyCode_Control), vim_key(KeyCode_L)));
    vim_bind_(vim_map, windmove_panel_right, SCu8((u8*)("windmove_panel_right"), (u64)(sizeof("windmove_panel_right") - 1)), vim_key_sequence(vim_key(KeyCode_W, KeyCode_Control), vim_key(KeyCode_L, KeyCode_Control)));
    vim_bind_(vim_map, windmove_panel_swap_left, SCu8((u8*)("windmove_panel_swap_left"), (u64)(sizeof("windmove_panel_swap_left") - 1)), vim_key_sequence(vim_key(KeyCode_W, KeyCode_Control), vim_key(KeyCode_H, KeyCode_Shift)));
    vim_bind_(vim_map, windmove_panel_swap_left, SCu8((u8*)("windmove_panel_swap_left"), (u64)(sizeof("windmove_panel_swap_left") - 1)), vim_key_sequence(vim_key(KeyCode_W, KeyCode_Control), vim_key(KeyCode_H, KeyCode_Shift, KeyCode_Control)));
    vim_bind_(vim_map, windmove_panel_swap_down, SCu8((u8*)("windmove_panel_swap_down"), (u64)(sizeof("windmove_panel_swap_down") - 1)), vim_key_sequence(vim_key(KeyCode_W, KeyCode_Control), vim_key(KeyCode_J, KeyCode_Shift)));
    vim_bind_(vim_map, windmove_panel_swap_down, SCu8((u8*)("windmove_panel_swap_down"), (u64)(sizeof("windmove_panel_swap_down") - 1)), vim_key_sequence(vim_key(KeyCode_W, KeyCode_Control), vim_key(KeyCode_J, KeyCode_Shift, KeyCode_Control)));
    vim_bind_(vim_map, windmove_panel_swap_up, SCu8((u8*)("windmove_panel_swap_up"), (u64)(sizeof("windmove_panel_swap_up") - 1)), vim_key_sequence(vim_key(KeyCode_W, KeyCode_Control), vim_key(KeyCode_K, KeyCode_Shift)));
    vim_bind_(vim_map, windmove_panel_swap_up, SCu8((u8*)("windmove_panel_swap_up"), (u64)(sizeof("windmove_panel_swap_up") - 1)), vim_key_sequence(vim_key(KeyCode_W, KeyCode_Control), vim_key(KeyCode_K, KeyCode_Shift, KeyCode_Control)));
    vim_bind_(vim_map, windmove_panel_swap_right, SCu8((u8*)("windmove_panel_swap_right"), (u64)(sizeof("windmove_panel_swap_right") - 1)), vim_key_sequence(vim_key(KeyCode_W, KeyCode_Control), vim_key(KeyCode_L, KeyCode_Shift)));
    vim_bind_(vim_map, windmove_panel_swap_right, SCu8((u8*)("windmove_panel_swap_right"), (u64)(sizeof("windmove_panel_swap_right") - 1)), vim_key_sequence(vim_key(KeyCode_W, KeyCode_Control), vim_key(KeyCode_L, KeyCode_Shift, KeyCode_Control)));
    vim_bind_(vim_map, vim_split_window_vertical, SCu8((u8*)("vim_split_window_vertical"), (u64)(sizeof("vim_split_window_vertical") - 1)), vim_key_sequence(vim_key(KeyCode_W, KeyCode_Control), vim_key(KeyCode_V)));
    vim_bind_(vim_map, vim_split_window_vertical, SCu8((u8*)("vim_split_window_vertical"), (u64)(sizeof("vim_split_window_vertical") - 1)), vim_key_sequence(vim_key(KeyCode_W, KeyCode_Control), vim_key(KeyCode_V, KeyCode_Control)));
    vim_bind_(vim_map, vim_split_window_horizontal, SCu8((u8*)("vim_split_window_horizontal"), (u64)(sizeof("vim_split_window_horizontal") - 1)), vim_key_sequence(vim_key(KeyCode_W, KeyCode_Control), vim_key(KeyCode_S)));
    vim_bind_(vim_map, vim_split_window_horizontal, SCu8((u8*)("vim_split_window_horizontal"), (u64)(sizeof("vim_split_window_horizontal") - 1)), vim_key_sequence(vim_key(KeyCode_W, KeyCode_Control), vim_key(KeyCode_S, KeyCode_Control)));

    vim_bind_(vim_map, center_view, SCu8((u8*)("center_view"), (u64)(sizeof("center_view") - 1)), vim_key_sequence(vim_key(KeyCode_Z), vim_key(KeyCode_Z)));
    vim_bind_(vim_map, vim_view_move_line_to_top, SCu8((u8*)("vim_view_move_line_to_top"), (u64)(sizeof("vim_view_move_line_to_top") - 1)), vim_key_sequence(vim_key(KeyCode_Z), vim_key(KeyCode_T)));
    vim_bind_(vim_map, vim_view_move_line_to_bottom, SCu8((u8*)("vim_view_move_line_to_bottom"), (u64)(sizeof("vim_view_move_line_to_bottom") - 1)), vim_key_sequence(vim_key(KeyCode_Z), vim_key(KeyCode_B)));

    vim_bind_(vim_map, vim_page_up, SCu8((u8*)("vim_page_up"), (u64)(sizeof("vim_page_up") - 1)), vim_key_sequence(vim_key(KeyCode_B, KeyCode_Control)));
    vim_bind_(vim_map, vim_page_down, SCu8((u8*)("vim_page_down"), (u64)(sizeof("vim_page_down") - 1)), vim_key_sequence(vim_key(KeyCode_F, KeyCode_Control)));
    vim_bind_(vim_map, vim_half_page_up, SCu8((u8*)("vim_half_page_up"), (u64)(sizeof("vim_half_page_up") - 1)), vim_key_sequence(vim_key(KeyCode_U, KeyCode_Control)));
    vim_bind_(vim_map, vim_half_page_down, SCu8((u8*)("vim_half_page_down"), (u64)(sizeof("vim_half_page_down") - 1)), vim_key_sequence(vim_key(KeyCode_D, KeyCode_Control)));

    vim_bind_(vim_map, vim_step_back_jump_history, SCu8((u8*)("vim_step_back_jump_history"), (u64)(sizeof("vim_step_back_jump_history") - 1)), vim_key_sequence(vim_key(KeyCode_O, KeyCode_Control)));
    vim_bind_(vim_map, vim_step_forward_jump_history, SCu8((u8*)("vim_step_forward_jump_history"), (u64)(sizeof("vim_step_forward_jump_history") - 1)), vim_key_sequence(vim_key(KeyCode_I, KeyCode_Control)));
    vim_bind_(vim_map, vim_previous_buffer, SCu8((u8*)("vim_previous_buffer"), (u64)(sizeof("vim_previous_buffer") - 1)), vim_key_sequence(vim_key(KeyCode_6, KeyCode_Control)));

    vim_bind_(vim_map, vim_record_macro, SCu8((u8*)("vim_record_macro"), (u64)(sizeof("vim_record_macro") - 1)), vim_key_sequence(vim_key(KeyCode_Q)));
    vim_bind_(vim_map, vim_replay_macro, SCu8((u8*)("vim_replay_macro"), (u64)(sizeof("vim_replay_macro") - 1)), vim_key_sequence(vim_key(KeyCode_2, KeyCode_Shift)))->flags |= VimBindingFlag_TextCommand;
    vim_bind_(vim_map, vim_set_mark, SCu8((u8*)("vim_set_mark"), (u64)(sizeof("vim_set_mark") - 1)), vim_key_sequence(vim_key(KeyCode_M)));
    vim_bind_(vim_map, vim_go_to_mark, SCu8((u8*)("vim_go_to_mark"), (u64)(sizeof("vim_go_to_mark") - 1)), vim_key_sequence(vim_key(KeyCode_Quote)));
    vim_bind_(vim_map, vim_go_to_mark, SCu8((u8*)("vim_go_to_mark"), (u64)(sizeof("vim_go_to_mark") - 1)), vim_key_sequence(vim_key(KeyCode_Tick)));
    vim_bind_(vim_map, vim_go_to_mark_less_history, SCu8((u8*)("vim_go_to_mark_less_history"), (u64)(sizeof("vim_go_to_mark_less_history") - 1)), vim_key_sequence(vim_key(KeyCode_G), vim_key(KeyCode_Quote)));
    vim_bind_(vim_map, vim_go_to_mark_less_history, SCu8((u8*)("vim_go_to_mark_less_history"), (u64)(sizeof("vim_go_to_mark_less_history") - 1)), vim_key_sequence(vim_key(KeyCode_G), vim_key(KeyCode_Tick)));
    vim_bind_(vim_map, vim_open_file_in_quotes_in_same_window, SCu8((u8*)("vim_open_file_in_quotes_in_same_window"), (u64)(sizeof("vim_open_file_in_quotes_in_same_window") - 1)), vim_key_sequence(vim_key(KeyCode_G), vim_key(KeyCode_F)));
    vim_bind_(vim_map, vim_jump_to_definition_under_cursor, SCu8((u8*)("vim_jump_to_definition_under_cursor"), (u64)(sizeof("vim_jump_to_definition_under_cursor") - 1)), vim_key_sequence(vim_key(KeyCode_RightBracket, KeyCode_Control)));

    vim_name_bind_(vim_map, SCu8((u8*)("Files"), (u64)(sizeof("Files") - 1)), vim_key_sequence(vim_leader, vim_key(KeyCode_F)));
    vim_bind_(vim_map, interactive_new, SCu8((u8*)("interactive_new"), (u64)(sizeof("interactive_new") - 1)), vim_key_sequence(vim_leader, vim_key(KeyCode_F), vim_key(KeyCode_N)));
    vim_bind_(vim_map, interactive_open_or_new, SCu8((u8*)("interactive_open_or_new"), (u64)(sizeof("interactive_open_or_new") - 1)), vim_key_sequence(vim_leader, vim_key(KeyCode_F), vim_key(KeyCode_E)));
    vim_bind_(vim_map, interactive_switch_buffer, SCu8((u8*)("interactive_switch_buffer"), (u64)(sizeof("interactive_switch_buffer") - 1)), vim_key_sequence(vim_leader, vim_key(KeyCode_F), vim_key(KeyCode_B)));
    vim_bind_(vim_map, interactive_kill_buffer, SCu8((u8*)("interactive_kill_buffer"), (u64)(sizeof("interactive_kill_buffer") - 1)), vim_key_sequence(vim_leader, vim_key(KeyCode_F), vim_key(KeyCode_K)));
    vim_bind_(vim_map, kill_buffer, SCu8((u8*)("kill_buffer"), (u64)(sizeof("kill_buffer") - 1)), vim_key_sequence(vim_leader, vim_key(KeyCode_F), vim_key(KeyCode_D)));
    vim_bind_(vim_map, q, SCu8((u8*)("q"), (u64)(sizeof("q") - 1)), vim_key_sequence(vim_leader, vim_key(KeyCode_F), vim_key(KeyCode_Q)));
    vim_bind_(vim_map, qa, SCu8((u8*)("qa"), (u64)(sizeof("qa") - 1)), vim_key_sequence(vim_leader, vim_key(KeyCode_F), vim_key(KeyCode_Q, KeyCode_Shift)));
    vim_bind_(vim_map, qa, SCu8((u8*)("qa"), (u64)(sizeof("qa") - 1)), vim_key_sequence(vim_leader, vim_key(KeyCode_F), vim_key(KeyCode_Q, KeyCode_Shift)));
    vim_bind_(vim_map, w, SCu8((u8*)("w"), (u64)(sizeof("w") - 1)), vim_key_sequence(vim_leader, vim_key(KeyCode_F), vim_key(KeyCode_W)));

    vim_name_bind_(vim_map, SCu8((u8*)("Search"), (u64)(sizeof("Search") - 1)), vim_key_sequence(vim_leader, vim_key(KeyCode_S)));
    vim_bind_(vim_map, list_all_substring_locations_case_insensitive, SCu8((u8*)("list_all_substring_locations_case_insensitive"), (u64)(sizeof("list_all_substring_locations_case_insensitive") - 1)), vim_key_sequence(vim_leader, vim_key(KeyCode_S), vim_key(KeyCode_S)));

    vim_name_bind_(vim_map, SCu8((u8*)("Tags"), (u64)(sizeof("Tags") - 1)), vim_key_sequence(vim_leader, vim_key(KeyCode_T)));
    vim_bind_(vim_map, jump_to_definition, SCu8((u8*)("jump_to_definition"), (u64)(sizeof("jump_to_definition") - 1)), vim_key_sequence(vim_leader, vim_key(KeyCode_T), vim_key(KeyCode_A)));

    vim_bind_(vim_map, vim_toggle_line_comment_range_indent_style, SCu8((u8*)("vim_toggle_line_comment_range_indent_style"), (u64)(sizeof("vim_toggle_line_comment_range_indent_style") - 1)), vim_key_sequence(vim_leader, vim_key(KeyCode_C), vim_key(KeyCode_Space)));

    vim_bind_(vim_map, vim_enter_normal_mode_escape, SCu8((u8*)("vim_enter_normal_mode_escape"), (u64)(sizeof("vim_enter_normal_mode_escape") - 1)), vim_key_sequence(vim_key(KeyCode_Escape)));
    vim_bind_(vim_map, vim_isearch_word_under_cursor, SCu8((u8*)("vim_isearch_word_under_cursor"), (u64)(sizeof("vim_isearch_word_under_cursor") - 1)), vim_key_sequence(vim_key(KeyCode_8, KeyCode_Shift)));
    vim_bind_(vim_map, vim_reverse_isearch_word_under_cursor, SCu8((u8*)("vim_reverse_isearch_word_under_cursor"), (u64)(sizeof("vim_reverse_isearch_word_under_cursor") - 1)), vim_key_sequence(vim_key(KeyCode_3, KeyCode_Shift)));
    vim_bind_(vim_map, vim_repeat_command, SCu8((u8*)("vim_repeat_command"), (u64)(sizeof("vim_repeat_command") - 1)), vim_key_sequence(vim_key(KeyCode_Period)));
    vim_bind_(vim_map, vim_move_line_up, SCu8((u8*)("vim_move_line_up"), (u64)(sizeof("vim_move_line_up") - 1)), vim_key_sequence(vim_key(KeyCode_K, KeyCode_Alt)));
    vim_bind_(vim_map, vim_move_line_down, SCu8((u8*)("vim_move_line_down"), (u64)(sizeof("vim_move_line_down") - 1)), vim_key_sequence(vim_key(KeyCode_J, KeyCode_Alt)));
    vim_bind_(vim_map, vim_isearch, SCu8((u8*)("vim_isearch"), (u64)(sizeof("vim_isearch") - 1)), vim_key_sequence(vim_key(KeyCode_ForwardSlash)));
    vim_bind_(vim_map, vim_isearch_backward, SCu8((u8*)("vim_isearch_backward"), (u64)(sizeof("vim_isearch_backward") - 1)), vim_key_sequence(vim_key(KeyCode_ForwardSlash, KeyCode_Shift)));
    vim_bind_(vim_map, vim_isearch_repeat_forward, SCu8((u8*)("vim_isearch_repeat_forward"), (u64)(sizeof("vim_isearch_repeat_forward") - 1)), vim_key_sequence(vim_key(KeyCode_N)));
    vim_bind_(vim_map, vim_isearch_repeat_backward, SCu8((u8*)("vim_isearch_repeat_backward"), (u64)(sizeof("vim_isearch_repeat_backward") - 1)), vim_key_sequence(vim_key(KeyCode_N, KeyCode_Shift)));
    vim_bind_(vim_map, noh, SCu8((u8*)("noh"), (u64)(sizeof("noh") - 1)), vim_key_sequence(vim_leader, vim_key(KeyCode_N)));
    vim_bind_(vim_map, goto_next_jump, SCu8((u8*)("goto_next_jump"), (u64)(sizeof("goto_next_jump") - 1)), vim_key_sequence(vim_key(KeyCode_N, KeyCode_Control)));
    vim_bind_(vim_map, goto_prev_jump, SCu8((u8*)("goto_prev_jump"), (u64)(sizeof("goto_prev_jump") - 1)), vim_key_sequence(vim_key(KeyCode_P, KeyCode_Control)));
    vim_bind_(vim_map, vim_undo, SCu8((u8*)("vim_undo"), (u64)(sizeof("vim_undo") - 1)), vim_key_sequence(vim_key(KeyCode_U)));
    vim_bind_(vim_map, vim_redo, SCu8((u8*)("vim_redo"), (u64)(sizeof("vim_redo") - 1)), vim_key_sequence(vim_key(KeyCode_R, KeyCode_Control)));
    vim_bind_(vim_map, command_lister, SCu8((u8*)("command_lister"), (u64)(sizeof("command_lister") - 1)), vim_key_sequence(vim_key(KeyCode_Semicolon, KeyCode_Shift)));
    vim_bind_(vim_map, if_read_only_goto_position, SCu8((u8*)("if_read_only_goto_position"), (u64)(sizeof("if_read_only_goto_position") - 1)), vim_key_sequence(vim_key(KeyCode_Return)));
    vim_bind_(vim_map, if_read_only_goto_position_same_panel, SCu8((u8*)("if_read_only_goto_position_same_panel"), (u64)(sizeof("if_read_only_goto_position_same_panel") - 1)), vim_key_sequence(vim_key(KeyCode_Return, KeyCode_Shift)));





    vim_map = vim_select_map_(app, &vim_map_visual);
    vim_add_parent_binding_map(vim_map, &(vim_map_normal));
    vim_add_parent_binding_map(vim_map, &(vim_map_text_objects));

    vim_bind_(vim_map, vim_enter_visual_insert_mode, SCu8((u8*)("vim_enter_visual_insert_mode"), (u64)(sizeof("vim_enter_visual_insert_mode") - 1)), vim_key_sequence(vim_key(KeyCode_I, KeyCode_Shift)))->flags |= VimBindingFlag_TextCommand;
    vim_bind_(vim_map, vim_enter_visual_append_mode, SCu8((u8*)("vim_enter_visual_append_mode"), (u64)(sizeof("vim_enter_visual_append_mode") - 1)), vim_key_sequence(vim_key(KeyCode_A, KeyCode_Shift)))->flags |= VimBindingFlag_TextCommand;

    vim_bind_(vim_map, vim_lowercase, SCu8((u8*)("vim_lowercase"), (u64)(sizeof("vim_lowercase") - 1)), vim_key_sequence(vim_key(KeyCode_U)));
    vim_bind_(vim_map, vim_uppercase, SCu8((u8*)("vim_uppercase"), (u64)(sizeof("vim_uppercase") - 1)), vim_key_sequence(vim_key(KeyCode_U, KeyCode_Shift)));

    vim_bind_(vim_map, vim_isearch_selection, SCu8((u8*)("vim_isearch_selection"), (u64)(sizeof("vim_isearch_selection") - 1)), vim_key_sequence(vim_key(KeyCode_ForwardSlash)));
    vim_bind_(vim_map, vim_reverse_isearch_selection, SCu8((u8*)("vim_reverse_isearch_selection"), (u64)(sizeof("vim_reverse_isearch_selection") - 1)), vim_key_sequence(vim_key(KeyCode_ForwardSlash, KeyCode_Shift)));
}

static void
vim_init(Application_Links* app) {
    vim_state.arena = make_arena_system();
    heap_init(&vim_state.heap, &vim_state.arena);
    vim_state.alloc = base_allocator_on_heap(&vim_state.heap);

    vim_state.active_register = &vim_state.unnamed_register;
    vim_state.search_direction = Scan_Forward;
    vim_state.chord_bar = Su8(vim_state.chord_bar_storage, 0, ((sizeof(vim_state.chord_bar_storage))/(sizeof(*vim_state.chord_bar_storage))));
    vim_state.echo_string = Su8(vim_state.echo_string_storage, 0, ((sizeof(vim_state.echo_string_storage))/(sizeof(*vim_state.echo_string_storage))));
    vim_state.echo_color = fcolor_id(defcolor_text_default);

    vim_state.next_command_rep = ((Vim_Command_Rep*)linalloc_wrap_zero(linalloc_push((&vim_state.arena), sizeof(Vim_Command_Rep)*(1), SCu8((u8*)("lib/external/4coder-vimmish/4coder_vimmish.cpp" ":" "6617" ":"), (u64)(sizeof("lib/external/4coder-vimmish/4coder_vimmish.cpp" ":" "6617" ":") - 1)))));
    vim_state.command_rep = ((Vim_Command_Rep*)linalloc_wrap_zero(linalloc_push((&vim_state.arena), sizeof(Vim_Command_Rep)*(1), SCu8((u8*)("lib/external/4coder-vimmish/4coder_vimmish.cpp" ":" "6618" ":"), (u64)(sizeof("lib/external/4coder-vimmish/4coder_vimmish.cpp" ":" "6618" ":") - 1)))));

    if (sizeof("jk") != 0 && sizeof("jk") != 3) {
        vim_echo_alert(app, "Warning: Only two-character escape sequences are supported.");
    }

    vim_set_default_colors(app);
}

static void
vim_set_default_hooks(Application_Links* app) {
    set_custom_hook((app),(HookID_ViewEventHandler),(Void_Func*)(vim_default_view_handler));
    set_custom_hook((app),(HookID_RenderCaller),(Void_Func*)(vim_render_caller));
    set_custom_hook((app),(HookID_WholeScreenRenderCaller),(Void_Func*)(vim_whole_screen_render_caller));
    set_custom_hook((app),(HookID_BeginBuffer),(Void_Func*)(vim_begin_buffer));
    set_custom_hook((app),(HookID_Tick),(Void_Func*)(vim_tick));
    set_custom_hook((app),(HookID_BufferEditRange),(Void_Func*)(vim_default_buffer_edit_range));
}
# 14 "4coder_sam.cpp" 2
# 1 "lib/project_lister.cpp" 1
# 1 "/usr/include/json/json.h" 1 3 4
# 9 "/usr/include/json/json.h" 3 4
# 1 "/usr/include/json/config.h" 1 3 4







# 1 "/usr/include/c++/10.2.0/cstddef" 1 3 4
# 42 "/usr/include/c++/10.2.0/cstddef" 3 4
       
# 43 "/usr/include/c++/10.2.0/cstddef" 3







# 1 "/usr/lib/gcc/x86_64-pc-linux-gnu/10.2.0/include/stddef.h" 1 3 4
# 143 "/usr/lib/gcc/x86_64-pc-linux-gnu/10.2.0/include/stddef.h" 3 4

# 143 "/usr/lib/gcc/x86_64-pc-linux-gnu/10.2.0/include/stddef.h" 3 4
typedef long int ptrdiff_t;
# 415 "/usr/lib/gcc/x86_64-pc-linux-gnu/10.2.0/include/stddef.h" 3 4
typedef struct {
  long long __max_align_ll __attribute__((__aligned__(__alignof__(long long))));
  long double __max_align_ld __attribute__((__aligned__(__alignof__(long double))));
# 426 "/usr/lib/gcc/x86_64-pc-linux-gnu/10.2.0/include/stddef.h" 3 4
} max_align_t;






  typedef decltype(nullptr) nullptr_t;
# 51 "/usr/include/c++/10.2.0/cstddef" 2 3

extern "C++"
{

namespace std
{

  using ::max_align_t;
}
# 179 "/usr/include/c++/10.2.0/cstddef" 3
}
# 9 "/usr/include/json/config.h" 2 3 4
# 1 "/usr/include/c++/10.2.0/cstdint" 1 3 4
# 32 "/usr/include/c++/10.2.0/cstdint" 3 4
       
# 33 "/usr/include/c++/10.2.0/cstdint" 3
# 44 "/usr/include/c++/10.2.0/cstdint" 3
namespace std
{

  using ::int8_t;
  using ::int16_t;
  using ::int32_t;
  using ::int64_t;

  using ::int_fast8_t;
  using ::int_fast16_t;
  using ::int_fast32_t;
  using ::int_fast64_t;

  using ::int_least8_t;
  using ::int_least16_t;
  using ::int_least32_t;
  using ::int_least64_t;

  using ::intmax_t;
  using ::intptr_t;

  using ::uint8_t;
  using ::uint16_t;
  using ::uint32_t;
  using ::uint64_t;

  using ::uint_fast8_t;
  using ::uint_fast16_t;
  using ::uint_fast32_t;
  using ::uint_fast64_t;

  using ::uint_least8_t;
  using ::uint_least16_t;
  using ::uint_least32_t;
  using ::uint_least64_t;

  using ::uintmax_t;
  using ::uintptr_t;





}
# 10 "/usr/include/json/config.h" 2 3 4
# 1 "/usr/include/c++/10.2.0/istream" 1 3 4
# 36 "/usr/include/c++/10.2.0/istream" 3 4
       
# 37 "/usr/include/c++/10.2.0/istream" 3

# 1 "/usr/include/c++/10.2.0/ios" 1 3
# 36 "/usr/include/c++/10.2.0/ios" 3
       
# 37 "/usr/include/c++/10.2.0/ios" 3

# 1 "/usr/include/c++/10.2.0/iosfwd" 1 3
# 36 "/usr/include/c++/10.2.0/iosfwd" 3
       
# 37 "/usr/include/c++/10.2.0/iosfwd" 3


# 1 "/usr/include/c++/10.2.0/bits/stringfwd.h" 1 3
# 37 "/usr/include/c++/10.2.0/bits/stringfwd.h" 3
       
# 38 "/usr/include/c++/10.2.0/bits/stringfwd.h" 3


# 1 "/usr/include/c++/10.2.0/bits/memoryfwd.h" 1 3
# 46 "/usr/include/c++/10.2.0/bits/memoryfwd.h" 3
       
# 47 "/usr/include/c++/10.2.0/bits/memoryfwd.h" 3



namespace std __attribute__ ((__visibility__ ("default")))
{

# 63 "/usr/include/c++/10.2.0/bits/memoryfwd.h" 3
  template<typename>
    class allocator;


  template<>
    class allocator<void>;




  template<typename, typename>
    struct uses_allocator;





}
# 41 "/usr/include/c++/10.2.0/bits/stringfwd.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{








  template<class _CharT>
    struct char_traits;

  template<> struct char_traits<char>;


  template<> struct char_traits<wchar_t>;







  template<> struct char_traits<char16_t>;
  template<> struct char_traits<char32_t>;


namespace __cxx11 {

  template<typename _CharT, typename _Traits = char_traits<_CharT>,
           typename _Alloc = allocator<_CharT> >
    class basic_string;

}


  typedef basic_string<char> string;



  typedef basic_string<wchar_t> wstring;
# 93 "/usr/include/c++/10.2.0/bits/stringfwd.h" 3
  typedef basic_string<char16_t> u16string;


  typedef basic_string<char32_t> u32string;





}
# 40 "/usr/include/c++/10.2.0/iosfwd" 2 3
# 1 "/usr/include/c++/10.2.0/bits/postypes.h" 1 3
# 38 "/usr/include/c++/10.2.0/bits/postypes.h" 3
       
# 39 "/usr/include/c++/10.2.0/bits/postypes.h" 3

# 1 "/usr/include/c++/10.2.0/cwchar" 1 3
# 39 "/usr/include/c++/10.2.0/cwchar" 3
       
# 40 "/usr/include/c++/10.2.0/cwchar" 3




# 1 "/usr/include/wchar.h" 1 3 4
# 27 "/usr/include/wchar.h" 3 4
# 1 "/usr/include/bits/libc-header-start.h" 1 3 4
# 28 "/usr/include/wchar.h" 2 3 4







# 1 "/usr/lib/gcc/x86_64-pc-linux-gnu/10.2.0/include/stddef.h" 1 3 4
# 36 "/usr/include/wchar.h" 2 3 4





# 1 "/usr/include/bits/types/wint_t.h" 1 3 4
# 20 "/usr/include/bits/types/wint_t.h" 3 4
typedef unsigned int wint_t;
# 42 "/usr/include/wchar.h" 2 3 4
# 1 "/usr/include/bits/types/mbstate_t.h" 1 3 4





typedef __mbstate_t mbstate_t;
# 43 "/usr/include/wchar.h" 2 3 4
# 79 "/usr/include/wchar.h" 3 4
extern "C" {



struct tm;



extern wchar_t *wcscpy (wchar_t *__restrict __dest,
   const wchar_t *__restrict __src)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern wchar_t *wcsncpy (wchar_t *__restrict __dest,
    const wchar_t *__restrict __src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern wchar_t *wcscat (wchar_t *__restrict __dest,
   const wchar_t *__restrict __src)
     throw () __attribute__ ((__nonnull__ (1, 2)));

extern wchar_t *wcsncat (wchar_t *__restrict __dest,
    const wchar_t *__restrict __src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int wcscmp (const wchar_t *__s1, const wchar_t *__s2)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));

extern int wcsncmp (const wchar_t *__s1, const wchar_t *__s2, size_t __n)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));



extern int wcscasecmp (const wchar_t *__s1, const wchar_t *__s2) throw ();


extern int wcsncasecmp (const wchar_t *__s1, const wchar_t *__s2,
   size_t __n) throw ();



extern int wcscasecmp_l (const wchar_t *__s1, const wchar_t *__s2,
    locale_t __loc) throw ();

extern int wcsncasecmp_l (const wchar_t *__s1, const wchar_t *__s2,
     size_t __n, locale_t __loc) throw ();




extern int wcscoll (const wchar_t *__s1, const wchar_t *__s2) throw ();



extern size_t wcsxfrm (wchar_t *__restrict __s1,
         const wchar_t *__restrict __s2, size_t __n) throw ();







extern int wcscoll_l (const wchar_t *__s1, const wchar_t *__s2,
        locale_t __loc) throw ();




extern size_t wcsxfrm_l (wchar_t *__s1, const wchar_t *__s2,
    size_t __n, locale_t __loc) throw ();


extern wchar_t *wcsdup (const wchar_t *__s) throw () __attribute__ ((__malloc__));




extern "C++" wchar_t *wcschr (wchar_t *__wcs, wchar_t __wc)
     throw () __asm ("wcschr") __attribute__ ((__pure__));
extern "C++" const wchar_t *wcschr (const wchar_t *__wcs, wchar_t __wc)
     throw () __asm ("wcschr") __attribute__ ((__pure__));






extern "C++" wchar_t *wcsrchr (wchar_t *__wcs, wchar_t __wc)
     throw () __asm ("wcsrchr") __attribute__ ((__pure__));
extern "C++" const wchar_t *wcsrchr (const wchar_t *__wcs, wchar_t __wc)
     throw () __asm ("wcsrchr") __attribute__ ((__pure__));
# 181 "/usr/include/wchar.h" 3 4
extern wchar_t *wcschrnul (const wchar_t *__s, wchar_t __wc)
     throw () __attribute__ ((__pure__));




extern size_t wcscspn (const wchar_t *__wcs, const wchar_t *__reject)
     throw () __attribute__ ((__pure__));


extern size_t wcsspn (const wchar_t *__wcs, const wchar_t *__accept)
     throw () __attribute__ ((__pure__));


extern "C++" wchar_t *wcspbrk (wchar_t *__wcs, const wchar_t *__accept)
     throw () __asm ("wcspbrk") __attribute__ ((__pure__));
extern "C++" const wchar_t *wcspbrk (const wchar_t *__wcs,
         const wchar_t *__accept)
     throw () __asm ("wcspbrk") __attribute__ ((__pure__));






extern "C++" wchar_t *wcsstr (wchar_t *__haystack, const wchar_t *__needle)
     throw () __asm ("wcsstr") __attribute__ ((__pure__));
extern "C++" const wchar_t *wcsstr (const wchar_t *__haystack,
        const wchar_t *__needle)
     throw () __asm ("wcsstr") __attribute__ ((__pure__));






extern wchar_t *wcstok (wchar_t *__restrict __s,
   const wchar_t *__restrict __delim,
   wchar_t **__restrict __ptr) throw ();


extern size_t wcslen (const wchar_t *__s) throw () __attribute__ ((__pure__));




extern "C++" wchar_t *wcswcs (wchar_t *__haystack, const wchar_t *__needle)
     throw () __asm ("wcswcs") __attribute__ ((__pure__));
extern "C++" const wchar_t *wcswcs (const wchar_t *__haystack,
        const wchar_t *__needle)
     throw () __asm ("wcswcs") __attribute__ ((__pure__));
# 240 "/usr/include/wchar.h" 3 4
extern size_t wcsnlen (const wchar_t *__s, size_t __maxlen)
     throw () __attribute__ ((__pure__));





extern "C++" wchar_t *wmemchr (wchar_t *__s, wchar_t __c, size_t __n)
     throw () __asm ("wmemchr") __attribute__ ((__pure__));
extern "C++" const wchar_t *wmemchr (const wchar_t *__s, wchar_t __c,
         size_t __n)
     throw () __asm ("wmemchr") __attribute__ ((__pure__));






extern int wmemcmp (const wchar_t *__s1, const wchar_t *__s2, size_t __n)
     throw () __attribute__ ((__pure__));


extern wchar_t *wmemcpy (wchar_t *__restrict __s1,
    const wchar_t *__restrict __s2, size_t __n) throw ();



extern wchar_t *wmemmove (wchar_t *__s1, const wchar_t *__s2, size_t __n)
     throw ();


extern wchar_t *wmemset (wchar_t *__s, wchar_t __c, size_t __n) throw ();




extern wchar_t *wmempcpy (wchar_t *__restrict __s1,
     const wchar_t *__restrict __s2, size_t __n)
     throw ();





extern wint_t btowc (int __c) throw ();



extern int wctob (wint_t __c) throw ();



extern int mbsinit (const mbstate_t *__ps) throw () __attribute__ ((__pure__));



extern size_t mbrtowc (wchar_t *__restrict __pwc,
         const char *__restrict __s, size_t __n,
         mbstate_t *__restrict __p) throw ();


extern size_t wcrtomb (char *__restrict __s, wchar_t __wc,
         mbstate_t *__restrict __ps) throw ();


extern size_t __mbrlen (const char *__restrict __s, size_t __n,
   mbstate_t *__restrict __ps) throw ();
extern size_t mbrlen (const char *__restrict __s, size_t __n,
        mbstate_t *__restrict __ps) throw ();
# 337 "/usr/include/wchar.h" 3 4
extern size_t mbsrtowcs (wchar_t *__restrict __dst,
    const char **__restrict __src, size_t __len,
    mbstate_t *__restrict __ps) throw ();



extern size_t wcsrtombs (char *__restrict __dst,
    const wchar_t **__restrict __src, size_t __len,
    mbstate_t *__restrict __ps) throw ();





extern size_t mbsnrtowcs (wchar_t *__restrict __dst,
     const char **__restrict __src, size_t __nmc,
     size_t __len, mbstate_t *__restrict __ps) throw ();



extern size_t wcsnrtombs (char *__restrict __dst,
     const wchar_t **__restrict __src,
     size_t __nwc, size_t __len,
     mbstate_t *__restrict __ps) throw ();






extern int wcwidth (wchar_t __c) throw ();



extern int wcswidth (const wchar_t *__s, size_t __n) throw ();





extern double wcstod (const wchar_t *__restrict __nptr,
        wchar_t **__restrict __endptr) throw ();



extern float wcstof (const wchar_t *__restrict __nptr,
       wchar_t **__restrict __endptr) throw ();
extern long double wcstold (const wchar_t *__restrict __nptr,
       wchar_t **__restrict __endptr) throw ();
# 396 "/usr/include/wchar.h" 3 4
extern _Float32 wcstof32 (const wchar_t *__restrict __nptr,
     wchar_t **__restrict __endptr) throw ();



extern _Float64 wcstof64 (const wchar_t *__restrict __nptr,
     wchar_t **__restrict __endptr) throw ();



extern _Float128 wcstof128 (const wchar_t *__restrict __nptr,
       wchar_t **__restrict __endptr) throw ();



extern _Float32x wcstof32x (const wchar_t *__restrict __nptr,
       wchar_t **__restrict __endptr) throw ();



extern _Float64x wcstof64x (const wchar_t *__restrict __nptr,
       wchar_t **__restrict __endptr) throw ();
# 428 "/usr/include/wchar.h" 3 4
extern long int wcstol (const wchar_t *__restrict __nptr,
   wchar_t **__restrict __endptr, int __base) throw ();



extern unsigned long int wcstoul (const wchar_t *__restrict __nptr,
      wchar_t **__restrict __endptr, int __base)
     throw ();




__extension__
extern long long int wcstoll (const wchar_t *__restrict __nptr,
         wchar_t **__restrict __endptr, int __base)
     throw ();



__extension__
extern unsigned long long int wcstoull (const wchar_t *__restrict __nptr,
     wchar_t **__restrict __endptr,
     int __base) throw ();





__extension__
extern long long int wcstoq (const wchar_t *__restrict __nptr,
        wchar_t **__restrict __endptr, int __base)
     throw ();



__extension__
extern unsigned long long int wcstouq (const wchar_t *__restrict __nptr,
           wchar_t **__restrict __endptr,
           int __base) throw ();






extern long int wcstol_l (const wchar_t *__restrict __nptr,
     wchar_t **__restrict __endptr, int __base,
     locale_t __loc) throw ();

extern unsigned long int wcstoul_l (const wchar_t *__restrict __nptr,
        wchar_t **__restrict __endptr,
        int __base, locale_t __loc) throw ();

__extension__
extern long long int wcstoll_l (const wchar_t *__restrict __nptr,
    wchar_t **__restrict __endptr,
    int __base, locale_t __loc) throw ();

__extension__
extern unsigned long long int wcstoull_l (const wchar_t *__restrict __nptr,
       wchar_t **__restrict __endptr,
       int __base, locale_t __loc)
     throw ();

extern double wcstod_l (const wchar_t *__restrict __nptr,
   wchar_t **__restrict __endptr, locale_t __loc)
     throw ();

extern float wcstof_l (const wchar_t *__restrict __nptr,
         wchar_t **__restrict __endptr, locale_t __loc)
     throw ();

extern long double wcstold_l (const wchar_t *__restrict __nptr,
         wchar_t **__restrict __endptr,
         locale_t __loc) throw ();
# 511 "/usr/include/wchar.h" 3 4
extern _Float32 wcstof32_l (const wchar_t *__restrict __nptr,
       wchar_t **__restrict __endptr,
       locale_t __loc) throw ();



extern _Float64 wcstof64_l (const wchar_t *__restrict __nptr,
       wchar_t **__restrict __endptr,
       locale_t __loc) throw ();



extern _Float128 wcstof128_l (const wchar_t *__restrict __nptr,
         wchar_t **__restrict __endptr,
         locale_t __loc) throw ();



extern _Float32x wcstof32x_l (const wchar_t *__restrict __nptr,
         wchar_t **__restrict __endptr,
         locale_t __loc) throw ();



extern _Float64x wcstof64x_l (const wchar_t *__restrict __nptr,
         wchar_t **__restrict __endptr,
         locale_t __loc) throw ();
# 551 "/usr/include/wchar.h" 3 4
extern wchar_t *wcpcpy (wchar_t *__restrict __dest,
   const wchar_t *__restrict __src) throw ();



extern wchar_t *wcpncpy (wchar_t *__restrict __dest,
    const wchar_t *__restrict __src, size_t __n)
     throw ();
# 567 "/usr/include/wchar.h" 3 4
extern __FILE *open_wmemstream (wchar_t **__bufloc, size_t *__sizeloc) throw ();





extern int fwide (__FILE *__fp, int __mode) throw ();






extern int fwprintf (__FILE *__restrict __stream,
       const wchar_t *__restrict __format, ...)
                                                           ;




extern int wprintf (const wchar_t *__restrict __format, ...)
                                                           ;

extern int swprintf (wchar_t *__restrict __s, size_t __n,
       const wchar_t *__restrict __format, ...)
     throw () ;





extern int vfwprintf (__FILE *__restrict __s,
        const wchar_t *__restrict __format,
        __gnuc_va_list __arg)
                                                           ;




extern int vwprintf (const wchar_t *__restrict __format,
       __gnuc_va_list __arg)
                                                           ;


extern int vswprintf (wchar_t *__restrict __s, size_t __n,
        const wchar_t *__restrict __format,
        __gnuc_va_list __arg)
     throw () ;






extern int fwscanf (__FILE *__restrict __stream,
      const wchar_t *__restrict __format, ...)
                                                          ;




extern int wscanf (const wchar_t *__restrict __format, ...)
                                                          ;

extern int swscanf (const wchar_t *__restrict __s,
      const wchar_t *__restrict __format, ...)
     throw () ;
# 642 "/usr/include/wchar.h" 3 4
extern int fwscanf (__FILE *__restrict __stream, const wchar_t *__restrict __format, ...) __asm__ ("" "__isoc99_fwscanf")


                                                          ;
extern int wscanf (const wchar_t *__restrict __format, ...) __asm__ ("" "__isoc99_wscanf")

                                                          ;
extern int swscanf (const wchar_t *__restrict __s, const wchar_t *__restrict __format, ...) throw () __asm__ ("" "__isoc99_swscanf")


                                                          ;
# 673 "/usr/include/wchar.h" 3 4
extern int vfwscanf (__FILE *__restrict __s,
       const wchar_t *__restrict __format,
       __gnuc_va_list __arg)
                                                          ;




extern int vwscanf (const wchar_t *__restrict __format,
      __gnuc_va_list __arg)
                                                          ;

extern int vswscanf (const wchar_t *__restrict __s,
       const wchar_t *__restrict __format,
       __gnuc_va_list __arg)
     throw () ;







extern int vfwscanf (__FILE *__restrict __s, const wchar_t *__restrict __format, __gnuc_va_list __arg) __asm__ ("" "__isoc99_vfwscanf")


                                                          ;
extern int vwscanf (const wchar_t *__restrict __format, __gnuc_va_list __arg) __asm__ ("" "__isoc99_vwscanf")

                                                          ;
extern int vswscanf (const wchar_t *__restrict __s, const wchar_t *__restrict __format, __gnuc_va_list __arg) throw () __asm__ ("" "__isoc99_vswscanf")


                                                          ;
# 729 "/usr/include/wchar.h" 3 4
extern wint_t fgetwc (__FILE *__stream);
extern wint_t getwc (__FILE *__stream);





extern wint_t getwchar (void);






extern wint_t fputwc (wchar_t __wc, __FILE *__stream);
extern wint_t putwc (wchar_t __wc, __FILE *__stream);





extern wint_t putwchar (wchar_t __wc);







extern wchar_t *fgetws (wchar_t *__restrict __ws, int __n,
   __FILE *__restrict __stream);





extern int fputws (const wchar_t *__restrict __ws,
     __FILE *__restrict __stream);






extern wint_t ungetwc (wint_t __wc, __FILE *__stream);
# 784 "/usr/include/wchar.h" 3 4
extern wint_t getwc_unlocked (__FILE *__stream);
extern wint_t getwchar_unlocked (void);







extern wint_t fgetwc_unlocked (__FILE *__stream);







extern wint_t fputwc_unlocked (wchar_t __wc, __FILE *__stream);
# 810 "/usr/include/wchar.h" 3 4
extern wint_t putwc_unlocked (wchar_t __wc, __FILE *__stream);
extern wint_t putwchar_unlocked (wchar_t __wc);
# 820 "/usr/include/wchar.h" 3 4
extern wchar_t *fgetws_unlocked (wchar_t *__restrict __ws, int __n,
     __FILE *__restrict __stream);







extern int fputws_unlocked (const wchar_t *__restrict __ws,
       __FILE *__restrict __stream);






extern size_t wcsftime (wchar_t *__restrict __s, size_t __maxsize,
   const wchar_t *__restrict __format,
   const struct tm *__restrict __tp) throw ();




extern size_t wcsftime_l (wchar_t *__restrict __s, size_t __maxsize,
     const wchar_t *__restrict __format,
     const struct tm *__restrict __tp,
     locale_t __loc) throw ();
# 860 "/usr/include/wchar.h" 3 4
}
# 45 "/usr/include/c++/10.2.0/cwchar" 2 3
# 62 "/usr/include/c++/10.2.0/cwchar" 3
namespace std
{
  using ::mbstate_t;
}
# 135 "/usr/include/c++/10.2.0/cwchar" 3
extern "C++"
{
namespace std __attribute__ ((__visibility__ ("default")))
{


  using ::wint_t;

  using ::btowc;
  using ::fgetwc;
  using ::fgetws;
  using ::fputwc;
  using ::fputws;
  using ::fwide;
  using ::fwprintf;
  using ::fwscanf;
  using ::getwc;
  using ::getwchar;
  using ::mbrlen;
  using ::mbrtowc;
  using ::mbsinit;
  using ::mbsrtowcs;
  using ::putwc;
  using ::putwchar;

  using ::swprintf;

  using ::swscanf;
  using ::ungetwc;
  using ::vfwprintf;

  using ::vfwscanf;


  using ::vswprintf;


  using ::vswscanf;

  using ::vwprintf;

  using ::vwscanf;

  using ::wcrtomb;
  using ::wcscat;
  using ::wcscmp;
  using ::wcscoll;
  using ::wcscpy;
  using ::wcscspn;
  using ::wcsftime;
  using ::wcslen;
  using ::wcsncat;
  using ::wcsncmp;
  using ::wcsncpy;
  using ::wcsrtombs;
  using ::wcsspn;
  using ::wcstod;

  using ::wcstof;

  using ::wcstok;
  using ::wcstol;
  using ::wcstoul;
  using ::wcsxfrm;
  using ::wctob;
  using ::wmemcmp;
  using ::wmemcpy;
  using ::wmemmove;
  using ::wmemset;
  using ::wprintf;
  using ::wscanf;
  using ::wcschr;
  using ::wcspbrk;
  using ::wcsrchr;
  using ::wcsstr;
  using ::wmemchr;
# 234 "/usr/include/c++/10.2.0/cwchar" 3

}
}







namespace __gnu_cxx
{





  using ::wcstold;
# 260 "/usr/include/c++/10.2.0/cwchar" 3
  using ::wcstoll;
  using ::wcstoull;

}

namespace std
{
  using ::__gnu_cxx::wcstold;
  using ::__gnu_cxx::wcstoll;
  using ::__gnu_cxx::wcstoull;
}
# 280 "/usr/include/c++/10.2.0/cwchar" 3
namespace std
{

  using std::wcstof;


  using std::vfwscanf;


  using std::vswscanf;


  using std::vwscanf;



  using std::wcstold;
  using std::wcstoll;
  using std::wcstoull;

}
# 41 "/usr/include/c++/10.2.0/bits/postypes.h" 2 3
# 68 "/usr/include/c++/10.2.0/bits/postypes.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{

# 88 "/usr/include/c++/10.2.0/bits/postypes.h" 3
  typedef long streamoff;
# 98 "/usr/include/c++/10.2.0/bits/postypes.h" 3
  typedef ptrdiff_t streamsize;
# 111 "/usr/include/c++/10.2.0/bits/postypes.h" 3
  template<typename _StateT>
    class fpos
    {
    private:
      streamoff _M_off;
      _StateT _M_state;

    public:




      fpos()
      : _M_off(0), _M_state() { }
# 133 "/usr/include/c++/10.2.0/bits/postypes.h" 3
      fpos(streamoff __off)
      : _M_off(__off), _M_state() { }


      fpos(const fpos&) = default;
      fpos& operator=(const fpos&) = default;
      ~fpos() = default;



      operator streamoff() const { return _M_off; }


      void
      state(_StateT __st)
      { _M_state = __st; }


      _StateT
      state() const
      { return _M_state; }





      fpos&
      operator+=(streamoff __off)
      {
 _M_off += __off;
 return *this;
      }





      fpos&
      operator-=(streamoff __off)
      {
 _M_off -= __off;
 return *this;
      }







      fpos
      operator+(streamoff __off) const
      {
 fpos __pos(*this);
 __pos += __off;
 return __pos;
      }







      fpos
      operator-(streamoff __off) const
      {
 fpos __pos(*this);
 __pos -= __off;
 return __pos;
      }






      streamoff
      operator-(const fpos& __other) const
      { return _M_off - __other._M_off; }
    };






  template<typename _StateT>
    inline bool
    operator==(const fpos<_StateT>& __lhs, const fpos<_StateT>& __rhs)
    { return streamoff(__lhs) == streamoff(__rhs); }

  template<typename _StateT>
    inline bool
    operator!=(const fpos<_StateT>& __lhs, const fpos<_StateT>& __rhs)
    { return streamoff(__lhs) != streamoff(__rhs); }





  typedef fpos<mbstate_t> streampos;

  typedef fpos<mbstate_t> wstreampos;
# 245 "/usr/include/c++/10.2.0/bits/postypes.h" 3
  typedef fpos<mbstate_t> u16streampos;

  typedef fpos<mbstate_t> u32streampos;



}
# 41 "/usr/include/c++/10.2.0/iosfwd" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{

# 74 "/usr/include/c++/10.2.0/iosfwd" 3
  class ios_base;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_ios;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_streambuf;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_istream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_ostream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_iostream;


namespace __cxx11 {

  template<typename _CharT, typename _Traits = char_traits<_CharT>,
     typename _Alloc = allocator<_CharT> >
    class basic_stringbuf;

  template<typename _CharT, typename _Traits = char_traits<_CharT>,
    typename _Alloc = allocator<_CharT> >
    class basic_istringstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT>,
    typename _Alloc = allocator<_CharT> >
    class basic_ostringstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT>,
    typename _Alloc = allocator<_CharT> >
    class basic_stringstream;

}

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_filebuf;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_ifstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_ofstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_fstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class istreambuf_iterator;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class ostreambuf_iterator;



  typedef basic_ios<char> ios;


  typedef basic_streambuf<char> streambuf;


  typedef basic_istream<char> istream;


  typedef basic_ostream<char> ostream;


  typedef basic_iostream<char> iostream;


  typedef basic_stringbuf<char> stringbuf;


  typedef basic_istringstream<char> istringstream;


  typedef basic_ostringstream<char> ostringstream;


  typedef basic_stringstream<char> stringstream;


  typedef basic_filebuf<char> filebuf;


  typedef basic_ifstream<char> ifstream;


  typedef basic_ofstream<char> ofstream;


  typedef basic_fstream<char> fstream;



  typedef basic_ios<wchar_t> wios;


  typedef basic_streambuf<wchar_t> wstreambuf;


  typedef basic_istream<wchar_t> wistream;


  typedef basic_ostream<wchar_t> wostream;


  typedef basic_iostream<wchar_t> wiostream;


  typedef basic_stringbuf<wchar_t> wstringbuf;


  typedef basic_istringstream<wchar_t> wistringstream;


  typedef basic_ostringstream<wchar_t> wostringstream;


  typedef basic_stringstream<wchar_t> wstringstream;


  typedef basic_filebuf<wchar_t> wfilebuf;


  typedef basic_ifstream<wchar_t> wifstream;


  typedef basic_ofstream<wchar_t> wofstream;


  typedef basic_fstream<wchar_t> wfstream;




}
# 39 "/usr/include/c++/10.2.0/ios" 2 3
# 1 "/usr/include/c++/10.2.0/exception" 1 3
# 33 "/usr/include/c++/10.2.0/exception" 3
       
# 34 "/usr/include/c++/10.2.0/exception" 3

#pragma GCC visibility push(default)


# 1 "/usr/include/c++/10.2.0/bits/exception.h" 1 3
# 34 "/usr/include/c++/10.2.0/bits/exception.h" 3
       
# 35 "/usr/include/c++/10.2.0/bits/exception.h" 3

#pragma GCC visibility push(default)



extern "C++" {

namespace std
{
# 60 "/usr/include/c++/10.2.0/bits/exception.h" 3
  class exception
  {
  public:
    exception() noexcept { }
    virtual ~exception() noexcept;

    exception(const exception&) = default;
    exception& operator=(const exception&) = default;
    exception(exception&&) = default;
    exception& operator=(exception&&) = default;




    virtual const char*
    what() const noexcept;
  };

}

}

#pragma GCC visibility pop
# 39 "/usr/include/c++/10.2.0/exception" 2 3

extern "C++" {

namespace std
{






  class bad_exception : public exception
  {
  public:
    bad_exception() noexcept { }



    virtual ~bad_exception() noexcept;


    virtual const char*
    what() const noexcept;
  };


  typedef void (*terminate_handler) ();


  typedef void (*unexpected_handler) ();


  terminate_handler set_terminate(terminate_handler) noexcept;



  terminate_handler get_terminate() noexcept;




  void terminate() noexcept __attribute__ ((__noreturn__));


  unexpected_handler set_unexpected(unexpected_handler) noexcept;



  unexpected_handler get_unexpected() noexcept;




  void unexpected() __attribute__ ((__noreturn__));
# 105 "/usr/include/c++/10.2.0/exception" 3
 
  bool uncaught_exception() noexcept __attribute__ ((__pure__));
# 115 "/usr/include/c++/10.2.0/exception" 3
}

namespace __gnu_cxx
{

# 137 "/usr/include/c++/10.2.0/exception" 3
  void __verbose_terminate_handler();


}

}

#pragma GCC visibility pop


# 1 "/usr/include/c++/10.2.0/bits/exception_ptr.h" 1 3
# 34 "/usr/include/c++/10.2.0/bits/exception_ptr.h" 3
#pragma GCC visibility push(default)


# 1 "/usr/include/c++/10.2.0/bits/exception_defines.h" 1 3
# 38 "/usr/include/c++/10.2.0/bits/exception_ptr.h" 2 3
# 1 "/usr/include/c++/10.2.0/bits/cxxabi_init_exception.h" 1 3
# 34 "/usr/include/c++/10.2.0/bits/cxxabi_init_exception.h" 3
       
# 35 "/usr/include/c++/10.2.0/bits/cxxabi_init_exception.h" 3

#pragma GCC visibility push(default)

# 1 "/usr/lib/gcc/x86_64-pc-linux-gnu/10.2.0/include/stddef.h" 1 3 4
# 39 "/usr/include/c++/10.2.0/bits/cxxabi_init_exception.h" 2 3
# 50 "/usr/include/c++/10.2.0/bits/cxxabi_init_exception.h" 3
namespace std
{
  class type_info;
}

namespace __cxxabiv1
{
  struct __cxa_refcounted_exception;

  extern "C"
    {

      void*
      __cxa_allocate_exception(size_t) noexcept;

      void
      __cxa_free_exception(void*) noexcept;


      __cxa_refcounted_exception*
      __cxa_init_primary_exception(void *object, std::type_info *tinfo,
                void ( *dest) (void *)) noexcept;

    }
}



#pragma GCC visibility pop
# 39 "/usr/include/c++/10.2.0/bits/exception_ptr.h" 2 3
# 1 "/usr/include/c++/10.2.0/typeinfo" 1 3
# 32 "/usr/include/c++/10.2.0/typeinfo" 3
       
# 33 "/usr/include/c++/10.2.0/typeinfo" 3



# 1 "/usr/include/c++/10.2.0/bits/hash_bytes.h" 1 3
# 33 "/usr/include/c++/10.2.0/bits/hash_bytes.h" 3
       
# 34 "/usr/include/c++/10.2.0/bits/hash_bytes.h" 3



namespace std
{







  size_t
  _Hash_bytes(const void* __ptr, size_t __len, size_t __seed);





  size_t
  _Fnv_hash_bytes(const void* __ptr, size_t __len, size_t __seed);


}
# 37 "/usr/include/c++/10.2.0/typeinfo" 2 3


#pragma GCC visibility push(default)

extern "C++" {

namespace __cxxabiv1
{
  class __class_type_info;
}
# 80 "/usr/include/c++/10.2.0/typeinfo" 3
namespace std
{






  class type_info
  {
  public:




    virtual ~type_info();



    const char* name() const noexcept
    { return __name[0] == '*' ? __name + 1 : __name; }
# 115 "/usr/include/c++/10.2.0/typeinfo" 3
    bool before(const type_info& __arg) const noexcept
    { return (__name[0] == '*' && __arg.__name[0] == '*')
 ? __name < __arg.__name
 : __builtin_strcmp (__name, __arg.__name) < 0; }

    bool operator==(const type_info& __arg) const noexcept
    {
      return ((__name == __arg.__name)
       || (__name[0] != '*' &&
    __builtin_strcmp (__name, __arg.__name) == 0));
    }
# 138 "/usr/include/c++/10.2.0/typeinfo" 3
    bool operator!=(const type_info& __arg) const noexcept
    { return !operator==(__arg); }



    size_t hash_code() const noexcept
    {

      return _Hash_bytes(name(), __builtin_strlen(name()),
    static_cast<size_t>(0xc70f6907UL));



    }



    virtual bool __is_pointer_p() const;


    virtual bool __is_function_p() const;







    virtual bool __do_catch(const type_info *__thr_type, void **__thr_obj,
       unsigned __outer) const;


    virtual bool __do_upcast(const __cxxabiv1::__class_type_info *__target,
        void **__obj_ptr) const;

  protected:
    const char *__name;

    explicit type_info(const char *__n): __name(__n) { }

  private:

    type_info& operator=(const type_info&);
    type_info(const type_info&);
  };







  class bad_cast : public exception
  {
  public:
    bad_cast() noexcept { }



    virtual ~bad_cast() noexcept;


    virtual const char* what() const noexcept;
  };





  class bad_typeid : public exception
  {
  public:
    bad_typeid () noexcept { }



    virtual ~bad_typeid() noexcept;


    virtual const char* what() const noexcept;
  };
}

}

#pragma GCC visibility pop
# 40 "/usr/include/c++/10.2.0/bits/exception_ptr.h" 2 3
# 1 "/usr/include/c++/10.2.0/new" 1 3
# 38 "/usr/include/c++/10.2.0/new" 3
       
# 39 "/usr/include/c++/10.2.0/new" 3


# 1 "/usr/include/c++/10.2.0/exception" 1 3
# 42 "/usr/include/c++/10.2.0/new" 2 3

#pragma GCC visibility push(default)

extern "C++" {

namespace std
{






  class bad_alloc : public exception
  {
  public:
    bad_alloc() throw() { }


    bad_alloc(const bad_alloc&) = default;
    bad_alloc& operator=(const bad_alloc&) = default;




    virtual ~bad_alloc() throw();


    virtual const char* what() const throw();
  };


  class bad_array_new_length : public bad_alloc
  {
  public:
    bad_array_new_length() throw() { }



    virtual ~bad_array_new_length() throw();


    virtual const char* what() const throw();
  };






  struct nothrow_t
  {

    explicit nothrow_t() = default;

  };

  extern const nothrow_t nothrow;



  typedef void (*new_handler)();



  new_handler set_new_handler(new_handler) throw();



  new_handler get_new_handler() noexcept;

}
# 126 "/usr/include/c++/10.2.0/new" 3
 void* operator new(std::size_t)
  __attribute__((__externally_visible__));
 void* operator new[](std::size_t)
  __attribute__((__externally_visible__));
void operator delete(void*) noexcept
  __attribute__((__externally_visible__));
void operator delete[](void*) noexcept
  __attribute__((__externally_visible__));






 void* operator new(std::size_t, const std::nothrow_t&) noexcept
  __attribute__((__externally_visible__, __malloc__));
 void* operator new[](std::size_t, const std::nothrow_t&) noexcept
  __attribute__((__externally_visible__, __malloc__));
void operator delete(void*, const std::nothrow_t&) noexcept
  __attribute__((__externally_visible__));
void operator delete[](void*, const std::nothrow_t&) noexcept
  __attribute__((__externally_visible__));
# 174 "/usr/include/c++/10.2.0/new" 3
 inline void* operator new(std::size_t, void* __p) noexcept
{ return __p; }
 inline void* operator new[](std::size_t, void* __p) noexcept
{ return __p; }


inline void operator delete (void*, void*) noexcept { }
inline void operator delete[](void*, void*) noexcept { }

}
# 230 "/usr/include/c++/10.2.0/new" 3
#pragma GCC visibility pop
# 41 "/usr/include/c++/10.2.0/bits/exception_ptr.h" 2 3

extern "C++" {

namespace std
{
  class type_info;






  namespace __exception_ptr
  {
    class exception_ptr;
  }

  using __exception_ptr::exception_ptr;





  exception_ptr current_exception() noexcept;

  template<typename _Ex>
  exception_ptr make_exception_ptr(_Ex) noexcept;


  void rethrow_exception(exception_ptr) __attribute__ ((__noreturn__));

  namespace __exception_ptr
  {
    using std::rethrow_exception;





    class exception_ptr
    {
      void* _M_exception_object;

      explicit exception_ptr(void* __e) noexcept;

      void _M_addref() noexcept;
      void _M_release() noexcept;

      void *_M_get() const noexcept __attribute__ ((__pure__));

      friend exception_ptr std::current_exception() noexcept;
      friend void std::rethrow_exception(exception_ptr);
      template<typename _Ex>
      friend exception_ptr std::make_exception_ptr(_Ex) noexcept;

    public:
      exception_ptr() noexcept;

      exception_ptr(const exception_ptr&) noexcept;


      exception_ptr(nullptr_t) noexcept
      : _M_exception_object(0)
      { }

      exception_ptr(exception_ptr&& __o) noexcept
      : _M_exception_object(__o._M_exception_object)
      { __o._M_exception_object = 0; }
# 118 "/usr/include/c++/10.2.0/bits/exception_ptr.h" 3
      exception_ptr&
      operator=(const exception_ptr&) noexcept;


      exception_ptr&
      operator=(exception_ptr&& __o) noexcept
      {
        exception_ptr(static_cast<exception_ptr&&>(__o)).swap(*this);
        return *this;
      }


      ~exception_ptr() noexcept;

      void
      swap(exception_ptr&) noexcept;
# 145 "/usr/include/c++/10.2.0/bits/exception_ptr.h" 3
      explicit operator bool() const
      { return _M_exception_object; }


      friend bool
      operator==(const exception_ptr&, const exception_ptr&)
 noexcept __attribute__ ((__pure__));

      const class std::type_info*
      __cxa_exception_type() const noexcept
 __attribute__ ((__pure__));
    };



    bool
    operator==(const exception_ptr&, const exception_ptr&)
      noexcept __attribute__ ((__pure__));

    bool
    operator!=(const exception_ptr&, const exception_ptr&)
      noexcept __attribute__ ((__pure__));

    inline void
    swap(exception_ptr& __lhs, exception_ptr& __rhs)
    { __lhs.swap(__rhs); }




    template<typename _Ex>
      inline void
      __dest_thunk(void* __x)
      { static_cast<_Ex*>(__x)->~_Ex(); }


  }


  template<typename _Ex>
    exception_ptr
    make_exception_ptr(_Ex __ex) noexcept
    {

      void* __e = __cxxabiv1::__cxa_allocate_exception(sizeof(_Ex));
      (void) __cxxabiv1::__cxa_init_primary_exception(
   __e, const_cast<std::type_info*>(&typeid(__ex)),
   __exception_ptr::__dest_thunk<_Ex>);
      try
 {
          ::new (__e) _Ex(__ex);
          return exception_ptr(__e);
 }
      catch(...)
 {
   __cxxabiv1::__cxa_free_exception(__e);
   return current_exception();
 }
# 215 "/usr/include/c++/10.2.0/bits/exception_ptr.h" 3
    }


}

}

#pragma GCC visibility pop
# 148 "/usr/include/c++/10.2.0/exception" 2 3
# 1 "/usr/include/c++/10.2.0/bits/nested_exception.h" 1 3
# 33 "/usr/include/c++/10.2.0/bits/nested_exception.h" 3
#pragma GCC visibility push(default)






# 1 "/usr/include/c++/10.2.0/bits/move.h" 1 3
# 38 "/usr/include/c++/10.2.0/bits/move.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{







  template<typename _Tp>
    inline constexpr _Tp*
    __addressof(_Tp& __r) noexcept
    { return __builtin_addressof(__r); }




}

# 1 "/usr/include/c++/10.2.0/type_traits" 1 3
# 32 "/usr/include/c++/10.2.0/type_traits" 3
       
# 33 "/usr/include/c++/10.2.0/type_traits" 3







namespace std __attribute__ ((__visibility__ ("default")))
{

# 56 "/usr/include/c++/10.2.0/type_traits" 3
  template<typename _Tp, _Tp __v>
    struct integral_constant
    {
      static constexpr _Tp value = __v;
      typedef _Tp value_type;
      typedef integral_constant<_Tp, __v> type;
      constexpr operator value_type() const noexcept { return value; }






    };

  template<typename _Tp, _Tp __v>
    constexpr _Tp integral_constant<_Tp, __v>::value;


  typedef integral_constant<bool, true> true_type;


  typedef integral_constant<bool, false> false_type;

  template<bool __v>
    using __bool_constant = integral_constant<bool, __v>;
# 91 "/usr/include/c++/10.2.0/type_traits" 3
  template<bool, typename, typename>
    struct conditional;

  template <typename _Type>
    struct __type_identity
    { using type = _Type; };

  template<typename _Tp>
    using __type_identity_t = typename __type_identity<_Tp>::type;

  template<typename...>
    struct __or_;

  template<>
    struct __or_<>
    : public false_type
    { };

  template<typename _B1>
    struct __or_<_B1>
    : public _B1
    { };

  template<typename _B1, typename _B2>
    struct __or_<_B1, _B2>
    : public conditional<_B1::value, _B1, _B2>::type
    { };

  template<typename _B1, typename _B2, typename _B3, typename... _Bn>
    struct __or_<_B1, _B2, _B3, _Bn...>
    : public conditional<_B1::value, _B1, __or_<_B2, _B3, _Bn...>>::type
    { };

  template<typename...>
    struct __and_;

  template<>
    struct __and_<>
    : public true_type
    { };

  template<typename _B1>
    struct __and_<_B1>
    : public _B1
    { };

  template<typename _B1, typename _B2>
    struct __and_<_B1, _B2>
    : public conditional<_B1::value, _B2, _B1>::type
    { };

  template<typename _B1, typename _B2, typename _B3, typename... _Bn>
    struct __and_<_B1, _B2, _B3, _Bn...>
    : public conditional<_B1::value, __and_<_B2, _B3, _Bn...>, _B1>::type
    { };

  template<typename _Pp>
    struct __not_
    : public __bool_constant<!bool(_Pp::value)>
    { };
# 188 "/usr/include/c++/10.2.0/type_traits" 3
  template<typename>
    struct is_reference;
  template<typename>
    struct is_function;
  template<typename>
    struct is_void;
  template<typename>
    struct __is_array_unknown_bounds;




  template <typename _Tp, size_t = sizeof(_Tp)>
    constexpr true_type __is_complete_or_unbounded(__type_identity<_Tp>)
    { return {}; }

  template <typename _TypeIdentity,
      typename _NestedType = typename _TypeIdentity::type>
    constexpr typename __or_<
      is_reference<_NestedType>,
      is_function<_NestedType>,
      is_void<_NestedType>,
      __is_array_unknown_bounds<_NestedType>
    >::type __is_complete_or_unbounded(_TypeIdentity)
    { return {}; }






  template<typename _Tp>
    struct __success_type
    { typedef _Tp type; };

  struct __failure_type
  { };

  template<typename>
    struct remove_cv;


  template<typename _Tp>
    using __remove_cv_t = typename remove_cv<_Tp>::type;

  template<typename>
    struct is_const;



  template<typename>
    struct __is_void_helper
    : public false_type { };

  template<>
    struct __is_void_helper<void>
    : public true_type { };


  template<typename _Tp>
    struct is_void
    : public __is_void_helper<__remove_cv_t<_Tp>>::type
    { };

  template<typename>
    struct __is_integral_helper
    : public false_type { };

  template<>
    struct __is_integral_helper<bool>
    : public true_type { };

  template<>
    struct __is_integral_helper<char>
    : public true_type { };

  template<>
    struct __is_integral_helper<signed char>
    : public true_type { };

  template<>
    struct __is_integral_helper<unsigned char>
    : public true_type { };


  template<>
    struct __is_integral_helper<wchar_t>
    : public true_type { };
# 284 "/usr/include/c++/10.2.0/type_traits" 3
  template<>
    struct __is_integral_helper<char16_t>
    : public true_type { };

  template<>
    struct __is_integral_helper<char32_t>
    : public true_type { };

  template<>
    struct __is_integral_helper<short>
    : public true_type { };

  template<>
    struct __is_integral_helper<unsigned short>
    : public true_type { };

  template<>
    struct __is_integral_helper<int>
    : public true_type { };

  template<>
    struct __is_integral_helper<unsigned int>
    : public true_type { };

  template<>
    struct __is_integral_helper<long>
    : public true_type { };

  template<>
    struct __is_integral_helper<unsigned long>
    : public true_type { };

  template<>
    struct __is_integral_helper<long long>
    : public true_type { };

  template<>
    struct __is_integral_helper<unsigned long long>
    : public true_type { };
# 364 "/usr/include/c++/10.2.0/type_traits" 3
  template<typename _Tp>
    struct is_integral
    : public __is_integral_helper<__remove_cv_t<_Tp>>::type
    { };

  template<typename>
    struct __is_floating_point_helper
    : public false_type { };

  template<>
    struct __is_floating_point_helper<float>
    : public true_type { };

  template<>
    struct __is_floating_point_helper<double>
    : public true_type { };

  template<>
    struct __is_floating_point_helper<long double>
    : public true_type { };
# 392 "/usr/include/c++/10.2.0/type_traits" 3
  template<typename _Tp>
    struct is_floating_point
    : public __is_floating_point_helper<__remove_cv_t<_Tp>>::type
    { };


  template<typename>
    struct is_array
    : public false_type { };

  template<typename _Tp, std::size_t _Size>
    struct is_array<_Tp[_Size]>
    : public true_type { };

  template<typename _Tp>
    struct is_array<_Tp[]>
    : public true_type { };

  template<typename>
    struct __is_pointer_helper
    : public false_type { };

  template<typename _Tp>
    struct __is_pointer_helper<_Tp*>
    : public true_type { };


  template<typename _Tp>
    struct is_pointer
    : public __is_pointer_helper<__remove_cv_t<_Tp>>::type
    { };


  template<typename>
    struct is_lvalue_reference
    : public false_type { };

  template<typename _Tp>
    struct is_lvalue_reference<_Tp&>
    : public true_type { };


  template<typename>
    struct is_rvalue_reference
    : public false_type { };

  template<typename _Tp>
    struct is_rvalue_reference<_Tp&&>
    : public true_type { };

  template<typename>
    struct __is_member_object_pointer_helper
    : public false_type { };

  template<typename _Tp, typename _Cp>
    struct __is_member_object_pointer_helper<_Tp _Cp::*>
    : public __not_<is_function<_Tp>>::type { };


  template<typename _Tp>
    struct is_member_object_pointer
    : public __is_member_object_pointer_helper<__remove_cv_t<_Tp>>::type
    { };

  template<typename>
    struct __is_member_function_pointer_helper
    : public false_type { };

  template<typename _Tp, typename _Cp>
    struct __is_member_function_pointer_helper<_Tp _Cp::*>
    : public is_function<_Tp>::type { };


  template<typename _Tp>
    struct is_member_function_pointer
    : public __is_member_function_pointer_helper<__remove_cv_t<_Tp>>::type
    { };


  template<typename _Tp>
    struct is_enum
    : public integral_constant<bool, __is_enum(_Tp)>
    { };


  template<typename _Tp>
    struct is_union
    : public integral_constant<bool, __is_union(_Tp)>
    { };


  template<typename _Tp>
    struct is_class
    : public integral_constant<bool, __is_class(_Tp)>
    { };


  template<typename _Tp>
    struct is_function
    : public __bool_constant<!is_const<const _Tp>::value> { };

  template<typename _Tp>
    struct is_function<_Tp&>
    : public false_type { };

  template<typename _Tp>
    struct is_function<_Tp&&>
    : public false_type { };



  template<typename>
    struct __is_null_pointer_helper
    : public false_type { };

  template<>
    struct __is_null_pointer_helper<std::nullptr_t>
    : public true_type { };


  template<typename _Tp>
    struct is_null_pointer
    : public __is_null_pointer_helper<__remove_cv_t<_Tp>>::type
    { };


  template<typename _Tp>
    struct __is_nullptr_t
    : public is_null_pointer<_Tp>
    { } __attribute__ ((__deprecated__));




  template<typename _Tp>
    struct is_reference
    : public __or_<is_lvalue_reference<_Tp>,
                   is_rvalue_reference<_Tp>>::type
    { };


  template<typename _Tp>
    struct is_arithmetic
    : public __or_<is_integral<_Tp>, is_floating_point<_Tp>>::type
    { };


  template<typename _Tp>
    struct is_fundamental
    : public __or_<is_arithmetic<_Tp>, is_void<_Tp>,
     is_null_pointer<_Tp>>::type
    { };


  template<typename _Tp>
    struct is_object
    : public __not_<__or_<is_function<_Tp>, is_reference<_Tp>,
                          is_void<_Tp>>>::type
    { };

  template<typename>
    struct is_member_pointer;


  template<typename _Tp>
    struct is_scalar
    : public __or_<is_arithmetic<_Tp>, is_enum<_Tp>, is_pointer<_Tp>,
                   is_member_pointer<_Tp>, is_null_pointer<_Tp>>::type
    { };


  template<typename _Tp>
    struct is_compound
    : public __not_<is_fundamental<_Tp>>::type { };

  template<typename _Tp>
    struct __is_member_pointer_helper
    : public false_type { };

  template<typename _Tp, typename _Cp>
    struct __is_member_pointer_helper<_Tp _Cp::*>
    : public true_type { };


  template<typename _Tp>
    struct is_member_pointer
    : public __is_member_pointer_helper<__remove_cv_t<_Tp>>::type
    { };

  template<typename, typename>
    struct is_same;

  template<typename _Tp, typename... _Types>
    using __is_one_of = __or_<is_same<_Tp, _Types>...>;


  template<typename _Tp>
    using __is_signed_integer = __is_one_of<__remove_cv_t<_Tp>,
   signed char, signed short, signed int, signed long,
   signed long long
# 604 "/usr/include/c++/10.2.0/type_traits" 3
   >;


  template<typename _Tp>
    using __is_unsigned_integer = __is_one_of<__remove_cv_t<_Tp>,
   unsigned char, unsigned short, unsigned int, unsigned long,
   unsigned long long
# 623 "/usr/include/c++/10.2.0/type_traits" 3
   >;


  template<typename _Tp>
    using __is_standard_integer
      = __or_<__is_signed_integer<_Tp>, __is_unsigned_integer<_Tp>>;


  template<typename...> using __void_t = void;



  template<typename _Tp, typename = void>
    struct __is_referenceable
    : public false_type
    { };

  template<typename _Tp>
    struct __is_referenceable<_Tp, __void_t<_Tp&>>
    : public true_type
    { };




  template<typename>
    struct is_const
    : public false_type { };

  template<typename _Tp>
    struct is_const<_Tp const>
    : public true_type { };


  template<typename>
    struct is_volatile
    : public false_type { };

  template<typename _Tp>
    struct is_volatile<_Tp volatile>
    : public true_type { };


  template<typename _Tp>
    struct is_trivial
    : public integral_constant<bool, __is_trivial(_Tp)>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp>
    struct is_trivially_copyable
    : public integral_constant<bool, __is_trivially_copyable(_Tp)>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp>
    struct is_standard_layout
    : public integral_constant<bool, __is_standard_layout(_Tp)>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };



  template<typename _Tp>
    struct
   
    is_pod
    : public integral_constant<bool, __is_pod(_Tp)>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp>
    struct is_literal_type
    : public integral_constant<bool, __is_literal_type(_Tp)>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp>
    struct is_empty
    : public integral_constant<bool, __is_empty(_Tp)>
    { };


  template<typename _Tp>
    struct is_polymorphic
    : public integral_constant<bool, __is_polymorphic(_Tp)>
    { };
# 735 "/usr/include/c++/10.2.0/type_traits" 3
  template<typename _Tp>
    struct is_abstract
    : public integral_constant<bool, __is_abstract(_Tp)>
    { };

  template<typename _Tp,
    bool = is_arithmetic<_Tp>::value>
    struct __is_signed_helper
    : public false_type { };

  template<typename _Tp>
    struct __is_signed_helper<_Tp, true>
    : public integral_constant<bool, _Tp(-1) < _Tp(0)>
    { };


  template<typename _Tp>
    struct is_signed
    : public __is_signed_helper<_Tp>::type
    { };


  template<typename _Tp>
    struct is_unsigned
    : public __and_<is_arithmetic<_Tp>, __not_<is_signed<_Tp>>>
    { };
# 770 "/usr/include/c++/10.2.0/type_traits" 3
  template<typename _Tp, typename _Up = _Tp&&>
    _Up
    __declval(int);

  template<typename _Tp>
    _Tp
    __declval(long);

  template<typename _Tp>
    auto declval() noexcept -> decltype(__declval<_Tp>(0));

  template<typename, unsigned = 0>
    struct extent;

  template<typename>
    struct remove_all_extents;

  template<typename _Tp>
    struct __is_array_known_bounds
    : public integral_constant<bool, (extent<_Tp>::value > 0)>
    { };

  template<typename _Tp>
    struct __is_array_unknown_bounds
    : public __and_<is_array<_Tp>, __not_<extent<_Tp>>>
    { };






  struct __do_is_destructible_impl
  {
    template<typename _Tp, typename = decltype(declval<_Tp&>().~_Tp())>
      static true_type __test(int);

    template<typename>
      static false_type __test(...);
  };

  template<typename _Tp>
    struct __is_destructible_impl
    : public __do_is_destructible_impl
    {
      typedef decltype(__test<_Tp>(0)) type;
    };

  template<typename _Tp,
           bool = __or_<is_void<_Tp>,
                        __is_array_unknown_bounds<_Tp>,
                        is_function<_Tp>>::value,
           bool = __or_<is_reference<_Tp>, is_scalar<_Tp>>::value>
    struct __is_destructible_safe;

  template<typename _Tp>
    struct __is_destructible_safe<_Tp, false, false>
    : public __is_destructible_impl<typename
               remove_all_extents<_Tp>::type>::type
    { };

  template<typename _Tp>
    struct __is_destructible_safe<_Tp, true, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_destructible_safe<_Tp, false, true>
    : public true_type { };


  template<typename _Tp>
    struct is_destructible
    : public __is_destructible_safe<_Tp>::type
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };





  struct __do_is_nt_destructible_impl
  {
    template<typename _Tp>
      static __bool_constant<noexcept(declval<_Tp&>().~_Tp())>
      __test(int);

    template<typename>
      static false_type __test(...);
  };

  template<typename _Tp>
    struct __is_nt_destructible_impl
    : public __do_is_nt_destructible_impl
    {
      typedef decltype(__test<_Tp>(0)) type;
    };

  template<typename _Tp,
           bool = __or_<is_void<_Tp>,
                        __is_array_unknown_bounds<_Tp>,
                        is_function<_Tp>>::value,
           bool = __or_<is_reference<_Tp>, is_scalar<_Tp>>::value>
    struct __is_nt_destructible_safe;

  template<typename _Tp>
    struct __is_nt_destructible_safe<_Tp, false, false>
    : public __is_nt_destructible_impl<typename
               remove_all_extents<_Tp>::type>::type
    { };

  template<typename _Tp>
    struct __is_nt_destructible_safe<_Tp, true, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_nt_destructible_safe<_Tp, false, true>
    : public true_type { };


  template<typename _Tp>
    struct is_nothrow_destructible
    : public __is_nt_destructible_safe<_Tp>::type
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };

  template<typename _Tp, typename... _Args>
    struct __is_constructible_impl
    : public __bool_constant<__is_constructible(_Tp, _Args...)>
    { };


  template<typename _Tp, typename... _Args>
    struct is_constructible
      : public __is_constructible_impl<_Tp, _Args...>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp>
    struct is_default_constructible
    : public __is_constructible_impl<_Tp>::type
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_copy_constructible_impl;

  template<typename _Tp>
    struct __is_copy_constructible_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_copy_constructible_impl<_Tp, true>
    : public __is_constructible_impl<_Tp, const _Tp&>
    { };


  template<typename _Tp>
    struct is_copy_constructible
    : public __is_copy_constructible_impl<_Tp>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_move_constructible_impl;

  template<typename _Tp>
    struct __is_move_constructible_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_move_constructible_impl<_Tp, true>
    : public __is_constructible_impl<_Tp, _Tp&&>
    { };


  template<typename _Tp>
    struct is_move_constructible
    : public __is_move_constructible_impl<_Tp>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };

  template<bool, typename _Tp, typename... _Args>
    struct __is_nt_constructible_impl
    : public false_type
    { };

  template<typename _Tp, typename... _Args>
    struct __is_nt_constructible_impl<true, _Tp, _Args...>
    : public __bool_constant<noexcept(_Tp(std::declval<_Args>()...))>
    { };

  template<typename _Tp, typename _Arg>
    struct __is_nt_constructible_impl<true, _Tp, _Arg>
    : public __bool_constant<noexcept(static_cast<_Tp>(std::declval<_Arg>()))>
    { };

  template<typename _Tp>
    struct __is_nt_constructible_impl<true, _Tp>
    : public __bool_constant<noexcept(_Tp())>
    { };

  template<typename _Tp, size_t _Num>
    struct __is_nt_constructible_impl<true, _Tp[_Num]>
    : public __bool_constant<noexcept(typename remove_all_extents<_Tp>::type())>
    { };
# 1001 "/usr/include/c++/10.2.0/type_traits" 3
  template<typename _Tp, typename... _Args>
    using __is_nothrow_constructible_impl
      = __is_nt_constructible_impl<__is_constructible(_Tp, _Args...),
       _Tp, _Args...>;


  template<typename _Tp, typename... _Args>
    struct is_nothrow_constructible
    : public __is_nothrow_constructible_impl<_Tp, _Args...>::type
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp>
    struct is_nothrow_default_constructible
    : public __is_nothrow_constructible_impl<_Tp>::type
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_nothrow_copy_constructible_impl;

  template<typename _Tp>
    struct __is_nothrow_copy_constructible_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_nothrow_copy_constructible_impl<_Tp, true>
    : public __is_nothrow_constructible_impl<_Tp, const _Tp&>
    { };


  template<typename _Tp>
    struct is_nothrow_copy_constructible
    : public __is_nothrow_copy_constructible_impl<_Tp>::type
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_nothrow_move_constructible_impl;

  template<typename _Tp>
    struct __is_nothrow_move_constructible_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_nothrow_move_constructible_impl<_Tp, true>
    : public __is_nothrow_constructible_impl<_Tp, _Tp&&>
    { };


  template<typename _Tp>
    struct is_nothrow_move_constructible
    : public __is_nothrow_move_constructible_impl<_Tp>::type
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp, typename _Up>
    struct is_assignable
    : public __bool_constant<__is_assignable(_Tp, _Up)>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_copy_assignable_impl;

  template<typename _Tp>
    struct __is_copy_assignable_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_copy_assignable_impl<_Tp, true>
    : public __bool_constant<__is_assignable(_Tp&, const _Tp&)>
    { };


  template<typename _Tp>
    struct is_copy_assignable
    : public __is_copy_assignable_impl<_Tp>::type
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_move_assignable_impl;

  template<typename _Tp>
    struct __is_move_assignable_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_move_assignable_impl<_Tp, true>
    : public __bool_constant<__is_assignable(_Tp&, _Tp&&)>
    { };


  template<typename _Tp>
    struct is_move_assignable
    : public __is_move_assignable_impl<_Tp>::type
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };

  template<typename _Tp, typename _Up>
    struct __is_nt_assignable_impl
    : public integral_constant<bool, noexcept(declval<_Tp>() = declval<_Up>())>
    { };

  template<typename _Tp, typename _Up>
    struct __is_nothrow_assignable_impl
    : public __and_<__bool_constant<__is_assignable(_Tp, _Up)>,
      __is_nt_assignable_impl<_Tp, _Up>>
    { };


  template<typename _Tp, typename _Up>
    struct is_nothrow_assignable
    : public __is_nothrow_assignable_impl<_Tp, _Up>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_nt_copy_assignable_impl;

  template<typename _Tp>
    struct __is_nt_copy_assignable_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_nt_copy_assignable_impl<_Tp, true>
    : public __is_nothrow_assignable_impl<_Tp&, const _Tp&>
    { };


  template<typename _Tp>
    struct is_nothrow_copy_assignable
    : public __is_nt_copy_assignable_impl<_Tp>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_nt_move_assignable_impl;

  template<typename _Tp>
    struct __is_nt_move_assignable_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_nt_move_assignable_impl<_Tp, true>
    : public __is_nothrow_assignable_impl<_Tp&, _Tp&&>
    { };


  template<typename _Tp>
    struct is_nothrow_move_assignable
    : public __is_nt_move_assignable_impl<_Tp>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp, typename... _Args>
    struct is_trivially_constructible
    : public __bool_constant<__is_trivially_constructible(_Tp, _Args...)>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp>
    struct is_trivially_default_constructible
    : public __bool_constant<__is_trivially_constructible(_Tp)>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };

  struct __do_is_implicitly_default_constructible_impl
  {
    template <typename _Tp>
    static void __helper(const _Tp&);

    template <typename _Tp>
    static true_type __test(const _Tp&,
                            decltype(__helper<const _Tp&>({}))* = 0);

    static false_type __test(...);
  };

  template<typename _Tp>
    struct __is_implicitly_default_constructible_impl
    : public __do_is_implicitly_default_constructible_impl
    {
      typedef decltype(__test(declval<_Tp>())) type;
    };

  template<typename _Tp>
    struct __is_implicitly_default_constructible_safe
    : public __is_implicitly_default_constructible_impl<_Tp>::type
    { };

  template <typename _Tp>
    struct __is_implicitly_default_constructible
    : public __and_<__is_constructible_impl<_Tp>,
      __is_implicitly_default_constructible_safe<_Tp>>
    { };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_trivially_copy_constructible_impl;

  template<typename _Tp>
    struct __is_trivially_copy_constructible_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_trivially_copy_constructible_impl<_Tp, true>
    : public __and_<__is_copy_constructible_impl<_Tp>,
      integral_constant<bool,
   __is_trivially_constructible(_Tp, const _Tp&)>>
    { };


  template<typename _Tp>
    struct is_trivially_copy_constructible
    : public __is_trivially_copy_constructible_impl<_Tp>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_trivially_move_constructible_impl;

  template<typename _Tp>
    struct __is_trivially_move_constructible_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_trivially_move_constructible_impl<_Tp, true>
    : public __and_<__is_move_constructible_impl<_Tp>,
      integral_constant<bool,
   __is_trivially_constructible(_Tp, _Tp&&)>>
    { };


  template<typename _Tp>
    struct is_trivially_move_constructible
    : public __is_trivially_move_constructible_impl<_Tp>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp, typename _Up>
    struct is_trivially_assignable
    : public __bool_constant<__is_trivially_assignable(_Tp, _Up)>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_trivially_copy_assignable_impl;

  template<typename _Tp>
    struct __is_trivially_copy_assignable_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_trivially_copy_assignable_impl<_Tp, true>
    : public __bool_constant<__is_trivially_assignable(_Tp&, const _Tp&)>
    { };


  template<typename _Tp>
    struct is_trivially_copy_assignable
    : public __is_trivially_copy_assignable_impl<_Tp>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_trivially_move_assignable_impl;

  template<typename _Tp>
    struct __is_trivially_move_assignable_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_trivially_move_assignable_impl<_Tp, true>
    : public __bool_constant<__is_trivially_assignable(_Tp&, _Tp&&)>
    { };


  template<typename _Tp>
    struct is_trivially_move_assignable
    : public __is_trivially_move_assignable_impl<_Tp>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp>
    struct is_trivially_destructible
    : public __and_<__is_destructible_safe<_Tp>,
      __bool_constant<__has_trivial_destructor(_Tp)>>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };



  template<typename _Tp>
    struct has_virtual_destructor
    : public integral_constant<bool, __has_virtual_destructor(_Tp)>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };





  template<typename _Tp>
    struct alignment_of
    : public integral_constant<std::size_t, alignof(_Tp)>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename>
    struct rank
    : public integral_constant<std::size_t, 0> { };

  template<typename _Tp, std::size_t _Size>
    struct rank<_Tp[_Size]>
    : public integral_constant<std::size_t, 1 + rank<_Tp>::value> { };

  template<typename _Tp>
    struct rank<_Tp[]>
    : public integral_constant<std::size_t, 1 + rank<_Tp>::value> { };


  template<typename, unsigned _Uint>
    struct extent
    : public integral_constant<std::size_t, 0> { };

  template<typename _Tp, unsigned _Uint, std::size_t _Size>
    struct extent<_Tp[_Size], _Uint>
    : public integral_constant<std::size_t,
          _Uint == 0 ? _Size : extent<_Tp,
          _Uint - 1>::value>
    { };

  template<typename _Tp, unsigned _Uint>
    struct extent<_Tp[], _Uint>
    : public integral_constant<std::size_t,
          _Uint == 0 ? 0 : extent<_Tp,
             _Uint - 1>::value>
    { };





  template<typename _Tp, typename _Up>
    struct is_same

    : public integral_constant<bool, __is_same_as(_Tp, _Up)>



    { };
# 1410 "/usr/include/c++/10.2.0/type_traits" 3
  template<typename _Base, typename _Derived>
    struct is_base_of
    : public integral_constant<bool, __is_base_of(_Base, _Derived)>
    { };

  template<typename _From, typename _To,
           bool = __or_<is_void<_From>, is_function<_To>,
                        is_array<_To>>::value>
    struct __is_convertible_helper
    {
      typedef typename is_void<_To>::type type;
    };

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wctor-dtor-privacy"
  template<typename _From, typename _To>
    class __is_convertible_helper<_From, _To, false>
    {
      template<typename _To1>
 static void __test_aux(_To1) noexcept;

      template<typename _From1, typename _To1,
        typename = decltype(__test_aux<_To1>(std::declval<_From1>()))>
 static true_type
 __test(int);

      template<typename, typename>
 static false_type
 __test(...);

    public:
      typedef decltype(__test<_From, _To>(0)) type;
    };
#pragma GCC diagnostic pop


  template<typename _From, typename _To>
    struct is_convertible
    : public __is_convertible_helper<_From, _To>::type
    { };


  template<typename _ToElementType, typename _FromElementType>
    using __is_array_convertible
      = is_convertible<_FromElementType(*)[], _ToElementType(*)[]>;

  template<typename _From, typename _To,
           bool = __or_<is_void<_From>, is_function<_To>,
                        is_array<_To>>::value>
    struct __is_nt_convertible_helper
    : is_void<_To>
    { };

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wctor-dtor-privacy"
  template<typename _From, typename _To>
    class __is_nt_convertible_helper<_From, _To, false>
    {
      template<typename _To1>
 static void __test_aux(_To1) noexcept;

      template<typename _From1, typename _To1>
 static
 __bool_constant<noexcept(__test_aux<_To1>(std::declval<_From1>()))>
 __test(int);

      template<typename, typename>
 static false_type
 __test(...);

    public:
      using type = decltype(__test<_From, _To>(0));
    };
#pragma GCC diagnostic pop


  template<typename _From, typename _To>
    struct __is_nothrow_convertible
    : public __is_nt_convertible_helper<_From, _To>::type
    { };
# 1508 "/usr/include/c++/10.2.0/type_traits" 3
  template<typename _Tp>
    struct remove_const
    { typedef _Tp type; };

  template<typename _Tp>
    struct remove_const<_Tp const>
    { typedef _Tp type; };


  template<typename _Tp>
    struct remove_volatile
    { typedef _Tp type; };

  template<typename _Tp>
    struct remove_volatile<_Tp volatile>
    { typedef _Tp type; };


  template<typename _Tp>
    struct remove_cv
    { using type = _Tp; };

  template<typename _Tp>
    struct remove_cv<const _Tp>
    { using type = _Tp; };

  template<typename _Tp>
    struct remove_cv<volatile _Tp>
    { using type = _Tp; };

  template<typename _Tp>
    struct remove_cv<const volatile _Tp>
    { using type = _Tp; };


  template<typename _Tp>
    struct add_const
    { typedef _Tp const type; };


  template<typename _Tp>
    struct add_volatile
    { typedef _Tp volatile type; };


  template<typename _Tp>
    struct add_cv
    {
      typedef typename
      add_const<typename add_volatile<_Tp>::type>::type type;
    };
# 1592 "/usr/include/c++/10.2.0/type_traits" 3
  template<typename _Tp>
    struct remove_reference
    { typedef _Tp type; };

  template<typename _Tp>
    struct remove_reference<_Tp&>
    { typedef _Tp type; };

  template<typename _Tp>
    struct remove_reference<_Tp&&>
    { typedef _Tp type; };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __add_lvalue_reference_helper
    { typedef _Tp type; };

  template<typename _Tp>
    struct __add_lvalue_reference_helper<_Tp, true>
    { typedef _Tp& type; };


  template<typename _Tp>
    struct add_lvalue_reference
    : public __add_lvalue_reference_helper<_Tp>
    { };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __add_rvalue_reference_helper
    { typedef _Tp type; };

  template<typename _Tp>
    struct __add_rvalue_reference_helper<_Tp, true>
    { typedef _Tp&& type; };


  template<typename _Tp>
    struct add_rvalue_reference
    : public __add_rvalue_reference_helper<_Tp>
    { };
# 1649 "/usr/include/c++/10.2.0/type_traits" 3
  template<typename _Unqualified, bool _IsConst, bool _IsVol>
    struct __cv_selector;

  template<typename _Unqualified>
    struct __cv_selector<_Unqualified, false, false>
    { typedef _Unqualified __type; };

  template<typename _Unqualified>
    struct __cv_selector<_Unqualified, false, true>
    { typedef volatile _Unqualified __type; };

  template<typename _Unqualified>
    struct __cv_selector<_Unqualified, true, false>
    { typedef const _Unqualified __type; };

  template<typename _Unqualified>
    struct __cv_selector<_Unqualified, true, true>
    { typedef const volatile _Unqualified __type; };

  template<typename _Qualified, typename _Unqualified,
    bool _IsConst = is_const<_Qualified>::value,
    bool _IsVol = is_volatile<_Qualified>::value>
    class __match_cv_qualifiers
    {
      typedef __cv_selector<_Unqualified, _IsConst, _IsVol> __match;

    public:
      typedef typename __match::__type __type;
    };


  template<typename _Tp>
    struct __make_unsigned
    { typedef _Tp __type; };

  template<>
    struct __make_unsigned<char>
    { typedef unsigned char __type; };

  template<>
    struct __make_unsigned<signed char>
    { typedef unsigned char __type; };

  template<>
    struct __make_unsigned<short>
    { typedef unsigned short __type; };

  template<>
    struct __make_unsigned<int>
    { typedef unsigned int __type; };

  template<>
    struct __make_unsigned<long>
    { typedef unsigned long __type; };

  template<>
    struct __make_unsigned<long long>
    { typedef unsigned long long __type; };
# 1730 "/usr/include/c++/10.2.0/type_traits" 3
  template<typename _Tp,
    bool _IsInt = is_integral<_Tp>::value,
    bool _IsEnum = is_enum<_Tp>::value>
    class __make_unsigned_selector;

  template<typename _Tp>
    class __make_unsigned_selector<_Tp, true, false>
    {
      using __unsigned_type
 = typename __make_unsigned<__remove_cv_t<_Tp>>::__type;

    public:
      using __type
 = typename __match_cv_qualifiers<_Tp, __unsigned_type>::__type;
    };

  class __make_unsigned_selector_base
  {
  protected:
    template<typename...> struct _List { };

    template<typename _Tp, typename... _Up>
      struct _List<_Tp, _Up...> : _List<_Up...>
      { static constexpr size_t __size = sizeof(_Tp); };

    template<size_t _Sz, typename _Tp, bool = (_Sz <= _Tp::__size)>
      struct __select;

    template<size_t _Sz, typename _Uint, typename... _UInts>
      struct __select<_Sz, _List<_Uint, _UInts...>, true>
      { using __type = _Uint; };

    template<size_t _Sz, typename _Uint, typename... _UInts>
      struct __select<_Sz, _List<_Uint, _UInts...>, false>
      : __select<_Sz, _List<_UInts...>>
      { };
  };


  template<typename _Tp>
    class __make_unsigned_selector<_Tp, false, true>
    : __make_unsigned_selector_base
    {

      using _UInts = _List<unsigned char, unsigned short, unsigned int,
      unsigned long, unsigned long long>;

      using __unsigned_type = typename __select<sizeof(_Tp), _UInts>::__type;

    public:
      using __type
 = typename __match_cv_qualifiers<_Tp, __unsigned_type>::__type;
    };






  template<>
    struct __make_unsigned<wchar_t>
    {
      using __type
 = typename __make_unsigned_selector<wchar_t, false, true>::__type;
    };
# 1806 "/usr/include/c++/10.2.0/type_traits" 3
  template<>
    struct __make_unsigned<char16_t>
    {
      using __type
 = typename __make_unsigned_selector<char16_t, false, true>::__type;
    };

  template<>
    struct __make_unsigned<char32_t>
    {
      using __type
 = typename __make_unsigned_selector<char32_t, false, true>::__type;
    };





  template<typename _Tp>
    struct make_unsigned
    { typedef typename __make_unsigned_selector<_Tp>::__type type; };


  template<>
    struct make_unsigned<bool>;



  template<typename _Tp>
    struct __make_signed
    { typedef _Tp __type; };

  template<>
    struct __make_signed<char>
    { typedef signed char __type; };

  template<>
    struct __make_signed<unsigned char>
    { typedef signed char __type; };

  template<>
    struct __make_signed<unsigned short>
    { typedef signed short __type; };

  template<>
    struct __make_signed<unsigned int>
    { typedef signed int __type; };

  template<>
    struct __make_signed<unsigned long>
    { typedef signed long __type; };

  template<>
    struct __make_signed<unsigned long long>
    { typedef signed long long __type; };
# 1884 "/usr/include/c++/10.2.0/type_traits" 3
  template<typename _Tp,
    bool _IsInt = is_integral<_Tp>::value,
    bool _IsEnum = is_enum<_Tp>::value>
    class __make_signed_selector;

  template<typename _Tp>
    class __make_signed_selector<_Tp, true, false>
    {
      using __signed_type
 = typename __make_signed<__remove_cv_t<_Tp>>::__type;

    public:
      using __type
 = typename __match_cv_qualifiers<_Tp, __signed_type>::__type;
    };


  template<typename _Tp>
    class __make_signed_selector<_Tp, false, true>
    {
      typedef typename __make_unsigned_selector<_Tp>::__type __unsigned_type;

    public:
      typedef typename __make_signed_selector<__unsigned_type>::__type __type;
    };






  template<>
    struct __make_signed<wchar_t>
    {
      using __type
 = typename __make_signed_selector<wchar_t, false, true>::__type;
    };
# 1932 "/usr/include/c++/10.2.0/type_traits" 3
  template<>
    struct __make_signed<char16_t>
    {
      using __type
 = typename __make_signed_selector<char16_t, false, true>::__type;
    };

  template<>
    struct __make_signed<char32_t>
    {
      using __type
 = typename __make_signed_selector<char32_t, false, true>::__type;
    };





  template<typename _Tp>
    struct make_signed
    { typedef typename __make_signed_selector<_Tp>::__type type; };


  template<>
    struct make_signed<bool>;
# 1971 "/usr/include/c++/10.2.0/type_traits" 3
  template<typename _Tp>
    struct remove_extent
    { typedef _Tp type; };

  template<typename _Tp, std::size_t _Size>
    struct remove_extent<_Tp[_Size]>
    { typedef _Tp type; };

  template<typename _Tp>
    struct remove_extent<_Tp[]>
    { typedef _Tp type; };


  template<typename _Tp>
    struct remove_all_extents
    { typedef _Tp type; };

  template<typename _Tp, std::size_t _Size>
    struct remove_all_extents<_Tp[_Size]>
    { typedef typename remove_all_extents<_Tp>::type type; };

  template<typename _Tp>
    struct remove_all_extents<_Tp[]>
    { typedef typename remove_all_extents<_Tp>::type type; };
# 2008 "/usr/include/c++/10.2.0/type_traits" 3
  template<typename _Tp, typename>
    struct __remove_pointer_helper
    { typedef _Tp type; };

  template<typename _Tp, typename _Up>
    struct __remove_pointer_helper<_Tp, _Up*>
    { typedef _Up type; };


  template<typename _Tp>
    struct remove_pointer
    : public __remove_pointer_helper<_Tp, __remove_cv_t<_Tp>>
    { };


  template<typename _Tp, bool = __or_<__is_referenceable<_Tp>,
          is_void<_Tp>>::value>
    struct __add_pointer_helper
    { typedef _Tp type; };

  template<typename _Tp>
    struct __add_pointer_helper<_Tp, true>
    { typedef typename remove_reference<_Tp>::type* type; };

  template<typename _Tp>
    struct add_pointer
    : public __add_pointer_helper<_Tp>
    { };
# 2047 "/usr/include/c++/10.2.0/type_traits" 3
  template<std::size_t _Len>
    struct __aligned_storage_msa
    {
      union __type
      {
 unsigned char __data[_Len];
 struct __attribute__((__aligned__)) { } __align;
      };
    };
# 2067 "/usr/include/c++/10.2.0/type_traits" 3
  template<std::size_t _Len, std::size_t _Align =
    __alignof__(typename __aligned_storage_msa<_Len>::__type)>
    struct aligned_storage
    {
      union type
      {
 unsigned char __data[_Len];
 struct __attribute__((__aligned__((_Align)))) { } __align;
      };
    };

  template <typename... _Types>
    struct __strictest_alignment
    {
      static const size_t _S_alignment = 0;
      static const size_t _S_size = 0;
    };

  template <typename _Tp, typename... _Types>
    struct __strictest_alignment<_Tp, _Types...>
    {
      static const size_t _S_alignment =
        alignof(_Tp) > __strictest_alignment<_Types...>::_S_alignment
 ? alignof(_Tp) : __strictest_alignment<_Types...>::_S_alignment;
      static const size_t _S_size =
        sizeof(_Tp) > __strictest_alignment<_Types...>::_S_size
 ? sizeof(_Tp) : __strictest_alignment<_Types...>::_S_size;
    };
# 2106 "/usr/include/c++/10.2.0/type_traits" 3
  template <size_t _Len, typename... _Types>
    struct aligned_union
    {
    private:
      static_assert(sizeof...(_Types) != 0, "At least one type is required");

      using __strictest = __strictest_alignment<_Types...>;
      static const size_t _S_len = _Len > __strictest::_S_size
 ? _Len : __strictest::_S_size;
    public:

      static const size_t alignment_value = __strictest::_S_alignment;

      typedef typename aligned_storage<_S_len, alignment_value>::type type;
    };

  template <size_t _Len, typename... _Types>
    const size_t aligned_union<_Len, _Types...>::alignment_value;



  template<typename _Up,
    bool _IsArray = is_array<_Up>::value,
    bool _IsFunction = is_function<_Up>::value>
    struct __decay_selector;


  template<typename _Up>
    struct __decay_selector<_Up, false, false>
    { typedef __remove_cv_t<_Up> __type; };

  template<typename _Up>
    struct __decay_selector<_Up, true, false>
    { typedef typename remove_extent<_Up>::type* __type; };

  template<typename _Up>
    struct __decay_selector<_Up, false, true>
    { typedef typename add_pointer<_Up>::type __type; };


  template<typename _Tp>
    class decay
    {
      typedef typename remove_reference<_Tp>::type __remove_type;

    public:
      typedef typename __decay_selector<__remove_type>::__type type;
    };


  template<typename _Tp>
    using __decay_t = typename decay<_Tp>::type;

  template<typename _Tp>
    class reference_wrapper;


  template<typename _Tp>
    struct __strip_reference_wrapper
    {
      typedef _Tp __type;
    };

  template<typename _Tp>
    struct __strip_reference_wrapper<reference_wrapper<_Tp> >
    {
      typedef _Tp& __type;
    };

  template<typename _Tp>
    using __decay_and_strip = __strip_reference_wrapper<__decay_t<_Tp>>;




  template<bool, typename _Tp = void>
    struct enable_if
    { };


  template<typename _Tp>
    struct enable_if<true, _Tp>
    { typedef _Tp type; };


  template<bool _Cond, typename _Tp = void>
    using __enable_if_t = typename enable_if<_Cond, _Tp>::type;

  template<typename... _Cond>
    using _Require = __enable_if_t<__and_<_Cond...>::value>;



  template<bool _Cond, typename _Iftrue, typename _Iffalse>
    struct conditional
    { typedef _Iftrue type; };


  template<typename _Iftrue, typename _Iffalse>
    struct conditional<false, _Iftrue, _Iffalse>
    { typedef _Iffalse type; };


  template<typename _Tp>
    using __remove_cvref_t
     = typename remove_cv<typename remove_reference<_Tp>::type>::type;


  template<typename... _Tp>
    struct common_type;



  struct __do_common_type_impl
  {
    template<typename _Tp, typename _Up>
      using __cond_t
 = decltype(true ? std::declval<_Tp>() : std::declval<_Up>());



    template<typename _Tp, typename _Up>
      static __success_type<__decay_t<__cond_t<_Tp, _Up>>>
      _S_test(int);
# 2239 "/usr/include/c++/10.2.0/type_traits" 3
    template<typename, typename>
      static __failure_type
      _S_test_2(...);

    template<typename _Tp, typename _Up>
      static decltype(_S_test_2<_Tp, _Up>(0))
      _S_test(...);
  };


  template<>
    struct common_type<>
    { };


  template<typename _Tp0>
    struct common_type<_Tp0>
    : public common_type<_Tp0, _Tp0>
    { };


  template<typename _Tp1, typename _Tp2,
    typename _Dp1 = __decay_t<_Tp1>, typename _Dp2 = __decay_t<_Tp2>>
    struct __common_type_impl
    {


      using type = common_type<_Dp1, _Dp2>;
    };

  template<typename _Tp1, typename _Tp2>
    struct __common_type_impl<_Tp1, _Tp2, _Tp1, _Tp2>
    : private __do_common_type_impl
    {


      using type = decltype(_S_test<_Tp1, _Tp2>(0));
    };


  template<typename _Tp1, typename _Tp2>
    struct common_type<_Tp1, _Tp2>
    : public __common_type_impl<_Tp1, _Tp2>::type
    { };

  template<typename...>
    struct __common_type_pack
    { };

  template<typename, typename, typename = void>
    struct __common_type_fold;


  template<typename _Tp1, typename _Tp2, typename... _Rp>
    struct common_type<_Tp1, _Tp2, _Rp...>
    : public __common_type_fold<common_type<_Tp1, _Tp2>,
    __common_type_pack<_Rp...>>
    { };




  template<typename _CTp, typename... _Rp>
    struct __common_type_fold<_CTp, __common_type_pack<_Rp...>,
         __void_t<typename _CTp::type>>
    : public common_type<typename _CTp::type, _Rp...>
    { };


  template<typename _CTp, typename _Rp>
    struct __common_type_fold<_CTp, _Rp, void>
    { };

  template<typename _Tp, bool = is_enum<_Tp>::value>
    struct __underlying_type_impl
    {
      using type = __underlying_type(_Tp);
    };

  template<typename _Tp>
    struct __underlying_type_impl<_Tp, false>
    { };


  template<typename _Tp>
    struct underlying_type
    : public __underlying_type_impl<_Tp>
    { };

  template<typename _Tp>
    struct __declval_protector
    {
      static const bool __stop = false;
    };

  template<typename _Tp>
    auto declval() noexcept -> decltype(__declval<_Tp>(0))
    {
      static_assert(__declval_protector<_Tp>::__stop,
      "declval() must not be used!");
      return __declval<_Tp>(0);
    }


  template<typename _Signature>
    class result_of;





  struct __invoke_memfun_ref { };
  struct __invoke_memfun_deref { };
  struct __invoke_memobj_ref { };
  struct __invoke_memobj_deref { };
  struct __invoke_other { };


  template<typename _Tp, typename _Tag>
    struct __result_of_success : __success_type<_Tp>
    { using __invoke_type = _Tag; };


  struct __result_of_memfun_ref_impl
  {
    template<typename _Fp, typename _Tp1, typename... _Args>
      static __result_of_success<decltype(
      (std::declval<_Tp1>().*std::declval<_Fp>())(std::declval<_Args>()...)
      ), __invoke_memfun_ref> _S_test(int);

    template<typename...>
      static __failure_type _S_test(...);
  };

  template<typename _MemPtr, typename _Arg, typename... _Args>
    struct __result_of_memfun_ref
    : private __result_of_memfun_ref_impl
    {
      typedef decltype(_S_test<_MemPtr, _Arg, _Args...>(0)) type;
    };


  struct __result_of_memfun_deref_impl
  {
    template<typename _Fp, typename _Tp1, typename... _Args>
      static __result_of_success<decltype(
      ((*std::declval<_Tp1>()).*std::declval<_Fp>())(std::declval<_Args>()...)
      ), __invoke_memfun_deref> _S_test(int);

    template<typename...>
      static __failure_type _S_test(...);
  };

  template<typename _MemPtr, typename _Arg, typename... _Args>
    struct __result_of_memfun_deref
    : private __result_of_memfun_deref_impl
    {
      typedef decltype(_S_test<_MemPtr, _Arg, _Args...>(0)) type;
    };


  struct __result_of_memobj_ref_impl
  {
    template<typename _Fp, typename _Tp1>
      static __result_of_success<decltype(
      std::declval<_Tp1>().*std::declval<_Fp>()
      ), __invoke_memobj_ref> _S_test(int);

    template<typename, typename>
      static __failure_type _S_test(...);
  };

  template<typename _MemPtr, typename _Arg>
    struct __result_of_memobj_ref
    : private __result_of_memobj_ref_impl
    {
      typedef decltype(_S_test<_MemPtr, _Arg>(0)) type;
    };


  struct __result_of_memobj_deref_impl
  {
    template<typename _Fp, typename _Tp1>
      static __result_of_success<decltype(
      (*std::declval<_Tp1>()).*std::declval<_Fp>()
      ), __invoke_memobj_deref> _S_test(int);

    template<typename, typename>
      static __failure_type _S_test(...);
  };

  template<typename _MemPtr, typename _Arg>
    struct __result_of_memobj_deref
    : private __result_of_memobj_deref_impl
    {
      typedef decltype(_S_test<_MemPtr, _Arg>(0)) type;
    };

  template<typename _MemPtr, typename _Arg>
    struct __result_of_memobj;

  template<typename _Res, typename _Class, typename _Arg>
    struct __result_of_memobj<_Res _Class::*, _Arg>
    {
      typedef __remove_cvref_t<_Arg> _Argval;
      typedef _Res _Class::* _MemPtr;
      typedef typename conditional<__or_<is_same<_Argval, _Class>,
        is_base_of<_Class, _Argval>>::value,
        __result_of_memobj_ref<_MemPtr, _Arg>,
        __result_of_memobj_deref<_MemPtr, _Arg>
      >::type::type type;
    };

  template<typename _MemPtr, typename _Arg, typename... _Args>
    struct __result_of_memfun;

  template<typename _Res, typename _Class, typename _Arg, typename... _Args>
    struct __result_of_memfun<_Res _Class::*, _Arg, _Args...>
    {
      typedef typename remove_reference<_Arg>::type _Argval;
      typedef _Res _Class::* _MemPtr;
      typedef typename conditional<is_base_of<_Class, _Argval>::value,
        __result_of_memfun_ref<_MemPtr, _Arg, _Args...>,
        __result_of_memfun_deref<_MemPtr, _Arg, _Args...>
      >::type::type type;
    };






  template<typename _Tp, typename _Up = __remove_cvref_t<_Tp>>
    struct __inv_unwrap
    {
      using type = _Tp;
    };

  template<typename _Tp, typename _Up>
    struct __inv_unwrap<_Tp, reference_wrapper<_Up>>
    {
      using type = _Up&;
    };

  template<bool, bool, typename _Functor, typename... _ArgTypes>
    struct __result_of_impl
    {
      typedef __failure_type type;
    };

  template<typename _MemPtr, typename _Arg>
    struct __result_of_impl<true, false, _MemPtr, _Arg>
    : public __result_of_memobj<__decay_t<_MemPtr>,
    typename __inv_unwrap<_Arg>::type>
    { };

  template<typename _MemPtr, typename _Arg, typename... _Args>
    struct __result_of_impl<false, true, _MemPtr, _Arg, _Args...>
    : public __result_of_memfun<__decay_t<_MemPtr>,
    typename __inv_unwrap<_Arg>::type, _Args...>
    { };


  struct __result_of_other_impl
  {
    template<typename _Fn, typename... _Args>
      static __result_of_success<decltype(
      std::declval<_Fn>()(std::declval<_Args>()...)
      ), __invoke_other> _S_test(int);

    template<typename...>
      static __failure_type _S_test(...);
  };

  template<typename _Functor, typename... _ArgTypes>
    struct __result_of_impl<false, false, _Functor, _ArgTypes...>
    : private __result_of_other_impl
    {
      typedef decltype(_S_test<_Functor, _ArgTypes...>(0)) type;
    };


  template<typename _Functor, typename... _ArgTypes>
    struct __invoke_result
    : public __result_of_impl<
        is_member_object_pointer<
          typename remove_reference<_Functor>::type
        >::value,
        is_member_function_pointer<
          typename remove_reference<_Functor>::type
        >::value,
 _Functor, _ArgTypes...
      >::type
    { };

  template<typename _Functor, typename... _ArgTypes>
    struct result_of<_Functor(_ArgTypes...)>
    : public __invoke_result<_Functor, _ArgTypes...>
    { };
# 2580 "/usr/include/c++/10.2.0/type_traits" 3
  template<typename _Default, typename _AlwaysVoid,
    template<typename...> class _Op, typename... _Args>
    struct __detector
    {
      using value_t = false_type;
      using type = _Default;
    };


  template<typename _Default, template<typename...> class _Op,
     typename... _Args>
    struct __detector<_Default, __void_t<_Op<_Args...>>, _Op, _Args...>
    {
      using value_t = true_type;
      using type = _Op<_Args...>;
    };


  template<typename _Default, template<typename...> class _Op,
    typename... _Args>
    using __detected_or = __detector<_Default, void, _Op, _Args...>;


  template<typename _Default, template<typename...> class _Op,
    typename... _Args>
    using __detected_or_t
      = typename __detected_or<_Default, _Op, _Args...>::type;
# 2624 "/usr/include/c++/10.2.0/type_traits" 3
  template <typename _Tp>
    struct __is_swappable;

  template <typename _Tp>
    struct __is_nothrow_swappable;

  template<typename... _Elements>
    class tuple;

  template<typename>
    struct __is_tuple_like_impl : false_type
    { };

  template<typename... _Tps>
    struct __is_tuple_like_impl<tuple<_Tps...>> : true_type
    { };


  template<typename _Tp>
    struct __is_tuple_like
    : public __is_tuple_like_impl<__remove_cvref_t<_Tp>>::type
    { };

  template<typename _Tp>
   
    inline
    _Require<__not_<__is_tuple_like<_Tp>>,
      is_move_constructible<_Tp>,
      is_move_assignable<_Tp>>
    swap(_Tp&, _Tp&)
    noexcept(__and_<is_nothrow_move_constructible<_Tp>,
             is_nothrow_move_assignable<_Tp>>::value);

  template<typename _Tp, size_t _Nm>
   
    inline
    __enable_if_t<__is_swappable<_Tp>::value>
    swap(_Tp (&__a)[_Nm], _Tp (&__b)[_Nm])
    noexcept(__is_nothrow_swappable<_Tp>::value);

  namespace __swappable_details {
    using std::swap;

    struct __do_is_swappable_impl
    {
      template<typename _Tp, typename
               = decltype(swap(std::declval<_Tp&>(), std::declval<_Tp&>()))>
        static true_type __test(int);

      template<typename>
        static false_type __test(...);
    };

    struct __do_is_nothrow_swappable_impl
    {
      template<typename _Tp>
        static __bool_constant<
          noexcept(swap(std::declval<_Tp&>(), std::declval<_Tp&>()))
        > __test(int);

      template<typename>
        static false_type __test(...);
    };

  }

  template<typename _Tp>
    struct __is_swappable_impl
    : public __swappable_details::__do_is_swappable_impl
    {
      typedef decltype(__test<_Tp>(0)) type;
    };

  template<typename _Tp>
    struct __is_nothrow_swappable_impl
    : public __swappable_details::__do_is_nothrow_swappable_impl
    {
      typedef decltype(__test<_Tp>(0)) type;
    };

  template<typename _Tp>
    struct __is_swappable
    : public __is_swappable_impl<_Tp>::type
    { };

  template<typename _Tp>
    struct __is_nothrow_swappable
    : public __is_nothrow_swappable_impl<_Tp>::type
    { };
# 2837 "/usr/include/c++/10.2.0/type_traits" 3
  template<typename _Result, typename _Ret,
    bool = is_void<_Ret>::value, typename = void>
    struct __is_invocable_impl : false_type { };


  template<typename _Result, typename _Ret>
    struct __is_invocable_impl<_Result, _Ret,
                                true,
          __void_t<typename _Result::type>>
    : true_type
    { };

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wctor-dtor-privacy"

  template<typename _Result, typename _Ret>
    struct __is_invocable_impl<_Result, _Ret,
                                false,
          __void_t<typename _Result::type>>
    {
    private:


      static typename _Result::type _S_get();

      template<typename _Tp>
 static void _S_conv(_Tp);


      template<typename _Tp, typename = decltype(_S_conv<_Tp>(_S_get()))>
 static true_type
 _S_test(int);

      template<typename _Tp>
 static false_type
 _S_test(...);

    public:
      using type = decltype(_S_test<_Ret>(1));
    };
#pragma GCC diagnostic pop

  template<typename _Fn, typename... _ArgTypes>
    struct __is_invocable
    : __is_invocable_impl<__invoke_result<_Fn, _ArgTypes...>, void>::type
    { };

  template<typename _Fn, typename _Tp, typename... _Args>
    constexpr bool __call_is_nt(__invoke_memfun_ref)
    {
      using _Up = typename __inv_unwrap<_Tp>::type;
      return noexcept((std::declval<_Up>().*std::declval<_Fn>())(
     std::declval<_Args>()...));
    }

  template<typename _Fn, typename _Tp, typename... _Args>
    constexpr bool __call_is_nt(__invoke_memfun_deref)
    {
      return noexcept(((*std::declval<_Tp>()).*std::declval<_Fn>())(
     std::declval<_Args>()...));
    }

  template<typename _Fn, typename _Tp>
    constexpr bool __call_is_nt(__invoke_memobj_ref)
    {
      using _Up = typename __inv_unwrap<_Tp>::type;
      return noexcept(std::declval<_Up>().*std::declval<_Fn>());
    }

  template<typename _Fn, typename _Tp>
    constexpr bool __call_is_nt(__invoke_memobj_deref)
    {
      return noexcept((*std::declval<_Tp>()).*std::declval<_Fn>());
    }

  template<typename _Fn, typename... _Args>
    constexpr bool __call_is_nt(__invoke_other)
    {
      return noexcept(std::declval<_Fn>()(std::declval<_Args>()...));
    }

  template<typename _Result, typename _Fn, typename... _Args>
    struct __call_is_nothrow
    : __bool_constant<
 std::__call_is_nt<_Fn, _Args...>(typename _Result::__invoke_type{})
      >
    { };

  template<typename _Fn, typename... _Args>
    using __call_is_nothrow_
      = __call_is_nothrow<__invoke_result<_Fn, _Args...>, _Fn, _Args...>;


  template<typename _Fn, typename... _Args>
    struct __is_nothrow_invocable
    : __and_<__is_invocable<_Fn, _Args...>,
             __call_is_nothrow_<_Fn, _Args...>>::type
    { };

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wctor-dtor-privacy"
  struct __nonesuchbase {};
  struct __nonesuch : private __nonesuchbase {
    ~__nonesuch() = delete;
    __nonesuch(__nonesuch const&) = delete;
    void operator=(__nonesuch const&) = delete;
  };
#pragma GCC diagnostic pop
# 3455 "/usr/include/c++/10.2.0/type_traits" 3

}
# 58 "/usr/include/c++/10.2.0/bits/move.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{

# 74 "/usr/include/c++/10.2.0/bits/move.h" 3
  template<typename _Tp>
    constexpr _Tp&&
    forward(typename std::remove_reference<_Tp>::type& __t) noexcept
    { return static_cast<_Tp&&>(__t); }







  template<typename _Tp>
    constexpr _Tp&&
    forward(typename std::remove_reference<_Tp>::type&& __t) noexcept
    {
      static_assert(!std::is_lvalue_reference<_Tp>::value, "template argument"
      " substituting _Tp is an lvalue reference type");
      return static_cast<_Tp&&>(__t);
    }






  template<typename _Tp>
    constexpr typename std::remove_reference<_Tp>::type&&
    move(_Tp&& __t) noexcept
    { return static_cast<typename std::remove_reference<_Tp>::type&&>(__t); }


  template<typename _Tp>
    struct __move_if_noexcept_cond
    : public __and_<__not_<is_nothrow_move_constructible<_Tp>>,
                    is_copy_constructible<_Tp>>::type { };
# 118 "/usr/include/c++/10.2.0/bits/move.h" 3
  template<typename _Tp>
    constexpr typename
    conditional<__move_if_noexcept_cond<_Tp>::value, const _Tp&, _Tp&&>::type
    move_if_noexcept(_Tp& __x) noexcept
    { return std::move(__x); }
# 138 "/usr/include/c++/10.2.0/bits/move.h" 3
  template<typename _Tp>
    inline _Tp*
    addressof(_Tp& __r) noexcept
    { return std::__addressof(__r); }



  template<typename _Tp>
    const _Tp* addressof(const _Tp&&) = delete;


  template <typename _Tp, typename _Up = _Tp>
   
    inline _Tp
    __exchange(_Tp& __obj, _Up&& __new_val)
    {
      _Tp __old_val = std::move(__obj);
      __obj = std::forward<_Up>(__new_val);
      return __old_val;
    }
# 179 "/usr/include/c++/10.2.0/bits/move.h" 3
  template<typename _Tp>
   
    inline

    typename enable_if<__and_<__not_<__is_tuple_like<_Tp>>,
         is_move_constructible<_Tp>,
         is_move_assignable<_Tp>>::value>::type



    swap(_Tp& __a, _Tp& __b)
    noexcept(__and_<is_nothrow_move_constructible<_Tp>, is_nothrow_move_assignable<_Tp>>::value)

    {




      _Tp __tmp = std::move(__a);
      __a = std::move(__b);
      __b = std::move(__tmp);
    }




  template<typename _Tp, size_t _Nm>
   
    inline

    typename enable_if<__is_swappable<_Tp>::value>::type



    swap(_Tp (&__a)[_Nm], _Tp (&__b)[_Nm])
    noexcept(__is_nothrow_swappable<_Tp>::value)
    {
      for (size_t __n = 0; __n < _Nm; ++__n)
 swap(__a[__n], __b[__n]);
    }



}
# 41 "/usr/include/c++/10.2.0/bits/nested_exception.h" 2 3

extern "C++" {

namespace std
{






  class nested_exception
  {
    exception_ptr _M_ptr;

  public:
    nested_exception() noexcept : _M_ptr(current_exception()) { }

    nested_exception(const nested_exception&) noexcept = default;

    nested_exception& operator=(const nested_exception&) noexcept = default;

    virtual ~nested_exception() noexcept;

    [[noreturn]]
    void
    rethrow_nested() const
    {
      if (_M_ptr)
 rethrow_exception(_M_ptr);
      std::terminate();
    }

    exception_ptr
    nested_ptr() const noexcept
    { return _M_ptr; }
  };



  template<typename _Except>
    struct _Nested_exception : public _Except, public nested_exception
    {
      explicit _Nested_exception(const _Except& __ex)
      : _Except(__ex)
      { }

      explicit _Nested_exception(_Except&& __ex)
      : _Except(static_cast<_Except&&>(__ex))
      { }
    };




  template<typename _Tp>
    [[noreturn]]
    inline void
    __throw_with_nested_impl(_Tp&& __t, true_type)
    {
      using _Up = typename remove_reference<_Tp>::type;
      throw _Nested_exception<_Up>{std::forward<_Tp>(__t)};
    }

  template<typename _Tp>
    [[noreturn]]
    inline void
    __throw_with_nested_impl(_Tp&& __t, false_type)
    { throw std::forward<_Tp>(__t); }





  template<typename _Tp>
    [[noreturn]]
    inline void
    throw_with_nested(_Tp&& __t)
    {
      using _Up = typename decay<_Tp>::type;
      using _CopyConstructible
 = __and_<is_copy_constructible<_Up>, is_move_constructible<_Up>>;
      static_assert(_CopyConstructible::value,
   "throw_with_nested argument must be CopyConstructible");
      using __nest = __and_<is_class<_Up>, __bool_constant<!__is_final(_Up)>,
       __not_<is_base_of<nested_exception, _Up>>>;
      std::__throw_with_nested_impl(std::forward<_Tp>(__t), __nest{});
    }




  template<typename _Tp>
    using __rethrow_if_nested_cond = typename enable_if<
      __and_<is_polymorphic<_Tp>,
      __or_<__not_<is_base_of<nested_exception, _Tp>>,
     is_convertible<_Tp*, nested_exception*>>>::value
    >::type;


  template<typename _Ex>
    inline __rethrow_if_nested_cond<_Ex>
    __rethrow_if_nested_impl(const _Ex* __ptr)
    {
      if (auto __ne_ptr = dynamic_cast<const nested_exception*>(__ptr))
 __ne_ptr->rethrow_nested();
    }


  inline void
  __rethrow_if_nested_impl(const void*)
  { }




  template<typename _Ex>
    inline void
    rethrow_if_nested(const _Ex& __ex)
    { std::__rethrow_if_nested_impl(std::__addressof(__ex)); }


}

}



#pragma GCC visibility pop
# 149 "/usr/include/c++/10.2.0/exception" 2 3
# 40 "/usr/include/c++/10.2.0/ios" 2 3
# 1 "/usr/include/c++/10.2.0/bits/char_traits.h" 1 3
# 37 "/usr/include/c++/10.2.0/bits/char_traits.h" 3
       
# 38 "/usr/include/c++/10.2.0/bits/char_traits.h" 3

# 1 "/usr/include/c++/10.2.0/bits/stl_algobase.h" 1 3
# 60 "/usr/include/c++/10.2.0/bits/stl_algobase.h" 3
# 1 "/usr/include/c++/10.2.0/bits/functexcept.h" 1 3
# 42 "/usr/include/c++/10.2.0/bits/functexcept.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{



  void
  __throw_bad_exception(void) __attribute__((__noreturn__));


  void
  __throw_bad_alloc(void) __attribute__((__noreturn__));


  void
  __throw_bad_cast(void) __attribute__((__noreturn__));

  void
  __throw_bad_typeid(void) __attribute__((__noreturn__));


  void
  __throw_logic_error(const char*) __attribute__((__noreturn__));

  void
  __throw_domain_error(const char*) __attribute__((__noreturn__));

  void
  __throw_invalid_argument(const char*) __attribute__((__noreturn__));

  void
  __throw_length_error(const char*) __attribute__((__noreturn__));

  void
  __throw_out_of_range(const char*) __attribute__((__noreturn__));

  void
  __throw_out_of_range_fmt(const char*, ...) __attribute__((__noreturn__))
    __attribute__((__format__(__gnu_printf__, 1, 2)));

  void
  __throw_runtime_error(const char*) __attribute__((__noreturn__));

  void
  __throw_range_error(const char*) __attribute__((__noreturn__));

  void
  __throw_overflow_error(const char*) __attribute__((__noreturn__));

  void
  __throw_underflow_error(const char*) __attribute__((__noreturn__));


  void
  __throw_ios_failure(const char*) __attribute__((__noreturn__));

  void
  __throw_ios_failure(const char*, int) __attribute__((__noreturn__));


  void
  __throw_system_error(int) __attribute__((__noreturn__));


  void
  __throw_future_error(int) __attribute__((__noreturn__));


  void
  __throw_bad_function_call() __attribute__((__noreturn__));


}
# 61 "/usr/include/c++/10.2.0/bits/stl_algobase.h" 2 3


# 1 "/usr/include/c++/10.2.0/ext/numeric_traits.h" 1 3
# 32 "/usr/include/c++/10.2.0/ext/numeric_traits.h" 3
       
# 33 "/usr/include/c++/10.2.0/ext/numeric_traits.h" 3




namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{

# 54 "/usr/include/c++/10.2.0/ext/numeric_traits.h" 3
  template<typename _Value>
    struct __numeric_traits_integer
    {

      static const _Value __min = (((_Value)(-1) < 0) ? -(((_Value)(-1) < 0) ? (((((_Value)1 << ((sizeof(_Value) * 8 - ((_Value)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(_Value)0) - 1 : (_Value)0);
      static const _Value __max = (((_Value)(-1) < 0) ? (((((_Value)1 << ((sizeof(_Value) * 8 - ((_Value)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(_Value)0);



      static const bool __is_signed = ((_Value)(-1) < 0);
      static const int __digits = (sizeof(_Value) * 8 - ((_Value)(-1) < 0));
    };

  template<typename _Value>
    const _Value __numeric_traits_integer<_Value>::__min;

  template<typename _Value>
    const _Value __numeric_traits_integer<_Value>::__max;

  template<typename _Value>
    const bool __numeric_traits_integer<_Value>::__is_signed;

  template<typename _Value>
    const int __numeric_traits_integer<_Value>::__digits;
# 99 "/usr/include/c++/10.2.0/ext/numeric_traits.h" 3
  template<typename _Value>
    struct __numeric_traits_floating
    {

      static const int __max_digits10 = (2 + (std::__are_same<_Value, float>::__value ? 24 : std::__are_same<_Value, double>::__value ? 53 : 64) * 643L / 2136);


      static const bool __is_signed = true;
      static const int __digits10 = (std::__are_same<_Value, float>::__value ? 6 : std::__are_same<_Value, double>::__value ? 15 : 18);
      static const int __max_exponent10 = (std::__are_same<_Value, float>::__value ? 38 : std::__are_same<_Value, double>::__value ? 308 : 4932);
    };

  template<typename _Value>
    const int __numeric_traits_floating<_Value>::__max_digits10;

  template<typename _Value>
    const bool __numeric_traits_floating<_Value>::__is_signed;

  template<typename _Value>
    const int __numeric_traits_floating<_Value>::__digits10;

  template<typename _Value>
    const int __numeric_traits_floating<_Value>::__max_exponent10;

  template<typename _Value>
    struct __numeric_traits
    : public __conditional_type<std::__is_integer<_Value>::__value,
    __numeric_traits_integer<_Value>,
    __numeric_traits_floating<_Value> >::__type
    { };


}
# 64 "/usr/include/c++/10.2.0/bits/stl_algobase.h" 2 3
# 1 "/usr/include/c++/10.2.0/bits/stl_pair.h" 1 3
# 69 "/usr/include/c++/10.2.0/bits/stl_pair.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{

# 80 "/usr/include/c++/10.2.0/bits/stl_pair.h" 3
  struct piecewise_construct_t { explicit piecewise_construct_t() = default; };


  constexpr piecewise_construct_t piecewise_construct =
    piecewise_construct_t();




  template<typename...>
    class tuple;

  template<std::size_t...>
    struct _Index_tuple;






  template <bool, typename _T1, typename _T2>
    struct _PCC
    {
      template <typename _U1, typename _U2>
      static constexpr bool _ConstructiblePair()
      {
 return __and_<is_constructible<_T1, const _U1&>,
        is_constructible<_T2, const _U2&>>::value;
      }

      template <typename _U1, typename _U2>
      static constexpr bool _ImplicitlyConvertiblePair()
      {
 return __and_<is_convertible<const _U1&, _T1>,
        is_convertible<const _U2&, _T2>>::value;
      }

      template <typename _U1, typename _U2>
      static constexpr bool _MoveConstructiblePair()
      {
 return __and_<is_constructible<_T1, _U1&&>,
        is_constructible<_T2, _U2&&>>::value;
      }

      template <typename _U1, typename _U2>
      static constexpr bool _ImplicitlyMoveConvertiblePair()
      {
 return __and_<is_convertible<_U1&&, _T1>,
        is_convertible<_U2&&, _T2>>::value;
      }

      template <bool __implicit, typename _U1, typename _U2>
      static constexpr bool _CopyMovePair()
      {
 using __do_converts = __and_<is_convertible<const _U1&, _T1>,
      is_convertible<_U2&&, _T2>>;
 using __converts = typename conditional<__implicit,
           __do_converts,
           __not_<__do_converts>>::type;
 return __and_<is_constructible<_T1, const _U1&>,
        is_constructible<_T2, _U2&&>,
        __converts
        >::value;
      }

      template <bool __implicit, typename _U1, typename _U2>
      static constexpr bool _MoveCopyPair()
      {
 using __do_converts = __and_<is_convertible<_U1&&, _T1>,
      is_convertible<const _U2&, _T2>>;
 using __converts = typename conditional<__implicit,
           __do_converts,
           __not_<__do_converts>>::type;
 return __and_<is_constructible<_T1, _U1&&>,
        is_constructible<_T2, const _U2&&>,
        __converts
        >::value;
      }
  };

  template <typename _T1, typename _T2>
    struct _PCC<false, _T1, _T2>
    {
      template <typename _U1, typename _U2>
      static constexpr bool _ConstructiblePair()
      {
 return false;
      }

      template <typename _U1, typename _U2>
      static constexpr bool _ImplicitlyConvertiblePair()
      {
 return false;
      }

      template <typename _U1, typename _U2>
      static constexpr bool _MoveConstructiblePair()
      {
 return false;
      }

      template <typename _U1, typename _U2>
      static constexpr bool _ImplicitlyMoveConvertiblePair()
      {
 return false;
      }
  };


  template<typename _U1, typename _U2> class __pair_base
  {

    template<typename _T1, typename _T2> friend struct pair;
    __pair_base() = default;
    ~__pair_base() = default;
    __pair_base(const __pair_base&) = default;
    __pair_base& operator=(const __pair_base&) = delete;

  };
# 210 "/usr/include/c++/10.2.0/bits/stl_pair.h" 3
  template<typename _T1, typename _T2>
    struct pair
    : private __pair_base<_T1, _T2>
    {
      typedef _T1 first_type;
      typedef _T2 second_type;

      _T1 first;
      _T2 second;






      template <typename _U1 = _T1,
                typename _U2 = _T2,
                typename enable_if<__and_<
                                     __is_implicitly_default_constructible<_U1>,
                                     __is_implicitly_default_constructible<_U2>>
                                   ::value, bool>::type = true>

      constexpr pair()
      : first(), second() { }


      template <typename _U1 = _T1,
                typename _U2 = _T2,
                typename enable_if<__and_<
                       is_default_constructible<_U1>,
                       is_default_constructible<_U2>,
                       __not_<
                         __and_<__is_implicitly_default_constructible<_U1>,
                                __is_implicitly_default_constructible<_U2>>>>
                                   ::value, bool>::type = false>
      explicit constexpr pair()
      : first(), second() { }
# 256 "/usr/include/c++/10.2.0/bits/stl_pair.h" 3
      using _PCCP = _PCC<true, _T1, _T2>;



      template<typename _U1 = _T1, typename _U2=_T2, typename
        enable_if<_PCCP::template
      _ConstructiblePair<_U1, _U2>()
                  && _PCCP::template
      _ImplicitlyConvertiblePair<_U1, _U2>(),
                         bool>::type=true>
      constexpr pair(const _T1& __a, const _T2& __b)
      : first(__a), second(__b) { }


       template<typename _U1 = _T1, typename _U2=_T2, typename
  enable_if<_PCCP::template
       _ConstructiblePair<_U1, _U2>()
                   && !_PCCP::template
       _ImplicitlyConvertiblePair<_U1, _U2>(),
                         bool>::type=false>
      explicit constexpr pair(const _T1& __a, const _T2& __b)
      : first(__a), second(__b) { }
# 288 "/usr/include/c++/10.2.0/bits/stl_pair.h" 3
      template <typename _U1, typename _U2>
        using _PCCFP = _PCC<!is_same<_T1, _U1>::value
       || !is_same<_T2, _U2>::value,
       _T1, _T2>;


      template<typename _U1, typename _U2, typename
        enable_if<_PCCFP<_U1, _U2>::template
      _ConstructiblePair<_U1, _U2>()
                  && _PCCFP<_U1, _U2>::template
      _ImplicitlyConvertiblePair<_U1, _U2>(),
     bool>::type=true>
        constexpr pair(const pair<_U1, _U2>& __p)
        : first(__p.first), second(__p.second) { }

      template<typename _U1, typename _U2, typename
        enable_if<_PCCFP<_U1, _U2>::template
      _ConstructiblePair<_U1, _U2>()
    && !_PCCFP<_U1, _U2>::template
      _ImplicitlyConvertiblePair<_U1, _U2>(),
                         bool>::type=false>
 explicit constexpr pair(const pair<_U1, _U2>& __p)
 : first(__p.first), second(__p.second) { }



      constexpr pair(const pair&) = default;
      constexpr pair(pair&&) = default;


      template<typename _U1, typename
        enable_if<_PCCP::template
      _MoveCopyPair<true, _U1, _T2>(),
                         bool>::type=true>
       constexpr pair(_U1&& __x, const _T2& __y)
       : first(std::forward<_U1>(__x)), second(__y) { }

      template<typename _U1, typename
        enable_if<_PCCP::template
      _MoveCopyPair<false, _U1, _T2>(),
                         bool>::type=false>
       explicit constexpr pair(_U1&& __x, const _T2& __y)
       : first(std::forward<_U1>(__x)), second(__y) { }

      template<typename _U2, typename
        enable_if<_PCCP::template
      _CopyMovePair<true, _T1, _U2>(),
                         bool>::type=true>
       constexpr pair(const _T1& __x, _U2&& __y)
       : first(__x), second(std::forward<_U2>(__y)) { }

      template<typename _U2, typename
        enable_if<_PCCP::template
      _CopyMovePair<false, _T1, _U2>(),
                         bool>::type=false>
       explicit pair(const _T1& __x, _U2&& __y)
       : first(__x), second(std::forward<_U2>(__y)) { }

      template<typename _U1, typename _U2, typename
        enable_if<_PCCP::template
      _MoveConstructiblePair<_U1, _U2>()
     && _PCCP::template
      _ImplicitlyMoveConvertiblePair<_U1, _U2>(),
                         bool>::type=true>
 constexpr pair(_U1&& __x, _U2&& __y)
 : first(std::forward<_U1>(__x)), second(std::forward<_U2>(__y)) { }

      template<typename _U1, typename _U2, typename
        enable_if<_PCCP::template
      _MoveConstructiblePair<_U1, _U2>()
     && !_PCCP::template
      _ImplicitlyMoveConvertiblePair<_U1, _U2>(),
                         bool>::type=false>
 explicit constexpr pair(_U1&& __x, _U2&& __y)
 : first(std::forward<_U1>(__x)), second(std::forward<_U2>(__y)) { }


      template<typename _U1, typename _U2, typename
        enable_if<_PCCFP<_U1, _U2>::template
      _MoveConstructiblePair<_U1, _U2>()
     && _PCCFP<_U1, _U2>::template
      _ImplicitlyMoveConvertiblePair<_U1, _U2>(),
                         bool>::type=true>
 constexpr pair(pair<_U1, _U2>&& __p)
 : first(std::forward<_U1>(__p.first)),
   second(std::forward<_U2>(__p.second)) { }

      template<typename _U1, typename _U2, typename
        enable_if<_PCCFP<_U1, _U2>::template
      _MoveConstructiblePair<_U1, _U2>()
     && !_PCCFP<_U1, _U2>::template
      _ImplicitlyMoveConvertiblePair<_U1, _U2>(),
                         bool>::type=false>
 explicit constexpr pair(pair<_U1, _U2>&& __p)
 : first(std::forward<_U1>(__p.first)),
   second(std::forward<_U2>(__p.second)) { }

      template<typename... _Args1, typename... _Args2>

        pair(piecewise_construct_t, tuple<_Args1...>, tuple<_Args2...>);

      pair&
      operator=(typename conditional<
  __and_<is_copy_assignable<_T1>,
         is_copy_assignable<_T2>>::value,
  const pair&, const __nonesuch&>::type __p)
      {
 first = __p.first;
 second = __p.second;
 return *this;
      }

      pair&
      operator=(typename conditional<
  __and_<is_move_assignable<_T1>,
         is_move_assignable<_T2>>::value,
  pair&&, __nonesuch&&>::type __p)
      noexcept(__and_<is_nothrow_move_assignable<_T1>,
        is_nothrow_move_assignable<_T2>>::value)
      {
 first = std::forward<first_type>(__p.first);
 second = std::forward<second_type>(__p.second);
 return *this;
      }

      template<typename _U1, typename _U2>

 typename enable_if<__and_<is_assignable<_T1&, const _U1&>,
      is_assignable<_T2&, const _U2&>>::value,
      pair&>::type
 operator=(const pair<_U1, _U2>& __p)
 {
   first = __p.first;
   second = __p.second;
   return *this;
 }

      template<typename _U1, typename _U2>

 typename enable_if<__and_<is_assignable<_T1&, _U1&&>,
      is_assignable<_T2&, _U2&&>>::value,
      pair&>::type
 operator=(pair<_U1, _U2>&& __p)
 {
   first = std::forward<_U1>(__p.first);
   second = std::forward<_U2>(__p.second);
   return *this;
 }


      void
      swap(pair& __p)
      noexcept(__and_<__is_nothrow_swappable<_T1>,
                      __is_nothrow_swappable<_T2>>::value)
      {
 using std::swap;
 swap(first, __p.first);
 swap(second, __p.second);
      }

    private:
      template<typename... _Args1, std::size_t... _Indexes1,
               typename... _Args2, std::size_t... _Indexes2>

        pair(tuple<_Args1...>&, tuple<_Args2...>&,
             _Index_tuple<_Indexes1...>, _Index_tuple<_Indexes2...>);

    };
# 464 "/usr/include/c++/10.2.0/bits/stl_pair.h" 3
  template<typename _T1, typename _T2>
    inline constexpr bool
    operator==(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return __x.first == __y.first && __x.second == __y.second; }
# 487 "/usr/include/c++/10.2.0/bits/stl_pair.h" 3
  template<typename _T1, typename _T2>
    inline constexpr bool
    operator<(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return __x.first < __y.first
      || (!(__y.first < __x.first) && __x.second < __y.second); }


  template<typename _T1, typename _T2>
    inline constexpr bool
    operator!=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return !(__x == __y); }


  template<typename _T1, typename _T2>
    inline constexpr bool
    operator>(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return __y < __x; }


  template<typename _T1, typename _T2>
    inline constexpr bool
    operator<=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return !(__y < __x); }


  template<typename _T1, typename _T2>
    inline constexpr bool
    operator>=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return !(__x < __y); }
# 524 "/usr/include/c++/10.2.0/bits/stl_pair.h" 3
  template<typename _T1, typename _T2>
    inline





    void

    swap(pair<_T1, _T2>& __x, pair<_T1, _T2>& __y)
    noexcept(noexcept(__x.swap(__y)))
    { __x.swap(__y); }
# 564 "/usr/include/c++/10.2.0/bits/stl_pair.h" 3
  template<typename _T1, typename _T2>
    constexpr pair<typename __decay_and_strip<_T1>::__type,
                   typename __decay_and_strip<_T2>::__type>
    make_pair(_T1&& __x, _T2&& __y)
    {
      typedef typename __decay_and_strip<_T1>::__type __ds_type1;
      typedef typename __decay_and_strip<_T2>::__type __ds_type2;
      typedef pair<__ds_type1, __ds_type2> __pair_type;
      return __pair_type(std::forward<_T1>(__x), std::forward<_T2>(__y));
    }
# 583 "/usr/include/c++/10.2.0/bits/stl_pair.h" 3

}
# 65 "/usr/include/c++/10.2.0/bits/stl_algobase.h" 2 3
# 1 "/usr/include/c++/10.2.0/bits/stl_iterator_base_types.h" 1 3
# 62 "/usr/include/c++/10.2.0/bits/stl_iterator_base_types.h" 3
       
# 63 "/usr/include/c++/10.2.0/bits/stl_iterator_base_types.h" 3
# 74 "/usr/include/c++/10.2.0/bits/stl_iterator_base_types.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{

# 93 "/usr/include/c++/10.2.0/bits/stl_iterator_base_types.h" 3
  struct input_iterator_tag { };


  struct output_iterator_tag { };


  struct forward_iterator_tag : public input_iterator_tag { };



  struct bidirectional_iterator_tag : public forward_iterator_tag { };



  struct random_access_iterator_tag : public bidirectional_iterator_tag { };
# 125 "/usr/include/c++/10.2.0/bits/stl_iterator_base_types.h" 3
  template<typename _Category, typename _Tp, typename _Distance = ptrdiff_t,
           typename _Pointer = _Tp*, typename _Reference = _Tp&>
    struct iterator
    {

      typedef _Category iterator_category;

      typedef _Tp value_type;

      typedef _Distance difference_type;

      typedef _Pointer pointer;

      typedef _Reference reference;
    };
# 149 "/usr/include/c++/10.2.0/bits/stl_iterator_base_types.h" 3
  template<typename _Iterator>
    struct iterator_traits;




  template<typename _Iterator, typename = __void_t<>>
    struct __iterator_traits { };



  template<typename _Iterator>
    struct __iterator_traits<_Iterator,
        __void_t<typename _Iterator::iterator_category,
          typename _Iterator::value_type,
          typename _Iterator::difference_type,
          typename _Iterator::pointer,
          typename _Iterator::reference>>
    {
      typedef typename _Iterator::iterator_category iterator_category;
      typedef typename _Iterator::value_type value_type;
      typedef typename _Iterator::difference_type difference_type;
      typedef typename _Iterator::pointer pointer;
      typedef typename _Iterator::reference reference;
    };


  template<typename _Iterator>
    struct iterator_traits
    : public __iterator_traits<_Iterator> { };
# 209 "/usr/include/c++/10.2.0/bits/stl_iterator_base_types.h" 3
  template<typename _Tp>
    struct iterator_traits<_Tp*>
    {
      typedef random_access_iterator_tag iterator_category;
      typedef _Tp value_type;
      typedef ptrdiff_t difference_type;
      typedef _Tp* pointer;
      typedef _Tp& reference;
    };


  template<typename _Tp>
    struct iterator_traits<const _Tp*>
    {
      typedef random_access_iterator_tag iterator_category;
      typedef _Tp value_type;
      typedef ptrdiff_t difference_type;
      typedef const _Tp* pointer;
      typedef const _Tp& reference;
    };






  template<typename _Iter>
    inline constexpr
    typename iterator_traits<_Iter>::iterator_category
    __iterator_category(const _Iter&)
    { return typename iterator_traits<_Iter>::iterator_category(); }




  template<typename _Iter>
    using __iterator_category_t
      = typename iterator_traits<_Iter>::iterator_category;

  template<typename _InIter>
    using _RequireInputIter =
      __enable_if_t<is_convertible<__iterator_category_t<_InIter>,
       input_iterator_tag>::value>;

  template<typename _It,
    typename _Cat = __iterator_category_t<_It>>
    struct __is_random_access_iter
      : is_base_of<random_access_iterator_tag, _Cat>
    {
      typedef is_base_of<random_access_iterator_tag, _Cat> _Base;
      enum { __value = _Base::value };
    };








}
# 66 "/usr/include/c++/10.2.0/bits/stl_algobase.h" 2 3
# 1 "/usr/include/c++/10.2.0/bits/stl_iterator_base_funcs.h" 1 3
# 62 "/usr/include/c++/10.2.0/bits/stl_iterator_base_funcs.h" 3
       
# 63 "/usr/include/c++/10.2.0/bits/stl_iterator_base_funcs.h" 3

# 1 "/usr/include/c++/10.2.0/bits/concept_check.h" 1 3
# 33 "/usr/include/c++/10.2.0/bits/concept_check.h" 3
       
# 34 "/usr/include/c++/10.2.0/bits/concept_check.h" 3
# 65 "/usr/include/c++/10.2.0/bits/stl_iterator_base_funcs.h" 2 3
# 1 "/usr/include/c++/10.2.0/debug/assertions.h" 1 3
# 66 "/usr/include/c++/10.2.0/bits/stl_iterator_base_funcs.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{




  template <typename> struct _List_iterator;
  template <typename> struct _List_const_iterator;


  template<typename _InputIterator>
    inline
    typename iterator_traits<_InputIterator>::difference_type
    __distance(_InputIterator __first, _InputIterator __last,
               input_iterator_tag)
    {

     

      typename iterator_traits<_InputIterator>::difference_type __n = 0;
      while (__first != __last)
 {
   ++__first;
   ++__n;
 }
      return __n;
    }

  template<typename _RandomAccessIterator>
    inline
    typename iterator_traits<_RandomAccessIterator>::difference_type
    __distance(_RandomAccessIterator __first, _RandomAccessIterator __last,
               random_access_iterator_tag)
    {

     

      return __last - __first;
    }



  template<typename _Tp>
    ptrdiff_t
    __distance(std::_List_iterator<_Tp>,
        std::_List_iterator<_Tp>,
        input_iterator_tag);

  template<typename _Tp>
    ptrdiff_t
    __distance(std::_List_const_iterator<_Tp>,
        std::_List_const_iterator<_Tp>,
        input_iterator_tag);
# 135 "/usr/include/c++/10.2.0/bits/stl_iterator_base_funcs.h" 3
  template<typename _InputIterator>
    inline
    typename iterator_traits<_InputIterator>::difference_type
    distance(_InputIterator __first, _InputIterator __last)
    {

      return std::__distance(__first, __last,
        std::__iterator_category(__first));
    }

  template<typename _InputIterator, typename _Distance>
    inline void
    __advance(_InputIterator& __i, _Distance __n, input_iterator_tag)
    {

     
      ;
      while (__n--)
 ++__i;
    }

  template<typename _BidirectionalIterator, typename _Distance>
    inline void
    __advance(_BidirectionalIterator& __i, _Distance __n,
       bidirectional_iterator_tag)
    {

     

      if (__n > 0)
        while (__n--)
   ++__i;
      else
        while (__n++)
   --__i;
    }

  template<typename _RandomAccessIterator, typename _Distance>
    inline void
    __advance(_RandomAccessIterator& __i, _Distance __n,
              random_access_iterator_tag)
    {

     

      if (__builtin_constant_p(__n) && __n == 1)
 ++__i;
      else if (__builtin_constant_p(__n) && __n == -1)
 --__i;
      else
 __i += __n;
    }
# 200 "/usr/include/c++/10.2.0/bits/stl_iterator_base_funcs.h" 3
  template<typename _InputIterator, typename _Distance>
    inline void
    advance(_InputIterator& __i, _Distance __n)
    {

      typename iterator_traits<_InputIterator>::difference_type __d = __n;
      std::__advance(__i, __d, std::__iterator_category(__i));
    }



  template<typename _InputIterator>
    inline _InputIterator
    next(_InputIterator __x, typename
  iterator_traits<_InputIterator>::difference_type __n = 1)
    {

     
      std::advance(__x, __n);
      return __x;
    }

  template<typename _BidirectionalIterator>
    inline _BidirectionalIterator
    prev(_BidirectionalIterator __x, typename
  iterator_traits<_BidirectionalIterator>::difference_type __n = 1)
    {

     

      std::advance(__x, -__n);
      return __x;
    }




}
# 67 "/usr/include/c++/10.2.0/bits/stl_algobase.h" 2 3
# 1 "/usr/include/c++/10.2.0/bits/stl_iterator.h" 1 3
# 66 "/usr/include/c++/10.2.0/bits/stl_iterator.h" 3
# 1 "/usr/include/c++/10.2.0/bits/ptr_traits.h" 1 3
# 42 "/usr/include/c++/10.2.0/bits/ptr_traits.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{


  class __undefined;


  template<typename _Tp>
    struct __get_first_arg
    { using type = __undefined; };

  template<template<typename, typename...> class _Template, typename _Tp,
           typename... _Types>
    struct __get_first_arg<_Template<_Tp, _Types...>>
    { using type = _Tp; };

  template<typename _Tp>
    using __get_first_arg_t = typename __get_first_arg<_Tp>::type;


  template<typename _Tp, typename _Up>
    struct __replace_first_arg
    { };

  template<template<typename, typename...> class _Template, typename _Up,
           typename _Tp, typename... _Types>
    struct __replace_first_arg<_Template<_Tp, _Types...>, _Up>
    { using type = _Template<_Up, _Types...>; };

  template<typename _Tp, typename _Up>
    using __replace_first_arg_t = typename __replace_first_arg<_Tp, _Up>::type;

  template<typename _Tp>
    using __make_not_void
      = typename conditional<is_void<_Tp>::value, __undefined, _Tp>::type;





  template<typename _Ptr>
    struct pointer_traits
    {
    private:
      template<typename _Tp>
 using __element_type = typename _Tp::element_type;

      template<typename _Tp>
 using __difference_type = typename _Tp::difference_type;

      template<typename _Tp, typename _Up, typename = void>
 struct __rebind : __replace_first_arg<_Tp, _Up> { };

      template<typename _Tp, typename _Up>
 struct __rebind<_Tp, _Up, __void_t<typename _Tp::template rebind<_Up>>>
 { using type = typename _Tp::template rebind<_Up>; };

    public:

      using pointer = _Ptr;


      using element_type
 = __detected_or_t<__get_first_arg_t<_Ptr>, __element_type, _Ptr>;


      using difference_type
 = __detected_or_t<ptrdiff_t, __difference_type, _Ptr>;


      template<typename _Up>
        using rebind = typename __rebind<_Ptr, _Up>::type;

      static _Ptr
      pointer_to(__make_not_void<element_type>& __e)
      { return _Ptr::pointer_to(__e); }

      static_assert(!is_same<element_type, __undefined>::value,
   "pointer type defines element_type or is like SomePointer<T, Args>");
    };





  template<typename _Tp>
    struct pointer_traits<_Tp*>
    {

      typedef _Tp* pointer;

      typedef _Tp element_type;

      typedef ptrdiff_t difference_type;

      template<typename _Up>
        using rebind = _Up*;






      static pointer
      pointer_to(__make_not_void<element_type>& __r) noexcept
      { return std::addressof(__r); }
    };


  template<typename _Ptr, typename _Tp>
    using __ptr_rebind = typename pointer_traits<_Ptr>::template rebind<_Tp>;

  template<typename _Tp>
    constexpr _Tp*
    __to_address(_Tp* __ptr) noexcept
    {
      static_assert(!std::is_function<_Tp>::value, "not a function pointer");
      return __ptr;
    }


  template<typename _Ptr>
    constexpr typename std::pointer_traits<_Ptr>::element_type*
    __to_address(const _Ptr& __ptr)
    { return std::__to_address(__ptr.operator->()); }
# 210 "/usr/include/c++/10.2.0/bits/ptr_traits.h" 3

}
# 67 "/usr/include/c++/10.2.0/bits/stl_iterator.h" 2 3
# 85 "/usr/include/c++/10.2.0/bits/stl_iterator.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{

# 124 "/usr/include/c++/10.2.0/bits/stl_iterator.h" 3
  template<typename _Iterator>
    class reverse_iterator
    : public iterator<typename iterator_traits<_Iterator>::iterator_category,
        typename iterator_traits<_Iterator>::value_type,
        typename iterator_traits<_Iterator>::difference_type,
        typename iterator_traits<_Iterator>::pointer,
                      typename iterator_traits<_Iterator>::reference>
    {
    protected:
      _Iterator current;

      typedef iterator_traits<_Iterator> __traits_type;

    public:
      typedef _Iterator iterator_type;
      typedef typename __traits_type::difference_type difference_type;
      typedef typename __traits_type::pointer pointer;
      typedef typename __traits_type::reference reference;
# 160 "/usr/include/c++/10.2.0/bits/stl_iterator.h" 3
     
      reverse_iterator() : current() { }




      explicit
      reverse_iterator(iterator_type __x) : current(__x) { }




     
      reverse_iterator(const reverse_iterator& __x)
      : current(__x.current) { }


      reverse_iterator& operator=(const reverse_iterator&) = default;






      template<typename _Iter>

        reverse_iterator(const reverse_iterator<_Iter>& __x)
 : current(__x.base()) { }




      iterator_type
      base() const
      { return current; }
# 206 "/usr/include/c++/10.2.0/bits/stl_iterator.h" 3
      reference
      operator*() const
      {
 _Iterator __tmp = current;
 return *--__tmp;
      }






      pointer
      operator->() const




      {


 _Iterator __tmp = current;
 --__tmp;
 return _S_to_pointer(__tmp);
      }






      reverse_iterator&
      operator++()
      {
 --current;
 return *this;
      }






      reverse_iterator
      operator++(int)
      {
 reverse_iterator __tmp = *this;
 --current;
 return __tmp;
      }






      reverse_iterator&
      operator--()
      {
 ++current;
 return *this;
      }






      reverse_iterator
      operator--(int)
      {
 reverse_iterator __tmp = *this;
 ++current;
 return __tmp;
      }






      reverse_iterator
      operator+(difference_type __n) const
      { return reverse_iterator(current - __n); }







      reverse_iterator&
      operator+=(difference_type __n)
      {
 current -= __n;
 return *this;
      }






      reverse_iterator
      operator-(difference_type __n) const
      { return reverse_iterator(current + __n); }







      reverse_iterator&
      operator-=(difference_type __n)
      {
 current += __n;
 return *this;
      }






      reference
      operator[](difference_type __n) const
      { return *(*this + __n); }

    private:
      template<typename _Tp>
 static _Tp*
 _S_to_pointer(_Tp* __p)
        { return __p; }

      template<typename _Tp>
 static pointer
 _S_to_pointer(_Tp __t)
        { return __t.operator->(); }
    };
# 358 "/usr/include/c++/10.2.0/bits/stl_iterator.h" 3
  template<typename _Iterator>
    inline bool
    operator==(const reverse_iterator<_Iterator>& __x,
        const reverse_iterator<_Iterator>& __y)
    { return __x.base() == __y.base(); }

  template<typename _Iterator>
    inline bool
    operator<(const reverse_iterator<_Iterator>& __x,
       const reverse_iterator<_Iterator>& __y)
    { return __y.base() < __x.base(); }

  template<typename _Iterator>
    inline bool
    operator!=(const reverse_iterator<_Iterator>& __x,
        const reverse_iterator<_Iterator>& __y)
    { return !(__x == __y); }

  template<typename _Iterator>
    inline bool
    operator>(const reverse_iterator<_Iterator>& __x,
       const reverse_iterator<_Iterator>& __y)
    { return __y < __x; }

  template<typename _Iterator>
    inline bool
    operator<=(const reverse_iterator<_Iterator>& __x,
        const reverse_iterator<_Iterator>& __y)
    { return !(__y < __x); }

  template<typename _Iterator>
    inline bool
    operator>=(const reverse_iterator<_Iterator>& __x,
        const reverse_iterator<_Iterator>& __y)
    { return !(__x < __y); }



  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator==(const reverse_iterator<_IteratorL>& __x,
        const reverse_iterator<_IteratorR>& __y)
    { return __x.base() == __y.base(); }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator<(const reverse_iterator<_IteratorL>& __x,
       const reverse_iterator<_IteratorR>& __y)
    { return __y.base() < __x.base(); }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator!=(const reverse_iterator<_IteratorL>& __x,
        const reverse_iterator<_IteratorR>& __y)
    { return !(__x == __y); }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator>(const reverse_iterator<_IteratorL>& __x,
       const reverse_iterator<_IteratorR>& __y)
    { return __y < __x; }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator<=(const reverse_iterator<_IteratorL>& __x,
        const reverse_iterator<_IteratorR>& __y)
    { return !(__y < __x); }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator>=(const reverse_iterator<_IteratorL>& __x,
        const reverse_iterator<_IteratorR>& __y)
    { return !(__x < __y); }
# 498 "/usr/include/c++/10.2.0/bits/stl_iterator.h" 3
  template<typename _IteratorL, typename _IteratorR>
    inline auto
    operator-(const reverse_iterator<_IteratorL>& __x,
       const reverse_iterator<_IteratorR>& __y)
    -> decltype(__y.base() - __x.base())
    { return __y.base() - __x.base(); }


  template<typename _Iterator>
    inline reverse_iterator<_Iterator>
    operator+(typename reverse_iterator<_Iterator>::difference_type __n,
       const reverse_iterator<_Iterator>& __x)
    { return reverse_iterator<_Iterator>(__x.base() - __n); }



  template<typename _Iterator>
    inline reverse_iterator<_Iterator>
    __make_reverse_iterator(_Iterator __i)
    { return reverse_iterator<_Iterator>(__i); }
# 539 "/usr/include/c++/10.2.0/bits/stl_iterator.h" 3
  template<typename _Iterator>
   
    auto
    __niter_base(reverse_iterator<_Iterator> __it)
    -> decltype(__make_reverse_iterator(__niter_base(__it.base())))
    { return __make_reverse_iterator(__niter_base(__it.base())); }

  template<typename _Iterator>
    struct __is_move_iterator<reverse_iterator<_Iterator> >
      : __is_move_iterator<_Iterator>
    { };

  template<typename _Iterator>
   
    auto
    __miter_base(reverse_iterator<_Iterator> __it)
    -> decltype(__make_reverse_iterator(__miter_base(__it.base())))
    { return __make_reverse_iterator(__miter_base(__it.base())); }
# 570 "/usr/include/c++/10.2.0/bits/stl_iterator.h" 3
  template<typename _Container>
    class back_insert_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    protected:
      _Container* container;

    public:

      typedef _Container container_type;







      explicit
      back_insert_iterator(_Container& __x)
      : container(std::__addressof(__x)) { }
# 610 "/usr/include/c++/10.2.0/bits/stl_iterator.h" 3
     
      back_insert_iterator&
      operator=(const typename _Container::value_type& __value)
      {
 container->push_back(__value);
 return *this;
      }

     
      back_insert_iterator&
      operator=(typename _Container::value_type&& __value)
      {
 container->push_back(std::move(__value));
 return *this;
      }



     
      back_insert_iterator&
      operator*()
      { return *this; }


     
      back_insert_iterator&
      operator++()
      { return *this; }


     
      back_insert_iterator
      operator++(int)
      { return *this; }
    };
# 657 "/usr/include/c++/10.2.0/bits/stl_iterator.h" 3
  template<typename _Container>
   
    inline back_insert_iterator<_Container>
    back_inserter(_Container& __x)
    { return back_insert_iterator<_Container>(__x); }
# 673 "/usr/include/c++/10.2.0/bits/stl_iterator.h" 3
  template<typename _Container>
    class front_insert_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    protected:
      _Container* container;

    public:

      typedef _Container container_type;







      explicit
      front_insert_iterator(_Container& __x)
      : container(std::__addressof(__x)) { }
# 713 "/usr/include/c++/10.2.0/bits/stl_iterator.h" 3
     
      front_insert_iterator&
      operator=(const typename _Container::value_type& __value)
      {
 container->push_front(__value);
 return *this;
      }

     
      front_insert_iterator&
      operator=(typename _Container::value_type&& __value)
      {
 container->push_front(std::move(__value));
 return *this;
      }



     
      front_insert_iterator&
      operator*()
      { return *this; }


     
      front_insert_iterator&
      operator++()
      { return *this; }


     
      front_insert_iterator
      operator++(int)
      { return *this; }
    };
# 760 "/usr/include/c++/10.2.0/bits/stl_iterator.h" 3
  template<typename _Container>
   
    inline front_insert_iterator<_Container>
    front_inserter(_Container& __x)
    { return front_insert_iterator<_Container>(__x); }
# 780 "/usr/include/c++/10.2.0/bits/stl_iterator.h" 3
  template<typename _Container>
    class insert_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {







      typedef typename _Container::iterator _Iter;

    protected:
      _Container* container;
      _Iter iter;


    public:

      typedef _Container container_type;
# 812 "/usr/include/c++/10.2.0/bits/stl_iterator.h" 3
     
      insert_iterator(_Container& __x, _Iter __i)
      : container(std::__addressof(__x)), iter(__i) {}
# 848 "/usr/include/c++/10.2.0/bits/stl_iterator.h" 3
     
      insert_iterator&
      operator=(const typename _Container::value_type& __value)
      {
 iter = container->insert(iter, __value);
 ++iter;
 return *this;
      }

     
      insert_iterator&
      operator=(typename _Container::value_type&& __value)
      {
 iter = container->insert(iter, std::move(__value));
 ++iter;
 return *this;
      }



     
      insert_iterator&
      operator*()
      { return *this; }


     
      insert_iterator&
      operator++()
      { return *this; }


     
      insert_iterator&
      operator++(int)
      { return *this; }
    };
# 904 "/usr/include/c++/10.2.0/bits/stl_iterator.h" 3
  template<typename _Container, typename _Iterator>
    inline insert_iterator<_Container>
    inserter(_Container& __x, _Iterator __i)
    {
      return insert_iterator<_Container>(__x,
      typename _Container::iterator(__i));
    }





}

namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{

# 929 "/usr/include/c++/10.2.0/bits/stl_iterator.h" 3
  template<typename _Iterator, typename _Container>
    class __normal_iterator
    {
    protected:
      _Iterator _M_current;

      typedef std::iterator_traits<_Iterator> __traits_type;

    public:
      typedef _Iterator iterator_type;
      typedef typename __traits_type::iterator_category iterator_category;
      typedef typename __traits_type::value_type value_type;
      typedef typename __traits_type::difference_type difference_type;
      typedef typename __traits_type::reference reference;
      typedef typename __traits_type::pointer pointer;





      constexpr __normal_iterator() noexcept
      : _M_current(_Iterator()) { }

      explicit
      __normal_iterator(const _Iterator& __i) noexcept
      : _M_current(__i) { }


      template<typename _Iter>
       
        __normal_iterator(const __normal_iterator<_Iter,
     typename __enable_if<
              (std::__are_same<_Iter, typename _Container::pointer>::__value),
        _Container>::__type>& __i) noexcept
        : _M_current(__i.base()) { }


     
      reference
      operator*() const noexcept
      { return *_M_current; }

     
      pointer
      operator->() const noexcept
      { return _M_current; }

     
      __normal_iterator&
      operator++() noexcept
      {
 ++_M_current;
 return *this;
      }

     
      __normal_iterator
      operator++(int) noexcept
      { return __normal_iterator(_M_current++); }


     
      __normal_iterator&
      operator--() noexcept
      {
 --_M_current;
 return *this;
      }

     
      __normal_iterator
      operator--(int) noexcept
      { return __normal_iterator(_M_current--); }


     
      reference
      operator[](difference_type __n) const noexcept
      { return _M_current[__n]; }

     
      __normal_iterator&
      operator+=(difference_type __n) noexcept
      { _M_current += __n; return *this; }

     
      __normal_iterator
      operator+(difference_type __n) const noexcept
      { return __normal_iterator(_M_current + __n); }

     
      __normal_iterator&
      operator-=(difference_type __n) noexcept
      { _M_current -= __n; return *this; }

     
      __normal_iterator
      operator-(difference_type __n) const noexcept
      { return __normal_iterator(_M_current - __n); }

     
      const _Iterator&
      base() const noexcept
      { return _M_current; }
    };
# 1061 "/usr/include/c++/10.2.0/bits/stl_iterator.h" 3
  template<typename _IteratorL, typename _IteratorR, typename _Container>
   
    inline bool
    operator==(const __normal_iterator<_IteratorL, _Container>& __lhs,
        const __normal_iterator<_IteratorR, _Container>& __rhs)
    noexcept
    { return __lhs.base() == __rhs.base(); }

  template<typename _Iterator, typename _Container>
   
    inline bool
    operator==(const __normal_iterator<_Iterator, _Container>& __lhs,
        const __normal_iterator<_Iterator, _Container>& __rhs)
    noexcept
    { return __lhs.base() == __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
   
    inline bool
    operator!=(const __normal_iterator<_IteratorL, _Container>& __lhs,
        const __normal_iterator<_IteratorR, _Container>& __rhs)
    noexcept
    { return __lhs.base() != __rhs.base(); }

  template<typename _Iterator, typename _Container>
   
    inline bool
    operator!=(const __normal_iterator<_Iterator, _Container>& __lhs,
        const __normal_iterator<_Iterator, _Container>& __rhs)
    noexcept
    { return __lhs.base() != __rhs.base(); }


  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator<(const __normal_iterator<_IteratorL, _Container>& __lhs,
       const __normal_iterator<_IteratorR, _Container>& __rhs)
    noexcept
    { return __lhs.base() < __rhs.base(); }

  template<typename _Iterator, typename _Container>
   
    inline bool
    operator<(const __normal_iterator<_Iterator, _Container>& __lhs,
       const __normal_iterator<_Iterator, _Container>& __rhs)
    noexcept
    { return __lhs.base() < __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator>(const __normal_iterator<_IteratorL, _Container>& __lhs,
       const __normal_iterator<_IteratorR, _Container>& __rhs)
    noexcept
    { return __lhs.base() > __rhs.base(); }

  template<typename _Iterator, typename _Container>
   
    inline bool
    operator>(const __normal_iterator<_Iterator, _Container>& __lhs,
       const __normal_iterator<_Iterator, _Container>& __rhs)
    noexcept
    { return __lhs.base() > __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator<=(const __normal_iterator<_IteratorL, _Container>& __lhs,
        const __normal_iterator<_IteratorR, _Container>& __rhs)
    noexcept
    { return __lhs.base() <= __rhs.base(); }

  template<typename _Iterator, typename _Container>
   
    inline bool
    operator<=(const __normal_iterator<_Iterator, _Container>& __lhs,
        const __normal_iterator<_Iterator, _Container>& __rhs)
    noexcept
    { return __lhs.base() <= __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator>=(const __normal_iterator<_IteratorL, _Container>& __lhs,
        const __normal_iterator<_IteratorR, _Container>& __rhs)
    noexcept
    { return __lhs.base() >= __rhs.base(); }

  template<typename _Iterator, typename _Container>
   
    inline bool
    operator>=(const __normal_iterator<_Iterator, _Container>& __lhs,
        const __normal_iterator<_Iterator, _Container>& __rhs)
    noexcept
    { return __lhs.base() >= __rhs.base(); }






  template<typename _IteratorL, typename _IteratorR, typename _Container>


   
    inline auto
    operator-(const __normal_iterator<_IteratorL, _Container>& __lhs,
       const __normal_iterator<_IteratorR, _Container>& __rhs) noexcept
    -> decltype(__lhs.base() - __rhs.base())





    { return __lhs.base() - __rhs.base(); }

  template<typename _Iterator, typename _Container>
   
    inline typename __normal_iterator<_Iterator, _Container>::difference_type
    operator-(const __normal_iterator<_Iterator, _Container>& __lhs,
       const __normal_iterator<_Iterator, _Container>& __rhs)
    noexcept
    { return __lhs.base() - __rhs.base(); }

  template<typename _Iterator, typename _Container>
   
    inline __normal_iterator<_Iterator, _Container>
    operator+(typename __normal_iterator<_Iterator, _Container>::difference_type
       __n, const __normal_iterator<_Iterator, _Container>& __i)
    noexcept
    { return __normal_iterator<_Iterator, _Container>(__i.base() + __n); }


}

namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _Iterator, typename _Container>
   
    _Iterator
    __niter_base(__gnu_cxx::__normal_iterator<_Iterator, _Container> __it)
    noexcept(std::is_nothrow_copy_constructible<_Iterator>::value)
    { return __it.base(); }
# 1260 "/usr/include/c++/10.2.0/bits/stl_iterator.h" 3
  template<typename _Iterator>
    class move_iterator
    {
      _Iterator _M_current;

      using __traits_type = iterator_traits<_Iterator>;



      using __base_ref = typename __traits_type::reference;


    public:
      using iterator_type = _Iterator;
# 1284 "/usr/include/c++/10.2.0/bits/stl_iterator.h" 3
      typedef typename __traits_type::iterator_category iterator_category;
      typedef typename __traits_type::value_type value_type;
      typedef typename __traits_type::difference_type difference_type;

      typedef _Iterator pointer;


      typedef typename conditional<is_reference<__base_ref>::value,
    typename remove_reference<__base_ref>::type&&,
    __base_ref>::type reference;


     
      move_iterator()
      : _M_current() { }

      explicit
      move_iterator(iterator_type __i)
      : _M_current(std::move(__i)) { }

      template<typename _Iter>

 move_iterator(const move_iterator<_Iter>& __i)
 : _M_current(__i.base()) { }


      iterator_type
      base() const
      { return _M_current; }
# 1326 "/usr/include/c++/10.2.0/bits/stl_iterator.h" 3
      reference
      operator*() const
      { return static_cast<reference>(*_M_current); }

      pointer
      operator->() const
      { return _M_current; }

      move_iterator&
      operator++()
      {
 ++_M_current;
 return *this;
      }

      move_iterator
      operator++(int)
      {
 move_iterator __tmp = *this;
 ++_M_current;
 return __tmp;
      }







      move_iterator&
      operator--()
      {
 --_M_current;
 return *this;
      }

      move_iterator
      operator--(int)
      {
 move_iterator __tmp = *this;
 --_M_current;
 return __tmp;
      }

      move_iterator
      operator+(difference_type __n) const
      { return move_iterator(_M_current + __n); }

      move_iterator&
      operator+=(difference_type __n)
      {
 _M_current += __n;
 return *this;
      }

      move_iterator
      operator-(difference_type __n) const
      { return move_iterator(_M_current - __n); }

      move_iterator&
      operator-=(difference_type __n)
      {
 _M_current -= __n;
 return *this;
      }

      reference
      operator[](difference_type __n) const
      { return std::move(_M_current[__n]); }
# 1423 "/usr/include/c++/10.2.0/bits/stl_iterator.h" 3
    };

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator==(const move_iterator<_IteratorL>& __x,
        const move_iterator<_IteratorR>& __y)



    { return __x.base() == __y.base(); }
# 1442 "/usr/include/c++/10.2.0/bits/stl_iterator.h" 3
  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator!=(const move_iterator<_IteratorL>& __x,
        const move_iterator<_IteratorR>& __y)
    { return !(__x == __y); }


  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator<(const move_iterator<_IteratorL>& __x,
       const move_iterator<_IteratorR>& __y)



    { return __x.base() < __y.base(); }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator<=(const move_iterator<_IteratorL>& __x,
        const move_iterator<_IteratorR>& __y)



    { return !(__y < __x); }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator>(const move_iterator<_IteratorL>& __x,
       const move_iterator<_IteratorR>& __y)



    { return __y < __x; }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator>=(const move_iterator<_IteratorL>& __x,
        const move_iterator<_IteratorR>& __y)



    { return !(__x < __y); }
# 1493 "/usr/include/c++/10.2.0/bits/stl_iterator.h" 3
  template<typename _Iterator>
    inline bool
    operator==(const move_iterator<_Iterator>& __x,
        const move_iterator<_Iterator>& __y)
    { return __x.base() == __y.base(); }

  template<typename _Iterator>
    inline bool
    operator!=(const move_iterator<_Iterator>& __x,
        const move_iterator<_Iterator>& __y)
    { return !(__x == __y); }

  template<typename _Iterator>
    inline bool
    operator<(const move_iterator<_Iterator>& __x,
       const move_iterator<_Iterator>& __y)
    { return __x.base() < __y.base(); }

  template<typename _Iterator>
    inline bool
    operator<=(const move_iterator<_Iterator>& __x,
        const move_iterator<_Iterator>& __y)
    { return !(__y < __x); }

  template<typename _Iterator>
    inline bool
    operator>(const move_iterator<_Iterator>& __x,
       const move_iterator<_Iterator>& __y)
    { return __y < __x; }

  template<typename _Iterator>
    inline bool
    operator>=(const move_iterator<_Iterator>& __x,
        const move_iterator<_Iterator>& __y)
    { return !(__x < __y); }



  template<typename _IteratorL, typename _IteratorR>
    inline auto
    operator-(const move_iterator<_IteratorL>& __x,
       const move_iterator<_IteratorR>& __y)
    -> decltype(__x.base() - __y.base())
    { return __x.base() - __y.base(); }

  template<typename _Iterator>
    inline move_iterator<_Iterator>
    operator+(typename move_iterator<_Iterator>::difference_type __n,
       const move_iterator<_Iterator>& __x)
    { return __x + __n; }

  template<typename _Iterator>
    inline move_iterator<_Iterator>
    make_move_iterator(_Iterator __i)
    { return move_iterator<_Iterator>(std::move(__i)); }

  template<typename _Iterator, typename _ReturnType
    = typename conditional<__move_if_noexcept_cond
      <typename iterator_traits<_Iterator>::value_type>::value,
                _Iterator, move_iterator<_Iterator>>::type>
    inline _ReturnType
    __make_move_if_noexcept_iterator(_Iterator __i)
    { return _ReturnType(__i); }



  template<typename _Tp, typename _ReturnType
    = typename conditional<__move_if_noexcept_cond<_Tp>::value,
      const _Tp*, move_iterator<_Tp*>>::type>
    inline _ReturnType
    __make_move_if_noexcept_iterator(_Tp* __i)
    { return _ReturnType(__i); }
# 2154 "/usr/include/c++/10.2.0/bits/stl_iterator.h" 3
  template<typename _Iterator>
    auto
    __niter_base(move_iterator<_Iterator> __it)
    -> decltype(make_move_iterator(__niter_base(__it.base())))
    { return make_move_iterator(__niter_base(__it.base())); }

  template<typename _Iterator>
    struct __is_move_iterator<move_iterator<_Iterator> >
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<typename _Iterator>
    auto
    __miter_base(move_iterator<_Iterator> __it)
    -> decltype(__miter_base(__it.base()))
    { return __miter_base(__it.base()); }
# 2201 "/usr/include/c++/10.2.0/bits/stl_iterator.h" 3

}
# 68 "/usr/include/c++/10.2.0/bits/stl_algobase.h" 2 3

# 1 "/usr/include/c++/10.2.0/debug/debug.h" 1 3
# 48 "/usr/include/c++/10.2.0/debug/debug.h" 3
namespace std
{
  namespace __debug { }
}




namespace __gnu_debug
{
  using namespace std::__debug;

  template<typename _Ite, typename _Seq, typename _Cat>
    struct _Safe_iterator;
}
# 70 "/usr/include/c++/10.2.0/bits/stl_algobase.h" 2 3

# 1 "/usr/include/c++/10.2.0/bits/predefined_ops.h" 1 3
# 33 "/usr/include/c++/10.2.0/bits/predefined_ops.h" 3
namespace __gnu_cxx
{
namespace __ops
{
  struct _Iter_less_iter
  {
    template<typename _Iterator1, typename _Iterator2>
     
      bool
      operator()(_Iterator1 __it1, _Iterator2 __it2) const
      { return *__it1 < *__it2; }
  };

 
  inline _Iter_less_iter
  __iter_less_iter()
  { return _Iter_less_iter(); }

  struct _Iter_less_val
  {

    constexpr _Iter_less_val() = default;




   
    explicit
    _Iter_less_val(_Iter_less_iter) { }

    template<typename _Iterator, typename _Value>
     
      bool
      operator()(_Iterator __it, _Value& __val) const
      { return *__it < __val; }
  };

 
  inline _Iter_less_val
  __iter_less_val()
  { return _Iter_less_val(); }

 
  inline _Iter_less_val
  __iter_comp_val(_Iter_less_iter)
  { return _Iter_less_val(); }

  struct _Val_less_iter
  {

    constexpr _Val_less_iter() = default;




   
    explicit
    _Val_less_iter(_Iter_less_iter) { }

    template<typename _Value, typename _Iterator>
     
      bool
      operator()(_Value& __val, _Iterator __it) const
      { return __val < *__it; }
  };

 
  inline _Val_less_iter
  __val_less_iter()
  { return _Val_less_iter(); }

 
  inline _Val_less_iter
  __val_comp_iter(_Iter_less_iter)
  { return _Val_less_iter(); }

  struct _Iter_equal_to_iter
  {
    template<typename _Iterator1, typename _Iterator2>
     
      bool
      operator()(_Iterator1 __it1, _Iterator2 __it2) const
      { return *__it1 == *__it2; }
  };

 
  inline _Iter_equal_to_iter
  __iter_equal_to_iter()
  { return _Iter_equal_to_iter(); }

  struct _Iter_equal_to_val
  {
    template<typename _Iterator, typename _Value>
     
      bool
      operator()(_Iterator __it, _Value& __val) const
      { return *__it == __val; }
  };

 
  inline _Iter_equal_to_val
  __iter_equal_to_val()
  { return _Iter_equal_to_val(); }

 
  inline _Iter_equal_to_val
  __iter_comp_val(_Iter_equal_to_iter)
  { return _Iter_equal_to_val(); }

  template<typename _Compare>
    struct _Iter_comp_iter
    {
      _Compare _M_comp;

      explicit
      _Iter_comp_iter(_Compare __comp)
 : _M_comp(std::move(__comp))
      { }

      template<typename _Iterator1, typename _Iterator2>
       
        bool
        operator()(_Iterator1 __it1, _Iterator2 __it2)
        { return bool(_M_comp(*__it1, *__it2)); }
    };

  template<typename _Compare>
   
    inline _Iter_comp_iter<_Compare>
    __iter_comp_iter(_Compare __comp)
    { return _Iter_comp_iter<_Compare>(std::move(__comp)); }

  template<typename _Compare>
    struct _Iter_comp_val
    {
      _Compare _M_comp;

     
      explicit
      _Iter_comp_val(_Compare __comp)
 : _M_comp(std::move(__comp))
      { }

     
      explicit
      _Iter_comp_val(const _Iter_comp_iter<_Compare>& __comp)
 : _M_comp(__comp._M_comp)
      { }


     
      explicit
      _Iter_comp_val(_Iter_comp_iter<_Compare>&& __comp)
 : _M_comp(std::move(__comp._M_comp))
      { }


      template<typename _Iterator, typename _Value>

 bool
 operator()(_Iterator __it, _Value& __val)
 { return bool(_M_comp(*__it, __val)); }
    };

  template<typename _Compare>
   
    inline _Iter_comp_val<_Compare>
    __iter_comp_val(_Compare __comp)
    { return _Iter_comp_val<_Compare>(std::move(__comp)); }

  template<typename _Compare>
   
    inline _Iter_comp_val<_Compare>
    __iter_comp_val(_Iter_comp_iter<_Compare> __comp)
    { return _Iter_comp_val<_Compare>(std::move(__comp)); }

  template<typename _Compare>
    struct _Val_comp_iter
    {
      _Compare _M_comp;

     
      explicit
      _Val_comp_iter(_Compare __comp)
 : _M_comp(std::move(__comp))
      { }

     
      explicit
      _Val_comp_iter(const _Iter_comp_iter<_Compare>& __comp)
 : _M_comp(__comp._M_comp)
      { }


     
      explicit
      _Val_comp_iter(_Iter_comp_iter<_Compare>&& __comp)
 : _M_comp(std::move(__comp._M_comp))
      { }


      template<typename _Value, typename _Iterator>

 bool
 operator()(_Value& __val, _Iterator __it)
 { return bool(_M_comp(__val, *__it)); }
    };

  template<typename _Compare>
   
    inline _Val_comp_iter<_Compare>
    __val_comp_iter(_Compare __comp)
    { return _Val_comp_iter<_Compare>(std::move(__comp)); }

  template<typename _Compare>
   
    inline _Val_comp_iter<_Compare>
    __val_comp_iter(_Iter_comp_iter<_Compare> __comp)
    { return _Val_comp_iter<_Compare>(std::move(__comp)); }

  template<typename _Value>
    struct _Iter_equals_val
    {
      _Value& _M_value;

     
      explicit
      _Iter_equals_val(_Value& __value)
 : _M_value(__value)
      { }

      template<typename _Iterator>

 bool
 operator()(_Iterator __it)
 { return *__it == _M_value; }
    };

  template<typename _Value>
   
    inline _Iter_equals_val<_Value>
    __iter_equals_val(_Value& __val)
    { return _Iter_equals_val<_Value>(__val); }

  template<typename _Iterator1>
    struct _Iter_equals_iter
    {
      _Iterator1 _M_it1;

     
      explicit
      _Iter_equals_iter(_Iterator1 __it1)
 : _M_it1(__it1)
      { }

      template<typename _Iterator2>

 bool
 operator()(_Iterator2 __it2)
 { return *__it2 == *_M_it1; }
    };

  template<typename _Iterator>
   
    inline _Iter_equals_iter<_Iterator>
    __iter_comp_iter(_Iter_equal_to_iter, _Iterator __it)
    { return _Iter_equals_iter<_Iterator>(__it); }

  template<typename _Predicate>
    struct _Iter_pred
    {
      _Predicate _M_pred;

     
      explicit
      _Iter_pred(_Predicate __pred)
 : _M_pred(std::move(__pred))
      { }

      template<typename _Iterator>

 bool
 operator()(_Iterator __it)
 { return bool(_M_pred(*__it)); }
    };

  template<typename _Predicate>
   
    inline _Iter_pred<_Predicate>
    __pred_iter(_Predicate __pred)
    { return _Iter_pred<_Predicate>(std::move(__pred)); }

  template<typename _Compare, typename _Value>
    struct _Iter_comp_to_val
    {
      _Compare _M_comp;
      _Value& _M_value;

     
      _Iter_comp_to_val(_Compare __comp, _Value& __value)
 : _M_comp(std::move(__comp)), _M_value(__value)
      { }

      template<typename _Iterator>

 bool
 operator()(_Iterator __it)
 { return bool(_M_comp(*__it, _M_value)); }
    };

  template<typename _Compare, typename _Value>
    _Iter_comp_to_val<_Compare, _Value>
   
    __iter_comp_val(_Compare __comp, _Value &__val)
    {
      return _Iter_comp_to_val<_Compare, _Value>(std::move(__comp), __val);
    }

  template<typename _Compare, typename _Iterator1>
    struct _Iter_comp_to_iter
    {
      _Compare _M_comp;
      _Iterator1 _M_it1;

     
      _Iter_comp_to_iter(_Compare __comp, _Iterator1 __it1)
 : _M_comp(std::move(__comp)), _M_it1(__it1)
      { }

      template<typename _Iterator2>

 bool
 operator()(_Iterator2 __it2)
 { return bool(_M_comp(*__it2, *_M_it1)); }
    };

  template<typename _Compare, typename _Iterator>
   
    inline _Iter_comp_to_iter<_Compare, _Iterator>
    __iter_comp_iter(_Iter_comp_iter<_Compare> __comp, _Iterator __it)
    {
      return _Iter_comp_to_iter<_Compare, _Iterator>(
   std::move(__comp._M_comp), __it);
    }

  template<typename _Predicate>
    struct _Iter_negate
    {
      _Predicate _M_pred;

     
      explicit
      _Iter_negate(_Predicate __pred)
 : _M_pred(std::move(__pred))
      { }

      template<typename _Iterator>

 bool
 operator()(_Iterator __it)
 { return !bool(_M_pred(*__it)); }
    };

  template<typename _Predicate>
   
    inline _Iter_negate<_Predicate>
    __negate(_Iter_pred<_Predicate> __pred)
    { return _Iter_negate<_Predicate>(std::move(__pred._M_pred)); }

}
}
# 72 "/usr/include/c++/10.2.0/bits/stl_algobase.h" 2 3







namespace std __attribute__ ((__visibility__ ("default")))
{






  template<typename _Tp, typename _Up>
   
    inline int
    __memcmp(const _Tp* __first1, const _Up* __first2, size_t __num)
    {

      static_assert(sizeof(_Tp) == sizeof(_Up), "can be compared with memcmp");
# 105 "/usr/include/c++/10.2.0/bits/stl_algobase.h" 3
 return __builtin_memcmp(__first1, __first2, sizeof(_Tp) * __num);
    }
# 149 "/usr/include/c++/10.2.0/bits/stl_algobase.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2>
   
    inline void
    iter_swap(_ForwardIterator1 __a, _ForwardIterator2 __b)
    {

     

     
# 182 "/usr/include/c++/10.2.0/bits/stl_algobase.h" 3
      swap(*__a, *__b);

    }
# 198 "/usr/include/c++/10.2.0/bits/stl_algobase.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2>
   
    _ForwardIterator2
    swap_ranges(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
  _ForwardIterator2 __first2)
    {

     

     

      ;

      for (; __first1 != __last1; ++__first1, (void)++__first2)
 std::iter_swap(__first1, __first2);
      return __first2;
    }
# 227 "/usr/include/c++/10.2.0/bits/stl_algobase.h" 3
  template<typename _Tp>
   
    inline const _Tp&
    min(const _Tp& __a, const _Tp& __b)
    {

     

      if (__b < __a)
 return __b;
      return __a;
    }
# 251 "/usr/include/c++/10.2.0/bits/stl_algobase.h" 3
  template<typename _Tp>
   
    inline const _Tp&
    max(const _Tp& __a, const _Tp& __b)
    {

     

      if (__a < __b)
 return __b;
      return __a;
    }
# 275 "/usr/include/c++/10.2.0/bits/stl_algobase.h" 3
  template<typename _Tp, typename _Compare>
   
    inline const _Tp&
    min(const _Tp& __a, const _Tp& __b, _Compare __comp)
    {

      if (__comp(__b, __a))
 return __b;
      return __a;
    }
# 297 "/usr/include/c++/10.2.0/bits/stl_algobase.h" 3
  template<typename _Tp, typename _Compare>
   
    inline const _Tp&
    max(const _Tp& __a, const _Tp& __b, _Compare __comp)
    {

      if (__comp(__a, __b))
 return __b;
      return __a;
    }



  template<typename _Iterator>
   
    inline _Iterator
    __niter_base(_Iterator __it)
    noexcept(std::is_nothrow_copy_constructible<_Iterator>::value)
    { return __it; }




  template<typename _From, typename _To>
   
    inline _From
    __niter_wrap(_From __from, _To __res)
    { return __from + (__res - std::__niter_base(__from)); }


  template<typename _Iterator>
   
    inline _Iterator
    __niter_wrap(const _Iterator&, _Iterator __res)
    { return __res; }







  template<bool _IsMove, bool _IsSimple, typename _Category>
    struct __copy_move
    {
      template<typename _II, typename _OI>

 static _OI
 __copy_m(_II __first, _II __last, _OI __result)
 {
   for (; __first != __last; ++__result, (void)++__first)
     *__result = *__first;
   return __result;
 }
    };


  template<typename _Category>
    struct __copy_move<true, false, _Category>
    {
      template<typename _II, typename _OI>

 static _OI
 __copy_m(_II __first, _II __last, _OI __result)
 {
   for (; __first != __last; ++__result, (void)++__first)
     *__result = std::move(*__first);
   return __result;
 }
    };


  template<>
    struct __copy_move<false, false, random_access_iterator_tag>
    {
      template<typename _II, typename _OI>

 static _OI
 __copy_m(_II __first, _II __last, _OI __result)
 {
   typedef typename iterator_traits<_II>::difference_type _Distance;
   for(_Distance __n = __last - __first; __n > 0; --__n)
     {
       *__result = *__first;
       ++__first;
       ++__result;
     }
   return __result;
 }
    };


  template<>
    struct __copy_move<true, false, random_access_iterator_tag>
    {
      template<typename _II, typename _OI>

 static _OI
 __copy_m(_II __first, _II __last, _OI __result)
 {
   typedef typename iterator_traits<_II>::difference_type _Distance;
   for(_Distance __n = __last - __first; __n > 0; --__n)
     {
       *__result = std::move(*__first);
       ++__first;
       ++__result;
     }
   return __result;
 }
    };


  template<bool _IsMove>
    struct __copy_move<_IsMove, true, random_access_iterator_tag>
    {
      template<typename _Tp>

 static _Tp*
 __copy_m(const _Tp* __first, const _Tp* __last, _Tp* __result)
 {

   using __assignable = conditional<_IsMove,
        is_move_assignable<_Tp>,
        is_copy_assignable<_Tp>>;

   static_assert( __assignable::type::value, "type is not assignable" );

   const ptrdiff_t _Num = __last - __first;
   if (_Num)
     __builtin_memmove(__result, __first, sizeof(_Tp) * _Num);
   return __result + _Num;
 }
    };



  template<typename _CharT>
    struct char_traits;

  template<typename _CharT, typename _Traits>
    class istreambuf_iterator;

  template<typename _CharT, typename _Traits>
    class ostreambuf_iterator;

  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
      ostreambuf_iterator<_CharT, char_traits<_CharT> > >::__type
    __copy_move_a2(_CharT*, _CharT*,
     ostreambuf_iterator<_CharT, char_traits<_CharT> >);

  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
      ostreambuf_iterator<_CharT, char_traits<_CharT> > >::__type
    __copy_move_a2(const _CharT*, const _CharT*,
     ostreambuf_iterator<_CharT, char_traits<_CharT> >);

  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
        _CharT*>::__type
    __copy_move_a2(istreambuf_iterator<_CharT, char_traits<_CharT> >,
     istreambuf_iterator<_CharT, char_traits<_CharT> >, _CharT*);

  template<bool _IsMove, typename _II, typename _OI>
   
    inline _OI
    __copy_move_a2(_II __first, _II __last, _OI __result)
    {
      typedef typename iterator_traits<_II>::iterator_category _Category;





      return std::__copy_move<_IsMove, __memcpyable<_OI, _II>::__value,
         _Category>::__copy_m(__first, __last, __result);
    }



  template<typename _Tp, typename _Ref, typename _Ptr>
    struct _Deque_iterator;



  template<bool _IsMove,
    typename _Tp, typename _Ref, typename _Ptr, typename _OI>
    _OI
    __copy_move_a1(std::_Deque_iterator<_Tp, _Ref, _Ptr>,
     std::_Deque_iterator<_Tp, _Ref, _Ptr>,
     _OI);

  template<bool _IsMove,
    typename _ITp, typename _IRef, typename _IPtr, typename _OTp>
    std::_Deque_iterator<_OTp, _OTp&, _OTp*>
    __copy_move_a1(std::_Deque_iterator<_ITp, _IRef, _IPtr>,
     std::_Deque_iterator<_ITp, _IRef, _IPtr>,
     std::_Deque_iterator<_OTp, _OTp&, _OTp*>);

  template<bool _IsMove, typename _II, typename _Tp>
    typename __gnu_cxx::__enable_if<
      __is_random_access_iter<_II>::__value,
      std::_Deque_iterator<_Tp, _Tp&, _Tp*> >::__type
    __copy_move_a1(_II, _II, std::_Deque_iterator<_Tp, _Tp&, _Tp*>);

  template<bool _IsMove, typename _II, typename _OI>
   
    inline _OI
    __copy_move_a1(_II __first, _II __last, _OI __result)
    { return std::__copy_move_a2<_IsMove>(__first, __last, __result); }

  template<bool _IsMove, typename _II, typename _OI>
   
    inline _OI
    __copy_move_a(_II __first, _II __last, _OI __result)
    {
      return std::__niter_wrap(__result,
  std::__copy_move_a1<_IsMove>(std::__niter_base(__first),
          std::__niter_base(__last),
          std::__niter_base(__result)));
    }

  template<bool _IsMove,
    typename _Ite, typename _Seq, typename _Cat, typename _OI>
    _OI
    __copy_move_a(const ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat>&,
    const ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat>&,
    _OI);

  template<bool _IsMove,
    typename _II, typename _Ite, typename _Seq, typename _Cat>
    __gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat>
    __copy_move_a(_II, _II,
    const ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat>&);

  template<bool _IsMove,
    typename _IIte, typename _ISeq, typename _ICat,
    typename _OIte, typename _OSeq, typename _OCat>
    ::__gnu_debug::_Safe_iterator<_OIte, _OSeq, _OCat>
    __copy_move_a(const ::__gnu_debug::_Safe_iterator<_IIte, _ISeq, _ICat>&,
    const ::__gnu_debug::_Safe_iterator<_IIte, _ISeq, _ICat>&,
    const ::__gnu_debug::_Safe_iterator<_OIte, _OSeq, _OCat>&);
# 557 "/usr/include/c++/10.2.0/bits/stl_algobase.h" 3
  template<typename _II, typename _OI>
   
    inline _OI
    copy(_II __first, _II __last, _OI __result)
    {

     
     

      ;

      return std::__copy_move_a<__is_move_iterator<_II>::__value>
      (std::__miter_base(__first), std::__miter_base(__last), __result);
    }
# 590 "/usr/include/c++/10.2.0/bits/stl_algobase.h" 3
  template<typename _II, typename _OI>
   
    inline _OI
    move(_II __first, _II __last, _OI __result)
    {

     
     

      ;

      return std::__copy_move_a<true>(std::__miter_base(__first),
          std::__miter_base(__last), __result);
    }






  template<bool _IsMove, bool _IsSimple, typename _Category>
    struct __copy_move_backward
    {
      template<typename _BI1, typename _BI2>

 static _BI2
 __copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)
 {
   while (__first != __last)
     *--__result = *--__last;
   return __result;
 }
    };


  template<typename _Category>
    struct __copy_move_backward<true, false, _Category>
    {
      template<typename _BI1, typename _BI2>

 static _BI2
 __copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)
 {
   while (__first != __last)
     *--__result = std::move(*--__last);
   return __result;
 }
    };


  template<>
    struct __copy_move_backward<false, false, random_access_iterator_tag>
    {
      template<typename _BI1, typename _BI2>

 static _BI2
 __copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)
 {
   typename iterator_traits<_BI1>::difference_type
     __n = __last - __first;
   for (; __n > 0; --__n)
     *--__result = *--__last;
   return __result;
 }
    };


  template<>
    struct __copy_move_backward<true, false, random_access_iterator_tag>
    {
      template<typename _BI1, typename _BI2>

 static _BI2
 __copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)
 {
   typename iterator_traits<_BI1>::difference_type
     __n = __last - __first;
   for (; __n > 0; --__n)
     *--__result = std::move(*--__last);
   return __result;
 }
    };


  template<bool _IsMove>
    struct __copy_move_backward<_IsMove, true, random_access_iterator_tag>
    {
      template<typename _Tp>

 static _Tp*
 __copy_move_b(const _Tp* __first, const _Tp* __last, _Tp* __result)
 {

   using __assignable = conditional<_IsMove,
        is_move_assignable<_Tp>,
        is_copy_assignable<_Tp>>;

   static_assert( __assignable::type::value, "type is not assignable" );

   const ptrdiff_t _Num = __last - __first;
   if (_Num)
     __builtin_memmove(__result - _Num, __first, sizeof(_Tp) * _Num);
   return __result - _Num;
 }
    };

  template<bool _IsMove, typename _BI1, typename _BI2>
   
    inline _BI2
    __copy_move_backward_a2(_BI1 __first, _BI1 __last, _BI2 __result)
    {
      typedef typename iterator_traits<_BI1>::iterator_category _Category;





      return std::__copy_move_backward<_IsMove,
           __memcpyable<_BI2, _BI1>::__value,
           _Category>::__copy_move_b(__first,
         __last,
         __result);
    }

  template<bool _IsMove, typename _BI1, typename _BI2>
   
    inline _BI2
    __copy_move_backward_a1(_BI1 __first, _BI1 __last, _BI2 __result)
    { return std::__copy_move_backward_a2<_IsMove>(__first, __last, __result); }

  template<bool _IsMove,
    typename _Tp, typename _Ref, typename _Ptr, typename _OI>
    _OI
    __copy_move_backward_a1(std::_Deque_iterator<_Tp, _Ref, _Ptr>,
       std::_Deque_iterator<_Tp, _Ref, _Ptr>,
       _OI);

  template<bool _IsMove,
    typename _ITp, typename _IRef, typename _IPtr, typename _OTp>
    std::_Deque_iterator<_OTp, _OTp&, _OTp*>
    __copy_move_backward_a1(
   std::_Deque_iterator<_ITp, _IRef, _IPtr>,
   std::_Deque_iterator<_ITp, _IRef, _IPtr>,
   std::_Deque_iterator<_OTp, _OTp&, _OTp*>);

  template<bool _IsMove, typename _II, typename _Tp>
    typename __gnu_cxx::__enable_if<
      __is_random_access_iter<_II>::__value,
      std::_Deque_iterator<_Tp, _Tp&, _Tp*> >::__type
    __copy_move_backward_a1(_II, _II,
       std::_Deque_iterator<_Tp, _Tp&, _Tp*>);

  template<bool _IsMove, typename _II, typename _OI>
   
    inline _OI
    __copy_move_backward_a(_II __first, _II __last, _OI __result)
    {
      return std::__niter_wrap(__result,
  std::__copy_move_backward_a1<_IsMove>
    (std::__niter_base(__first), std::__niter_base(__last),
     std::__niter_base(__result)));
    }

  template<bool _IsMove,
    typename _Ite, typename _Seq, typename _Cat, typename _OI>
    _OI
    __copy_move_backward_a(
  const ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat>&,
  const ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat>&,
  _OI);

  template<bool _IsMove,
    typename _II, typename _Ite, typename _Seq, typename _Cat>
    __gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat>
    __copy_move_backward_a(_II, _II,
  const ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat>&);

  template<bool _IsMove,
    typename _IIte, typename _ISeq, typename _ICat,
    typename _OIte, typename _OSeq, typename _OCat>
    ::__gnu_debug::_Safe_iterator<_OIte, _OSeq, _OCat>
    __copy_move_backward_a(
  const ::__gnu_debug::_Safe_iterator<_IIte, _ISeq, _ICat>&,
  const ::__gnu_debug::_Safe_iterator<_IIte, _ISeq, _ICat>&,
  const ::__gnu_debug::_Safe_iterator<_OIte, _OSeq, _OCat>&);
# 794 "/usr/include/c++/10.2.0/bits/stl_algobase.h" 3
  template<typename _BI1, typename _BI2>
   
    inline _BI2
    copy_backward(_BI1 __first, _BI1 __last, _BI2 __result)
    {

     
     
     


      ;

      return std::__copy_move_backward_a<__is_move_iterator<_BI1>::__value>
      (std::__miter_base(__first), std::__miter_base(__last), __result);
    }
# 830 "/usr/include/c++/10.2.0/bits/stl_algobase.h" 3
  template<typename _BI1, typename _BI2>
   
    inline _BI2
    move_backward(_BI1 __first, _BI1 __last, _BI2 __result)
    {

     
     
     


      ;

      return std::__copy_move_backward_a<true>(std::__miter_base(__first),
            std::__miter_base(__last),
            __result);
    }






  template<typename _ForwardIterator, typename _Tp>
   
    inline typename
    __gnu_cxx::__enable_if<!__is_scalar<_Tp>::__value, void>::__type
    __fill_a1(_ForwardIterator __first, _ForwardIterator __last,
       const _Tp& __value)
    {
      for (; __first != __last; ++__first)
 *__first = __value;
    }

  template<typename _ForwardIterator, typename _Tp>
   
    inline typename
    __gnu_cxx::__enable_if<__is_scalar<_Tp>::__value, void>::__type
    __fill_a1(_ForwardIterator __first, _ForwardIterator __last,
       const _Tp& __value)
    {
      const _Tp __tmp = __value;
      for (; __first != __last; ++__first)
 *__first = __tmp;
    }


  template<typename _Tp>
   
    inline typename
    __gnu_cxx::__enable_if<__is_byte<_Tp>::__value, void>::__type
    __fill_a1(_Tp* __first, _Tp* __last, const _Tp& __c)
    {
      const _Tp __tmp = __c;
# 892 "/usr/include/c++/10.2.0/bits/stl_algobase.h" 3
      if (const size_t __len = __last - __first)
 __builtin_memset(__first, static_cast<unsigned char>(__tmp), __len);
    }

  template<typename _Ite, typename _Cont, typename _Tp>
   
    inline void
    __fill_a1(::__gnu_cxx::__normal_iterator<_Ite, _Cont> __first,
       ::__gnu_cxx::__normal_iterator<_Ite, _Cont> __last,
       const _Tp& __value)
    { std::__fill_a1(__first.base(), __last.base(), __value); }

  template<typename _Tp, typename _VTp>
    void
    __fill_a1(const std::_Deque_iterator<_Tp, _Tp&, _Tp*>&,
       const std::_Deque_iterator<_Tp, _Tp&, _Tp*>&,
       const _VTp&);

  template<typename _FIte, typename _Tp>
   
    inline void
    __fill_a(_FIte __first, _FIte __last, const _Tp& __value)
    { std::__fill_a1(__first, __last, __value); }

  template<typename _Ite, typename _Seq, typename _Cat, typename _Tp>
    void
    __fill_a(const ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat>&,
      const ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat>&,
      const _Tp&);
# 934 "/usr/include/c++/10.2.0/bits/stl_algobase.h" 3
  template<typename _ForwardIterator, typename _Tp>
   
    inline void
    fill(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value)
    {

     

      ;

      std::__fill_a(__first, __last, __value);
    }


  inline constexpr int
  __size_to_integer(int __n) { return __n; }
  inline constexpr unsigned
  __size_to_integer(unsigned __n) { return __n; }
  inline constexpr long
  __size_to_integer(long __n) { return __n; }
  inline constexpr unsigned long
  __size_to_integer(unsigned long __n) { return __n; }
  inline constexpr long long
  __size_to_integer(long long __n) { return __n; }
  inline constexpr unsigned long long
  __size_to_integer(unsigned long long __n) { return __n; }
# 986 "/usr/include/c++/10.2.0/bits/stl_algobase.h" 3
  inline constexpr long long
  __size_to_integer(float __n) { return __n; }
  inline constexpr long long
  __size_to_integer(double __n) { return __n; }
  inline constexpr long long
  __size_to_integer(long double __n) { return __n; }





  template<typename _OutputIterator, typename _Size, typename _Tp>
   
    inline typename
    __gnu_cxx::__enable_if<!__is_scalar<_Tp>::__value, _OutputIterator>::__type
    __fill_n_a1(_OutputIterator __first, _Size __n, const _Tp& __value)
    {
      for (; __n > 0; --__n, (void) ++__first)
 *__first = __value;
      return __first;
    }

  template<typename _OutputIterator, typename _Size, typename _Tp>
   
    inline typename
    __gnu_cxx::__enable_if<__is_scalar<_Tp>::__value, _OutputIterator>::__type
    __fill_n_a1(_OutputIterator __first, _Size __n, const _Tp& __value)
    {
      const _Tp __tmp = __value;
      for (; __n > 0; --__n, (void) ++__first)
 *__first = __tmp;
      return __first;
    }

  template<typename _Ite, typename _Seq, typename _Cat, typename _Size,
    typename _Tp>
    ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat>
    __fill_n_a(const ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat>& __first,
        _Size __n, const _Tp& __value,
        std::input_iterator_tag);

  template<typename _OutputIterator, typename _Size, typename _Tp>
   
    inline _OutputIterator
    __fill_n_a(_OutputIterator __first, _Size __n, const _Tp& __value,
        std::output_iterator_tag)
    {

      static_assert(is_integral<_Size>{}, "fill_n must pass integral size");

      return __fill_n_a1(__first, __n, __value);
    }

  template<typename _OutputIterator, typename _Size, typename _Tp>
   
    inline _OutputIterator
    __fill_n_a(_OutputIterator __first, _Size __n, const _Tp& __value,
        std::input_iterator_tag)
    {

      static_assert(is_integral<_Size>{}, "fill_n must pass integral size");

      return __fill_n_a1(__first, __n, __value);
    }

  template<typename _OutputIterator, typename _Size, typename _Tp>
   
    inline _OutputIterator
    __fill_n_a(_OutputIterator __first, _Size __n, const _Tp& __value,
        std::random_access_iterator_tag)
    {

      static_assert(is_integral<_Size>{}, "fill_n must pass integral size");

      if (__n <= 0)
 return __first;

      ;

      std::__fill_a(__first, __first + __n, __value);
      return __first + __n;
    }
# 1086 "/usr/include/c++/10.2.0/bits/stl_algobase.h" 3
  template<typename _OI, typename _Size, typename _Tp>
   
    inline _OI
    fill_n(_OI __first, _Size __n, const _Tp& __value)
    {

     

      return std::__fill_n_a(__first, std::__size_to_integer(__n), __value,
          std::__iterator_category(__first));
    }

  template<bool _BoolType>
    struct __equal
    {
      template<typename _II1, typename _II2>

 static bool
 equal(_II1 __first1, _II1 __last1, _II2 __first2)
 {
   for (; __first1 != __last1; ++__first1, (void) ++__first2)
     if (!(*__first1 == *__first2))
       return false;
   return true;
 }
    };

  template<>
    struct __equal<true>
    {
      template<typename _Tp>

 static bool
 equal(const _Tp* __first1, const _Tp* __last1, const _Tp* __first2)
 {
   if (const size_t __len = (__last1 - __first1))
     return !std::__memcmp(__first1, __first2, __len);
   return true;
 }
    };

  template<typename _Tp, typename _Ref, typename _Ptr, typename _II>
    typename __gnu_cxx::__enable_if<
      __is_random_access_iter<_II>::__value, bool>::__type
    __equal_aux1(std::_Deque_iterator<_Tp, _Ref, _Ptr>,
   std::_Deque_iterator<_Tp, _Ref, _Ptr>,
   _II);

  template<typename _Tp1, typename _Ref1, typename _Ptr1,
    typename _Tp2, typename _Ref2, typename _Ptr2>
    bool
    __equal_aux1(std::_Deque_iterator<_Tp1, _Ref1, _Ptr1>,
   std::_Deque_iterator<_Tp1, _Ref1, _Ptr1>,
   std::_Deque_iterator<_Tp2, _Ref2, _Ptr2>);

  template<typename _II, typename _Tp, typename _Ref, typename _Ptr>
    typename __gnu_cxx::__enable_if<
      __is_random_access_iter<_II>::__value, bool>::__type
    __equal_aux1(_II, _II,
  std::_Deque_iterator<_Tp, _Ref, _Ptr>);

  template<typename _II1, typename _II2>
   
    inline bool
    __equal_aux1(_II1 __first1, _II1 __last1, _II2 __first2)
    {
      typedef typename iterator_traits<_II1>::value_type _ValueType1;
      const bool __simple = ((__is_integer<_ValueType1>::__value
         || __is_pointer<_ValueType1>::__value)
        && __memcmpable<_II1, _II2>::__value);
      return std::__equal<__simple>::equal(__first1, __last1, __first2);
    }

  template<typename _II1, typename _II2>
   
    inline bool
    __equal_aux(_II1 __first1, _II1 __last1, _II2 __first2)
    {
      return std::__equal_aux1(std::__niter_base(__first1),
          std::__niter_base(__last1),
          std::__niter_base(__first2));
    }

  template<typename _II1, typename _Seq1, typename _Cat1, typename _II2>
    bool
    __equal_aux(const ::__gnu_debug::_Safe_iterator<_II1, _Seq1, _Cat1>&,
  const ::__gnu_debug::_Safe_iterator<_II1, _Seq1, _Cat1>&,
  _II2);

  template<typename _II1, typename _II2, typename _Seq2, typename _Cat2>
    bool
    __equal_aux(_II1, _II1,
  const ::__gnu_debug::_Safe_iterator<_II2, _Seq2, _Cat2>&);

  template<typename _II1, typename _Seq1, typename _Cat1,
    typename _II2, typename _Seq2, typename _Cat2>
    bool
    __equal_aux(const ::__gnu_debug::_Safe_iterator<_II1, _Seq1, _Cat1>&,
  const ::__gnu_debug::_Safe_iterator<_II1, _Seq1, _Cat1>&,
  const ::__gnu_debug::_Safe_iterator<_II2, _Seq2, _Cat2>&);

  template<typename, typename>
    struct __lc_rai
    {
      template<typename _II1, typename _II2>

 static _II1
 __newlast1(_II1, _II1 __last1, _II2, _II2)
 { return __last1; }

      template<typename _II>

 static bool
 __cnd2(_II __first, _II __last)
 { return __first != __last; }
    };

  template<>
    struct __lc_rai<random_access_iterator_tag, random_access_iterator_tag>
    {
      template<typename _RAI1, typename _RAI2>

 static _RAI1
 __newlast1(_RAI1 __first1, _RAI1 __last1,
     _RAI2 __first2, _RAI2 __last2)
 {
   const typename iterator_traits<_RAI1>::difference_type
     __diff1 = __last1 - __first1;
   const typename iterator_traits<_RAI2>::difference_type
     __diff2 = __last2 - __first2;
   return __diff2 < __diff1 ? __first1 + __diff2 : __last1;
 }

      template<typename _RAI>
 static bool
 __cnd2(_RAI, _RAI)
 { return true; }
    };

  template<typename _II1, typename _II2, typename _Compare>
   
    bool
    __lexicographical_compare_impl(_II1 __first1, _II1 __last1,
       _II2 __first2, _II2 __last2,
       _Compare __comp)
    {
      typedef typename iterator_traits<_II1>::iterator_category _Category1;
      typedef typename iterator_traits<_II2>::iterator_category _Category2;
      typedef std::__lc_rai<_Category1, _Category2> __rai_type;

      __last1 = __rai_type::__newlast1(__first1, __last1, __first2, __last2);
      for (; __first1 != __last1 && __rai_type::__cnd2(__first2, __last2);
    ++__first1, (void)++__first2)
 {
   if (__comp(__first1, __first2))
     return true;
   if (__comp(__first2, __first1))
     return false;
 }
      return __first1 == __last1 && __first2 != __last2;
    }

  template<bool _BoolType>
    struct __lexicographical_compare
    {
      template<typename _II1, typename _II2>

 static bool
 __lc(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2)
 {
   using __gnu_cxx::__ops::__iter_less_iter;
   return std::__lexicographical_compare_impl(__first1, __last1,
           __first2, __last2,
           __iter_less_iter());
 }
    };

  template<>
    struct __lexicographical_compare<true>
    {
      template<typename _Tp, typename _Up>

 static bool
 __lc(const _Tp* __first1, const _Tp* __last1,
      const _Up* __first2, const _Up* __last2)
 {
   const size_t __len1 = __last1 - __first1;
   const size_t __len2 = __last2 - __first2;
   if (const size_t __len = std::min(__len1, __len2))
     if (int __result = std::__memcmp(__first1, __first2, __len))
       return __result < 0;
   return __len1 < __len2;
 }
    };

  template<typename _II1, typename _II2>
   
    inline bool
    __lexicographical_compare_aux(_II1 __first1, _II1 __last1,
      _II2 __first2, _II2 __last2)
    {
      typedef typename iterator_traits<_II1>::value_type _ValueType1;
      typedef typename iterator_traits<_II2>::value_type _ValueType2;
      const bool __simple =
 (__is_byte<_ValueType1>::__value && __is_byte<_ValueType2>::__value
  && !__gnu_cxx::__numeric_traits<_ValueType1>::__is_signed
  && !__gnu_cxx::__numeric_traits<_ValueType2>::__is_signed
  && __is_pointer<_II1>::__value
  && __is_pointer<_II2>::__value







  );

      return std::__lexicographical_compare<__simple>::__lc(__first1, __last1,
           __first2, __last2);
    }

  template<typename _ForwardIterator, typename _Tp, typename _Compare>
   
    _ForwardIterator
    __lower_bound(_ForwardIterator __first, _ForwardIterator __last,
    const _Tp& __val, _Compare __comp)
    {
      typedef typename iterator_traits<_ForwardIterator>::difference_type
 _DistanceType;

      _DistanceType __len = std::distance(__first, __last);

      while (__len > 0)
 {
   _DistanceType __half = __len >> 1;
   _ForwardIterator __middle = __first;
   std::advance(__middle, __half);
   if (__comp(__middle, __val))
     {
       __first = __middle;
       ++__first;
       __len = __len - __half - 1;
     }
   else
     __len = __half;
 }
      return __first;
    }
# 1347 "/usr/include/c++/10.2.0/bits/stl_algobase.h" 3
  template<typename _ForwardIterator, typename _Tp>
   
    inline _ForwardIterator
    lower_bound(_ForwardIterator __first, _ForwardIterator __last,
  const _Tp& __val)
    {

     
     

      ;

      return std::__lower_bound(__first, __last, __val,
    __gnu_cxx::__ops::__iter_less_val());
    }



  inline constexpr int
  __lg(int __n)
  { return (int)sizeof(int) * 8 - 1 - __builtin_clz(__n); }

  inline constexpr unsigned
  __lg(unsigned __n)
  { return (int)sizeof(int) * 8 - 1 - __builtin_clz(__n); }

  inline constexpr long
  __lg(long __n)
  { return (int)sizeof(long) * 8 - 1 - __builtin_clzl(__n); }

  inline constexpr unsigned long
  __lg(unsigned long __n)
  { return (int)sizeof(long) * 8 - 1 - __builtin_clzl(__n); }

  inline constexpr long long
  __lg(long long __n)
  { return (int)sizeof(long long) * 8 - 1 - __builtin_clzll(__n); }

  inline constexpr unsigned long long
  __lg(unsigned long long __n)
  { return (int)sizeof(long long) * 8 - 1 - __builtin_clzll(__n); }


# 1403 "/usr/include/c++/10.2.0/bits/stl_algobase.h" 3
  template<typename _II1, typename _II2>
   
    inline bool
    equal(_II1 __first1, _II1 __last1, _II2 __first2)
    {

     
     
     


      ;

      return std::__equal_aux(__first1, __last1, __first2);
    }
# 1434 "/usr/include/c++/10.2.0/bits/stl_algobase.h" 3
  template<typename _IIter1, typename _IIter2, typename _BinaryPredicate>
   
    inline bool
    equal(_IIter1 __first1, _IIter1 __last1,
   _IIter2 __first2, _BinaryPredicate __binary_pred)
    {

     
     
      ;

      for (; __first1 != __last1; ++__first1, (void)++__first2)
 if (!bool(__binary_pred(*__first1, *__first2)))
   return false;
      return true;
    }



  template<typename _II1, typename _II2>
   
    inline bool
    __equal4(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2)
    {
      using _RATag = random_access_iterator_tag;
      using _Cat1 = typename iterator_traits<_II1>::iterator_category;
      using _Cat2 = typename iterator_traits<_II2>::iterator_category;
      using _RAIters = __and_<is_same<_Cat1, _RATag>, is_same<_Cat2, _RATag>>;
      if (_RAIters())
 {
   auto __d1 = std::distance(__first1, __last1);
   auto __d2 = std::distance(__first2, __last2);
   if (__d1 != __d2)
     return false;
   return std::equal(__first1, __last1, __first2);
 }

      for (; __first1 != __last1 && __first2 != __last2;
   ++__first1, (void)++__first2)
 if (!(*__first1 == *__first2))
   return false;
      return __first1 == __last1 && __first2 == __last2;
    }


  template<typename _II1, typename _II2, typename _BinaryPredicate>
   
    inline bool
    __equal4(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2,
      _BinaryPredicate __binary_pred)
    {
      using _RATag = random_access_iterator_tag;
      using _Cat1 = typename iterator_traits<_II1>::iterator_category;
      using _Cat2 = typename iterator_traits<_II2>::iterator_category;
      using _RAIters = __and_<is_same<_Cat1, _RATag>, is_same<_Cat2, _RATag>>;
      if (_RAIters())
 {
   auto __d1 = std::distance(__first1, __last1);
   auto __d2 = std::distance(__first2, __last2);
   if (__d1 != __d2)
     return false;
   return std::equal(__first1, __last1, __first2,
           __binary_pred);
 }

      for (; __first1 != __last1 && __first2 != __last2;
   ++__first1, (void)++__first2)
 if (!bool(__binary_pred(*__first1, *__first2)))
   return false;
      return __first1 == __last1 && __first2 == __last2;
    }
# 1589 "/usr/include/c++/10.2.0/bits/stl_algobase.h" 3
  template<typename _II1, typename _II2>
   
    inline bool
    lexicographical_compare(_II1 __first1, _II1 __last1,
       _II2 __first2, _II2 __last2)
    {





     
     
     
     
      ;
      ;

      return std::__lexicographical_compare_aux(std::__niter_base(__first1),
      std::__niter_base(__last1),
      std::__niter_base(__first2),
      std::__niter_base(__last2));
    }
# 1626 "/usr/include/c++/10.2.0/bits/stl_algobase.h" 3
  template<typename _II1, typename _II2, typename _Compare>
   
    inline bool
    lexicographical_compare(_II1 __first1, _II1 __last1,
       _II2 __first2, _II2 __last2, _Compare __comp)
    {

     
     
      ;
      ;

      return std::__lexicographical_compare_impl
 (__first1, __last1, __first2, __last2,
  __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }
# 1740 "/usr/include/c++/10.2.0/bits/stl_algobase.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _BinaryPredicate>
   
    pair<_InputIterator1, _InputIterator2>
    __mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
        _InputIterator2 __first2, _BinaryPredicate __binary_pred)
    {
      while (__first1 != __last1 && __binary_pred(__first1, __first2))
 {
   ++__first1;
   ++__first2;
 }
      return pair<_InputIterator1, _InputIterator2>(__first1, __first2);
    }
# 1768 "/usr/include/c++/10.2.0/bits/stl_algobase.h" 3
  template<typename _InputIterator1, typename _InputIterator2>
   
    inline pair<_InputIterator1, _InputIterator2>
    mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2)
    {

     
     
     


      ;

      return std::__mismatch(__first1, __last1, __first2,
        __gnu_cxx::__ops::__iter_equal_to_iter());
    }
# 1802 "/usr/include/c++/10.2.0/bits/stl_algobase.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _BinaryPredicate>
   
    inline pair<_InputIterator1, _InputIterator2>
    mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2, _BinaryPredicate __binary_pred)
    {

     
     
      ;

      return std::__mismatch(__first1, __last1, __first2,
 __gnu_cxx::__ops::__iter_comp_iter(__binary_pred));
    }
# 1906 "/usr/include/c++/10.2.0/bits/stl_algobase.h" 3



  template<typename _InputIterator, typename _Predicate>
   
    inline _InputIterator
    __find_if(_InputIterator __first, _InputIterator __last,
       _Predicate __pred, input_iterator_tag)
    {
      while (__first != __last && !__pred(__first))
 ++__first;
      return __first;
    }


  template<typename _RandomAccessIterator, typename _Predicate>
   
    _RandomAccessIterator
    __find_if(_RandomAccessIterator __first, _RandomAccessIterator __last,
       _Predicate __pred, random_access_iterator_tag)
    {
      typename iterator_traits<_RandomAccessIterator>::difference_type
 __trip_count = (__last - __first) >> 2;

      for (; __trip_count > 0; --__trip_count)
 {
   if (__pred(__first))
     return __first;
   ++__first;

   if (__pred(__first))
     return __first;
   ++__first;

   if (__pred(__first))
     return __first;
   ++__first;

   if (__pred(__first))
     return __first;
   ++__first;
 }

      switch (__last - __first)
 {
 case 3:
   if (__pred(__first))
     return __first;
   ++__first;

 case 2:
   if (__pred(__first))
     return __first;
   ++__first;

 case 1:
   if (__pred(__first))
     return __first;
   ++__first;

 case 0:
 default:
   return __last;
 }
    }

  template<typename _Iterator, typename _Predicate>
   
    inline _Iterator
    __find_if(_Iterator __first, _Iterator __last, _Predicate __pred)
    {
      return __find_if(__first, __last, __pred,
         std::__iterator_category(__first));
    }

  template<typename _InputIterator, typename _Predicate>
   
    typename iterator_traits<_InputIterator>::difference_type
    __count_if(_InputIterator __first, _InputIterator __last, _Predicate __pred)
    {
      typename iterator_traits<_InputIterator>::difference_type __n = 0;
      for (; __first != __last; ++__first)
 if (__pred(__first))
   ++__n;
      return __n;
    }


  template<typename _ForwardIterator1, typename _ForwardIterator2,
    typename _BinaryPredicate>
   
    bool
    __is_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
       _ForwardIterator2 __first2, _BinaryPredicate __pred)
    {


      for (; __first1 != __last1; ++__first1, (void)++__first2)
 if (!__pred(__first1, __first2))
   break;

      if (__first1 == __last1)
 return true;



      _ForwardIterator2 __last2 = __first2;
      std::advance(__last2, std::distance(__first1, __last1));
      for (_ForwardIterator1 __scan = __first1; __scan != __last1; ++__scan)
 {
   if (__scan != std::__find_if(__first1, __scan,
     __gnu_cxx::__ops::__iter_comp_iter(__pred, __scan)))
     continue;

   auto __matches
     = std::__count_if(__first2, __last2,
   __gnu_cxx::__ops::__iter_comp_iter(__pred, __scan));
   if (0 == __matches ||
       std::__count_if(__scan, __last1,
   __gnu_cxx::__ops::__iter_comp_iter(__pred, __scan))
       != __matches)
     return false;
 }
      return true;
    }
# 2044 "/usr/include/c++/10.2.0/bits/stl_algobase.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2>
   
    inline bool
    is_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
     _ForwardIterator2 __first2)
    {

     
     
     


      ;

      return std::__is_permutation(__first1, __last1, __first2,
       __gnu_cxx::__ops::__iter_equal_to_iter());
    }



}
# 40 "/usr/include/c++/10.2.0/bits/char_traits.h" 2 3

# 1 "/usr/include/c++/10.2.0/cwchar" 1 3
# 39 "/usr/include/c++/10.2.0/cwchar" 3
       
# 40 "/usr/include/c++/10.2.0/cwchar" 3
# 42 "/usr/include/c++/10.2.0/bits/char_traits.h" 2 3
# 50 "/usr/include/c++/10.2.0/bits/char_traits.h" 3
namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{

# 64 "/usr/include/c++/10.2.0/bits/char_traits.h" 3
  template<typename _CharT>
    struct _Char_types
    {
      typedef unsigned long int_type;
      typedef std::streampos pos_type;
      typedef std::streamoff off_type;
      typedef std::mbstate_t state_type;
    };
# 89 "/usr/include/c++/10.2.0/bits/char_traits.h" 3
  template<typename _CharT>
    struct char_traits
    {
      typedef _CharT char_type;
      typedef typename _Char_types<_CharT>::int_type int_type;
      typedef typename _Char_types<_CharT>::pos_type pos_type;
      typedef typename _Char_types<_CharT>::off_type off_type;
      typedef typename _Char_types<_CharT>::state_type state_type;




      static void
      assign(char_type& __c1, const char_type& __c2)
      { __c1 = __c2; }

      static constexpr bool
      eq(const char_type& __c1, const char_type& __c2)
      { return __c1 == __c2; }

      static constexpr bool
      lt(const char_type& __c1, const char_type& __c2)
      { return __c1 < __c2; }

      static int
      compare(const char_type* __s1, const char_type* __s2, std::size_t __n);

      static std::size_t
      length(const char_type* __s);

      static const char_type*
      find(const char_type* __s, std::size_t __n, const char_type& __a);

      static char_type*
      move(char_type* __s1, const char_type* __s2, std::size_t __n);

      static char_type*
      copy(char_type* __s1, const char_type* __s2, std::size_t __n);

      static char_type*
      assign(char_type* __s, std::size_t __n, char_type __a);

      static constexpr char_type
      to_char_type(const int_type& __c)
      { return static_cast<char_type>(__c); }

      static constexpr int_type
      to_int_type(const char_type& __c)
      { return static_cast<int_type>(__c); }

      static constexpr bool
      eq_int_type(const int_type& __c1, const int_type& __c2)
      { return __c1 == __c2; }

      static constexpr int_type
      eof()
      { return static_cast<int_type>(-1); }

      static constexpr int_type
      not_eof(const int_type& __c)
      { return !eq_int_type(__c, eof()) ? __c : to_int_type(char_type()); }
    };

  template<typename _CharT>
    int
    char_traits<_CharT>::
    compare(const char_type* __s1, const char_type* __s2, std::size_t __n)
    {
      for (std::size_t __i = 0; __i < __n; ++__i)
 if (lt(__s1[__i], __s2[__i]))
   return -1;
 else if (lt(__s2[__i], __s1[__i]))
   return 1;
      return 0;
    }

  template<typename _CharT>
    std::size_t
    char_traits<_CharT>::
    length(const char_type* __p)
    {
      std::size_t __i = 0;
      while (!eq(__p[__i], char_type()))
        ++__i;
      return __i;
    }

  template<typename _CharT>
    const typename char_traits<_CharT>::char_type*
    char_traits<_CharT>::
    find(const char_type* __s, std::size_t __n, const char_type& __a)
    {
      for (std::size_t __i = 0; __i < __n; ++__i)
        if (eq(__s[__i], __a))
          return __s + __i;
      return 0;
    }

  template<typename _CharT>
   
    typename char_traits<_CharT>::char_type*
    char_traits<_CharT>::
    move(char_type* __s1, const char_type* __s2, std::size_t __n)
    {
      if (__n == 0)
 return __s1;
# 205 "/usr/include/c++/10.2.0/bits/char_traits.h" 3
      return static_cast<_CharT*>(__builtin_memmove(__s1, __s2,
          __n * sizeof(char_type)));
    }

  template<typename _CharT>
   
    typename char_traits<_CharT>::char_type*
    char_traits<_CharT>::
    copy(char_type* __s1, const char_type* __s2, std::size_t __n)
    {

      std::copy(__s2, __s2 + __n, __s1);
      return __s1;
    }

  template<typename _CharT>
   
    typename char_traits<_CharT>::char_type*
    char_traits<_CharT>::
    assign(char_type* __s, std::size_t __n, char_type __a)
    {

      std::fill_n(__s, __n, __a);
      return __s;
    }


}

namespace std __attribute__ ((__visibility__ ("default")))
{

# 302 "/usr/include/c++/10.2.0/bits/char_traits.h" 3
  template<class _CharT>
    struct char_traits : public __gnu_cxx::char_traits<_CharT>
    { };



  template<>
    struct char_traits<char>
    {
      typedef char char_type;
      typedef int int_type;
      typedef streampos pos_type;
      typedef streamoff off_type;
      typedef mbstate_t state_type;




      static void
      assign(char_type& __c1, const char_type& __c2) noexcept
      { __c1 = __c2; }

      static constexpr bool
      eq(const char_type& __c1, const char_type& __c2) noexcept
      { return __c1 == __c2; }

      static constexpr bool
      lt(const char_type& __c1, const char_type& __c2) noexcept
      {

 return (static_cast<unsigned char>(__c1)
  < static_cast<unsigned char>(__c2));
      }

      static int
      compare(const char_type* __s1, const char_type* __s2, size_t __n)
      {
 if (__n == 0)
   return 0;






 return __builtin_memcmp(__s1, __s2, __n);
      }

      static size_t
      length(const char_type* __s)
      {




 return __builtin_strlen(__s);
      }

      static const char_type*
      find(const char_type* __s, size_t __n, const char_type& __a)
      {
 if (__n == 0)
   return 0;






 return static_cast<const char_type*>(__builtin_memchr(__s, __a, __n));
      }

      static char_type*
      move(char_type* __s1, const char_type* __s2, size_t __n)
      {
 if (__n == 0)
   return __s1;




 return static_cast<char_type*>(__builtin_memmove(__s1, __s2, __n));
      }

      static char_type*
      copy(char_type* __s1, const char_type* __s2, size_t __n)
      {
 if (__n == 0)
   return __s1;




 return static_cast<char_type*>(__builtin_memcpy(__s1, __s2, __n));
      }

      static char_type*
      assign(char_type* __s, size_t __n, char_type __a)
      {
 if (__n == 0)
   return __s;




 return static_cast<char_type*>(__builtin_memset(__s, __a, __n));
      }

      static constexpr char_type
      to_char_type(const int_type& __c) noexcept
      { return static_cast<char_type>(__c); }



      static constexpr int_type
      to_int_type(const char_type& __c) noexcept
      { return static_cast<int_type>(static_cast<unsigned char>(__c)); }

      static constexpr bool
      eq_int_type(const int_type& __c1, const int_type& __c2) noexcept
      { return __c1 == __c2; }

      static constexpr int_type
      eof() noexcept
      { return static_cast<int_type>(-1); }

      static constexpr int_type
      not_eof(const int_type& __c) noexcept
      { return (__c == eof()) ? 0 : __c; }
  };




  template<>
    struct char_traits<wchar_t>
    {
      typedef wchar_t char_type;
      typedef wint_t int_type;
      typedef streamoff off_type;
      typedef wstreampos pos_type;
      typedef mbstate_t state_type;




      static void
      assign(char_type& __c1, const char_type& __c2) noexcept
      { __c1 = __c2; }

      static constexpr bool
      eq(const char_type& __c1, const char_type& __c2) noexcept
      { return __c1 == __c2; }

      static constexpr bool
      lt(const char_type& __c1, const char_type& __c2) noexcept
      { return __c1 < __c2; }

      static int
      compare(const char_type* __s1, const char_type* __s2, size_t __n)
      {
 if (__n == 0)
   return 0;






 return wmemcmp(__s1, __s2, __n);
      }

      static size_t
      length(const char_type* __s)
      {




 return wcslen(__s);
      }

      static const char_type*
      find(const char_type* __s, size_t __n, const char_type& __a)
      {
 if (__n == 0)
   return 0;






 return wmemchr(__s, __a, __n);
      }

      static char_type*
      move(char_type* __s1, const char_type* __s2, size_t __n)
      {
 if (__n == 0)
   return __s1;




 return wmemmove(__s1, __s2, __n);
      }

      static char_type*
      copy(char_type* __s1, const char_type* __s2, size_t __n)
      {
 if (__n == 0)
   return __s1;




 return wmemcpy(__s1, __s2, __n);
      }

      static char_type*
      assign(char_type* __s, size_t __n, char_type __a)
      {
 if (__n == 0)
   return __s;




 return wmemset(__s, __a, __n);
      }

      static constexpr char_type
      to_char_type(const int_type& __c) noexcept
      { return char_type(__c); }

      static constexpr int_type
      to_int_type(const char_type& __c) noexcept
      { return int_type(__c); }

      static constexpr bool
      eq_int_type(const int_type& __c1, const int_type& __c2) noexcept
      { return __c1 == __c2; }

      static constexpr int_type
      eof() noexcept
      { return static_cast<int_type>((0xffffffffu)); }

      static constexpr int_type
      not_eof(const int_type& __c) noexcept
      { return eq_int_type(__c, eof()) ? 0 : __c; }
  };
# 680 "/usr/include/c++/10.2.0/bits/char_traits.h" 3

}





namespace std __attribute__ ((__visibility__ ("default")))
{


  template<>
    struct char_traits<char16_t>
    {
      typedef char16_t char_type;

      typedef uint_least16_t int_type;





      typedef streamoff off_type;
      typedef u16streampos pos_type;
      typedef mbstate_t state_type;




      static void
      assign(char_type& __c1, const char_type& __c2) noexcept
      { __c1 = __c2; }

      static constexpr bool
      eq(const char_type& __c1, const char_type& __c2) noexcept
      { return __c1 == __c2; }

      static constexpr bool
      lt(const char_type& __c1, const char_type& __c2) noexcept
      { return __c1 < __c2; }

      static int
      compare(const char_type* __s1, const char_type* __s2, size_t __n)
      {
 for (size_t __i = 0; __i < __n; ++__i)
   if (lt(__s1[__i], __s2[__i]))
     return -1;
   else if (lt(__s2[__i], __s1[__i]))
     return 1;
 return 0;
      }

      static size_t
      length(const char_type* __s)
      {
 size_t __i = 0;
 while (!eq(__s[__i], char_type()))
   ++__i;
 return __i;
      }

      static const char_type*
      find(const char_type* __s, size_t __n, const char_type& __a)
      {
 for (size_t __i = 0; __i < __n; ++__i)
   if (eq(__s[__i], __a))
     return __s + __i;
 return 0;
      }

      static char_type*
      move(char_type* __s1, const char_type* __s2, size_t __n)
      {
 if (__n == 0)
   return __s1;




 return (static_cast<char_type*>
  (__builtin_memmove(__s1, __s2, __n * sizeof(char_type))));
      }

      static char_type*
      copy(char_type* __s1, const char_type* __s2, size_t __n)
      {
 if (__n == 0)
   return __s1;




 return (static_cast<char_type*>
  (__builtin_memcpy(__s1, __s2, __n * sizeof(char_type))));
      }

      static char_type*
      assign(char_type* __s, size_t __n, char_type __a)
      {
 for (size_t __i = 0; __i < __n; ++__i)
   assign(__s[__i], __a);
 return __s;
      }

      static constexpr char_type
      to_char_type(const int_type& __c) noexcept
      { return char_type(__c); }

      static constexpr int_type
      to_int_type(const char_type& __c) noexcept
      { return __c == eof() ? int_type(0xfffd) : int_type(__c); }

      static constexpr bool
      eq_int_type(const int_type& __c1, const int_type& __c2) noexcept
      { return __c1 == __c2; }

      static constexpr int_type
      eof() noexcept
      { return static_cast<int_type>(-1); }

      static constexpr int_type
      not_eof(const int_type& __c) noexcept
      { return eq_int_type(__c, eof()) ? 0 : __c; }
    };

  template<>
    struct char_traits<char32_t>
    {
      typedef char32_t char_type;

      typedef uint_least32_t int_type;





      typedef streamoff off_type;
      typedef u32streampos pos_type;
      typedef mbstate_t state_type;




      static void
      assign(char_type& __c1, const char_type& __c2) noexcept
      { __c1 = __c2; }

      static constexpr bool
      eq(const char_type& __c1, const char_type& __c2) noexcept
      { return __c1 == __c2; }

      static constexpr bool
      lt(const char_type& __c1, const char_type& __c2) noexcept
      { return __c1 < __c2; }

      static int
      compare(const char_type* __s1, const char_type* __s2, size_t __n)
      {
 for (size_t __i = 0; __i < __n; ++__i)
   if (lt(__s1[__i], __s2[__i]))
     return -1;
   else if (lt(__s2[__i], __s1[__i]))
     return 1;
 return 0;
      }

      static size_t
      length(const char_type* __s)
      {
 size_t __i = 0;
 while (!eq(__s[__i], char_type()))
   ++__i;
 return __i;
      }

      static const char_type*
      find(const char_type* __s, size_t __n, const char_type& __a)
      {
 for (size_t __i = 0; __i < __n; ++__i)
   if (eq(__s[__i], __a))
     return __s + __i;
 return 0;
      }

      static char_type*
      move(char_type* __s1, const char_type* __s2, size_t __n)
      {
 if (__n == 0)
   return __s1;




 return (static_cast<char_type*>
  (__builtin_memmove(__s1, __s2, __n * sizeof(char_type))));
      }

      static char_type*
      copy(char_type* __s1, const char_type* __s2, size_t __n)
      {
 if (__n == 0)
   return __s1;




 return (static_cast<char_type*>
  (__builtin_memcpy(__s1, __s2, __n * sizeof(char_type))));
      }

      static char_type*
      assign(char_type* __s, size_t __n, char_type __a)
      {
 for (size_t __i = 0; __i < __n; ++__i)
   assign(__s[__i], __a);
 return __s;
      }

      static constexpr char_type
      to_char_type(const int_type& __c) noexcept
      { return char_type(__c); }

      static constexpr int_type
      to_int_type(const char_type& __c) noexcept
      { return int_type(__c); }

      static constexpr bool
      eq_int_type(const int_type& __c1, const int_type& __c2) noexcept
      { return __c1 == __c2; }

      static constexpr int_type
      eof() noexcept
      { return static_cast<int_type>(-1); }

      static constexpr int_type
      not_eof(const int_type& __c) noexcept
      { return eq_int_type(__c, eof()) ? 0 : __c; }
    };
# 938 "/usr/include/c++/10.2.0/bits/char_traits.h" 3

}
# 41 "/usr/include/c++/10.2.0/ios" 2 3
# 1 "/usr/include/c++/10.2.0/bits/localefwd.h" 1 3
# 37 "/usr/include/c++/10.2.0/bits/localefwd.h" 3
       
# 38 "/usr/include/c++/10.2.0/bits/localefwd.h" 3


# 1 "/usr/include/c++/10.2.0/x86_64-pc-linux-gnu/bits/c++locale.h" 1 3
# 39 "/usr/include/c++/10.2.0/x86_64-pc-linux-gnu/bits/c++locale.h" 3
       
# 40 "/usr/include/c++/10.2.0/x86_64-pc-linux-gnu/bits/c++locale.h" 3

# 1 "/usr/include/c++/10.2.0/clocale" 1 3
# 39 "/usr/include/c++/10.2.0/clocale" 3
       
# 40 "/usr/include/c++/10.2.0/clocale" 3


# 1 "/usr/include/locale.h" 1 3 4
# 28 "/usr/include/locale.h" 3 4
# 1 "/usr/lib/gcc/x86_64-pc-linux-gnu/10.2.0/include/stddef.h" 1 3 4
# 29 "/usr/include/locale.h" 2 3 4
# 1 "/usr/include/bits/locale.h" 1 3 4
# 30 "/usr/include/locale.h" 2 3 4

extern "C" {
# 51 "/usr/include/locale.h" 3 4
struct lconv
{


  char *decimal_point;
  char *thousands_sep;





  char *grouping;





  char *int_curr_symbol;
  char *currency_symbol;
  char *mon_decimal_point;
  char *mon_thousands_sep;
  char *mon_grouping;
  char *positive_sign;
  char *negative_sign;
  char int_frac_digits;
  char frac_digits;

  char p_cs_precedes;

  char p_sep_by_space;

  char n_cs_precedes;

  char n_sep_by_space;






  char p_sign_posn;
  char n_sign_posn;


  char int_p_cs_precedes;

  char int_p_sep_by_space;

  char int_n_cs_precedes;

  char int_n_sep_by_space;






  char int_p_sign_posn;
  char int_n_sign_posn;
# 118 "/usr/include/locale.h" 3 4
};



extern char *setlocale (int __category, const char *__locale) throw ();


extern struct lconv *localeconv (void) throw ();
# 141 "/usr/include/locale.h" 3 4
extern locale_t newlocale (int __category_mask, const char *__locale,
      locale_t __base) throw ();
# 176 "/usr/include/locale.h" 3 4
extern locale_t duplocale (locale_t __dataset) throw ();



extern void freelocale (locale_t __dataset) throw ();






extern locale_t uselocale (locale_t __dataset) throw ();







}
# 43 "/usr/include/c++/10.2.0/clocale" 2 3
# 51 "/usr/include/c++/10.2.0/clocale" 3
namespace std
{
  using ::lconv;
  using ::setlocale;
  using ::localeconv;
}
# 42 "/usr/include/c++/10.2.0/x86_64-pc-linux-gnu/bits/c++locale.h" 2 3






namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{


  extern "C" __typeof(uselocale) __uselocale;


}


namespace std __attribute__ ((__visibility__ ("default")))
{


  typedef __locale_t __c_locale;





  inline int
  __convert_from_v(const __c_locale& __cloc __attribute__ ((__unused__)),
     char* __out,
     const int __size __attribute__ ((__unused__)),
     const char* __fmt, ...)
  {

    __c_locale __old = __gnu_cxx::__uselocale(__cloc);
# 88 "/usr/include/c++/10.2.0/x86_64-pc-linux-gnu/bits/c++locale.h" 3
    __builtin_va_list __args;
    __builtin_va_start(__args, __fmt);


    const int __ret = __builtin_vsnprintf(__out, __size, __fmt, __args);




    __builtin_va_end(__args);


    __gnu_cxx::__uselocale(__old);







    return __ret;
  }


}
# 41 "/usr/include/c++/10.2.0/bits/localefwd.h" 2 3

# 1 "/usr/include/c++/10.2.0/cctype" 1 3
# 39 "/usr/include/c++/10.2.0/cctype" 3
       
# 40 "/usr/include/c++/10.2.0/cctype" 3


# 1 "/usr/include/ctype.h" 1 3 4
# 28 "/usr/include/ctype.h" 3 4
extern "C" {
# 46 "/usr/include/ctype.h" 3 4
enum
{
  _ISupper = ((0) < 8 ? ((1 << (0)) << 8) : ((1 << (0)) >> 8)),
  _ISlower = ((1) < 8 ? ((1 << (1)) << 8) : ((1 << (1)) >> 8)),
  _ISalpha = ((2) < 8 ? ((1 << (2)) << 8) : ((1 << (2)) >> 8)),
  _ISdigit = ((3) < 8 ? ((1 << (3)) << 8) : ((1 << (3)) >> 8)),
  _ISxdigit = ((4) < 8 ? ((1 << (4)) << 8) : ((1 << (4)) >> 8)),
  _ISspace = ((5) < 8 ? ((1 << (5)) << 8) : ((1 << (5)) >> 8)),
  _ISprint = ((6) < 8 ? ((1 << (6)) << 8) : ((1 << (6)) >> 8)),
  _ISgraph = ((7) < 8 ? ((1 << (7)) << 8) : ((1 << (7)) >> 8)),
  _ISblank = ((8) < 8 ? ((1 << (8)) << 8) : ((1 << (8)) >> 8)),
  _IScntrl = ((9) < 8 ? ((1 << (9)) << 8) : ((1 << (9)) >> 8)),
  _ISpunct = ((10) < 8 ? ((1 << (10)) << 8) : ((1 << (10)) >> 8)),
  _ISalnum = ((11) < 8 ? ((1 << (11)) << 8) : ((1 << (11)) >> 8))
};
# 79 "/usr/include/ctype.h" 3 4
extern const unsigned short int **__ctype_b_loc (void)
     throw () __attribute__ ((__const__));
extern const __int32_t **__ctype_tolower_loc (void)
     throw () __attribute__ ((__const__));
extern const __int32_t **__ctype_toupper_loc (void)
     throw () __attribute__ ((__const__));
# 108 "/usr/include/ctype.h" 3 4
extern int isalnum (int) throw ();
extern int isalpha (int) throw ();
extern int iscntrl (int) throw ();
extern int isdigit (int) throw ();
extern int islower (int) throw ();
extern int isgraph (int) throw ();
extern int isprint (int) throw ();
extern int ispunct (int) throw ();
extern int isspace (int) throw ();
extern int isupper (int) throw ();
extern int isxdigit (int) throw ();



extern int tolower (int __c) throw ();


extern int toupper (int __c) throw ();




extern int isblank (int) throw ();




extern int isctype (int __c, int __mask) throw ();






extern int isascii (int __c) throw ();



extern int toascii (int __c) throw ();



extern int _toupper (int) throw ();
extern int _tolower (int) throw ();
# 251 "/usr/include/ctype.h" 3 4
extern int isalnum_l (int, locale_t) throw ();
extern int isalpha_l (int, locale_t) throw ();
extern int iscntrl_l (int, locale_t) throw ();
extern int isdigit_l (int, locale_t) throw ();
extern int islower_l (int, locale_t) throw ();
extern int isgraph_l (int, locale_t) throw ();
extern int isprint_l (int, locale_t) throw ();
extern int ispunct_l (int, locale_t) throw ();
extern int isspace_l (int, locale_t) throw ();
extern int isupper_l (int, locale_t) throw ();
extern int isxdigit_l (int, locale_t) throw ();

extern int isblank_l (int, locale_t) throw ();



extern int __tolower_l (int __c, locale_t __l) throw ();
extern int tolower_l (int __c, locale_t __l) throw ();


extern int __toupper_l (int __c, locale_t __l) throw ();
extern int toupper_l (int __c, locale_t __l) throw ();
# 327 "/usr/include/ctype.h" 3 4
}
# 43 "/usr/include/c++/10.2.0/cctype" 2 3
# 62 "/usr/include/c++/10.2.0/cctype" 3
namespace std
{
  using ::isalnum;
  using ::isalpha;
  using ::iscntrl;
  using ::isdigit;
  using ::isgraph;
  using ::islower;
  using ::isprint;
  using ::ispunct;
  using ::isspace;
  using ::isupper;
  using ::isxdigit;
  using ::tolower;
  using ::toupper;
}







namespace std
{
  using ::isblank;
}
# 43 "/usr/include/c++/10.2.0/bits/localefwd.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{

# 55 "/usr/include/c++/10.2.0/bits/localefwd.h" 3
  class locale;

  template<typename _Facet>
    bool
    has_facet(const locale&) throw();

  template<typename _Facet>
    const _Facet&
    use_facet(const locale&);


  template<typename _CharT>
    bool
    isspace(_CharT, const locale&);

  template<typename _CharT>
    bool
    isprint(_CharT, const locale&);

  template<typename _CharT>
    bool
    iscntrl(_CharT, const locale&);

  template<typename _CharT>
    bool
    isupper(_CharT, const locale&);

  template<typename _CharT>
    bool
    islower(_CharT, const locale&);

  template<typename _CharT>
    bool
    isalpha(_CharT, const locale&);

  template<typename _CharT>
    bool
    isdigit(_CharT, const locale&);

  template<typename _CharT>
    bool
    ispunct(_CharT, const locale&);

  template<typename _CharT>
    bool
    isxdigit(_CharT, const locale&);

  template<typename _CharT>
    bool
    isalnum(_CharT, const locale&);

  template<typename _CharT>
    bool
    isgraph(_CharT, const locale&);


  template<typename _CharT>
    bool
    isblank(_CharT, const locale&);


  template<typename _CharT>
    _CharT
    toupper(_CharT, const locale&);

  template<typename _CharT>
    _CharT
    tolower(_CharT, const locale&);


  class ctype_base;
  template<typename _CharT>
    class ctype;
  template<> class ctype<char>;

  template<> class ctype<wchar_t>;

  template<typename _CharT>
    class ctype_byname;


  class codecvt_base;
  template<typename _InternT, typename _ExternT, typename _StateT>
    class codecvt;
  template<> class codecvt<char, char, mbstate_t>;

  template<> class codecvt<wchar_t, char, mbstate_t>;


  template<> class codecvt<char16_t, char, mbstate_t>;
  template<> class codecvt<char32_t, char, mbstate_t>;





  template<typename _InternT, typename _ExternT, typename _StateT>
    class codecvt_byname;



  template<typename _CharT, typename _InIter = istreambuf_iterator<_CharT> >
    class num_get;
  template<typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT> >
    class num_put;

namespace __cxx11 {
  template<typename _CharT> class numpunct;
  template<typename _CharT> class numpunct_byname;
}

namespace __cxx11 {

  template<typename _CharT>
    class collate;
  template<typename _CharT>
    class collate_byname;
}


  class time_base;
namespace __cxx11 {
  template<typename _CharT, typename _InIter = istreambuf_iterator<_CharT> >
    class time_get;
  template<typename _CharT, typename _InIter = istreambuf_iterator<_CharT> >
    class time_get_byname;
}
  template<typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT> >
    class time_put;
  template<typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT> >
    class time_put_byname;


  class money_base;
namespace __cxx11 {
  template<typename _CharT, typename _InIter = istreambuf_iterator<_CharT> >
    class money_get;
  template<typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT> >
    class money_put;
}
namespace __cxx11 {
  template<typename _CharT, bool _Intl = false>
    class moneypunct;
  template<typename _CharT, bool _Intl = false>
    class moneypunct_byname;
}


  class messages_base;
namespace __cxx11 {
  template<typename _CharT>
    class messages;
  template<typename _CharT>
    class messages_byname;
}


}
# 42 "/usr/include/c++/10.2.0/ios" 2 3
# 1 "/usr/include/c++/10.2.0/bits/ios_base.h" 1 3
# 37 "/usr/include/c++/10.2.0/bits/ios_base.h" 3
       
# 38 "/usr/include/c++/10.2.0/bits/ios_base.h" 3

# 1 "/usr/include/c++/10.2.0/ext/atomicity.h" 1 3
# 32 "/usr/include/c++/10.2.0/ext/atomicity.h" 3
       
# 33 "/usr/include/c++/10.2.0/ext/atomicity.h" 3


# 1 "/usr/include/c++/10.2.0/x86_64-pc-linux-gnu/bits/gthr.h" 1 3
# 30 "/usr/include/c++/10.2.0/x86_64-pc-linux-gnu/bits/gthr.h" 3
#pragma GCC visibility push(default)
# 148 "/usr/include/c++/10.2.0/x86_64-pc-linux-gnu/bits/gthr.h" 3
# 1 "/usr/include/c++/10.2.0/x86_64-pc-linux-gnu/bits/gthr-default.h" 1 3
# 35 "/usr/include/c++/10.2.0/x86_64-pc-linux-gnu/bits/gthr-default.h" 3
# 1 "/usr/include/pthread.h" 1 3 4
# 22 "/usr/include/pthread.h" 3 4
# 1 "/usr/include/sched.h" 1 3 4
# 29 "/usr/include/sched.h" 3 4
# 1 "/usr/lib/gcc/x86_64-pc-linux-gnu/10.2.0/include/stddef.h" 1 3 4
# 30 "/usr/include/sched.h" 2 3 4
# 43 "/usr/include/sched.h" 3 4
# 1 "/usr/include/bits/sched.h" 1 3 4
# 76 "/usr/include/bits/sched.h" 3 4
# 1 "/usr/include/bits/types/struct_sched_param.h" 1 3 4
# 23 "/usr/include/bits/types/struct_sched_param.h" 3 4
struct sched_param
{
  int sched_priority;
};
# 77 "/usr/include/bits/sched.h" 2 3 4

extern "C" {



extern int clone (int (*__fn) (void *__arg), void *__child_stack,
    int __flags, void *__arg, ...) throw ();


extern int unshare (int __flags) throw ();


extern int sched_getcpu (void) throw ();


extern int getcpu (unsigned int *, unsigned int *) throw ();


extern int setns (int __fd, int __nstype) throw ();


}
# 44 "/usr/include/sched.h" 2 3 4
# 1 "/usr/include/bits/cpu-set.h" 1 3 4
# 32 "/usr/include/bits/cpu-set.h" 3 4
typedef unsigned long int __cpu_mask;






typedef struct
{
  __cpu_mask __bits[1024 / (8 * sizeof (__cpu_mask))];
} cpu_set_t;
# 115 "/usr/include/bits/cpu-set.h" 3 4
extern "C" {

extern int __sched_cpucount (size_t __setsize, const cpu_set_t *__setp)
     throw ();
extern cpu_set_t *__sched_cpualloc (size_t __count) throw () ;
extern void __sched_cpufree (cpu_set_t *__set) throw ();

}
# 45 "/usr/include/sched.h" 2 3 4






extern "C" {


extern int sched_setparam (__pid_t __pid, const struct sched_param *__param)
     throw ();


extern int sched_getparam (__pid_t __pid, struct sched_param *__param) throw ();


extern int sched_setscheduler (__pid_t __pid, int __policy,
          const struct sched_param *__param) throw ();


extern int sched_getscheduler (__pid_t __pid) throw ();


extern int sched_yield (void) throw ();


extern int sched_get_priority_max (int __algorithm) throw ();


extern int sched_get_priority_min (int __algorithm) throw ();


extern int sched_rr_get_interval (__pid_t __pid, struct timespec *__t) throw ();
# 121 "/usr/include/sched.h" 3 4
extern int sched_setaffinity (__pid_t __pid, size_t __cpusetsize,
         const cpu_set_t *__cpuset) throw ();


extern int sched_getaffinity (__pid_t __pid, size_t __cpusetsize,
         cpu_set_t *__cpuset) throw ();


}
# 23 "/usr/include/pthread.h" 2 3 4




# 1 "/usr/include/bits/setjmp.h" 1 3 4
# 26 "/usr/include/bits/setjmp.h" 3 4
# 1 "/usr/include/bits/wordsize.h" 1 3 4
# 27 "/usr/include/bits/setjmp.h" 2 3 4




typedef long int __jmp_buf[8];
# 28 "/usr/include/pthread.h" 2 3 4
# 1 "/usr/include/bits/wordsize.h" 1 3 4
# 29 "/usr/include/pthread.h" 2 3 4





enum
{
  PTHREAD_CREATE_JOINABLE,

  PTHREAD_CREATE_DETACHED

};



enum
{
  PTHREAD_MUTEX_TIMED_NP,
  PTHREAD_MUTEX_RECURSIVE_NP,
  PTHREAD_MUTEX_ERRORCHECK_NP,
  PTHREAD_MUTEX_ADAPTIVE_NP

  ,
  PTHREAD_MUTEX_NORMAL = PTHREAD_MUTEX_TIMED_NP,
  PTHREAD_MUTEX_RECURSIVE = PTHREAD_MUTEX_RECURSIVE_NP,
  PTHREAD_MUTEX_ERRORCHECK = PTHREAD_MUTEX_ERRORCHECK_NP,
  PTHREAD_MUTEX_DEFAULT = PTHREAD_MUTEX_NORMAL



  , PTHREAD_MUTEX_FAST_NP = PTHREAD_MUTEX_TIMED_NP

};




enum
{
  PTHREAD_MUTEX_STALLED,
  PTHREAD_MUTEX_STALLED_NP = PTHREAD_MUTEX_STALLED,
  PTHREAD_MUTEX_ROBUST,
  PTHREAD_MUTEX_ROBUST_NP = PTHREAD_MUTEX_ROBUST
};





enum
{
  PTHREAD_PRIO_NONE,
  PTHREAD_PRIO_INHERIT,
  PTHREAD_PRIO_PROTECT
};
# 101 "/usr/include/pthread.h" 3 4
enum
{
  PTHREAD_RWLOCK_PREFER_READER_NP,
  PTHREAD_RWLOCK_PREFER_WRITER_NP,
  PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP,
  PTHREAD_RWLOCK_DEFAULT_NP = PTHREAD_RWLOCK_PREFER_READER_NP
};
# 121 "/usr/include/pthread.h" 3 4
enum
{
  PTHREAD_INHERIT_SCHED,

  PTHREAD_EXPLICIT_SCHED

};



enum
{
  PTHREAD_SCOPE_SYSTEM,

  PTHREAD_SCOPE_PROCESS

};



enum
{
  PTHREAD_PROCESS_PRIVATE,

  PTHREAD_PROCESS_SHARED

};
# 156 "/usr/include/pthread.h" 3 4
struct _pthread_cleanup_buffer
{
  void (*__routine) (void *);
  void *__arg;
  int __canceltype;
  struct _pthread_cleanup_buffer *__prev;
};


enum
{
  PTHREAD_CANCEL_ENABLE,

  PTHREAD_CANCEL_DISABLE

};
enum
{
  PTHREAD_CANCEL_DEFERRED,

  PTHREAD_CANCEL_ASYNCHRONOUS

};
# 194 "/usr/include/pthread.h" 3 4
extern "C" {




extern int pthread_create (pthread_t *__restrict __newthread,
      const pthread_attr_t *__restrict __attr,
      void *(*__start_routine) (void *),
      void *__restrict __arg) throw () __attribute__ ((__nonnull__ (1, 3)));





extern void pthread_exit (void *__retval) __attribute__ ((__noreturn__));







extern int pthread_join (pthread_t __th, void **__thread_return);




extern int pthread_tryjoin_np (pthread_t __th, void **__thread_return) throw ();







extern int pthread_timedjoin_np (pthread_t __th, void **__thread_return,
     const struct timespec *__abstime);
# 239 "/usr/include/pthread.h" 3 4
extern int pthread_clockjoin_np (pthread_t __th, void **__thread_return,
                                 clockid_t __clockid,
     const struct timespec *__abstime);






extern int pthread_detach (pthread_t __th) throw ();



extern pthread_t pthread_self (void) throw () __attribute__ ((__const__));


extern int pthread_equal (pthread_t __thread1, pthread_t __thread2)
  throw () __attribute__ ((__const__));







extern int pthread_attr_init (pthread_attr_t *__attr) throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_attr_destroy (pthread_attr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_attr_getdetachstate (const pthread_attr_t *__attr,
     int *__detachstate)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setdetachstate (pthread_attr_t *__attr,
     int __detachstate)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_attr_getguardsize (const pthread_attr_t *__attr,
          size_t *__guardsize)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setguardsize (pthread_attr_t *__attr,
          size_t __guardsize)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_attr_getschedparam (const pthread_attr_t *__restrict __attr,
           struct sched_param *__restrict __param)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setschedparam (pthread_attr_t *__restrict __attr,
           const struct sched_param *__restrict
           __param) throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_getschedpolicy (const pthread_attr_t *__restrict
     __attr, int *__restrict __policy)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setschedpolicy (pthread_attr_t *__attr, int __policy)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_attr_getinheritsched (const pthread_attr_t *__restrict
      __attr, int *__restrict __inherit)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setinheritsched (pthread_attr_t *__attr,
      int __inherit)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_attr_getscope (const pthread_attr_t *__restrict __attr,
      int *__restrict __scope)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setscope (pthread_attr_t *__attr, int __scope)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_attr_getstackaddr (const pthread_attr_t *__restrict
          __attr, void **__restrict __stackaddr)
     throw () __attribute__ ((__nonnull__ (1, 2))) __attribute__ ((__deprecated__));





extern int pthread_attr_setstackaddr (pthread_attr_t *__attr,
          void *__stackaddr)
     throw () __attribute__ ((__nonnull__ (1))) __attribute__ ((__deprecated__));


extern int pthread_attr_getstacksize (const pthread_attr_t *__restrict
          __attr, size_t *__restrict __stacksize)
     throw () __attribute__ ((__nonnull__ (1, 2)));




extern int pthread_attr_setstacksize (pthread_attr_t *__attr,
          size_t __stacksize)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_attr_getstack (const pthread_attr_t *__restrict __attr,
      void **__restrict __stackaddr,
      size_t *__restrict __stacksize)
     throw () __attribute__ ((__nonnull__ (1, 2, 3)));




extern int pthread_attr_setstack (pthread_attr_t *__attr, void *__stackaddr,
      size_t __stacksize) throw () __attribute__ ((__nonnull__ (1)));





extern int pthread_attr_setaffinity_np (pthread_attr_t *__attr,
     size_t __cpusetsize,
     const cpu_set_t *__cpuset)
     throw () __attribute__ ((__nonnull__ (1, 3)));



extern int pthread_attr_getaffinity_np (const pthread_attr_t *__attr,
     size_t __cpusetsize,
     cpu_set_t *__cpuset)
     throw () __attribute__ ((__nonnull__ (1, 3)));


extern int pthread_getattr_default_np (pthread_attr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_attr_setsigmask_np (pthread_attr_t *__attr,
           const __sigset_t *sigmask);




extern int pthread_attr_getsigmask_np (const pthread_attr_t *__attr,
           __sigset_t *sigmask);







extern int pthread_setattr_default_np (const pthread_attr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));




extern int pthread_getattr_np (pthread_t __th, pthread_attr_t *__attr)
     throw () __attribute__ ((__nonnull__ (2)));







extern int pthread_setschedparam (pthread_t __target_thread, int __policy,
      const struct sched_param *__param)
     throw () __attribute__ ((__nonnull__ (3)));


extern int pthread_getschedparam (pthread_t __target_thread,
      int *__restrict __policy,
      struct sched_param *__restrict __param)
     throw () __attribute__ ((__nonnull__ (2, 3)));


extern int pthread_setschedprio (pthread_t __target_thread, int __prio)
     throw ();




extern int pthread_getname_np (pthread_t __target_thread, char *__buf,
          size_t __buflen)
     throw () __attribute__ ((__nonnull__ (2)));


extern int pthread_setname_np (pthread_t __target_thread, const char *__name)
     throw () __attribute__ ((__nonnull__ (2)));





extern int pthread_getconcurrency (void) throw ();


extern int pthread_setconcurrency (int __level) throw ();







extern int pthread_yield (void) throw ();




extern int pthread_setaffinity_np (pthread_t __th, size_t __cpusetsize,
       const cpu_set_t *__cpuset)
     throw () __attribute__ ((__nonnull__ (3)));


extern int pthread_getaffinity_np (pthread_t __th, size_t __cpusetsize,
       cpu_set_t *__cpuset)
     throw () __attribute__ ((__nonnull__ (3)));
# 485 "/usr/include/pthread.h" 3 4
extern int pthread_once (pthread_once_t *__once_control,
    void (*__init_routine) (void)) __attribute__ ((__nonnull__ (1, 2)));
# 497 "/usr/include/pthread.h" 3 4
extern int pthread_setcancelstate (int __state, int *__oldstate);



extern int pthread_setcanceltype (int __type, int *__oldtype);


extern int pthread_cancel (pthread_t __th);




extern void pthread_testcancel (void);




typedef struct
{
  struct
  {
    __jmp_buf __cancel_jmp_buf;
    int __mask_was_saved;
  } __cancel_jmp_buf[1];
  void *__pad[4];
} __pthread_unwind_buf_t __attribute__ ((__aligned__));
# 531 "/usr/include/pthread.h" 3 4
struct __pthread_cleanup_frame
{
  void (*__cancel_routine) (void *);
  void *__cancel_arg;
  int __do_it;
  int __cancel_type;
};




class __pthread_cleanup_class
{
  void (*__cancel_routine) (void *);
  void *__cancel_arg;
  int __do_it;
  int __cancel_type;

 public:
  __pthread_cleanup_class (void (*__fct) (void *), void *__arg)
    : __cancel_routine (__fct), __cancel_arg (__arg), __do_it (1) { }
  ~__pthread_cleanup_class () { if (__do_it) __cancel_routine (__cancel_arg); }
  void __setdoit (int __newval) { __do_it = __newval; }
  void __defer () { pthread_setcanceltype (PTHREAD_CANCEL_DEFERRED,
        &__cancel_type); }
  void __restore () const { pthread_setcanceltype (__cancel_type, 0); }
};
# 733 "/usr/include/pthread.h" 3 4
struct __jmp_buf_tag;
extern int __sigsetjmp (struct __jmp_buf_tag *__env, int __savemask) throw ();





extern int pthread_mutex_init (pthread_mutex_t *__mutex,
          const pthread_mutexattr_t *__mutexattr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_mutex_destroy (pthread_mutex_t *__mutex)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_mutex_trylock (pthread_mutex_t *__mutex)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_mutex_lock (pthread_mutex_t *__mutex)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_mutex_timedlock (pthread_mutex_t *__restrict __mutex,
        const struct timespec *__restrict
        __abstime) throw () __attribute__ ((__nonnull__ (1, 2)));



extern int pthread_mutex_clocklock (pthread_mutex_t *__restrict __mutex,
        clockid_t __clockid,
        const struct timespec *__restrict
        __abstime) throw () __attribute__ ((__nonnull__ (1, 3)));



extern int pthread_mutex_unlock (pthread_mutex_t *__mutex)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_mutex_getprioceiling (const pthread_mutex_t *
      __restrict __mutex,
      int *__restrict __prioceiling)
     throw () __attribute__ ((__nonnull__ (1, 2)));



extern int pthread_mutex_setprioceiling (pthread_mutex_t *__restrict __mutex,
      int __prioceiling,
      int *__restrict __old_ceiling)
     throw () __attribute__ ((__nonnull__ (1, 3)));




extern int pthread_mutex_consistent (pthread_mutex_t *__mutex)
     throw () __attribute__ ((__nonnull__ (1)));

extern int pthread_mutex_consistent_np (pthread_mutex_t *__mutex)
     throw () __attribute__ ((__nonnull__ (1)));
# 804 "/usr/include/pthread.h" 3 4
extern int pthread_mutexattr_init (pthread_mutexattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_mutexattr_destroy (pthread_mutexattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_mutexattr_getpshared (const pthread_mutexattr_t *
      __restrict __attr,
      int *__restrict __pshared)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_mutexattr_setpshared (pthread_mutexattr_t *__attr,
      int __pshared)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_mutexattr_gettype (const pthread_mutexattr_t *__restrict
          __attr, int *__restrict __kind)
     throw () __attribute__ ((__nonnull__ (1, 2)));




extern int pthread_mutexattr_settype (pthread_mutexattr_t *__attr, int __kind)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_mutexattr_getprotocol (const pthread_mutexattr_t *
       __restrict __attr,
       int *__restrict __protocol)
     throw () __attribute__ ((__nonnull__ (1, 2)));



extern int pthread_mutexattr_setprotocol (pthread_mutexattr_t *__attr,
       int __protocol)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_mutexattr_getprioceiling (const pthread_mutexattr_t *
          __restrict __attr,
          int *__restrict __prioceiling)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_mutexattr_setprioceiling (pthread_mutexattr_t *__attr,
          int __prioceiling)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_mutexattr_getrobust (const pthread_mutexattr_t *__attr,
     int *__robustness)
     throw () __attribute__ ((__nonnull__ (1, 2)));

extern int pthread_mutexattr_getrobust_np (const pthread_mutexattr_t *__attr,
        int *__robustness)
     throw () __attribute__ ((__nonnull__ (1, 2)));



extern int pthread_mutexattr_setrobust (pthread_mutexattr_t *__attr,
     int __robustness)
     throw () __attribute__ ((__nonnull__ (1)));

extern int pthread_mutexattr_setrobust_np (pthread_mutexattr_t *__attr,
        int __robustness)
     throw () __attribute__ ((__nonnull__ (1)));
# 886 "/usr/include/pthread.h" 3 4
extern int pthread_rwlock_init (pthread_rwlock_t *__restrict __rwlock,
    const pthread_rwlockattr_t *__restrict
    __attr) throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlock_destroy (pthread_rwlock_t *__rwlock)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlock_rdlock (pthread_rwlock_t *__rwlock)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlock_tryrdlock (pthread_rwlock_t *__rwlock)
  throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_rwlock_timedrdlock (pthread_rwlock_t *__restrict __rwlock,
           const struct timespec *__restrict
           __abstime) throw () __attribute__ ((__nonnull__ (1, 2)));



extern int pthread_rwlock_clockrdlock (pthread_rwlock_t *__restrict __rwlock,
           clockid_t __clockid,
           const struct timespec *__restrict
           __abstime) throw () __attribute__ ((__nonnull__ (1, 3)));



extern int pthread_rwlock_wrlock (pthread_rwlock_t *__rwlock)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlock_trywrlock (pthread_rwlock_t *__rwlock)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_rwlock_timedwrlock (pthread_rwlock_t *__restrict __rwlock,
           const struct timespec *__restrict
           __abstime) throw () __attribute__ ((__nonnull__ (1, 2)));



extern int pthread_rwlock_clockwrlock (pthread_rwlock_t *__restrict __rwlock,
           clockid_t __clockid,
           const struct timespec *__restrict
           __abstime) throw () __attribute__ ((__nonnull__ (1, 3)));



extern int pthread_rwlock_unlock (pthread_rwlock_t *__rwlock)
     throw () __attribute__ ((__nonnull__ (1)));





extern int pthread_rwlockattr_init (pthread_rwlockattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlockattr_destroy (pthread_rwlockattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlockattr_getpshared (const pthread_rwlockattr_t *
       __restrict __attr,
       int *__restrict __pshared)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_rwlockattr_setpshared (pthread_rwlockattr_t *__attr,
       int __pshared)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlockattr_getkind_np (const pthread_rwlockattr_t *
       __restrict __attr,
       int *__restrict __pref)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_rwlockattr_setkind_np (pthread_rwlockattr_t *__attr,
       int __pref) throw () __attribute__ ((__nonnull__ (1)));







extern int pthread_cond_init (pthread_cond_t *__restrict __cond,
         const pthread_condattr_t *__restrict __cond_attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_cond_destroy (pthread_cond_t *__cond)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_cond_signal (pthread_cond_t *__cond)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_cond_broadcast (pthread_cond_t *__cond)
     throw () __attribute__ ((__nonnull__ (1)));






extern int pthread_cond_wait (pthread_cond_t *__restrict __cond,
         pthread_mutex_t *__restrict __mutex)
     __attribute__ ((__nonnull__ (1, 2)));
# 1012 "/usr/include/pthread.h" 3 4
extern int pthread_cond_timedwait (pthread_cond_t *__restrict __cond,
       pthread_mutex_t *__restrict __mutex,
       const struct timespec *__restrict __abstime)
     __attribute__ ((__nonnull__ (1, 2, 3)));
# 1025 "/usr/include/pthread.h" 3 4
extern int pthread_cond_clockwait (pthread_cond_t *__restrict __cond,
       pthread_mutex_t *__restrict __mutex,
       __clockid_t __clock_id,
       const struct timespec *__restrict __abstime)
     __attribute__ ((__nonnull__ (1, 2, 4)));





extern int pthread_condattr_init (pthread_condattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_condattr_destroy (pthread_condattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_condattr_getpshared (const pthread_condattr_t *
     __restrict __attr,
     int *__restrict __pshared)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_condattr_setpshared (pthread_condattr_t *__attr,
     int __pshared) throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_condattr_getclock (const pthread_condattr_t *
          __restrict __attr,
          __clockid_t *__restrict __clock_id)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_condattr_setclock (pthread_condattr_t *__attr,
          __clockid_t __clock_id)
     throw () __attribute__ ((__nonnull__ (1)));
# 1071 "/usr/include/pthread.h" 3 4
extern int pthread_spin_init (pthread_spinlock_t *__lock, int __pshared)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_spin_destroy (pthread_spinlock_t *__lock)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_spin_lock (pthread_spinlock_t *__lock)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_spin_trylock (pthread_spinlock_t *__lock)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_spin_unlock (pthread_spinlock_t *__lock)
     throw () __attribute__ ((__nonnull__ (1)));






extern int pthread_barrier_init (pthread_barrier_t *__restrict __barrier,
     const pthread_barrierattr_t *__restrict
     __attr, unsigned int __count)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_barrier_destroy (pthread_barrier_t *__barrier)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_barrier_wait (pthread_barrier_t *__barrier)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_barrierattr_init (pthread_barrierattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_barrierattr_destroy (pthread_barrierattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_barrierattr_getpshared (const pthread_barrierattr_t *
        __restrict __attr,
        int *__restrict __pshared)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_barrierattr_setpshared (pthread_barrierattr_t *__attr,
        int __pshared)
     throw () __attribute__ ((__nonnull__ (1)));
# 1138 "/usr/include/pthread.h" 3 4
extern int pthread_key_create (pthread_key_t *__key,
          void (*__destr_function) (void *))
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_key_delete (pthread_key_t __key) throw ();


extern void *pthread_getspecific (pthread_key_t __key) throw ();


extern int pthread_setspecific (pthread_key_t __key,
    const void *__pointer) throw () ;




extern int pthread_getcpuclockid (pthread_t __thread_id,
      __clockid_t *__clock_id)
     throw () __attribute__ ((__nonnull__ (2)));
# 1172 "/usr/include/pthread.h" 3 4
extern int pthread_atfork (void (*__prepare) (void),
      void (*__parent) (void),
      void (*__child) (void)) throw ();
# 1186 "/usr/include/pthread.h" 3 4
}
# 36 "/usr/include/c++/10.2.0/x86_64-pc-linux-gnu/bits/gthr-default.h" 2 3
# 47 "/usr/include/c++/10.2.0/x86_64-pc-linux-gnu/bits/gthr-default.h" 3
typedef pthread_t __gthread_t;
typedef pthread_key_t __gthread_key_t;
typedef pthread_once_t __gthread_once_t;
typedef pthread_mutex_t __gthread_mutex_t;
typedef pthread_mutex_t __gthread_recursive_mutex_t;
typedef pthread_cond_t __gthread_cond_t;
typedef struct timespec __gthread_time_t;
# 102 "/usr/include/c++/10.2.0/x86_64-pc-linux-gnu/bits/gthr-default.h" 3
static __typeof(pthread_once) __gthrw_pthread_once __attribute__ ((__weakref__("pthread_once"), __copy__ (pthread_once)));
static __typeof(pthread_getspecific) __gthrw_pthread_getspecific __attribute__ ((__weakref__("pthread_getspecific"), __copy__ (pthread_getspecific)));
static __typeof(pthread_setspecific) __gthrw_pthread_setspecific __attribute__ ((__weakref__("pthread_setspecific"), __copy__ (pthread_setspecific)));

static __typeof(pthread_create) __gthrw_pthread_create __attribute__ ((__weakref__("pthread_create"), __copy__ (pthread_create)));
static __typeof(pthread_join) __gthrw_pthread_join __attribute__ ((__weakref__("pthread_join"), __copy__ (pthread_join)));
static __typeof(pthread_equal) __gthrw_pthread_equal __attribute__ ((__weakref__("pthread_equal"), __copy__ (pthread_equal)));
static __typeof(pthread_self) __gthrw_pthread_self __attribute__ ((__weakref__("pthread_self"), __copy__ (pthread_self)));
static __typeof(pthread_detach) __gthrw_pthread_detach __attribute__ ((__weakref__("pthread_detach"), __copy__ (pthread_detach)));

static __typeof(pthread_cancel) __gthrw_pthread_cancel __attribute__ ((__weakref__("pthread_cancel"), __copy__ (pthread_cancel)));

static __typeof(sched_yield) __gthrw_sched_yield __attribute__ ((__weakref__("sched_yield"), __copy__ (sched_yield)));

static __typeof(pthread_mutex_lock) __gthrw_pthread_mutex_lock __attribute__ ((__weakref__("pthread_mutex_lock"), __copy__ (pthread_mutex_lock)));
static __typeof(pthread_mutex_trylock) __gthrw_pthread_mutex_trylock __attribute__ ((__weakref__("pthread_mutex_trylock"), __copy__ (pthread_mutex_trylock)));

static __typeof(pthread_mutex_timedlock) __gthrw_pthread_mutex_timedlock __attribute__ ((__weakref__("pthread_mutex_timedlock"), __copy__ (pthread_mutex_timedlock)));

static __typeof(pthread_mutex_unlock) __gthrw_pthread_mutex_unlock __attribute__ ((__weakref__("pthread_mutex_unlock"), __copy__ (pthread_mutex_unlock)));
static __typeof(pthread_mutex_init) __gthrw_pthread_mutex_init __attribute__ ((__weakref__("pthread_mutex_init"), __copy__ (pthread_mutex_init)));
static __typeof(pthread_mutex_destroy) __gthrw_pthread_mutex_destroy __attribute__ ((__weakref__("pthread_mutex_destroy"), __copy__ (pthread_mutex_destroy)));

static __typeof(pthread_cond_init) __gthrw_pthread_cond_init __attribute__ ((__weakref__("pthread_cond_init"), __copy__ (pthread_cond_init)));
static __typeof(pthread_cond_broadcast) __gthrw_pthread_cond_broadcast __attribute__ ((__weakref__("pthread_cond_broadcast"), __copy__ (pthread_cond_broadcast)));
static __typeof(pthread_cond_signal) __gthrw_pthread_cond_signal __attribute__ ((__weakref__("pthread_cond_signal"), __copy__ (pthread_cond_signal)));
static __typeof(pthread_cond_wait) __gthrw_pthread_cond_wait __attribute__ ((__weakref__("pthread_cond_wait"), __copy__ (pthread_cond_wait)));
static __typeof(pthread_cond_timedwait) __gthrw_pthread_cond_timedwait __attribute__ ((__weakref__("pthread_cond_timedwait"), __copy__ (pthread_cond_timedwait)));
static __typeof(pthread_cond_destroy) __gthrw_pthread_cond_destroy __attribute__ ((__weakref__("pthread_cond_destroy"), __copy__ (pthread_cond_destroy)));

static __typeof(pthread_key_create) __gthrw_pthread_key_create __attribute__ ((__weakref__("pthread_key_create"), __copy__ (pthread_key_create)));
static __typeof(pthread_key_delete) __gthrw_pthread_key_delete __attribute__ ((__weakref__("pthread_key_delete"), __copy__ (pthread_key_delete)));
static __typeof(pthread_mutexattr_init) __gthrw_pthread_mutexattr_init __attribute__ ((__weakref__("pthread_mutexattr_init"), __copy__ (pthread_mutexattr_init)));
static __typeof(pthread_mutexattr_settype) __gthrw_pthread_mutexattr_settype __attribute__ ((__weakref__("pthread_mutexattr_settype"), __copy__ (pthread_mutexattr_settype)));
static __typeof(pthread_mutexattr_destroy) __gthrw_pthread_mutexattr_destroy __attribute__ ((__weakref__("pthread_mutexattr_destroy"), __copy__ (pthread_mutexattr_destroy)));
# 237 "/usr/include/c++/10.2.0/x86_64-pc-linux-gnu/bits/gthr-default.h" 3
static __typeof(pthread_key_create) __gthrw___pthread_key_create __attribute__ ((__weakref__("__pthread_key_create"), __copy__ (pthread_key_create)));
# 247 "/usr/include/c++/10.2.0/x86_64-pc-linux-gnu/bits/gthr-default.h" 3
static inline int
__gthread_active_p (void)
{
  static void *const __gthread_active_ptr
    = __extension__ (void *) &__gthrw___pthread_key_create;
  return __gthread_active_ptr != 0;
}
# 659 "/usr/include/c++/10.2.0/x86_64-pc-linux-gnu/bits/gthr-default.h" 3
static inline int
__gthread_create (__gthread_t *__threadid, void *(*__func) (void*),
    void *__args)
{
  return __gthrw_pthread_create (__threadid, __null, __func, __args);
}

static inline int
__gthread_join (__gthread_t __threadid, void **__value_ptr)
{
  return __gthrw_pthread_join (__threadid, __value_ptr);
}

static inline int
__gthread_detach (__gthread_t __threadid)
{
  return __gthrw_pthread_detach (__threadid);
}

static inline int
__gthread_equal (__gthread_t __t1, __gthread_t __t2)
{
  return __gthrw_pthread_equal (__t1, __t2);
}

static inline __gthread_t
__gthread_self (void)
{
  return __gthrw_pthread_self ();
}

static inline int
__gthread_yield (void)
{
  return __gthrw_sched_yield ();
}

static inline int
__gthread_once (__gthread_once_t *__once, void (*__func) (void))
{
  if (__gthread_active_p ())
    return __gthrw_pthread_once (__once, __func);
  else
    return -1;
}

static inline int
__gthread_key_create (__gthread_key_t *__key, void (*__dtor) (void *))
{
  return __gthrw_pthread_key_create (__key, __dtor);
}

static inline int
__gthread_key_delete (__gthread_key_t __key)
{
  return __gthrw_pthread_key_delete (__key);
}

static inline void *
__gthread_getspecific (__gthread_key_t __key)
{
  return __gthrw_pthread_getspecific (__key);
}

static inline int
__gthread_setspecific (__gthread_key_t __key, const void *__ptr)
{
  return __gthrw_pthread_setspecific (__key, __ptr);
}

static inline void
__gthread_mutex_init_function (__gthread_mutex_t *__mutex)
{
  if (__gthread_active_p ())
    __gthrw_pthread_mutex_init (__mutex, __null);
}

static inline int
__gthread_mutex_destroy (__gthread_mutex_t *__mutex)
{
  if (__gthread_active_p ())
    return __gthrw_pthread_mutex_destroy (__mutex);
  else
    return 0;
}

static inline int
__gthread_mutex_lock (__gthread_mutex_t *__mutex)
{
  if (__gthread_active_p ())
    return __gthrw_pthread_mutex_lock (__mutex);
  else
    return 0;
}

static inline int
__gthread_mutex_trylock (__gthread_mutex_t *__mutex)
{
  if (__gthread_active_p ())
    return __gthrw_pthread_mutex_trylock (__mutex);
  else
    return 0;
}


static inline int
__gthread_mutex_timedlock (__gthread_mutex_t *__mutex,
      const __gthread_time_t *__abs_timeout)
{
  if (__gthread_active_p ())
    return __gthrw_pthread_mutex_timedlock (__mutex, __abs_timeout);
  else
    return 0;
}


static inline int
__gthread_mutex_unlock (__gthread_mutex_t *__mutex)
{
  if (__gthread_active_p ())
    return __gthrw_pthread_mutex_unlock (__mutex);
  else
    return 0;
}
# 808 "/usr/include/c++/10.2.0/x86_64-pc-linux-gnu/bits/gthr-default.h" 3
static inline int
__gthread_recursive_mutex_lock (__gthread_recursive_mutex_t *__mutex)
{
  return __gthread_mutex_lock (__mutex);
}

static inline int
__gthread_recursive_mutex_trylock (__gthread_recursive_mutex_t *__mutex)
{
  return __gthread_mutex_trylock (__mutex);
}


static inline int
__gthread_recursive_mutex_timedlock (__gthread_recursive_mutex_t *__mutex,
         const __gthread_time_t *__abs_timeout)
{
  return __gthread_mutex_timedlock (__mutex, __abs_timeout);
}


static inline int
__gthread_recursive_mutex_unlock (__gthread_recursive_mutex_t *__mutex)
{
  return __gthread_mutex_unlock (__mutex);
}

static inline int
__gthread_recursive_mutex_destroy (__gthread_recursive_mutex_t *__mutex)
{
  return __gthread_mutex_destroy (__mutex);
}
# 850 "/usr/include/c++/10.2.0/x86_64-pc-linux-gnu/bits/gthr-default.h" 3
static inline int
__gthread_cond_broadcast (__gthread_cond_t *__cond)
{
  return __gthrw_pthread_cond_broadcast (__cond);
}

static inline int
__gthread_cond_signal (__gthread_cond_t *__cond)
{
  return __gthrw_pthread_cond_signal (__cond);
}

static inline int
__gthread_cond_wait (__gthread_cond_t *__cond, __gthread_mutex_t *__mutex)
{
  return __gthrw_pthread_cond_wait (__cond, __mutex);
}

static inline int
__gthread_cond_timedwait (__gthread_cond_t *__cond, __gthread_mutex_t *__mutex,
     const __gthread_time_t *__abs_timeout)
{
  return __gthrw_pthread_cond_timedwait (__cond, __mutex, __abs_timeout);
}

static inline int
__gthread_cond_wait_recursive (__gthread_cond_t *__cond,
          __gthread_recursive_mutex_t *__mutex)
{
  return __gthread_cond_wait (__cond, __mutex);
}

static inline int
__gthread_cond_destroy (__gthread_cond_t* __cond)
{
  return __gthrw_pthread_cond_destroy (__cond);
}
# 149 "/usr/include/c++/10.2.0/x86_64-pc-linux-gnu/bits/gthr.h" 2 3


#pragma GCC visibility pop
# 36 "/usr/include/c++/10.2.0/ext/atomicity.h" 2 3
# 1 "/usr/include/c++/10.2.0/x86_64-pc-linux-gnu/bits/atomic_word.h" 1 3
# 32 "/usr/include/c++/10.2.0/x86_64-pc-linux-gnu/bits/atomic_word.h" 3
typedef int _Atomic_word;
# 37 "/usr/include/c++/10.2.0/ext/atomicity.h" 2 3

namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{







  inline _Atomic_word
  __attribute__((__always_inline__))
  __exchange_and_add(volatile _Atomic_word* __mem, int __val)
  { return __atomic_fetch_add(__mem, __val, 4); }

  inline void
  __attribute__((__always_inline__))
  __atomic_add(volatile _Atomic_word* __mem, int __val)
  { __atomic_fetch_add(__mem, __val, 4); }
# 64 "/usr/include/c++/10.2.0/ext/atomicity.h" 3
  inline _Atomic_word
  __attribute__((__always_inline__))
  __exchange_and_add_single(_Atomic_word* __mem, int __val)
  {
    _Atomic_word __result = *__mem;
    *__mem += __val;
    return __result;
  }

  inline void
  __attribute__((__always_inline__))
  __atomic_add_single(_Atomic_word* __mem, int __val)
  { *__mem += __val; }

  inline _Atomic_word
  __attribute__ ((__always_inline__))
  __exchange_and_add_dispatch(_Atomic_word* __mem, int __val)
  {

    if (__gthread_active_p())
      return __exchange_and_add(__mem, __val);

    return __exchange_and_add_single(__mem, __val);
  }

  inline void
  __attribute__ ((__always_inline__))
  __atomic_add_dispatch(_Atomic_word* __mem, int __val)
  {

    if (__gthread_active_p())
      {
 __atomic_add(__mem, __val);
 return;
      }

    __atomic_add_single(__mem, __val);
  }


}
# 40 "/usr/include/c++/10.2.0/bits/ios_base.h" 2 3

# 1 "/usr/include/c++/10.2.0/bits/locale_classes.h" 1 3
# 37 "/usr/include/c++/10.2.0/bits/locale_classes.h" 3
       
# 38 "/usr/include/c++/10.2.0/bits/locale_classes.h" 3


# 1 "/usr/include/c++/10.2.0/string" 1 3
# 36 "/usr/include/c++/10.2.0/string" 3
       
# 37 "/usr/include/c++/10.2.0/string" 3




# 1 "/usr/include/c++/10.2.0/bits/allocator.h" 1 3
# 46 "/usr/include/c++/10.2.0/bits/allocator.h" 3
# 1 "/usr/include/c++/10.2.0/x86_64-pc-linux-gnu/bits/c++allocator.h" 1 3
# 33 "/usr/include/c++/10.2.0/x86_64-pc-linux-gnu/bits/c++allocator.h" 3
# 1 "/usr/include/c++/10.2.0/ext/new_allocator.h" 1 3
# 40 "/usr/include/c++/10.2.0/ext/new_allocator.h" 3
namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{

# 54 "/usr/include/c++/10.2.0/ext/new_allocator.h" 3
  template<typename _Tp>
    class new_allocator
    {
    public:
      typedef _Tp value_type;
      typedef std::size_t size_type;
      typedef std::ptrdiff_t difference_type;

      typedef _Tp* pointer;
      typedef const _Tp* const_pointer;
      typedef _Tp& reference;
      typedef const _Tp& const_reference;

      template<typename _Tp1>
 struct rebind
 { typedef new_allocator<_Tp1> other; };





      typedef std::true_type propagate_on_container_move_assignment;


     
      new_allocator() noexcept { }

     
      new_allocator(const new_allocator&) noexcept { }

      template<typename _Tp1>

 new_allocator(const new_allocator<_Tp1>&) noexcept { }


      ~new_allocator() noexcept { }

      pointer
      address(reference __x) const noexcept
      { return std::__addressof(__x); }

      const_pointer
      address(const_reference __x) const noexcept
      { return std::__addressof(__x); }




      _Tp*
      allocate(size_type __n, const void* = static_cast<const void*>(0))
      {
 if (__n > this->_M_max_size())
   std::__throw_bad_alloc();
# 115 "/usr/include/c++/10.2.0/ext/new_allocator.h" 3
 return static_cast<_Tp*>(::operator new(__n * sizeof(_Tp)));
      }


      void
      deallocate(_Tp* __p, size_type __t)
      {
# 133 "/usr/include/c++/10.2.0/ext/new_allocator.h" 3
 ::operator delete(__p



    );
      }


      size_type
      max_size() const noexcept
      { return _M_max_size(); }


      template<typename _Up, typename... _Args>
 void
 construct(_Up* __p, _Args&&... __args)
 noexcept(std::is_nothrow_constructible<_Up, _Args...>::value)
 { ::new((void *)__p) _Up(std::forward<_Args>(__args)...); }

      template<typename _Up>
 void
 destroy(_Up* __p)
 noexcept(std::is_nothrow_destructible<_Up>::value)
 { __p->~_Up(); }
# 169 "/usr/include/c++/10.2.0/ext/new_allocator.h" 3
      template<typename _Up>
 friend bool
 operator==(const new_allocator&, const new_allocator<_Up>&)
 noexcept
 { return true; }


      template<typename _Up>
 friend bool
 operator!=(const new_allocator&, const new_allocator<_Up>&)
 noexcept
 { return false; }


    private:
      constexpr size_type
      _M_max_size() const noexcept
      {

 return std::size_t(0x7fffffffffffffffL) / sizeof(_Tp);



      }
    };


}
# 34 "/usr/include/c++/10.2.0/x86_64-pc-linux-gnu/bits/c++allocator.h" 2 3


namespace std
{
# 47 "/usr/include/c++/10.2.0/x86_64-pc-linux-gnu/bits/c++allocator.h" 3
  template<typename _Tp>
    using __allocator_base = __gnu_cxx::new_allocator<_Tp>;
}
# 47 "/usr/include/c++/10.2.0/bits/allocator.h" 2 3







namespace std __attribute__ ((__visibility__ ("default")))
{








  template<>
    class allocator<void>
    {
    public:
      typedef void value_type;
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;

      typedef void* pointer;
      typedef const void* const_pointer;

      template<typename _Tp1>
 struct rebind
 { typedef allocator<_Tp1> other; };
# 89 "/usr/include/c++/10.2.0/bits/allocator.h" 3
      typedef true_type propagate_on_container_move_assignment;

      typedef true_type is_always_equal;

      template<typename _Up, typename... _Args>
 void
 construct(_Up* __p, _Args&&... __args)
 noexcept(std::is_nothrow_constructible<_Up, _Args...>::value)
 { ::new((void *)__p) _Up(std::forward<_Args>(__args)...); }

      template<typename _Up>
 void
 destroy(_Up* __p)
 noexcept(std::is_nothrow_destructible<_Up>::value)
 { __p->~_Up(); }

    };
# 115 "/usr/include/c++/10.2.0/bits/allocator.h" 3
  template<typename _Tp>
    class allocator : public __allocator_base<_Tp>
    {
    public:
      typedef _Tp value_type;
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;

      typedef _Tp* pointer;
      typedef const _Tp* const_pointer;
      typedef _Tp& reference;
      typedef const _Tp& const_reference;

      template<typename _Tp1>
 struct rebind
 { typedef allocator<_Tp1> other; };





      typedef true_type propagate_on_container_move_assignment;

      typedef true_type is_always_equal;




     
      allocator() noexcept { }

     
      allocator(const allocator& __a) noexcept
      : __allocator_base<_Tp>(__a) { }



      allocator& operator=(const allocator&) = default;


      template<typename _Tp1>

 allocator(const allocator<_Tp1>&) noexcept { }




      ~allocator() noexcept { }
# 191 "/usr/include/c++/10.2.0/bits/allocator.h" 3
      friend bool
      operator==(const allocator&, const allocator&) noexcept
      { return true; }


      friend bool
      operator!=(const allocator&, const allocator&) noexcept
      { return false; }



    };

  template<typename _T1, typename _T2>
    inline bool
    operator==(const allocator<_T1>&, const allocator<_T2>&)
    noexcept
    { return true; }


  template<typename _T1, typename _T2>
    inline bool
    operator!=(const allocator<_T1>&, const allocator<_T2>&)
    noexcept
    { return false; }




  template<typename _Tp>
    class allocator<const _Tp>
    {
    public:
      typedef _Tp value_type;
      template<typename _Up> allocator(const allocator<_Up>&) { }
    };

  template<typename _Tp>
    class allocator<volatile _Tp>
    {
    public:
      typedef _Tp value_type;
      template<typename _Up> allocator(const allocator<_Up>&) { }
    };

  template<typename _Tp>
    class allocator<const volatile _Tp>
    {
    public:
      typedef _Tp value_type;
      template<typename _Up> allocator(const allocator<_Up>&) { }
    };






  extern template class allocator<char>;
  extern template class allocator<wchar_t>;






  template<typename _Alloc, bool = __is_empty(_Alloc)>
    struct __alloc_swap
    { static void _S_do_it(_Alloc&, _Alloc&) noexcept { } };

  template<typename _Alloc>
    struct __alloc_swap<_Alloc, false>
    {
      static void
      _S_do_it(_Alloc& __one, _Alloc& __two) noexcept
      {

 if (__one != __two)
   swap(__one, __two);
      }
    };


  template<typename _Alloc, bool = __is_empty(_Alloc)>
    struct __alloc_neq
    {
      static bool
      _S_do_it(const _Alloc&, const _Alloc&)
      { return false; }
    };

  template<typename _Alloc>
    struct __alloc_neq<_Alloc, false>
    {
      static bool
      _S_do_it(const _Alloc& __one, const _Alloc& __two)
      { return __one != __two; }
    };


  template<typename _Tp, bool
    = __or_<is_copy_constructible<typename _Tp::value_type>,
            is_nothrow_move_constructible<typename _Tp::value_type>>::value>
    struct __shrink_to_fit_aux
    { static bool _S_do_it(_Tp&) noexcept { return false; } };

  template<typename _Tp>
    struct __shrink_to_fit_aux<_Tp, true>
    {
      static bool
      _S_do_it(_Tp& __c) noexcept
      {

 try
   {
     _Tp(__make_move_if_noexcept_iterator(__c.begin()),
  __make_move_if_noexcept_iterator(__c.end()),
  __c.get_allocator()).swap(__c);
     return true;
   }
 catch(...)
   { return false; }



      }
    };



}
# 42 "/usr/include/c++/10.2.0/string" 2 3


# 1 "/usr/include/c++/10.2.0/bits/ostream_insert.h" 1 3
# 33 "/usr/include/c++/10.2.0/bits/ostream_insert.h" 3
       
# 34 "/usr/include/c++/10.2.0/bits/ostream_insert.h" 3


# 1 "/usr/include/c++/10.2.0/bits/cxxabi_forced.h" 1 3
# 34 "/usr/include/c++/10.2.0/bits/cxxabi_forced.h" 3
       
# 35 "/usr/include/c++/10.2.0/bits/cxxabi_forced.h" 3

#pragma GCC visibility push(default)


namespace __cxxabiv1
{







  class __forced_unwind
  {
    virtual ~__forced_unwind() throw();


    virtual void __pure_dummy() = 0;
  };
}


#pragma GCC visibility pop
# 37 "/usr/include/c++/10.2.0/bits/ostream_insert.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _CharT, typename _Traits>
    inline void
    __ostream_write(basic_ostream<_CharT, _Traits>& __out,
      const _CharT* __s, streamsize __n)
    {
      typedef basic_ostream<_CharT, _Traits> __ostream_type;
      typedef typename __ostream_type::ios_base __ios_base;

      const streamsize __put = __out.rdbuf()->sputn(__s, __n);
      if (__put != __n)
 __out.setstate(__ios_base::badbit);
    }

  template<typename _CharT, typename _Traits>
    inline void
    __ostream_fill(basic_ostream<_CharT, _Traits>& __out, streamsize __n)
    {
      typedef basic_ostream<_CharT, _Traits> __ostream_type;
      typedef typename __ostream_type::ios_base __ios_base;

      const _CharT __c = __out.fill();
      for (; __n > 0; --__n)
 {
   const typename _Traits::int_type __put = __out.rdbuf()->sputc(__c);
   if (_Traits::eq_int_type(__put, _Traits::eof()))
     {
       __out.setstate(__ios_base::badbit);
       break;
     }
 }
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    __ostream_insert(basic_ostream<_CharT, _Traits>& __out,
       const _CharT* __s, streamsize __n)
    {
      typedef basic_ostream<_CharT, _Traits> __ostream_type;
      typedef typename __ostream_type::ios_base __ios_base;

      typename __ostream_type::sentry __cerb(__out);
      if (__cerb)
 {
   try
     {
       const streamsize __w = __out.width();
       if (__w > __n)
  {
    const bool __left = ((__out.flags()
     & __ios_base::adjustfield)
           == __ios_base::left);
    if (!__left)
      __ostream_fill(__out, __w - __n);
    if (__out.good())
      __ostream_write(__out, __s, __n);
    if (__left && __out.good())
      __ostream_fill(__out, __w - __n);
  }
       else
  __ostream_write(__out, __s, __n);
       __out.width(0);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       __out._M_setstate(__ios_base::badbit);
       throw;
     }
   catch(...)
     { __out._M_setstate(__ios_base::badbit); }
 }
      return __out;
    }




  extern template ostream& __ostream_insert(ostream&, const char*, streamsize);


  extern template wostream& __ostream_insert(wostream&, const wchar_t*,
          streamsize);




}
# 45 "/usr/include/c++/10.2.0/string" 2 3



# 1 "/usr/include/c++/10.2.0/bits/stl_function.h" 1 3
# 63 "/usr/include/c++/10.2.0/bits/stl_function.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{

# 104 "/usr/include/c++/10.2.0/bits/stl_function.h" 3
  template<typename _Arg, typename _Result>
    struct unary_function
    {

      typedef _Arg argument_type;


      typedef _Result result_type;
    };




  template<typename _Arg1, typename _Arg2, typename _Result>
    struct binary_function
    {

      typedef _Arg1 first_argument_type;


      typedef _Arg2 second_argument_type;


      typedef _Result result_type;
    };
# 166 "/usr/include/c++/10.2.0/bits/stl_function.h" 3
  template<typename _Tp>
    struct plus : public binary_function<_Tp, _Tp, _Tp>
    {
     
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x + __y; }
    };


  template<typename _Tp>
    struct minus : public binary_function<_Tp, _Tp, _Tp>
    {
     
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x - __y; }
    };


  template<typename _Tp>
    struct multiplies : public binary_function<_Tp, _Tp, _Tp>
    {
     
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x * __y; }
    };


  template<typename _Tp>
    struct divides : public binary_function<_Tp, _Tp, _Tp>
    {
     
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x / __y; }
    };


  template<typename _Tp>
    struct modulus : public binary_function<_Tp, _Tp, _Tp>
    {
     
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x % __y; }
    };


  template<typename _Tp>
    struct negate : public unary_function<_Tp, _Tp>
    {
     
      _Tp
      operator()(const _Tp& __x) const
      { return -__x; }
    };
# 350 "/usr/include/c++/10.2.0/bits/stl_function.h" 3
  template<typename _Tp>
    struct equal_to : public binary_function<_Tp, _Tp, bool>
    {
     
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x == __y; }
    };


  template<typename _Tp>
    struct not_equal_to : public binary_function<_Tp, _Tp, bool>
    {
     
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x != __y; }
    };


  template<typename _Tp>
    struct greater : public binary_function<_Tp, _Tp, bool>
    {
     
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x > __y; }
    };


  template<typename _Tp>
    struct less : public binary_function<_Tp, _Tp, bool>
    {
     
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x < __y; }
    };


  template<typename _Tp>
    struct greater_equal : public binary_function<_Tp, _Tp, bool>
    {
     
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x >= __y; }
    };


  template<typename _Tp>
    struct less_equal : public binary_function<_Tp, _Tp, bool>
    {
     
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x <= __y; }
    };


  template<typename _Tp>
    struct greater<_Tp*> : public binary_function<_Tp*, _Tp*, bool>
    {
      bool
      operator()(_Tp* __x, _Tp* __y) const noexcept
      {
# 424 "/usr/include/c++/10.2.0/bits/stl_function.h" 3
 return (long unsigned int)__x > (long unsigned int)__y;
      }
    };


  template<typename _Tp>
    struct less<_Tp*> : public binary_function<_Tp*, _Tp*, bool>
    {
      bool
      operator()(_Tp* __x, _Tp* __y) const noexcept
      {
# 443 "/usr/include/c++/10.2.0/bits/stl_function.h" 3
 return (long unsigned int)__x < (long unsigned int)__y;
      }
    };


  template<typename _Tp>
    struct greater_equal<_Tp*> : public binary_function<_Tp*, _Tp*, bool>
    {
      bool
      operator()(_Tp* __x, _Tp* __y) const noexcept
      {
# 462 "/usr/include/c++/10.2.0/bits/stl_function.h" 3
 return (long unsigned int)__x >= (long unsigned int)__y;
      }
    };


  template<typename _Tp>
    struct less_equal<_Tp*> : public binary_function<_Tp*, _Tp*, bool>
    {
      bool
      operator()(_Tp* __x, _Tp* __y) const noexcept
      {
# 481 "/usr/include/c++/10.2.0/bits/stl_function.h" 3
 return (long unsigned int)__x <= (long unsigned int)__y;
      }
    };
# 785 "/usr/include/c++/10.2.0/bits/stl_function.h" 3
  template<typename _Tp>
    struct logical_and : public binary_function<_Tp, _Tp, bool>
    {
     
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x && __y; }
    };


  template<typename _Tp>
    struct logical_or : public binary_function<_Tp, _Tp, bool>
    {
     
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x || __y; }
    };


  template<typename _Tp>
    struct logical_not : public unary_function<_Tp, bool>
    {
     
      bool
      operator()(const _Tp& __x) const
      { return !__x; }
    };
# 878 "/usr/include/c++/10.2.0/bits/stl_function.h" 3
  template<typename _Tp>
    struct bit_and : public binary_function<_Tp, _Tp, _Tp>
    {
     
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x & __y; }
    };

  template<typename _Tp>
    struct bit_or : public binary_function<_Tp, _Tp, _Tp>
    {
     
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x | __y; }
    };

  template<typename _Tp>
    struct bit_xor : public binary_function<_Tp, _Tp, _Tp>
    {
     
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x ^ __y; }
    };

  template<typename _Tp>
    struct bit_not : public unary_function<_Tp, _Tp>
    {
   
      _Tp
      operator()(const _Tp& __x) const
      { return ~__x; }
    };
# 1002 "/usr/include/c++/10.2.0/bits/stl_function.h" 3
  template<typename _Predicate>
    class unary_negate
    : public unary_function<typename _Predicate::argument_type, bool>
    {
    protected:
      _Predicate _M_pred;

    public:
     
      explicit
      unary_negate(const _Predicate& __x) : _M_pred(__x) { }

     
      bool
      operator()(const typename _Predicate::argument_type& __x) const
      { return !_M_pred(__x); }
    };


  template<typename _Predicate>
   
    inline unary_negate<_Predicate>
    not1(const _Predicate& __pred)
    { return unary_negate<_Predicate>(__pred); }


  template<typename _Predicate>
    class binary_negate
    : public binary_function<typename _Predicate::first_argument_type,
        typename _Predicate::second_argument_type, bool>
    {
    protected:
      _Predicate _M_pred;

    public:
     
      explicit
      binary_negate(const _Predicate& __x) : _M_pred(__x) { }

     
      bool
      operator()(const typename _Predicate::first_argument_type& __x,
   const typename _Predicate::second_argument_type& __y) const
      { return !_M_pred(__x, __y); }
    };


  template<typename _Predicate>
   
    inline binary_negate<_Predicate>
    not2(const _Predicate& __pred)
    { return binary_negate<_Predicate>(__pred); }
# 1079 "/usr/include/c++/10.2.0/bits/stl_function.h" 3
  template<typename _Arg, typename _Result>
    class pointer_to_unary_function : public unary_function<_Arg, _Result>
    {
    protected:
      _Result (*_M_ptr)(_Arg);

    public:
      pointer_to_unary_function() { }

      explicit
      pointer_to_unary_function(_Result (*__x)(_Arg))
      : _M_ptr(__x) { }

      _Result
      operator()(_Arg __x) const
      { return _M_ptr(__x); }
    };


  template<typename _Arg, typename _Result>
    inline pointer_to_unary_function<_Arg, _Result>
    ptr_fun(_Result (*__x)(_Arg))
    { return pointer_to_unary_function<_Arg, _Result>(__x); }


  template<typename _Arg1, typename _Arg2, typename _Result>
    class pointer_to_binary_function
    : public binary_function<_Arg1, _Arg2, _Result>
    {
    protected:
      _Result (*_M_ptr)(_Arg1, _Arg2);

    public:
      pointer_to_binary_function() { }

      explicit
      pointer_to_binary_function(_Result (*__x)(_Arg1, _Arg2))
      : _M_ptr(__x) { }

      _Result
      operator()(_Arg1 __x, _Arg2 __y) const
      { return _M_ptr(__x, __y); }
    };


  template<typename _Arg1, typename _Arg2, typename _Result>
    inline pointer_to_binary_function<_Arg1, _Arg2, _Result>
    ptr_fun(_Result (*__x)(_Arg1, _Arg2))
    { return pointer_to_binary_function<_Arg1, _Arg2, _Result>(__x); }


  template<typename _Tp>
    struct _Identity
    : public unary_function<_Tp, _Tp>
    {
      _Tp&
      operator()(_Tp& __x) const
      { return __x; }

      const _Tp&
      operator()(const _Tp& __x) const
      { return __x; }
    };


  template<typename _Tp> struct _Identity<const _Tp> : _Identity<_Tp> { };

  template<typename _Pair>
    struct _Select1st
    : public unary_function<_Pair, typename _Pair::first_type>
    {
      typename _Pair::first_type&
      operator()(_Pair& __x) const
      { return __x.first; }

      const typename _Pair::first_type&
      operator()(const _Pair& __x) const
      { return __x.first; }


      template<typename _Pair2>
        typename _Pair2::first_type&
        operator()(_Pair2& __x) const
        { return __x.first; }

      template<typename _Pair2>
        const typename _Pair2::first_type&
        operator()(const _Pair2& __x) const
        { return __x.first; }

    };

  template<typename _Pair>
    struct _Select2nd
    : public unary_function<_Pair, typename _Pair::second_type>
    {
      typename _Pair::second_type&
      operator()(_Pair& __x) const
      { return __x.second; }

      const typename _Pair::second_type&
      operator()(const _Pair& __x) const
      { return __x.second; }
    };
# 1202 "/usr/include/c++/10.2.0/bits/stl_function.h" 3
  template<typename _Ret, typename _Tp>
    class mem_fun_t : public unary_function<_Tp*, _Ret>
    {
    public:
      explicit
      mem_fun_t(_Ret (_Tp::*__pf)())
      : _M_f(__pf) { }

      _Ret
      operator()(_Tp* __p) const
      { return (__p->*_M_f)(); }

    private:
      _Ret (_Tp::*_M_f)();
    };



  template<typename _Ret, typename _Tp>
    class const_mem_fun_t : public unary_function<const _Tp*, _Ret>
    {
    public:
      explicit
      const_mem_fun_t(_Ret (_Tp::*__pf)() const)
      : _M_f(__pf) { }

      _Ret
      operator()(const _Tp* __p) const
      { return (__p->*_M_f)(); }

    private:
      _Ret (_Tp::*_M_f)() const;
    };



  template<typename _Ret, typename _Tp>
    class mem_fun_ref_t : public unary_function<_Tp, _Ret>
    {
    public:
      explicit
      mem_fun_ref_t(_Ret (_Tp::*__pf)())
      : _M_f(__pf) { }

      _Ret
      operator()(_Tp& __r) const
      { return (__r.*_M_f)(); }

    private:
      _Ret (_Tp::*_M_f)();
  };



  template<typename _Ret, typename _Tp>
    class const_mem_fun_ref_t : public unary_function<_Tp, _Ret>
    {
    public:
      explicit
      const_mem_fun_ref_t(_Ret (_Tp::*__pf)() const)
      : _M_f(__pf) { }

      _Ret
      operator()(const _Tp& __r) const
      { return (__r.*_M_f)(); }

    private:
      _Ret (_Tp::*_M_f)() const;
    };



  template<typename _Ret, typename _Tp, typename _Arg>
    class mem_fun1_t : public binary_function<_Tp*, _Arg, _Ret>
    {
    public:
      explicit
      mem_fun1_t(_Ret (_Tp::*__pf)(_Arg))
      : _M_f(__pf) { }

      _Ret
      operator()(_Tp* __p, _Arg __x) const
      { return (__p->*_M_f)(__x); }

    private:
      _Ret (_Tp::*_M_f)(_Arg);
    };



  template<typename _Ret, typename _Tp, typename _Arg>
    class const_mem_fun1_t : public binary_function<const _Tp*, _Arg, _Ret>
    {
    public:
      explicit
      const_mem_fun1_t(_Ret (_Tp::*__pf)(_Arg) const)
      : _M_f(__pf) { }

      _Ret
      operator()(const _Tp* __p, _Arg __x) const
      { return (__p->*_M_f)(__x); }

    private:
      _Ret (_Tp::*_M_f)(_Arg) const;
    };



  template<typename _Ret, typename _Tp, typename _Arg>
    class mem_fun1_ref_t : public binary_function<_Tp, _Arg, _Ret>
    {
    public:
      explicit
      mem_fun1_ref_t(_Ret (_Tp::*__pf)(_Arg))
      : _M_f(__pf) { }

      _Ret
      operator()(_Tp& __r, _Arg __x) const
      { return (__r.*_M_f)(__x); }

    private:
      _Ret (_Tp::*_M_f)(_Arg);
    };



  template<typename _Ret, typename _Tp, typename _Arg>
    class const_mem_fun1_ref_t : public binary_function<_Tp, _Arg, _Ret>
    {
    public:
      explicit
      const_mem_fun1_ref_t(_Ret (_Tp::*__pf)(_Arg) const)
      : _M_f(__pf) { }

      _Ret
      operator()(const _Tp& __r, _Arg __x) const
      { return (__r.*_M_f)(__x); }

    private:
      _Ret (_Tp::*_M_f)(_Arg) const;
    };



  template<typename _Ret, typename _Tp>
    inline mem_fun_t<_Ret, _Tp>
    mem_fun(_Ret (_Tp::*__f)())
    { return mem_fun_t<_Ret, _Tp>(__f); }

  template<typename _Ret, typename _Tp>
    inline const_mem_fun_t<_Ret, _Tp>
    mem_fun(_Ret (_Tp::*__f)() const)
    { return const_mem_fun_t<_Ret, _Tp>(__f); }

  template<typename _Ret, typename _Tp>
    inline mem_fun_ref_t<_Ret, _Tp>
    mem_fun_ref(_Ret (_Tp::*__f)())
    { return mem_fun_ref_t<_Ret, _Tp>(__f); }

  template<typename _Ret, typename _Tp>
    inline const_mem_fun_ref_t<_Ret, _Tp>
    mem_fun_ref(_Ret (_Tp::*__f)() const)
    { return const_mem_fun_ref_t<_Ret, _Tp>(__f); }

  template<typename _Ret, typename _Tp, typename _Arg>
    inline mem_fun1_t<_Ret, _Tp, _Arg>
    mem_fun(_Ret (_Tp::*__f)(_Arg))
    { return mem_fun1_t<_Ret, _Tp, _Arg>(__f); }

  template<typename _Ret, typename _Tp, typename _Arg>
    inline const_mem_fun1_t<_Ret, _Tp, _Arg>
    mem_fun(_Ret (_Tp::*__f)(_Arg) const)
    { return const_mem_fun1_t<_Ret, _Tp, _Arg>(__f); }

  template<typename _Ret, typename _Tp, typename _Arg>
    inline mem_fun1_ref_t<_Ret, _Tp, _Arg>
    mem_fun_ref(_Ret (_Tp::*__f)(_Arg))
    { return mem_fun1_ref_t<_Ret, _Tp, _Arg>(__f); }

  template<typename _Ret, typename _Tp, typename _Arg>
    inline const_mem_fun1_ref_t<_Ret, _Tp, _Arg>
    mem_fun_ref(_Ret (_Tp::*__f)(_Arg) const)
    { return const_mem_fun1_ref_t<_Ret, _Tp, _Arg>(__f); }




}


# 1 "/usr/include/c++/10.2.0/backward/binders.h" 1 3
# 60 "/usr/include/c++/10.2.0/backward/binders.h" 3
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"

namespace std __attribute__ ((__visibility__ ("default")))
{

# 107 "/usr/include/c++/10.2.0/backward/binders.h" 3
  template<typename _Operation>
    class binder1st
    : public unary_function<typename _Operation::second_argument_type,
       typename _Operation::result_type>
    {
    protected:
      _Operation op;
      typename _Operation::first_argument_type value;

    public:
      binder1st(const _Operation& __x,
  const typename _Operation::first_argument_type& __y)
      : op(__x), value(__y) { }

      typename _Operation::result_type
      operator()(const typename _Operation::second_argument_type& __x) const
      { return op(value, __x); }



      typename _Operation::result_type
      operator()(typename _Operation::second_argument_type& __x) const
      { return op(value, __x); }
    } __attribute__ ((__deprecated__));


  template<typename _Operation, typename _Tp>
    inline binder1st<_Operation>
    bind1st(const _Operation& __fn, const _Tp& __x)
    {
      typedef typename _Operation::first_argument_type _Arg1_type;
      return binder1st<_Operation>(__fn, _Arg1_type(__x));
    }


  template<typename _Operation>
    class binder2nd
    : public unary_function<typename _Operation::first_argument_type,
       typename _Operation::result_type>
    {
    protected:
      _Operation op;
      typename _Operation::second_argument_type value;

    public:
      binder2nd(const _Operation& __x,
  const typename _Operation::second_argument_type& __y)
      : op(__x), value(__y) { }

      typename _Operation::result_type
      operator()(const typename _Operation::first_argument_type& __x) const
      { return op(__x, value); }



      typename _Operation::result_type
      operator()(typename _Operation::first_argument_type& __x) const
      { return op(__x, value); }
    } __attribute__ ((__deprecated__));


  template<typename _Operation, typename _Tp>
    inline binder2nd<_Operation>
    bind2nd(const _Operation& __fn, const _Tp& __x)
    {
      typedef typename _Operation::second_argument_type _Arg2_type;
      return binder2nd<_Operation>(__fn, _Arg2_type(__x));
    }



}

#pragma GCC diagnostic pop
# 1393 "/usr/include/c++/10.2.0/bits/stl_function.h" 2 3
# 49 "/usr/include/c++/10.2.0/string" 2 3





# 1 "/usr/include/c++/10.2.0/bits/range_access.h" 1 3
# 33 "/usr/include/c++/10.2.0/bits/range_access.h" 3
       
# 34 "/usr/include/c++/10.2.0/bits/range_access.h" 3


# 1 "/usr/include/c++/10.2.0/initializer_list" 1 3
# 33 "/usr/include/c++/10.2.0/initializer_list" 3
       
# 34 "/usr/include/c++/10.2.0/initializer_list" 3





#pragma GCC visibility push(default)



namespace std
{

  template<class _E>
    class initializer_list
    {
    public:
      typedef _E value_type;
      typedef const _E& reference;
      typedef const _E& const_reference;
      typedef size_t size_type;
      typedef const _E* iterator;
      typedef const _E* const_iterator;

    private:
      iterator _M_array;
      size_type _M_len;


      constexpr initializer_list(const_iterator __a, size_type __l)
      : _M_array(__a), _M_len(__l) { }

    public:
      constexpr initializer_list() noexcept
      : _M_array(0), _M_len(0) { }


      constexpr size_type
      size() const noexcept { return _M_len; }


      constexpr const_iterator
      begin() const noexcept { return _M_array; }


      constexpr const_iterator
      end() const noexcept { return begin() + size(); }
    };







  template<class _Tp>
    constexpr const _Tp*
    begin(initializer_list<_Tp> __ils) noexcept
    { return __ils.begin(); }







  template<class _Tp>
    constexpr const _Tp*
    end(initializer_list<_Tp> __ils) noexcept
    { return __ils.end(); }
}

#pragma GCC visibility pop
# 37 "/usr/include/c++/10.2.0/bits/range_access.h" 2 3
# 1 "/usr/include/c++/10.2.0/bits/iterator_concepts.h" 1 3
# 33 "/usr/include/c++/10.2.0/bits/iterator_concepts.h" 3
       
# 34 "/usr/include/c++/10.2.0/bits/iterator_concepts.h" 3

# 1 "/usr/include/c++/10.2.0/concepts" 1 3
# 36 "/usr/include/c++/10.2.0/bits/iterator_concepts.h" 2 3

# 1 "/usr/include/c++/10.2.0/bits/range_cmp.h" 1 3
# 38 "/usr/include/c++/10.2.0/bits/iterator_concepts.h" 2 3
# 38 "/usr/include/c++/10.2.0/bits/range_access.h" 2 3
# 1 "/usr/include/c++/10.2.0/bits/int_limits.h" 1 3
# 33 "/usr/include/c++/10.2.0/bits/int_limits.h" 3
       
# 34 "/usr/include/c++/10.2.0/bits/int_limits.h" 3




namespace std __attribute__ ((__visibility__ ("default")))
{

namespace __detail
{






  template<typename _Tp, bool = is_signed<_Tp>::value>
    struct __int_limits
    {
      static_assert(is_integral<_Tp>::value, "unsupported specialization");
      using _Up = typename make_unsigned<_Tp>::type;
      static constexpr int digits = sizeof(_Tp) * 8 - 1;
      static constexpr _Tp min() noexcept { return _Tp(_Up(1) << digits); }
      static constexpr _Tp max() noexcept { return _Tp(_Up(~_Up(0)) >> 1); }
    };


  template<typename _Tp>
    struct __int_limits<_Tp, false>
    {
      static_assert(is_integral<_Tp>::value, "unsupported specialization");
      static constexpr int digits = sizeof(_Tp) * 8;
      static constexpr _Tp min() noexcept { return 0; }
      static constexpr _Tp max() noexcept { return _Tp(-1); }
    };

  template<> struct __int_limits<bool>;
}

}
# 39 "/usr/include/c++/10.2.0/bits/range_access.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{







  template<typename _Container>
    inline auto
    begin(_Container& __cont) -> decltype(__cont.begin())
    { return __cont.begin(); }






  template<typename _Container>
    inline auto
    begin(const _Container& __cont) -> decltype(__cont.begin())
    { return __cont.begin(); }






  template<typename _Container>
    inline auto
    end(_Container& __cont) -> decltype(__cont.end())
    { return __cont.end(); }






  template<typename _Container>
    inline auto
    end(const _Container& __cont) -> decltype(__cont.end())
    { return __cont.end(); }





  template<typename _Tp, size_t _Nm>
    inline _Tp*
    begin(_Tp (&__arr)[_Nm])
    { return __arr; }






  template<typename _Tp, size_t _Nm>
    inline _Tp*
    end(_Tp (&__arr)[_Nm])
    { return __arr + _Nm; }
# 1143 "/usr/include/c++/10.2.0/bits/range_access.h" 3

}
# 55 "/usr/include/c++/10.2.0/string" 2 3
# 1 "/usr/include/c++/10.2.0/bits/basic_string.h" 1 3
# 37 "/usr/include/c++/10.2.0/bits/basic_string.h" 3
       
# 38 "/usr/include/c++/10.2.0/bits/basic_string.h" 3


# 1 "/usr/include/c++/10.2.0/ext/alloc_traits.h" 1 3
# 32 "/usr/include/c++/10.2.0/ext/alloc_traits.h" 3
       
# 33 "/usr/include/c++/10.2.0/ext/alloc_traits.h" 3

# 1 "/usr/include/c++/10.2.0/bits/alloc_traits.h" 1 3
# 33 "/usr/include/c++/10.2.0/bits/alloc_traits.h" 3
# 1 "/usr/include/c++/10.2.0/bits/stl_construct.h" 1 3
# 73 "/usr/include/c++/10.2.0/bits/stl_construct.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{

# 106 "/usr/include/c++/10.2.0/bits/stl_construct.h" 3
  template<typename _Tp, typename... _Args>
    inline void
    _Construct(_Tp* __p, _Args&&... __args)
    { ::new(static_cast<void*>(__p)) _Tp(std::forward<_Args>(__args)...); }
# 121 "/usr/include/c++/10.2.0/bits/stl_construct.h" 3
  template<typename _T1>
    inline void
    _Construct_novalue(_T1* __p)
    { ::new(static_cast<void*>(__p)) _T1; }

  template<typename _ForwardIterator>
    void
    _Destroy(_ForwardIterator __first, _ForwardIterator __last);




  template<typename _Tp>
    inline void
    _Destroy(_Tp* __pointer)
    {



      __pointer->~_Tp();

    }

  template<bool>
    struct _Destroy_aux
    {
      template<typename _ForwardIterator>
 static void
 __destroy(_ForwardIterator __first, _ForwardIterator __last)
 {
   for (; __first != __last; ++__first)
     std::_Destroy(std::__addressof(*__first));
 }
    };

  template<>
    struct _Destroy_aux<true>
    {
      template<typename _ForwardIterator>
        static void
        __destroy(_ForwardIterator, _ForwardIterator) { }
    };






  template<typename _ForwardIterator>
    inline void
    _Destroy(_ForwardIterator __first, _ForwardIterator __last)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
                       _Value_type;


      static_assert(is_destructible<_Value_type>::value,
      "value type is destructible");





      std::_Destroy_aux<__has_trivial_destructor(_Value_type)>::
 __destroy(__first, __last);
    }

  template<bool>
    struct _Destroy_n_aux
    {
      template<typename _ForwardIterator, typename _Size>
 static _ForwardIterator
 __destroy_n(_ForwardIterator __first, _Size __count)
 {
   for (; __count > 0; (void)++__first, --__count)
     std::_Destroy(std::__addressof(*__first));
   return __first;
 }
    };

  template<>
    struct _Destroy_n_aux<true>
    {
      template<typename _ForwardIterator, typename _Size>
        static _ForwardIterator
        __destroy_n(_ForwardIterator __first, _Size __count)
 {
   std::advance(__first, __count);
   return __first;
 }
    };






  template<typename _ForwardIterator, typename _Size>
    inline _ForwardIterator
    _Destroy_n(_ForwardIterator __first, _Size __count)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
                       _Value_type;


      static_assert(is_destructible<_Value_type>::value,
      "value type is destructible");





      return std::_Destroy_n_aux<__has_trivial_destructor(_Value_type)>::
 __destroy_n(__first, __count);
    }
# 253 "/usr/include/c++/10.2.0/bits/stl_construct.h" 3

}
# 34 "/usr/include/c++/10.2.0/bits/alloc_traits.h" 2 3







namespace std __attribute__ ((__visibility__ ("default")))
{





  struct __allocator_traits_base
  {
    template<typename _Tp, typename _Up, typename = void>
      struct __rebind : __replace_first_arg<_Tp, _Up> { };

    template<typename _Tp, typename _Up>
      struct __rebind<_Tp, _Up,
        __void_t<typename _Tp::template rebind<_Up>::other>>
      { using type = typename _Tp::template rebind<_Up>::other; };

  protected:
    template<typename _Tp>
      using __pointer = typename _Tp::pointer;
    template<typename _Tp>
      using __c_pointer = typename _Tp::const_pointer;
    template<typename _Tp>
      using __v_pointer = typename _Tp::void_pointer;
    template<typename _Tp>
      using __cv_pointer = typename _Tp::const_void_pointer;
    template<typename _Tp>
      using __pocca = typename _Tp::propagate_on_container_copy_assignment;
    template<typename _Tp>
      using __pocma = typename _Tp::propagate_on_container_move_assignment;
    template<typename _Tp>
      using __pocs = typename _Tp::propagate_on_container_swap;
    template<typename _Tp>
      using __equal = typename _Tp::is_always_equal;
  };

  template<typename _Alloc, typename _Up>
    using __alloc_rebind
      = typename __allocator_traits_base::template __rebind<_Alloc, _Up>::type;





  template<typename _Alloc>
    struct allocator_traits : __allocator_traits_base
    {

      typedef _Alloc allocator_type;

      typedef typename _Alloc::value_type value_type;






      using pointer = __detected_or_t<value_type*, __pointer, _Alloc>;

    private:

      template<template<typename> class _Func, typename _Tp, typename = void>
 struct _Ptr
 {
   using type = typename pointer_traits<pointer>::template rebind<_Tp>;
 };

      template<template<typename> class _Func, typename _Tp>
 struct _Ptr<_Func, _Tp, __void_t<_Func<_Alloc>>>
 {
   using type = _Func<_Alloc>;
 };


      template<typename _A2, typename _PtrT, typename = void>
 struct _Diff
 { using type = typename pointer_traits<_PtrT>::difference_type; };

      template<typename _A2, typename _PtrT>
 struct _Diff<_A2, _PtrT, __void_t<typename _A2::difference_type>>
 { using type = typename _A2::difference_type; };


      template<typename _A2, typename _DiffT, typename = void>
 struct _Size : make_unsigned<_DiffT> { };

      template<typename _A2, typename _DiffT>
 struct _Size<_A2, _DiffT, __void_t<typename _A2::size_type>>
 { using type = typename _A2::size_type; };

    public:






      using const_pointer = typename _Ptr<__c_pointer, const value_type>::type;







      using void_pointer = typename _Ptr<__v_pointer, void>::type;







      using const_void_pointer = typename _Ptr<__cv_pointer, const void>::type;







      using difference_type = typename _Diff<_Alloc, pointer>::type;







      using size_type = typename _Size<_Alloc, difference_type>::type;







      using propagate_on_container_copy_assignment
 = __detected_or_t<false_type, __pocca, _Alloc>;







      using propagate_on_container_move_assignment
 = __detected_or_t<false_type, __pocma, _Alloc>;







      using propagate_on_container_swap
 = __detected_or_t<false_type, __pocs, _Alloc>;







      using is_always_equal
 = __detected_or_t<typename is_empty<_Alloc>::type, __equal, _Alloc>;

      template<typename _Tp>
 using rebind_alloc = __alloc_rebind<_Alloc, _Tp>;
      template<typename _Tp>
 using rebind_traits = allocator_traits<rebind_alloc<_Tp>>;

    private:
      template<typename _Alloc2>
 static constexpr auto
 _S_allocate(_Alloc2& __a, size_type __n, const_void_pointer __hint, int)
 -> decltype(__a.allocate(__n, __hint))
 { return __a.allocate(__n, __hint); }

      template<typename _Alloc2>
 static constexpr pointer
 _S_allocate(_Alloc2& __a, size_type __n, const_void_pointer, ...)
 { return __a.allocate(__n); }

      template<typename _Tp, typename... _Args>
 struct __construct_helper
 {
   template<typename _Alloc2,
     typename = decltype(std::declval<_Alloc2*>()->construct(
    std::declval<_Tp*>(), std::declval<_Args>()...))>
     static true_type __test(int);

   template<typename>
     static false_type __test(...);

   using type = decltype(__test<_Alloc>(0));
 };

      template<typename _Tp, typename... _Args>
 using __has_construct
   = typename __construct_helper<_Tp, _Args...>::type;

      template<typename _Tp, typename... _Args>
 static _Require<__has_construct<_Tp, _Args...>>
 _S_construct(_Alloc& __a, _Tp* __p, _Args&&... __args)
 noexcept(noexcept(__a.construct(__p, std::forward<_Args>(__args)...)))
 { __a.construct(__p, std::forward<_Args>(__args)...); }

      template<typename _Tp, typename... _Args>
 static
 _Require<__and_<__not_<__has_construct<_Tp, _Args...>>,
          is_constructible<_Tp, _Args...>>>
 _S_construct(_Alloc&, _Tp* __p, _Args&&... __args)
 noexcept(std::is_nothrow_constructible<_Tp, _Args...>::value)
 {

   ::new((void*)__p) _Tp(std::forward<_Args>(__args)...);



 }

      template<typename _Alloc2, typename _Tp>
 static auto
 _S_destroy(_Alloc2& __a, _Tp* __p, int)
 noexcept(noexcept(__a.destroy(__p)))
 -> decltype(__a.destroy(__p))
 { __a.destroy(__p); }

      template<typename _Alloc2, typename _Tp>
 static void
 _S_destroy(_Alloc2&, _Tp* __p, ...)
 noexcept(std::is_nothrow_destructible<_Tp>::value)
 { std::_Destroy(__p); }

      template<typename _Alloc2>
 static constexpr auto
 _S_max_size(_Alloc2& __a, int)
 -> decltype(__a.max_size())
 { return __a.max_size(); }

      template<typename _Alloc2>
 static constexpr size_type
 _S_max_size(_Alloc2&, ...)
 {


   return __gnu_cxx::__numeric_traits<size_type>::__max
     / sizeof(value_type);
 }

      template<typename _Alloc2>
 static constexpr auto
 _S_select(_Alloc2& __a, int)
 -> decltype(__a.select_on_container_copy_construction())
 { return __a.select_on_container_copy_construction(); }

      template<typename _Alloc2>
 static constexpr _Alloc2
 _S_select(_Alloc2& __a, ...)
 { return __a; }

    public:
# 312 "/usr/include/c++/10.2.0/bits/alloc_traits.h" 3
      static pointer
      allocate(_Alloc& __a, size_type __n)
      { return __a.allocate(__n); }
# 327 "/usr/include/c++/10.2.0/bits/alloc_traits.h" 3
      static pointer
      allocate(_Alloc& __a, size_type __n, const_void_pointer __hint)
      { return _S_allocate(__a, __n, __hint, 0); }
# 339 "/usr/include/c++/10.2.0/bits/alloc_traits.h" 3
      static void
      deallocate(_Alloc& __a, pointer __p, size_type __n)
      { __a.deallocate(__p, __n); }
# 354 "/usr/include/c++/10.2.0/bits/alloc_traits.h" 3
      template<typename _Tp, typename... _Args>
 static auto
 construct(_Alloc& __a, _Tp* __p, _Args&&... __args)
 noexcept(noexcept(_S_construct(__a, __p,
           std::forward<_Args>(__args)...)))
 -> decltype(_S_construct(__a, __p, std::forward<_Args>(__args)...))
 { _S_construct(__a, __p, std::forward<_Args>(__args)...); }
# 370 "/usr/include/c++/10.2.0/bits/alloc_traits.h" 3
      template<typename _Tp>
 static void
 destroy(_Alloc& __a, _Tp* __p)
 noexcept(noexcept(_S_destroy(__a, __p, 0)))
 { _S_destroy(__a, __p, 0); }
# 384 "/usr/include/c++/10.2.0/bits/alloc_traits.h" 3
      static size_type
      max_size(const _Alloc& __a) noexcept
      { return _S_max_size(__a, 0); }
# 396 "/usr/include/c++/10.2.0/bits/alloc_traits.h" 3
      static _Alloc
      select_on_container_copy_construction(const _Alloc& __rhs)
      { return _S_select(__rhs, 0); }
    };






  template<typename _Tp>
    struct allocator_traits<allocator<_Tp>>
    {

      using allocator_type = allocator<_Tp>;


      using value_type = _Tp;


      using pointer = _Tp*;


      using const_pointer = const _Tp*;


      using void_pointer = void*;


      using const_void_pointer = const void*;


      using difference_type = std::ptrdiff_t;


      using size_type = std::size_t;


      using propagate_on_container_copy_assignment = false_type;


      using propagate_on_container_move_assignment = true_type;


      using propagate_on_container_swap = false_type;


      using is_always_equal = true_type;

      template<typename _Up>
 using rebind_alloc = allocator<_Up>;

      template<typename _Up>
 using rebind_traits = allocator_traits<allocator<_Up>>;
# 458 "/usr/include/c++/10.2.0/bits/alloc_traits.h" 3
      static pointer
      allocate(allocator_type& __a, size_type __n)
      { return __a.allocate(__n); }
# 472 "/usr/include/c++/10.2.0/bits/alloc_traits.h" 3
      static pointer
      allocate(allocator_type& __a, size_type __n, const_void_pointer __hint)
      {

 return __a.allocate(__n, __hint);



      }
# 490 "/usr/include/c++/10.2.0/bits/alloc_traits.h" 3
      static void
      deallocate(allocator_type& __a, pointer __p, size_type __n)
      { __a.deallocate(__p, __n); }
# 505 "/usr/include/c++/10.2.0/bits/alloc_traits.h" 3
      template<typename _Up, typename... _Args>
 static void
 construct(allocator_type& __a __attribute__((__unused__)), _Up* __p,
    _Args&&... __args)
 noexcept(std::is_nothrow_constructible<_Up, _Args...>::value)
 {

   __a.construct(__p, std::forward<_Args>(__args)...);



 }
# 525 "/usr/include/c++/10.2.0/bits/alloc_traits.h" 3
      template<typename _Up>
 static void
 destroy(allocator_type& __a __attribute__((__unused__)), _Up* __p)
 noexcept(is_nothrow_destructible<_Up>::value)
 {

   __a.destroy(__p);



 }






      static size_type
      max_size(const allocator_type& __a __attribute__((__unused__))) noexcept
      {

 return __a.max_size();



      }






      static allocator_type
      select_on_container_copy_construction(const allocator_type& __rhs)
      { return __rhs; }
    };


  template<typename _Alloc>
    inline void
    __do_alloc_on_copy(_Alloc& __one, const _Alloc& __two, true_type)
    { __one = __two; }

  template<typename _Alloc>
    inline void
    __do_alloc_on_copy(_Alloc&, const _Alloc&, false_type)
    { }


  template<typename _Alloc>
    inline void
    __alloc_on_copy(_Alloc& __one, const _Alloc& __two)
    {
      typedef allocator_traits<_Alloc> __traits;
      typedef typename __traits::propagate_on_container_copy_assignment __pocca;




      __do_alloc_on_copy(__one, __two, __pocca());

    }

  template<typename _Alloc>
    constexpr _Alloc
    __alloc_on_copy(const _Alloc& __a)
    {
      typedef allocator_traits<_Alloc> __traits;
      return __traits::select_on_container_copy_construction(__a);
    }


  template<typename _Alloc>
    inline void __do_alloc_on_move(_Alloc& __one, _Alloc& __two, true_type)
    { __one = std::move(__two); }

  template<typename _Alloc>
    inline void __do_alloc_on_move(_Alloc&, _Alloc&, false_type)
    { }


  template<typename _Alloc>
    inline void
    __alloc_on_move(_Alloc& __one, _Alloc& __two)
    {
      typedef allocator_traits<_Alloc> __traits;
      typedef typename __traits::propagate_on_container_move_assignment __pocma;




      __do_alloc_on_move(__one, __two, __pocma());

    }


  template<typename _Alloc>
    inline void __do_alloc_on_swap(_Alloc& __one, _Alloc& __two, true_type)
    {
      using std::swap;
      swap(__one, __two);
    }

  template<typename _Alloc>
    inline void __do_alloc_on_swap(_Alloc&, _Alloc&, false_type)
    { }


  template<typename _Alloc>
    inline void
    __alloc_on_swap(_Alloc& __one, _Alloc& __two)
    {
      typedef allocator_traits<_Alloc> __traits;
      typedef typename __traits::propagate_on_container_swap __pocs;







      __do_alloc_on_swap(__one, __two, __pocs());

    }

  template<typename _Alloc, typename _Tp,
    typename _ValueT = __remove_cvref_t<typename _Alloc::value_type>,
    typename = void>
    struct __is_alloc_insertable_impl
    : false_type
    { };

  template<typename _Alloc, typename _Tp, typename _ValueT>
    struct __is_alloc_insertable_impl<_Alloc, _Tp, _ValueT,
      __void_t<decltype(allocator_traits<_Alloc>::construct(
     std::declval<_Alloc&>(), std::declval<_ValueT*>(),
     std::declval<_Tp>()))>>
    : true_type
    { };




  template<typename _Alloc>
    struct __is_copy_insertable
    : __is_alloc_insertable_impl<_Alloc,
     typename _Alloc::value_type const&>::type
    { };


  template<typename _Tp>
    struct __is_copy_insertable<allocator<_Tp>>
    : is_copy_constructible<_Tp>
    { };




  template<typename _Alloc>
    struct __is_move_insertable
    : __is_alloc_insertable_impl<_Alloc, typename _Alloc::value_type>::type
    { };


  template<typename _Tp>
    struct __is_move_insertable<allocator<_Tp>>
    : is_move_constructible<_Tp>
    { };


  template<typename _Alloc, typename = void>
    struct __is_allocator : false_type { };

  template<typename _Alloc>
    struct __is_allocator<_Alloc,
      __void_t<typename _Alloc::value_type,
        decltype(std::declval<_Alloc&>().allocate(size_t{}))>>
    : true_type { };

  template<typename _Alloc>
    using _RequireAllocator
      = typename enable_if<__is_allocator<_Alloc>::value, _Alloc>::type;

  template<typename _Alloc>
    using _RequireNotAllocator
      = typename enable_if<!__is_allocator<_Alloc>::value, _Alloc>::type;
# 719 "/usr/include/c++/10.2.0/bits/alloc_traits.h" 3
  template<typename _ForwardIterator, typename _Allocator>
    void
    _Destroy(_ForwardIterator __first, _ForwardIterator __last,
      _Allocator& __alloc)
    {
      for (; __first != __last; ++__first)



 allocator_traits<_Allocator>::destroy(__alloc,
           std::__addressof(*__first));

    }

  template<typename _ForwardIterator, typename _Tp>
    inline void
    _Destroy(_ForwardIterator __first, _ForwardIterator __last,
      allocator<_Tp>&)
    {
      _Destroy(__first, __last);
    }


}
# 35 "/usr/include/c++/10.2.0/ext/alloc_traits.h" 2 3




namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{






template<typename _Alloc, typename = typename _Alloc::value_type>
  struct __alloc_traits

  : std::allocator_traits<_Alloc>

  {
    typedef _Alloc allocator_type;

    typedef std::allocator_traits<_Alloc> _Base_type;
    typedef typename _Base_type::value_type value_type;
    typedef typename _Base_type::pointer pointer;
    typedef typename _Base_type::const_pointer const_pointer;
    typedef typename _Base_type::size_type size_type;
    typedef typename _Base_type::difference_type difference_type;

    typedef value_type& reference;
    typedef const value_type& const_reference;
    using _Base_type::allocate;
    using _Base_type::deallocate;
    using _Base_type::construct;
    using _Base_type::destroy;
    using _Base_type::max_size;

  private:
    template<typename _Ptr>
      using __is_custom_pointer
 = std::__and_<std::is_same<pointer, _Ptr>,
        std::__not_<std::is_pointer<_Ptr>>>;

  public:

    template<typename _Ptr, typename... _Args>
      static
      std::__enable_if_t<__is_custom_pointer<_Ptr>::value>
      construct(_Alloc& __a, _Ptr __p, _Args&&... __args)
      noexcept(noexcept(_Base_type::construct(__a, std::__to_address(__p),
           std::forward<_Args>(__args)...)))
      {
 _Base_type::construct(__a, std::__to_address(__p),
         std::forward<_Args>(__args)...);
      }


    template<typename _Ptr>
      static
      std::__enable_if_t<__is_custom_pointer<_Ptr>::value>
      destroy(_Alloc& __a, _Ptr __p)
      noexcept(noexcept(_Base_type::destroy(__a, std::__to_address(__p))))
      { _Base_type::destroy(__a, std::__to_address(__p)); }

    static constexpr _Alloc _S_select_on_copy(const _Alloc& __a)
    { return _Base_type::select_on_container_copy_construction(__a); }

    static void _S_on_swap(_Alloc& __a, _Alloc& __b)
    { std::__alloc_on_swap(__a, __b); }

    static constexpr bool _S_propagate_on_copy_assign()
    { return _Base_type::propagate_on_container_copy_assignment::value; }

    static constexpr bool _S_propagate_on_move_assign()
    { return _Base_type::propagate_on_container_move_assignment::value; }

    static constexpr bool _S_propagate_on_swap()
    { return _Base_type::propagate_on_container_swap::value; }

    static constexpr bool _S_always_equal()
    { return _Base_type::is_always_equal::value; }

    static constexpr bool _S_nothrow_move()
    { return _S_propagate_on_move_assign() || _S_always_equal(); }

    template<typename _Tp>
      struct rebind
      { typedef typename _Base_type::template rebind_alloc<_Tp> other; };
# 166 "/usr/include/c++/10.2.0/ext/alloc_traits.h" 3
  };


}
# 41 "/usr/include/c++/10.2.0/bits/basic_string.h" 2 3
# 52 "/usr/include/c++/10.2.0/bits/basic_string.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{



namespace __cxx11 {
# 76 "/usr/include/c++/10.2.0/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    class basic_string
    {
      typedef typename __gnu_cxx::__alloc_traits<_Alloc>::template
 rebind<_CharT>::other _Char_alloc_type;
      typedef __gnu_cxx::__alloc_traits<_Char_alloc_type> _Alloc_traits;


    public:
      typedef _Traits traits_type;
      typedef typename _Traits::char_type value_type;
      typedef _Char_alloc_type allocator_type;
      typedef typename _Alloc_traits::size_type size_type;
      typedef typename _Alloc_traits::difference_type difference_type;
      typedef typename _Alloc_traits::reference reference;
      typedef typename _Alloc_traits::const_reference const_reference;
      typedef typename _Alloc_traits::pointer pointer;
      typedef typename _Alloc_traits::const_pointer const_pointer;
      typedef __gnu_cxx::__normal_iterator<pointer, basic_string> iterator;
      typedef __gnu_cxx::__normal_iterator<const_pointer, basic_string>
       const_iterator;
      typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
      typedef std::reverse_iterator<iterator> reverse_iterator;


      static const size_type npos = static_cast<size_type>(-1);

    protected:




      typedef const_iterator __const_iterator;


    private:
# 150 "/usr/include/c++/10.2.0/bits/basic_string.h" 3
      struct _Alloc_hider : allocator_type
      {




 _Alloc_hider(pointer __dat, const _Alloc& __a)
 : allocator_type(__a), _M_p(__dat) { }

 _Alloc_hider(pointer __dat, _Alloc&& __a = _Alloc())
 : allocator_type(std::move(__a)), _M_p(__dat) { }


 pointer _M_p;
      };

      _Alloc_hider _M_dataplus;
      size_type _M_string_length;

      enum { _S_local_capacity = 15 / sizeof(_CharT) };

      union
      {
 _CharT _M_local_buf[_S_local_capacity + 1];
 size_type _M_allocated_capacity;
      };

      void
      _M_data(pointer __p)
      { _M_dataplus._M_p = __p; }

      void
      _M_length(size_type __length)
      { _M_string_length = __length; }

      pointer
      _M_data() const
      { return _M_dataplus._M_p; }

      pointer
      _M_local_data()
      {

 return std::pointer_traits<pointer>::pointer_to(*_M_local_buf);



      }

      const_pointer
      _M_local_data() const
      {

 return std::pointer_traits<const_pointer>::pointer_to(*_M_local_buf);



      }

      void
      _M_capacity(size_type __capacity)
      { _M_allocated_capacity = __capacity; }

      void
      _M_set_length(size_type __n)
      {
 _M_length(__n);
 traits_type::assign(_M_data()[__n], _CharT());
      }

      bool
      _M_is_local() const
      { return _M_data() == _M_local_data(); }


      pointer
      _M_create(size_type&, size_type);

      void
      _M_dispose()
      {
 if (!_M_is_local())
   _M_destroy(_M_allocated_capacity);
      }

      void
      _M_destroy(size_type __size) throw()
      { _Alloc_traits::deallocate(_M_get_allocator(), _M_data(), __size + 1); }



      template<typename _InIterator>
        void
        _M_construct_aux(_InIterator __beg, _InIterator __end,
    std::__false_type)
 {
          typedef typename iterator_traits<_InIterator>::iterator_category _Tag;
          _M_construct(__beg, __end, _Tag());
 }



      template<typename _Integer>
        void
        _M_construct_aux(_Integer __beg, _Integer __end, std::__true_type)
 { _M_construct_aux_2(static_cast<size_type>(__beg), __end); }

      void
      _M_construct_aux_2(size_type __req, _CharT __c)
      { _M_construct(__req, __c); }

      template<typename _InIterator>
        void
        _M_construct(_InIterator __beg, _InIterator __end)
 {
   typedef typename std::__is_integer<_InIterator>::__type _Integral;
   _M_construct_aux(__beg, __end, _Integral());
        }


      template<typename _InIterator>
        void
        _M_construct(_InIterator __beg, _InIterator __end,
       std::input_iterator_tag);



      template<typename _FwdIterator>
        void
        _M_construct(_FwdIterator __beg, _FwdIterator __end,
       std::forward_iterator_tag);

      void
      _M_construct(size_type __req, _CharT __c);

      allocator_type&
      _M_get_allocator()
      { return _M_dataplus; }

      const allocator_type&
      _M_get_allocator() const
      { return _M_dataplus; }

    private:
# 309 "/usr/include/c++/10.2.0/bits/basic_string.h" 3
      size_type
      _M_check(size_type __pos, const char* __s) const
      {
 if (__pos > this->size())
   __throw_out_of_range_fmt(("%s: __pos (which is %zu) > " "this->size() (which is %zu)")
                                         ,
       __s, __pos, this->size());
 return __pos;
      }

      void
      _M_check_length(size_type __n1, size_type __n2, const char* __s) const
      {
 if (this->max_size() - (this->size() - __n1) < __n2)
   __throw_length_error((__s));
      }



      size_type
      _M_limit(size_type __pos, size_type __off) const noexcept
      {
 const bool __testoff = __off < this->size() - __pos;
 return __testoff ? __off : this->size() - __pos;
      }


      bool
      _M_disjunct(const _CharT* __s) const noexcept
      {
 return (less<const _CharT*>()(__s, _M_data())
  || less<const _CharT*>()(_M_data() + this->size(), __s));
      }



      static void
      _S_copy(_CharT* __d, const _CharT* __s, size_type __n)
      {
 if (__n == 1)
   traits_type::assign(*__d, *__s);
 else
   traits_type::copy(__d, __s, __n);
      }

      static void
      _S_move(_CharT* __d, const _CharT* __s, size_type __n)
      {
 if (__n == 1)
   traits_type::assign(*__d, *__s);
 else
   traits_type::move(__d, __s, __n);
      }

      static void
      _S_assign(_CharT* __d, size_type __n, _CharT __c)
      {
 if (__n == 1)
   traits_type::assign(*__d, __c);
 else
   traits_type::assign(__d, __n, __c);
      }



      template<class _Iterator>
        static void
        _S_copy_chars(_CharT* __p, _Iterator __k1, _Iterator __k2)
        {
   for (; __k1 != __k2; ++__k1, (void)++__p)
     traits_type::assign(*__p, *__k1);
 }

      static void
      _S_copy_chars(_CharT* __p, iterator __k1, iterator __k2) noexcept
      { _S_copy_chars(__p, __k1.base(), __k2.base()); }

      static void
      _S_copy_chars(_CharT* __p, const_iterator __k1, const_iterator __k2)
      noexcept
      { _S_copy_chars(__p, __k1.base(), __k2.base()); }

      static void
      _S_copy_chars(_CharT* __p, _CharT* __k1, _CharT* __k2) noexcept
      { _S_copy(__p, __k1, __k2 - __k1); }

      static void
      _S_copy_chars(_CharT* __p, const _CharT* __k1, const _CharT* __k2)
      noexcept
      { _S_copy(__p, __k1, __k2 - __k1); }

      static int
      _S_compare(size_type __n1, size_type __n2) noexcept
      {
 const difference_type __d = difference_type(__n1 - __n2);

 if (__d > __gnu_cxx::__numeric_traits<int>::__max)
   return __gnu_cxx::__numeric_traits<int>::__max;
 else if (__d < __gnu_cxx::__numeric_traits<int>::__min)
   return __gnu_cxx::__numeric_traits<int>::__min;
 else
   return int(__d);
      }

      void
      _M_assign(const basic_string&);

      void
      _M_mutate(size_type __pos, size_type __len1, const _CharT* __s,
  size_type __len2);

      void
      _M_erase(size_type __pos, size_type __n);

    public:







      basic_string()
      noexcept(is_nothrow_default_constructible<_Alloc>::value)
      : _M_dataplus(_M_local_data())
      { _M_set_length(0); }




      explicit
      basic_string(const _Alloc& __a) noexcept
      : _M_dataplus(_M_local_data(), __a)
      { _M_set_length(0); }





      basic_string(const basic_string& __str)
      : _M_dataplus(_M_local_data(),
      _Alloc_traits::_S_select_on_copy(__str._M_get_allocator()))
      { _M_construct(__str._M_data(), __str._M_data() + __str.length()); }
# 461 "/usr/include/c++/10.2.0/bits/basic_string.h" 3
      basic_string(const basic_string& __str, size_type __pos,
     const _Alloc& __a = _Alloc())
      : _M_dataplus(_M_local_data(), __a)
      {
 const _CharT* __start = __str._M_data()
   + __str._M_check(__pos, "basic_string::basic_string");
 _M_construct(__start, __start + __str._M_limit(__pos, npos));
      }







      basic_string(const basic_string& __str, size_type __pos,
     size_type __n)
      : _M_dataplus(_M_local_data())
      {
 const _CharT* __start = __str._M_data()
   + __str._M_check(__pos, "basic_string::basic_string");
 _M_construct(__start, __start + __str._M_limit(__pos, __n));
      }
# 492 "/usr/include/c++/10.2.0/bits/basic_string.h" 3
      basic_string(const basic_string& __str, size_type __pos,
     size_type __n, const _Alloc& __a)
      : _M_dataplus(_M_local_data(), __a)
      {
 const _CharT* __start
   = __str._M_data() + __str._M_check(__pos, "string::string");
 _M_construct(__start, __start + __str._M_limit(__pos, __n));
      }
# 510 "/usr/include/c++/10.2.0/bits/basic_string.h" 3
      basic_string(const _CharT* __s, size_type __n,
     const _Alloc& __a = _Alloc())
      : _M_dataplus(_M_local_data(), __a)
      { _M_construct(__s, __s + __n); }
# 525 "/usr/include/c++/10.2.0/bits/basic_string.h" 3
      basic_string(const _CharT* __s, const _Alloc& __a = _Alloc())
      : _M_dataplus(_M_local_data(), __a)
      { _M_construct(__s, __s ? __s + traits_type::length(__s) : __s+npos); }
# 540 "/usr/include/c++/10.2.0/bits/basic_string.h" 3
      basic_string(size_type __n, _CharT __c, const _Alloc& __a = _Alloc())
      : _M_dataplus(_M_local_data(), __a)
      { _M_construct(__n, __c); }
# 552 "/usr/include/c++/10.2.0/bits/basic_string.h" 3
      basic_string(basic_string&& __str) noexcept
      : _M_dataplus(_M_local_data(), std::move(__str._M_get_allocator()))
      {
 if (__str._M_is_local())
   {
     traits_type::copy(_M_local_buf, __str._M_local_buf,
         _S_local_capacity + 1);
   }
 else
   {
     _M_data(__str._M_data());
     _M_capacity(__str._M_allocated_capacity);
   }




 _M_length(__str.length());
 __str._M_data(__str._M_local_data());
 __str._M_set_length(0);
      }






      basic_string(initializer_list<_CharT> __l, const _Alloc& __a = _Alloc())
      : _M_dataplus(_M_local_data(), __a)
      { _M_construct(__l.begin(), __l.end()); }

      basic_string(const basic_string& __str, const _Alloc& __a)
      : _M_dataplus(_M_local_data(), __a)
      { _M_construct(__str.begin(), __str.end()); }

      basic_string(basic_string&& __str, const _Alloc& __a)
      noexcept(_Alloc_traits::_S_always_equal())
      : _M_dataplus(_M_local_data(), __a)
      {
 if (__str._M_is_local())
   {
     traits_type::copy(_M_local_buf, __str._M_local_buf,
         _S_local_capacity + 1);
     _M_length(__str.length());
     __str._M_set_length(0);
   }
 else if (_Alloc_traits::_S_always_equal()
     || __str.get_allocator() == __a)
   {
     _M_data(__str._M_data());
     _M_length(__str.length());
     _M_capacity(__str._M_allocated_capacity);
     __str._M_data(__str._M_local_buf);
     __str._M_set_length(0);
   }
 else
   _M_construct(__str.begin(), __str.end());
      }
# 620 "/usr/include/c++/10.2.0/bits/basic_string.h" 3
      template<typename _InputIterator,
        typename = std::_RequireInputIter<_InputIterator>>



        basic_string(_InputIterator __beg, _InputIterator __end,
       const _Alloc& __a = _Alloc())
 : _M_dataplus(_M_local_data(), __a)
 { _M_construct(__beg, __end); }
# 657 "/usr/include/c++/10.2.0/bits/basic_string.h" 3
      ~basic_string()
      { _M_dispose(); }





      basic_string&
      operator=(const basic_string& __str)
      {
 return this->assign(__str);
      }





      basic_string&
      operator=(const _CharT* __s)
      { return this->assign(__s); }
# 685 "/usr/include/c++/10.2.0/bits/basic_string.h" 3
      basic_string&
      operator=(_CharT __c)
      {
 this->assign(1, __c);
 return *this;
      }
# 702 "/usr/include/c++/10.2.0/bits/basic_string.h" 3
      basic_string&
      operator=(basic_string&& __str)
      noexcept(_Alloc_traits::_S_nothrow_move())
      {
 if (!_M_is_local() && _Alloc_traits::_S_propagate_on_move_assign()
     && !_Alloc_traits::_S_always_equal()
     && _M_get_allocator() != __str._M_get_allocator())
   {

     _M_destroy(_M_allocated_capacity);
     _M_data(_M_local_data());
     _M_set_length(0);
   }

 std::__alloc_on_move(_M_get_allocator(), __str._M_get_allocator());

 if (__str._M_is_local())
   {

     if (__str.size())
       this->_S_copy(_M_data(), __str._M_data(), __str.size());
     _M_set_length(__str.size());
   }
 else if (_Alloc_traits::_S_propagate_on_move_assign()
     || _Alloc_traits::_S_always_equal()
     || _M_get_allocator() == __str._M_get_allocator())
   {

     pointer __data = nullptr;
     size_type __capacity;
     if (!_M_is_local())
       {
  if (_Alloc_traits::_S_always_equal())
    {

      __data = _M_data();
      __capacity = _M_allocated_capacity;
    }
  else
    _M_destroy(_M_allocated_capacity);
       }

     _M_data(__str._M_data());
     _M_length(__str.length());
     _M_capacity(__str._M_allocated_capacity);
     if (__data)
       {
  __str._M_data(__data);
  __str._M_capacity(__capacity);
       }
     else
       __str._M_data(__str._M_local_buf);
   }
 else
   assign(__str);
 __str.clear();
 return *this;
      }





      basic_string&
      operator=(initializer_list<_CharT> __l)
      {
 this->assign(__l.begin(), __l.size());
 return *this;
      }
# 796 "/usr/include/c++/10.2.0/bits/basic_string.h" 3
      iterator
      begin() noexcept
      { return iterator(_M_data()); }





      const_iterator
      begin() const noexcept
      { return const_iterator(_M_data()); }





      iterator
      end() noexcept
      { return iterator(_M_data() + this->size()); }





      const_iterator
      end() const noexcept
      { return const_iterator(_M_data() + this->size()); }






      reverse_iterator
      rbegin() noexcept
      { return reverse_iterator(this->end()); }






      const_reverse_iterator
      rbegin() const noexcept
      { return const_reverse_iterator(this->end()); }






      reverse_iterator
      rend() noexcept
      { return reverse_iterator(this->begin()); }






      const_reverse_iterator
      rend() const noexcept
      { return const_reverse_iterator(this->begin()); }






      const_iterator
      cbegin() const noexcept
      { return const_iterator(this->_M_data()); }





      const_iterator
      cend() const noexcept
      { return const_iterator(this->_M_data() + this->size()); }






      const_reverse_iterator
      crbegin() const noexcept
      { return const_reverse_iterator(this->end()); }






      const_reverse_iterator
      crend() const noexcept
      { return const_reverse_iterator(this->begin()); }


    public:



      size_type
      size() const noexcept
      { return _M_string_length; }



      size_type
      length() const noexcept
      { return _M_string_length; }


      size_type
      max_size() const noexcept
      { return (_Alloc_traits::max_size(_M_get_allocator()) - 1) / 2; }
# 925 "/usr/include/c++/10.2.0/bits/basic_string.h" 3
      void
      resize(size_type __n, _CharT __c);
# 938 "/usr/include/c++/10.2.0/bits/basic_string.h" 3
      void
      resize(size_type __n)
      { this->resize(__n, _CharT()); }



      void
      shrink_to_fit() noexcept
      {

 if (capacity() > size())
   {
     try
       { reserve(0); }
     catch(...)
       { }
   }

      }






      size_type
      capacity() const noexcept
      {
 return _M_is_local() ? size_type(_S_local_capacity)
                      : _M_allocated_capacity;
      }
# 987 "/usr/include/c++/10.2.0/bits/basic_string.h" 3
      void
      reserve(size_type __res_arg = 0);




      void
      clear() noexcept
      { _M_set_length(0); }





      bool
      empty() const noexcept
      { return this->size() == 0; }
# 1016 "/usr/include/c++/10.2.0/bits/basic_string.h" 3
      const_reference
      operator[] (size_type __pos) const noexcept
      {
 ;
 return _M_data()[__pos];
      }
# 1033 "/usr/include/c++/10.2.0/bits/basic_string.h" 3
      reference
      operator[](size_type __pos)
      {


 ;

 ;
 return _M_data()[__pos];
      }
# 1054 "/usr/include/c++/10.2.0/bits/basic_string.h" 3
      const_reference
      at(size_type __n) const
      {
 if (__n >= this->size())
   __throw_out_of_range_fmt(("basic_string::at: __n " "(which is %zu) >= this->size() " "(which is %zu)")

                            ,
       __n, this->size());
 return _M_data()[__n];
      }
# 1075 "/usr/include/c++/10.2.0/bits/basic_string.h" 3
      reference
      at(size_type __n)
      {
 if (__n >= size())
   __throw_out_of_range_fmt(("basic_string::at: __n " "(which is %zu) >= this->size() " "(which is %zu)")

                            ,
       __n, this->size());
 return _M_data()[__n];
      }






      reference
      front() noexcept
      {
 ;
 return operator[](0);
      }





      const_reference
      front() const noexcept
      {
 ;
 return operator[](0);
      }





      reference
      back() noexcept
      {
 ;
 return operator[](this->size() - 1);
      }





      const_reference
      back() const noexcept
      {
 ;
 return operator[](this->size() - 1);
      }
# 1138 "/usr/include/c++/10.2.0/bits/basic_string.h" 3
      basic_string&
      operator+=(const basic_string& __str)
      { return this->append(__str); }






      basic_string&
      operator+=(const _CharT* __s)
      { return this->append(__s); }






      basic_string&
      operator+=(_CharT __c)
      {
 this->push_back(__c);
 return *this;
      }







      basic_string&
      operator+=(initializer_list<_CharT> __l)
      { return this->append(__l.begin(), __l.size()); }
# 1191 "/usr/include/c++/10.2.0/bits/basic_string.h" 3
      basic_string&
      append(const basic_string& __str)
      { return _M_append(__str._M_data(), __str.size()); }
# 1208 "/usr/include/c++/10.2.0/bits/basic_string.h" 3
      basic_string&
      append(const basic_string& __str, size_type __pos, size_type __n = npos)
      { return _M_append(__str._M_data()
    + __str._M_check(__pos, "basic_string::append"),
    __str._M_limit(__pos, __n)); }







      basic_string&
      append(const _CharT* __s, size_type __n)
      {
 ;
 _M_check_length(size_type(0), __n, "basic_string::append");
 return _M_append(__s, __n);
      }






      basic_string&
      append(const _CharT* __s)
      {
 ;
 const size_type __n = traits_type::length(__s);
 _M_check_length(size_type(0), __n, "basic_string::append");
 return _M_append(__s, __n);
      }
# 1250 "/usr/include/c++/10.2.0/bits/basic_string.h" 3
      basic_string&
      append(size_type __n, _CharT __c)
      { return _M_replace_aux(this->size(), size_type(0), __n, __c); }







      basic_string&
      append(initializer_list<_CharT> __l)
      { return this->append(__l.begin(), __l.size()); }
# 1274 "/usr/include/c++/10.2.0/bits/basic_string.h" 3
      template<class _InputIterator,
        typename = std::_RequireInputIter<_InputIterator>>



        basic_string&
        append(_InputIterator __first, _InputIterator __last)
        { return this->replace(end(), end(), __first, __last); }
# 1319 "/usr/include/c++/10.2.0/bits/basic_string.h" 3
      void
      push_back(_CharT __c)
      {
 const size_type __size = this->size();
 if (__size + 1 > this->capacity())
   this->_M_mutate(__size, size_type(0), 0, size_type(1));
 traits_type::assign(this->_M_data()[__size], __c);
 this->_M_set_length(__size + 1);
      }






      basic_string&
      assign(const basic_string& __str)
      {

 if (_Alloc_traits::_S_propagate_on_copy_assign())
   {
     if (!_Alloc_traits::_S_always_equal() && !_M_is_local()
  && _M_get_allocator() != __str._M_get_allocator())
       {


  if (__str.size() <= _S_local_capacity)
    {
      _M_destroy(_M_allocated_capacity);
      _M_data(_M_local_data());
      _M_set_length(0);
    }
  else
    {
      const auto __len = __str.size();
      auto __alloc = __str._M_get_allocator();

      auto __ptr = _Alloc_traits::allocate(__alloc, __len + 1);
      _M_destroy(_M_allocated_capacity);
      _M_data(__ptr);
      _M_capacity(__len);
      _M_set_length(__len);
    }
       }
     std::__alloc_on_copy(_M_get_allocator(), __str._M_get_allocator());
   }

 this->_M_assign(__str);
 return *this;
      }
# 1379 "/usr/include/c++/10.2.0/bits/basic_string.h" 3
      basic_string&
      assign(basic_string&& __str)
      noexcept(_Alloc_traits::_S_nothrow_move())
      {


 return *this = std::move(__str);
      }
# 1402 "/usr/include/c++/10.2.0/bits/basic_string.h" 3
      basic_string&
      assign(const basic_string& __str, size_type __pos, size_type __n = npos)
      { return _M_replace(size_type(0), this->size(), __str._M_data()
     + __str._M_check(__pos, "basic_string::assign"),
     __str._M_limit(__pos, __n)); }
# 1418 "/usr/include/c++/10.2.0/bits/basic_string.h" 3
      basic_string&
      assign(const _CharT* __s, size_type __n)
      {
 ;
 return _M_replace(size_type(0), this->size(), __s, __n);
      }
# 1434 "/usr/include/c++/10.2.0/bits/basic_string.h" 3
      basic_string&
      assign(const _CharT* __s)
      {
 ;
 return _M_replace(size_type(0), this->size(), __s,
     traits_type::length(__s));
      }
# 1451 "/usr/include/c++/10.2.0/bits/basic_string.h" 3
      basic_string&
      assign(size_type __n, _CharT __c)
      { return _M_replace_aux(size_type(0), this->size(), __n, __c); }
# 1464 "/usr/include/c++/10.2.0/bits/basic_string.h" 3
      template<class _InputIterator,
        typename = std::_RequireInputIter<_InputIterator>>



        basic_string&
        assign(_InputIterator __first, _InputIterator __last)
        { return this->replace(begin(), end(), __first, __last); }







      basic_string&
      assign(initializer_list<_CharT> __l)
      { return this->assign(__l.begin(), __l.size()); }
# 1533 "/usr/include/c++/10.2.0/bits/basic_string.h" 3
      iterator
      insert(const_iterator __p, size_type __n, _CharT __c)
      {
 ;
 const size_type __pos = __p - begin();
 this->replace(__p, __p, __n, __c);
 return iterator(this->_M_data() + __pos);
      }
# 1575 "/usr/include/c++/10.2.0/bits/basic_string.h" 3
      template<class _InputIterator,
        typename = std::_RequireInputIter<_InputIterator>>
 iterator
        insert(const_iterator __p, _InputIterator __beg, _InputIterator __end)
        {
   ;
   const size_type __pos = __p - begin();
   this->replace(__p, __p, __beg, __end);
   return iterator(this->_M_data() + __pos);
 }
# 1611 "/usr/include/c++/10.2.0/bits/basic_string.h" 3
      iterator
      insert(const_iterator __p, initializer_list<_CharT> __l)
      { return this->insert(__p, __l.begin(), __l.end()); }
# 1638 "/usr/include/c++/10.2.0/bits/basic_string.h" 3
      basic_string&
      insert(size_type __pos1, const basic_string& __str)
      { return this->replace(__pos1, size_type(0),
        __str._M_data(), __str.size()); }
# 1661 "/usr/include/c++/10.2.0/bits/basic_string.h" 3
      basic_string&
      insert(size_type __pos1, const basic_string& __str,
      size_type __pos2, size_type __n = npos)
      { return this->replace(__pos1, size_type(0), __str._M_data()
        + __str._M_check(__pos2, "basic_string::insert"),
        __str._M_limit(__pos2, __n)); }
# 1684 "/usr/include/c++/10.2.0/bits/basic_string.h" 3
      basic_string&
      insert(size_type __pos, const _CharT* __s, size_type __n)
      { return this->replace(__pos, size_type(0), __s, __n); }
# 1703 "/usr/include/c++/10.2.0/bits/basic_string.h" 3
      basic_string&
      insert(size_type __pos, const _CharT* __s)
      {
 ;
 return this->replace(__pos, size_type(0), __s,
        traits_type::length(__s));
      }
# 1727 "/usr/include/c++/10.2.0/bits/basic_string.h" 3
      basic_string&
      insert(size_type __pos, size_type __n, _CharT __c)
      { return _M_replace_aux(_M_check(__pos, "basic_string::insert"),
         size_type(0), __n, __c); }
# 1745 "/usr/include/c++/10.2.0/bits/basic_string.h" 3
      iterator
      insert(__const_iterator __p, _CharT __c)
      {
 ;
 const size_type __pos = __p - begin();
 _M_replace_aux(__pos, size_type(0), size_type(1), __c);
 return iterator(_M_data() + __pos);
      }
# 1805 "/usr/include/c++/10.2.0/bits/basic_string.h" 3
      basic_string&
      erase(size_type __pos = 0, size_type __n = npos)
      {
 _M_check(__pos, "basic_string::erase");
 if (__n == npos)
   this->_M_set_length(__pos);
 else if (__n != 0)
   this->_M_erase(__pos, _M_limit(__pos, __n));
 return *this;
      }
# 1824 "/usr/include/c++/10.2.0/bits/basic_string.h" 3
      iterator
      erase(__const_iterator __position)
      {

                           ;
 const size_type __pos = __position - begin();
 this->_M_erase(__pos, size_type(1));
 return iterator(_M_data() + __pos);
      }
# 1843 "/usr/include/c++/10.2.0/bits/basic_string.h" 3
      iterator
      erase(__const_iterator __first, __const_iterator __last)
      {

                        ;
        const size_type __pos = __first - begin();
 if (__last == end())
   this->_M_set_length(__pos);
 else
   this->_M_erase(__pos, __last - __first);
 return iterator(this->_M_data() + __pos);
      }







      void
      pop_back() noexcept
      {
 ;
 _M_erase(size() - 1, 1);
      }
# 1887 "/usr/include/c++/10.2.0/bits/basic_string.h" 3
      basic_string&
      replace(size_type __pos, size_type __n, const basic_string& __str)
      { return this->replace(__pos, __n, __str._M_data(), __str.size()); }
# 1909 "/usr/include/c++/10.2.0/bits/basic_string.h" 3
      basic_string&
      replace(size_type __pos1, size_type __n1, const basic_string& __str,
       size_type __pos2, size_type __n2 = npos)
      { return this->replace(__pos1, __n1, __str._M_data()
        + __str._M_check(__pos2, "basic_string::replace"),
        __str._M_limit(__pos2, __n2)); }
# 1934 "/usr/include/c++/10.2.0/bits/basic_string.h" 3
      basic_string&
      replace(size_type __pos, size_type __n1, const _CharT* __s,
       size_type __n2)
      {
 ;
 return _M_replace(_M_check(__pos, "basic_string::replace"),
     _M_limit(__pos, __n1), __s, __n2);
      }
# 1959 "/usr/include/c++/10.2.0/bits/basic_string.h" 3
      basic_string&
      replace(size_type __pos, size_type __n1, const _CharT* __s)
      {
 ;
 return this->replace(__pos, __n1, __s, traits_type::length(__s));
      }
# 1983 "/usr/include/c++/10.2.0/bits/basic_string.h" 3
      basic_string&
      replace(size_type __pos, size_type __n1, size_type __n2, _CharT __c)
      { return _M_replace_aux(_M_check(__pos, "basic_string::replace"),
         _M_limit(__pos, __n1), __n2, __c); }
# 2001 "/usr/include/c++/10.2.0/bits/basic_string.h" 3
      basic_string&
      replace(__const_iterator __i1, __const_iterator __i2,
       const basic_string& __str)
      { return this->replace(__i1, __i2, __str._M_data(), __str.size()); }
# 2021 "/usr/include/c++/10.2.0/bits/basic_string.h" 3
      basic_string&
      replace(__const_iterator __i1, __const_iterator __i2,
       const _CharT* __s, size_type __n)
      {

                      ;
 return this->replace(__i1 - begin(), __i2 - __i1, __s, __n);
      }
# 2043 "/usr/include/c++/10.2.0/bits/basic_string.h" 3
      basic_string&
      replace(__const_iterator __i1, __const_iterator __i2, const _CharT* __s)
      {
 ;
 return this->replace(__i1, __i2, __s, traits_type::length(__s));
      }
# 2064 "/usr/include/c++/10.2.0/bits/basic_string.h" 3
      basic_string&
      replace(__const_iterator __i1, __const_iterator __i2, size_type __n,
       _CharT __c)
      {

                      ;
 return _M_replace_aux(__i1 - begin(), __i2 - __i1, __n, __c);
      }
# 2089 "/usr/include/c++/10.2.0/bits/basic_string.h" 3
      template<class _InputIterator,
        typename = std::_RequireInputIter<_InputIterator>>
        basic_string&
        replace(const_iterator __i1, const_iterator __i2,
  _InputIterator __k1, _InputIterator __k2)
        {
  
                        ;
   ;
   return this->_M_replace_dispatch(__i1, __i2, __k1, __k2,
        std::__false_type());
 }
# 2121 "/usr/include/c++/10.2.0/bits/basic_string.h" 3
      basic_string&
      replace(__const_iterator __i1, __const_iterator __i2,
       _CharT* __k1, _CharT* __k2)
      {

                      ;
 ;
 return this->replace(__i1 - begin(), __i2 - __i1,
        __k1, __k2 - __k1);
      }

      basic_string&
      replace(__const_iterator __i1, __const_iterator __i2,
       const _CharT* __k1, const _CharT* __k2)
      {

                      ;
 ;
 return this->replace(__i1 - begin(), __i2 - __i1,
        __k1, __k2 - __k1);
      }

      basic_string&
      replace(__const_iterator __i1, __const_iterator __i2,
       iterator __k1, iterator __k2)
      {

                      ;
 ;
 return this->replace(__i1 - begin(), __i2 - __i1,
        __k1.base(), __k2 - __k1);
      }

      basic_string&
      replace(__const_iterator __i1, __const_iterator __i2,
       const_iterator __k1, const_iterator __k2)
      {

                      ;
 ;
 return this->replace(__i1 - begin(), __i2 - __i1,
        __k1.base(), __k2 - __k1);
      }
# 2180 "/usr/include/c++/10.2.0/bits/basic_string.h" 3
      basic_string& replace(const_iterator __i1, const_iterator __i2,
       initializer_list<_CharT> __l)
      { return this->replace(__i1, __i2, __l.begin(), __l.size()); }
# 2240 "/usr/include/c++/10.2.0/bits/basic_string.h" 3
    private:
      template<class _Integer>
 basic_string&
 _M_replace_dispatch(const_iterator __i1, const_iterator __i2,
       _Integer __n, _Integer __val, __true_type)
        { return _M_replace_aux(__i1 - begin(), __i2 - __i1, __n, __val); }

      template<class _InputIterator>
 basic_string&
 _M_replace_dispatch(const_iterator __i1, const_iterator __i2,
       _InputIterator __k1, _InputIterator __k2,
       __false_type);

      basic_string&
      _M_replace_aux(size_type __pos1, size_type __n1, size_type __n2,
       _CharT __c);

      basic_string&
      _M_replace(size_type __pos, size_type __len1, const _CharT* __s,
   const size_type __len2);

      basic_string&
      _M_append(const _CharT* __s, size_type __n);

    public:
# 2278 "/usr/include/c++/10.2.0/bits/basic_string.h" 3
      size_type
      copy(_CharT* __s, size_type __n, size_type __pos = 0) const;
# 2288 "/usr/include/c++/10.2.0/bits/basic_string.h" 3
      void
      swap(basic_string& __s) noexcept;
# 2298 "/usr/include/c++/10.2.0/bits/basic_string.h" 3
      const _CharT*
      c_str() const noexcept
      { return _M_data(); }
# 2310 "/usr/include/c++/10.2.0/bits/basic_string.h" 3
      const _CharT*
      data() const noexcept
      { return _M_data(); }
# 2329 "/usr/include/c++/10.2.0/bits/basic_string.h" 3
      allocator_type
      get_allocator() const noexcept
      { return _M_get_allocator(); }
# 2345 "/usr/include/c++/10.2.0/bits/basic_string.h" 3
      size_type
      find(const _CharT* __s, size_type __pos, size_type __n) const
      noexcept;
# 2359 "/usr/include/c++/10.2.0/bits/basic_string.h" 3
      size_type
      find(const basic_string& __str, size_type __pos = 0) const
      noexcept
      { return this->find(__str.data(), __pos, __str.size()); }
# 2391 "/usr/include/c++/10.2.0/bits/basic_string.h" 3
      size_type
      find(const _CharT* __s, size_type __pos = 0) const noexcept
      {
 ;
 return this->find(__s, __pos, traits_type::length(__s));
      }
# 2408 "/usr/include/c++/10.2.0/bits/basic_string.h" 3
      size_type
      find(_CharT __c, size_type __pos = 0) const noexcept;
# 2421 "/usr/include/c++/10.2.0/bits/basic_string.h" 3
      size_type
      rfind(const basic_string& __str, size_type __pos = npos) const
      noexcept
      { return this->rfind(__str.data(), __pos, __str.size()); }
# 2455 "/usr/include/c++/10.2.0/bits/basic_string.h" 3
      size_type
      rfind(const _CharT* __s, size_type __pos, size_type __n) const
      noexcept;
# 2469 "/usr/include/c++/10.2.0/bits/basic_string.h" 3
      size_type
      rfind(const _CharT* __s, size_type __pos = npos) const
      {
 ;
 return this->rfind(__s, __pos, traits_type::length(__s));
      }
# 2486 "/usr/include/c++/10.2.0/bits/basic_string.h" 3
      size_type
      rfind(_CharT __c, size_type __pos = npos) const noexcept;
# 2500 "/usr/include/c++/10.2.0/bits/basic_string.h" 3
      size_type
      find_first_of(const basic_string& __str, size_type __pos = 0) const
      noexcept
      { return this->find_first_of(__str.data(), __pos, __str.size()); }
# 2535 "/usr/include/c++/10.2.0/bits/basic_string.h" 3
      size_type
      find_first_of(const _CharT* __s, size_type __pos, size_type __n) const
      noexcept;
# 2549 "/usr/include/c++/10.2.0/bits/basic_string.h" 3
      size_type
      find_first_of(const _CharT* __s, size_type __pos = 0) const
      noexcept
      {
 ;
 return this->find_first_of(__s, __pos, traits_type::length(__s));
      }
# 2569 "/usr/include/c++/10.2.0/bits/basic_string.h" 3
      size_type
      find_first_of(_CharT __c, size_type __pos = 0) const noexcept
      { return this->find(__c, __pos); }
# 2584 "/usr/include/c++/10.2.0/bits/basic_string.h" 3
      size_type
      find_last_of(const basic_string& __str, size_type __pos = npos) const
      noexcept
      { return this->find_last_of(__str.data(), __pos, __str.size()); }
# 2619 "/usr/include/c++/10.2.0/bits/basic_string.h" 3
      size_type
      find_last_of(const _CharT* __s, size_type __pos, size_type __n) const
      noexcept;
# 2633 "/usr/include/c++/10.2.0/bits/basic_string.h" 3
      size_type
      find_last_of(const _CharT* __s, size_type __pos = npos) const
      noexcept
      {
 ;
 return this->find_last_of(__s, __pos, traits_type::length(__s));
      }
# 2653 "/usr/include/c++/10.2.0/bits/basic_string.h" 3
      size_type
      find_last_of(_CharT __c, size_type __pos = npos) const noexcept
      { return this->rfind(__c, __pos); }
# 2667 "/usr/include/c++/10.2.0/bits/basic_string.h" 3
      size_type
      find_first_not_of(const basic_string& __str, size_type __pos = 0) const
      noexcept
      { return this->find_first_not_of(__str.data(), __pos, __str.size()); }
# 2702 "/usr/include/c++/10.2.0/bits/basic_string.h" 3
      size_type
      find_first_not_of(const _CharT* __s, size_type __pos,
   size_type __n) const noexcept;
# 2716 "/usr/include/c++/10.2.0/bits/basic_string.h" 3
      size_type
      find_first_not_of(const _CharT* __s, size_type __pos = 0) const
      noexcept
      {
 ;
 return this->find_first_not_of(__s, __pos, traits_type::length(__s));
      }
# 2734 "/usr/include/c++/10.2.0/bits/basic_string.h" 3
      size_type
      find_first_not_of(_CharT __c, size_type __pos = 0) const
      noexcept;
# 2749 "/usr/include/c++/10.2.0/bits/basic_string.h" 3
      size_type
      find_last_not_of(const basic_string& __str, size_type __pos = npos) const
      noexcept
      { return this->find_last_not_of(__str.data(), __pos, __str.size()); }
# 2784 "/usr/include/c++/10.2.0/bits/basic_string.h" 3
      size_type
      find_last_not_of(const _CharT* __s, size_type __pos,
         size_type __n) const noexcept;
# 2798 "/usr/include/c++/10.2.0/bits/basic_string.h" 3
      size_type
      find_last_not_of(const _CharT* __s, size_type __pos = npos) const
      noexcept
      {
 ;
 return this->find_last_not_of(__s, __pos, traits_type::length(__s));
      }
# 2816 "/usr/include/c++/10.2.0/bits/basic_string.h" 3
      size_type
      find_last_not_of(_CharT __c, size_type __pos = npos) const
      noexcept;
# 2832 "/usr/include/c++/10.2.0/bits/basic_string.h" 3
      basic_string
      substr(size_type __pos = 0, size_type __n = npos) const
      { return basic_string(*this,
       _M_check(__pos, "basic_string::substr"), __n); }
# 2851 "/usr/include/c++/10.2.0/bits/basic_string.h" 3
      int
      compare(const basic_string& __str) const
      {
 const size_type __size = this->size();
 const size_type __osize = __str.size();
 const size_type __len = std::min(__size, __osize);

 int __r = traits_type::compare(_M_data(), __str.data(), __len);
 if (!__r)
   __r = _S_compare(__size, __osize);
 return __r;
      }
# 2944 "/usr/include/c++/10.2.0/bits/basic_string.h" 3
      int
      compare(size_type __pos, size_type __n, const basic_string& __str) const;
# 2970 "/usr/include/c++/10.2.0/bits/basic_string.h" 3
      int
      compare(size_type __pos1, size_type __n1, const basic_string& __str,
       size_type __pos2, size_type __n2 = npos) const;
# 2988 "/usr/include/c++/10.2.0/bits/basic_string.h" 3
      int
      compare(const _CharT* __s) const noexcept;
# 3012 "/usr/include/c++/10.2.0/bits/basic_string.h" 3
      int
      compare(size_type __pos, size_type __n1, const _CharT* __s) const;
# 3039 "/usr/include/c++/10.2.0/bits/basic_string.h" 3
      int
      compare(size_type __pos, size_type __n1, const _CharT* __s,
       size_type __n2) const;
# 3070 "/usr/include/c++/10.2.0/bits/basic_string.h" 3
      template<typename, typename, typename> friend class basic_stringbuf;
    };
}
# 6020 "/usr/include/c++/10.2.0/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>
    operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    {
      basic_string<_CharT, _Traits, _Alloc> __str(__lhs);
      __str.append(__rhs);
      return __str;
    }







  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT,_Traits,_Alloc>
    operator+(const _CharT* __lhs,
       const basic_string<_CharT,_Traits,_Alloc>& __rhs);







  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT,_Traits,_Alloc>
    operator+(_CharT __lhs, const basic_string<_CharT,_Traits,_Alloc>& __rhs);







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       const _CharT* __rhs)
    {
      basic_string<_CharT, _Traits, _Alloc> __str(__lhs);
      __str.append(__rhs);
      return __str;
    }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs, _CharT __rhs)
    {
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef typename __string_type::size_type __size_type;
      __string_type __str(__lhs);
      __str.append(__size_type(1), __rhs);
      return __str;
    }


  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(basic_string<_CharT, _Traits, _Alloc>&& __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return std::move(__lhs.append(__rhs)); }

  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       basic_string<_CharT, _Traits, _Alloc>&& __rhs)
    { return std::move(__rhs.insert(0, __lhs)); }

  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(basic_string<_CharT, _Traits, _Alloc>&& __lhs,
       basic_string<_CharT, _Traits, _Alloc>&& __rhs)
    {

      using _Alloc_traits = allocator_traits<_Alloc>;
      bool __use_rhs = false;
      if (typename _Alloc_traits::is_always_equal{})
 __use_rhs = true;
      else if (__lhs.get_allocator() == __rhs.get_allocator())
 __use_rhs = true;
      if (__use_rhs)

 {
   const auto __size = __lhs.size() + __rhs.size();
   if (__size > __lhs.capacity() && __size <= __rhs.capacity())
     return std::move(__rhs.insert(0, __lhs));
 }
      return std::move(__lhs.append(__rhs));
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(const _CharT* __lhs,
       basic_string<_CharT, _Traits, _Alloc>&& __rhs)
    { return std::move(__rhs.insert(0, __lhs)); }

  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(_CharT __lhs,
       basic_string<_CharT, _Traits, _Alloc>&& __rhs)
    { return std::move(__rhs.insert(0, 1, __lhs)); }

  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(basic_string<_CharT, _Traits, _Alloc>&& __lhs,
       const _CharT* __rhs)
    { return std::move(__lhs.append(__rhs)); }

  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(basic_string<_CharT, _Traits, _Alloc>&& __lhs,
       _CharT __rhs)
    { return std::move(__lhs.append(1, __rhs)); }
# 6151 "/usr/include/c++/10.2.0/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator==(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    noexcept
    { return __lhs.compare(__rhs) == 0; }

  template<typename _CharT>
    inline
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value, bool>::__type
    operator==(const basic_string<_CharT>& __lhs,
        const basic_string<_CharT>& __rhs) noexcept
    { return (__lhs.size() == __rhs.size()
       && !std::char_traits<_CharT>::compare(__lhs.data(), __rhs.data(),
          __lhs.size())); }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator==(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const _CharT* __rhs)
    { return __lhs.compare(__rhs) == 0; }
# 6214 "/usr/include/c++/10.2.0/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator==(const _CharT* __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) == 0; }
# 6227 "/usr/include/c++/10.2.0/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    noexcept
    { return !(__lhs == __rhs); }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator!=(const _CharT* __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return !(__lhs == __rhs); }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const _CharT* __rhs)
    { return !(__lhs == __rhs); }
# 6265 "/usr/include/c++/10.2.0/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    noexcept
    { return __lhs.compare(__rhs) < 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       const _CharT* __rhs)
    { return __lhs.compare(__rhs) < 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<(const _CharT* __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) > 0; }
# 6303 "/usr/include/c++/10.2.0/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    noexcept
    { return __lhs.compare(__rhs) > 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       const _CharT* __rhs)
    { return __lhs.compare(__rhs) > 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>(const _CharT* __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) < 0; }
# 6341 "/usr/include/c++/10.2.0/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    noexcept
    { return __lhs.compare(__rhs) <= 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const _CharT* __rhs)
    { return __lhs.compare(__rhs) <= 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<=(const _CharT* __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) >= 0; }
# 6379 "/usr/include/c++/10.2.0/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    noexcept
    { return __lhs.compare(__rhs) >= 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const _CharT* __rhs)
    { return __lhs.compare(__rhs) >= 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>=(const _CharT* __lhs,
      const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) <= 0; }
# 6418 "/usr/include/c++/10.2.0/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline void
    swap(basic_string<_CharT, _Traits, _Alloc>& __lhs,
  basic_string<_CharT, _Traits, _Alloc>& __rhs)
    noexcept(noexcept(__lhs.swap(__rhs)))
    { __lhs.swap(__rhs); }
# 6438 "/usr/include/c++/10.2.0/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __is,
        basic_string<_CharT, _Traits, _Alloc>& __str);

  template<>
    basic_istream<char>&
    operator>>(basic_istream<char>& __is, basic_string<char>& __str);
# 6456 "/usr/include/c++/10.2.0/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __os,
        const basic_string<_CharT, _Traits, _Alloc>& __str)
    {


      return __ostream_insert(__os, __str.data(), __str.size());
    }
# 6479 "/usr/include/c++/10.2.0/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_istream<_CharT, _Traits>&
    getline(basic_istream<_CharT, _Traits>& __is,
     basic_string<_CharT, _Traits, _Alloc>& __str, _CharT __delim);
# 6496 "/usr/include/c++/10.2.0/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_istream<_CharT, _Traits>&
    getline(basic_istream<_CharT, _Traits>& __is,
     basic_string<_CharT, _Traits, _Alloc>& __str)
    { return std::getline(__is, __str, __is.widen('\n')); }



  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_istream<_CharT, _Traits>&
    getline(basic_istream<_CharT, _Traits>&& __is,
     basic_string<_CharT, _Traits, _Alloc>& __str, _CharT __delim)
    { return std::getline(__is, __str, __delim); }


  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_istream<_CharT, _Traits>&
    getline(basic_istream<_CharT, _Traits>&& __is,
     basic_string<_CharT, _Traits, _Alloc>& __str)
    { return std::getline(__is, __str); }


  template<>
    basic_istream<char>&
    getline(basic_istream<char>& __in, basic_string<char>& __str,
     char __delim);


  template<>
    basic_istream<wchar_t>&
    getline(basic_istream<wchar_t>& __in, basic_string<wchar_t>& __str,
     wchar_t __delim);



}



# 1 "/usr/include/c++/10.2.0/ext/string_conversions.h" 1 3
# 32 "/usr/include/c++/10.2.0/ext/string_conversions.h" 3
       
# 33 "/usr/include/c++/10.2.0/ext/string_conversions.h" 3
# 41 "/usr/include/c++/10.2.0/ext/string_conversions.h" 3
# 1 "/usr/include/c++/10.2.0/cstdlib" 1 3
# 39 "/usr/include/c++/10.2.0/cstdlib" 3
       
# 40 "/usr/include/c++/10.2.0/cstdlib" 3
# 42 "/usr/include/c++/10.2.0/ext/string_conversions.h" 2 3
# 1 "/usr/include/c++/10.2.0/cwchar" 1 3
# 39 "/usr/include/c++/10.2.0/cwchar" 3
       
# 40 "/usr/include/c++/10.2.0/cwchar" 3
# 43 "/usr/include/c++/10.2.0/ext/string_conversions.h" 2 3
# 1 "/usr/include/c++/10.2.0/cstdio" 1 3
# 39 "/usr/include/c++/10.2.0/cstdio" 3
       
# 40 "/usr/include/c++/10.2.0/cstdio" 3
# 96 "/usr/include/c++/10.2.0/cstdio" 3
namespace std
{
  using ::FILE;
  using ::fpos_t;

  using ::clearerr;
  using ::fclose;
  using ::feof;
  using ::ferror;
  using ::fflush;
  using ::fgetc;
  using ::fgetpos;
  using ::fgets;
  using ::fopen;
  using ::fprintf;
  using ::fputc;
  using ::fputs;
  using ::fread;
  using ::freopen;
  using ::fscanf;
  using ::fseek;
  using ::fsetpos;
  using ::ftell;
  using ::fwrite;
  using ::getc;
  using ::getchar;


  using ::gets;

  using ::perror;
  using ::printf;
  using ::putc;
  using ::putchar;
  using ::puts;
  using ::remove;
  using ::rename;
  using ::rewind;
  using ::scanf;
  using ::setbuf;
  using ::setvbuf;
  using ::sprintf;
  using ::sscanf;
  using ::tmpfile;

  using ::tmpnam;

  using ::ungetc;
  using ::vfprintf;
  using ::vprintf;
  using ::vsprintf;
}
# 157 "/usr/include/c++/10.2.0/cstdio" 3
namespace __gnu_cxx
{
# 175 "/usr/include/c++/10.2.0/cstdio" 3
  using ::snprintf;
  using ::vfscanf;
  using ::vscanf;
  using ::vsnprintf;
  using ::vsscanf;

}

namespace std
{
  using ::__gnu_cxx::snprintf;
  using ::__gnu_cxx::vfscanf;
  using ::__gnu_cxx::vscanf;
  using ::__gnu_cxx::vsnprintf;
  using ::__gnu_cxx::vsscanf;
}
# 44 "/usr/include/c++/10.2.0/ext/string_conversions.h" 2 3
# 1 "/usr/include/c++/10.2.0/cerrno" 1 3
# 39 "/usr/include/c++/10.2.0/cerrno" 3
       
# 40 "/usr/include/c++/10.2.0/cerrno" 3


# 1 "/usr/include/errno.h" 1 3 4
# 28 "/usr/include/errno.h" 3 4
# 1 "/usr/include/bits/errno.h" 1 3 4
# 26 "/usr/include/bits/errno.h" 3 4
# 1 "/usr/include/linux/errno.h" 1 3 4
# 1 "/usr/include/asm/errno.h" 1 3 4
# 1 "/usr/include/asm-generic/errno.h" 1 3 4




# 1 "/usr/include/asm-generic/errno-base.h" 1 3 4
# 6 "/usr/include/asm-generic/errno.h" 2 3 4
# 2 "/usr/include/asm/errno.h" 2 3 4
# 2 "/usr/include/linux/errno.h" 2 3 4
# 27 "/usr/include/bits/errno.h" 2 3 4
# 29 "/usr/include/errno.h" 2 3 4





extern "C" {


extern int *__errno_location (void) throw () __attribute__ ((__const__));







extern char *program_invocation_name;
extern char *program_invocation_short_name;

# 1 "/usr/include/bits/types/error_t.h" 1 3 4
# 22 "/usr/include/bits/types/error_t.h" 3 4
typedef int error_t;
# 49 "/usr/include/errno.h" 2 3 4



}
# 43 "/usr/include/c++/10.2.0/cerrno" 2 3
# 45 "/usr/include/c++/10.2.0/ext/string_conversions.h" 2 3

namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{



  template<typename _TRet, typename _Ret = _TRet, typename _CharT,
    typename... _Base>
    _Ret
    __stoa(_TRet (*__convf) (const _CharT*, _CharT**, _Base...),
    const char* __name, const _CharT* __str, std::size_t* __idx,
    _Base... __base)
    {
      _Ret __ret;

      _CharT* __endptr;

      struct _Save_errno {
 _Save_errno() : _M_errno((*__errno_location ())) { (*__errno_location ()) = 0; }
 ~_Save_errno() { if ((*__errno_location ()) == 0) (*__errno_location ()) = _M_errno; }
 int _M_errno;
      } const __save_errno;

      struct _Range_chk {
   static bool
   _S_chk(_TRet, std::false_type) { return false; }

   static bool
   _S_chk(_TRet __val, std::true_type)
   {
     return __val < _TRet(__numeric_traits<int>::__min)
       || __val > _TRet(__numeric_traits<int>::__max);
   }
      };

      const _TRet __tmp = __convf(__str, &__endptr, __base...);

      if (__endptr == __str)
 std::__throw_invalid_argument(__name);
      else if ((*__errno_location ()) == 34
   || _Range_chk::_S_chk(__tmp, std::is_same<_Ret, int>{}))
 std::__throw_out_of_range(__name);
      else
 __ret = __tmp;

      if (__idx)
 *__idx = __endptr - __str;

      return __ret;
    }


  template<typename _String, typename _CharT = typename _String::value_type>
    _String
    __to_xstring(int (*__convf) (_CharT*, std::size_t, const _CharT*,
     __builtin_va_list), std::size_t __n,
   const _CharT* __fmt, ...)
    {


      _CharT* __s = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
         * __n));

      __builtin_va_list __args;
      __builtin_va_start(__args, __fmt);

      const int __len = __convf(__s, __n, __fmt, __args);

      __builtin_va_end(__args);

      return _String(__s, __s + __len);
    }


}
# 6536 "/usr/include/c++/10.2.0/bits/basic_string.h" 2 3
# 1 "/usr/include/c++/10.2.0/bits/charconv.h" 1 3
# 33 "/usr/include/c++/10.2.0/bits/charconv.h" 3
       
# 34 "/usr/include/c++/10.2.0/bits/charconv.h" 3





namespace std __attribute__ ((__visibility__ ("default")))
{

namespace __detail
{

  template<typename _Tp>
    unsigned
    __to_chars_len(_Tp __value, int __base = 10) noexcept
    {
      static_assert(is_integral<_Tp>::value, "implementation bug");
      static_assert(is_unsigned<_Tp>::value, "implementation bug");

      unsigned __n = 1;
      const unsigned __b2 = __base * __base;
      const unsigned __b3 = __b2 * __base;
      const unsigned long __b4 = __b3 * __base;
      for (;;)
 {
   if (__value < (unsigned)__base) return __n;
   if (__value < __b2) return __n + 1;
   if (__value < __b3) return __n + 2;
   if (__value < __b4) return __n + 3;
   __value /= __b4;
   __n += 4;
 }
    }




  template<typename _Tp>
    void
    __to_chars_10_impl(char* __first, unsigned __len, _Tp __val) noexcept
    {
      static_assert(is_integral<_Tp>::value, "implementation bug");
      static_assert(is_unsigned<_Tp>::value, "implementation bug");

      static constexpr char __digits[201] =
 "0001020304050607080910111213141516171819"
 "2021222324252627282930313233343536373839"
 "4041424344454647484950515253545556575859"
 "6061626364656667686970717273747576777879"
 "8081828384858687888990919293949596979899";
      unsigned __pos = __len - 1;
      while (__val >= 100)
 {
   auto const __num = (__val % 100) * 2;
   __val /= 100;
   __first[__pos] = __digits[__num + 1];
   __first[__pos - 1] = __digits[__num];
   __pos -= 2;
 }
      if (__val >= 10)
 {
   auto const __num = __val * 2;
   __first[1] = __digits[__num + 1];
   __first[0] = __digits[__num];
 }
      else
 __first[0] = '0' + __val;
    }

}

}
# 6537 "/usr/include/c++/10.2.0/bits/basic_string.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{

namespace __cxx11 {



  inline int
  stoi(const string& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa<long, int>(&std::strtol, "stoi", __str.c_str(),
     __idx, __base); }

  inline long
  stol(const string& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa(&std::strtol, "stol", __str.c_str(),
        __idx, __base); }

  inline unsigned long
  stoul(const string& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa(&std::strtoul, "stoul", __str.c_str(),
        __idx, __base); }

  inline long long
  stoll(const string& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa(&std::strtoll, "stoll", __str.c_str(),
        __idx, __base); }

  inline unsigned long long
  stoull(const string& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa(&std::strtoull, "stoull", __str.c_str(),
        __idx, __base); }


  inline float
  stof(const string& __str, size_t* __idx = 0)
  { return __gnu_cxx::__stoa(&std::strtof, "stof", __str.c_str(), __idx); }

  inline double
  stod(const string& __str, size_t* __idx = 0)
  { return __gnu_cxx::__stoa(&std::strtod, "stod", __str.c_str(), __idx); }

  inline long double
  stold(const string& __str, size_t* __idx = 0)
  { return __gnu_cxx::__stoa(&std::strtold, "stold", __str.c_str(), __idx); }




  inline string
  to_string(int __val)
  {
    const bool __neg = __val < 0;
    const unsigned __uval = __neg ? (unsigned)~__val + 1u : __val;
    const auto __len = __detail::__to_chars_len(__uval);
    string __str(__neg + __len, '-');
    __detail::__to_chars_10_impl(&__str[__neg], __len, __uval);
    return __str;
  }

  inline string
  to_string(unsigned __val)
  {
    string __str(__detail::__to_chars_len(__val), '\0');
    __detail::__to_chars_10_impl(&__str[0], __str.size(), __val);
    return __str;
  }

  inline string
  to_string(long __val)
  {
    const bool __neg = __val < 0;
    const unsigned long __uval = __neg ? (unsigned long)~__val + 1ul : __val;
    const auto __len = __detail::__to_chars_len(__uval);
    string __str(__neg + __len, '-');
    __detail::__to_chars_10_impl(&__str[__neg], __len, __uval);
    return __str;
  }

  inline string
  to_string(unsigned long __val)
  {
    string __str(__detail::__to_chars_len(__val), '\0');
    __detail::__to_chars_10_impl(&__str[0], __str.size(), __val);
    return __str;
  }

  inline string
  to_string(long long __val)
  {
    const bool __neg = __val < 0;
    const unsigned long long __uval
      = __neg ? (unsigned long long)~__val + 1ull : __val;
    const auto __len = __detail::__to_chars_len(__uval);
    string __str(__neg + __len, '-');
    __detail::__to_chars_10_impl(&__str[__neg], __len, __uval);
    return __str;
  }

  inline string
  to_string(unsigned long long __val)
  {
    string __str(__detail::__to_chars_len(__val), '\0');
    __detail::__to_chars_10_impl(&__str[0], __str.size(), __val);
    return __str;
  }




  inline string
  to_string(float __val)
  {
    const int __n =
      __gnu_cxx::__numeric_traits<float>::__max_exponent10 + 20;
    return __gnu_cxx::__to_xstring<string>(&std::vsnprintf, __n,
        "%f", __val);
  }

  inline string
  to_string(double __val)
  {
    const int __n =
      __gnu_cxx::__numeric_traits<double>::__max_exponent10 + 20;
    return __gnu_cxx::__to_xstring<string>(&std::vsnprintf, __n,
        "%f", __val);
  }

  inline string
  to_string(long double __val)
  {
    const int __n =
      __gnu_cxx::__numeric_traits<long double>::__max_exponent10 + 20;
    return __gnu_cxx::__to_xstring<string>(&std::vsnprintf, __n,
        "%Lf", __val);
  }



  inline int
  stoi(const wstring& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa<long, int>(&std::wcstol, "stoi", __str.c_str(),
     __idx, __base); }

  inline long
  stol(const wstring& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa(&std::wcstol, "stol", __str.c_str(),
        __idx, __base); }

  inline unsigned long
  stoul(const wstring& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa(&std::wcstoul, "stoul", __str.c_str(),
        __idx, __base); }

  inline long long
  stoll(const wstring& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa(&std::wcstoll, "stoll", __str.c_str(),
        __idx, __base); }

  inline unsigned long long
  stoull(const wstring& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa(&std::wcstoull, "stoull", __str.c_str(),
        __idx, __base); }


  inline float
  stof(const wstring& __str, size_t* __idx = 0)
  { return __gnu_cxx::__stoa(&std::wcstof, "stof", __str.c_str(), __idx); }

  inline double
  stod(const wstring& __str, size_t* __idx = 0)
  { return __gnu_cxx::__stoa(&std::wcstod, "stod", __str.c_str(), __idx); }

  inline long double
  stold(const wstring& __str, size_t* __idx = 0)
  { return __gnu_cxx::__stoa(&std::wcstold, "stold", __str.c_str(), __idx); }



  inline wstring
  to_wstring(int __val)
  { return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf, 4 * sizeof(int),
         L"%d", __val); }

  inline wstring
  to_wstring(unsigned __val)
  { return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf,
         4 * sizeof(unsigned),
         L"%u", __val); }

  inline wstring
  to_wstring(long __val)
  { return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf, 4 * sizeof(long),
         L"%ld", __val); }

  inline wstring
  to_wstring(unsigned long __val)
  { return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf,
         4 * sizeof(unsigned long),
         L"%lu", __val); }

  inline wstring
  to_wstring(long long __val)
  { return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf,
         4 * sizeof(long long),
         L"%lld", __val); }

  inline wstring
  to_wstring(unsigned long long __val)
  { return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf,
         4 * sizeof(unsigned long long),
         L"%llu", __val); }

  inline wstring
  to_wstring(float __val)
  {
    const int __n =
      __gnu_cxx::__numeric_traits<float>::__max_exponent10 + 20;
    return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf, __n,
         L"%f", __val);
  }

  inline wstring
  to_wstring(double __val)
  {
    const int __n =
      __gnu_cxx::__numeric_traits<double>::__max_exponent10 + 20;
    return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf, __n,
         L"%f", __val);
  }

  inline wstring
  to_wstring(long double __val)
  {
    const int __n =
      __gnu_cxx::__numeric_traits<long double>::__max_exponent10 + 20;
    return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf, __n,
         L"%Lf", __val);
  }



}

}





# 1 "/usr/include/c++/10.2.0/bits/functional_hash.h" 1 3
# 33 "/usr/include/c++/10.2.0/bits/functional_hash.h" 3
       
# 34 "/usr/include/c++/10.2.0/bits/functional_hash.h" 3



namespace std __attribute__ ((__visibility__ ("default")))
{

# 49 "/usr/include/c++/10.2.0/bits/functional_hash.h" 3
  template<typename _Result, typename _Arg>
    struct __hash_base
    {
      typedef _Result result_type ;
      typedef _Arg argument_type ;
    };


  template<typename _Tp>
    struct hash;

  template<typename _Tp, typename = void>
    struct __poison_hash
    {
      static constexpr bool __enable_hash_call = false;
    private:

      __poison_hash(__poison_hash&&);
      ~__poison_hash();
    };

  template<typename _Tp>
    struct __poison_hash<_Tp, __void_t<decltype(hash<_Tp>()(declval<_Tp>()))>>
    {
      static constexpr bool __enable_hash_call = true;
    };


  template<typename _Tp, bool = is_enum<_Tp>::value>
    struct __hash_enum
    {
    private:

      __hash_enum(__hash_enum&&);
      ~__hash_enum();
    };


  template<typename _Tp>
    struct __hash_enum<_Tp, true> : public __hash_base<size_t, _Tp>
    {
      size_t
      operator()(_Tp __val) const noexcept
      {
       using __type = typename underlying_type<_Tp>::type;
       return hash<__type>{}(static_cast<__type>(__val));
      }
    };



  template<typename _Tp>
    struct hash : __hash_enum<_Tp>
    { };


  template<typename _Tp>
    struct hash<_Tp*> : public __hash_base<size_t, _Tp*>
    {
      size_t
      operator()(_Tp* __p) const noexcept
      { return reinterpret_cast<size_t>(__p); }
    };
# 124 "/usr/include/c++/10.2.0/bits/functional_hash.h" 3
  template<> struct hash<bool> : public __hash_base<size_t, bool> { size_t operator()(bool __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<char> : public __hash_base<size_t, char> { size_t operator()(char __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<signed char> : public __hash_base<size_t, signed char> { size_t operator()(signed char __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<unsigned char> : public __hash_base<size_t, unsigned char> { size_t operator()(unsigned char __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<wchar_t> : public __hash_base<size_t, wchar_t> { size_t operator()(wchar_t __val) const noexcept { return static_cast<size_t>(__val); } };







  template<> struct hash<char16_t> : public __hash_base<size_t, char16_t> { size_t operator()(char16_t __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<char32_t> : public __hash_base<size_t, char32_t> { size_t operator()(char32_t __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<short> : public __hash_base<size_t, short> { size_t operator()(short __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<int> : public __hash_base<size_t, int> { size_t operator()(int __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<long> : public __hash_base<size_t, long> { size_t operator()(long __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<long long> : public __hash_base<size_t, long long> { size_t operator()(long long __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<unsigned short> : public __hash_base<size_t, unsigned short> { size_t operator()(unsigned short __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<unsigned int> : public __hash_base<size_t, unsigned int> { size_t operator()(unsigned int __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<unsigned long> : public __hash_base<size_t, unsigned long> { size_t operator()(unsigned long __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<unsigned long long> : public __hash_base<size_t, unsigned long long> { size_t operator()(unsigned long long __val) const noexcept { return static_cast<size_t>(__val); } };
# 192 "/usr/include/c++/10.2.0/bits/functional_hash.h" 3
  struct _Hash_impl
  {
    static size_t
    hash(const void* __ptr, size_t __clength,
  size_t __seed = static_cast<size_t>(0xc70f6907UL))
    { return _Hash_bytes(__ptr, __clength, __seed); }

    template<typename _Tp>
      static size_t
      hash(const _Tp& __val)
      { return hash(&__val, sizeof(__val)); }

    template<typename _Tp>
      static size_t
      __hash_combine(const _Tp& __val, size_t __hash)
      { return hash(&__val, sizeof(__val), __hash); }
  };


  struct _Fnv_hash_impl
  {
    static size_t
    hash(const void* __ptr, size_t __clength,
  size_t __seed = static_cast<size_t>(2166136261UL))
    { return _Fnv_hash_bytes(__ptr, __clength, __seed); }

    template<typename _Tp>
      static size_t
      hash(const _Tp& __val)
      { return hash(&__val, sizeof(__val)); }

    template<typename _Tp>
      static size_t
      __hash_combine(const _Tp& __val, size_t __hash)
      { return hash(&__val, sizeof(__val), __hash); }
  };


  template<>
    struct hash<float> : public __hash_base<size_t, float>
    {
      size_t
      operator()(float __val) const noexcept
      {

 return __val != 0.0f ? std::_Hash_impl::hash(__val) : 0;
      }
    };


  template<>
    struct hash<double> : public __hash_base<size_t, double>
    {
      size_t
      operator()(double __val) const noexcept
      {

 return __val != 0.0 ? std::_Hash_impl::hash(__val) : 0;
      }
    };


  template<>
    struct hash<long double>
    : public __hash_base<size_t, long double>
    {
      __attribute__ ((__pure__)) size_t
      operator()(long double __val) const noexcept;
    };
# 278 "/usr/include/c++/10.2.0/bits/functional_hash.h" 3
  template<typename _Hash>
    struct __is_fast_hash : public std::true_type
    { };

  template<>
    struct __is_fast_hash<hash<long double>> : public std::false_type
    { };


}
# 6788 "/usr/include/c++/10.2.0/bits/basic_string.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{






  template<>
    struct hash<string>
    : public __hash_base<size_t, string>
    {
      size_t
      operator()(const string& __s) const noexcept
      { return std::_Hash_impl::hash(__s.data(), __s.length()); }
    };

  template<>
    struct __is_fast_hash<hash<string>> : std::false_type
    { };



  template<>
    struct hash<wstring>
    : public __hash_base<size_t, wstring>
    {
      size_t
      operator()(const wstring& __s) const noexcept
      { return std::_Hash_impl::hash(__s.data(),
                                     __s.length() * sizeof(wchar_t)); }
    };

  template<>
    struct __is_fast_hash<hash<wstring>> : std::false_type
    { };
# 6846 "/usr/include/c++/10.2.0/bits/basic_string.h" 3
  template<>
    struct hash<u16string>
    : public __hash_base<size_t, u16string>
    {
      size_t
      operator()(const u16string& __s) const noexcept
      { return std::_Hash_impl::hash(__s.data(),
                                     __s.length() * sizeof(char16_t)); }
    };

  template<>
    struct __is_fast_hash<hash<u16string>> : std::false_type
    { };


  template<>
    struct hash<u32string>
    : public __hash_base<size_t, u32string>
    {
      size_t
      operator()(const u32string& __s) const noexcept
      { return std::_Hash_impl::hash(__s.data(),
                                     __s.length() * sizeof(char32_t)); }
    };

  template<>
    struct __is_fast_hash<hash<u32string>> : std::false_type
    { };
# 6936 "/usr/include/c++/10.2.0/bits/basic_string.h" 3

}
# 56 "/usr/include/c++/10.2.0/string" 2 3
# 1 "/usr/include/c++/10.2.0/bits/basic_string.tcc" 1 3
# 42 "/usr/include/c++/10.2.0/bits/basic_string.tcc" 3
       
# 43 "/usr/include/c++/10.2.0/bits/basic_string.tcc" 3



namespace std __attribute__ ((__visibility__ ("default")))
{




  template<typename _CharT, typename _Traits, typename _Alloc>
    const typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::npos;

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    swap(basic_string& __s) noexcept
    {
      if (this == &__s)
 return;

      _Alloc_traits::_S_on_swap(_M_get_allocator(), __s._M_get_allocator());

      if (_M_is_local())
 if (__s._M_is_local())
   {
     if (length() && __s.length())
       {
  _CharT __tmp_data[_S_local_capacity + 1];
  traits_type::copy(__tmp_data, __s._M_local_buf,
      _S_local_capacity + 1);
  traits_type::copy(__s._M_local_buf, _M_local_buf,
      _S_local_capacity + 1);
  traits_type::copy(_M_local_buf, __tmp_data,
      _S_local_capacity + 1);
       }
     else if (__s.length())
       {
  traits_type::copy(_M_local_buf, __s._M_local_buf,
      _S_local_capacity + 1);
  _M_length(__s.length());
  __s._M_set_length(0);
  return;
       }
     else if (length())
       {
  traits_type::copy(__s._M_local_buf, _M_local_buf,
      _S_local_capacity + 1);
  __s._M_length(length());
  _M_set_length(0);
  return;
       }
   }
 else
   {
     const size_type __tmp_capacity = __s._M_allocated_capacity;
     traits_type::copy(__s._M_local_buf, _M_local_buf,
         _S_local_capacity + 1);
     _M_data(__s._M_data());
     __s._M_data(__s._M_local_buf);
     _M_capacity(__tmp_capacity);
   }
      else
 {
   const size_type __tmp_capacity = _M_allocated_capacity;
   if (__s._M_is_local())
     {
       traits_type::copy(_M_local_buf, __s._M_local_buf,
    _S_local_capacity + 1);
       __s._M_data(_M_data());
       _M_data(_M_local_buf);
     }
   else
     {
       pointer __tmp_ptr = _M_data();
       _M_data(__s._M_data());
       __s._M_data(__tmp_ptr);
       _M_capacity(__s._M_allocated_capacity);
     }
   __s._M_capacity(__tmp_capacity);
 }

      const size_type __tmp_length = length();
      _M_length(__s.length());
      __s._M_length(__tmp_length);
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::pointer
    basic_string<_CharT, _Traits, _Alloc>::
    _M_create(size_type& __capacity, size_type __old_capacity)
    {


      if (__capacity > max_size())
 std::__throw_length_error(("basic_string::_M_create"));




      if (__capacity > __old_capacity && __capacity < 2 * __old_capacity)
 {
   __capacity = 2 * __old_capacity;

   if (__capacity > max_size())
     __capacity = max_size();
 }



      return _Alloc_traits::allocate(_M_get_allocator(), __capacity + 1);
    }





  template<typename _CharT, typename _Traits, typename _Alloc>
    template<typename _InIterator>
      void
      basic_string<_CharT, _Traits, _Alloc>::
      _M_construct(_InIterator __beg, _InIterator __end,
     std::input_iterator_tag)
      {
 size_type __len = 0;
 size_type __capacity = size_type(_S_local_capacity);

 while (__beg != __end && __len < __capacity)
   {
     _M_data()[__len++] = *__beg;
     ++__beg;
   }

 try
   {
     while (__beg != __end)
       {
  if (__len == __capacity)
    {

      __capacity = __len + 1;
      pointer __another = _M_create(__capacity, __len);
      this->_S_copy(__another, _M_data(), __len);
      _M_dispose();
      _M_data(__another);
      _M_capacity(__capacity);
    }
  _M_data()[__len++] = *__beg;
  ++__beg;
       }
   }
 catch(...)
   {
     _M_dispose();
     throw;
   }

 _M_set_length(__len);
      }

  template<typename _CharT, typename _Traits, typename _Alloc>
    template<typename _InIterator>
      void
      basic_string<_CharT, _Traits, _Alloc>::
      _M_construct(_InIterator __beg, _InIterator __end,
     std::forward_iterator_tag)
      {

 if (__gnu_cxx::__is_null_pointer(__beg) && __beg != __end)
   std::__throw_logic_error(("basic_string::" "_M_construct null not valid")
                                         );

 size_type __dnew = static_cast<size_type>(std::distance(__beg, __end));

 if (__dnew > size_type(_S_local_capacity))
   {
     _M_data(_M_create(__dnew, size_type(0)));
     _M_capacity(__dnew);
   }


 try
   { this->_S_copy_chars(_M_data(), __beg, __end); }
 catch(...)
   {
     _M_dispose();
     throw;
   }

 _M_set_length(__dnew);
      }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    _M_construct(size_type __n, _CharT __c)
    {
      if (__n > size_type(_S_local_capacity))
 {
   _M_data(_M_create(__n, size_type(0)));
   _M_capacity(__n);
 }

      if (__n)
 this->_S_assign(_M_data(), __n, __c);

      _M_set_length(__n);
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    _M_assign(const basic_string& __str)
    {
      if (this != &__str)
 {
   const size_type __rsize = __str.length();
   const size_type __capacity = capacity();

   if (__rsize > __capacity)
     {
       size_type __new_capacity = __rsize;
       pointer __tmp = _M_create(__new_capacity, __capacity);
       _M_dispose();
       _M_data(__tmp);
       _M_capacity(__new_capacity);
     }

   if (__rsize)
     this->_S_copy(_M_data(), __str._M_data(), __rsize);

   _M_set_length(__rsize);
 }
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    reserve(size_type __res)
    {

      if (__res < length())
 __res = length();

      const size_type __capacity = capacity();
      if (__res != __capacity)
 {
   if (__res > __capacity
       || __res > size_type(_S_local_capacity))
     {
       pointer __tmp = _M_create(__res, __capacity);
       this->_S_copy(__tmp, _M_data(), length() + 1);
       _M_dispose();
       _M_data(__tmp);
       _M_capacity(__res);
     }
   else if (!_M_is_local())
     {
       this->_S_copy(_M_local_data(), _M_data(), length() + 1);
       _M_destroy(__capacity);
       _M_data(_M_local_data());
     }
 }
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    _M_mutate(size_type __pos, size_type __len1, const _CharT* __s,
       size_type __len2)
    {
      const size_type __how_much = length() - __pos - __len1;

      size_type __new_capacity = length() + __len2 - __len1;
      pointer __r = _M_create(__new_capacity, capacity());

      if (__pos)
 this->_S_copy(__r, _M_data(), __pos);
      if (__s && __len2)
 this->_S_copy(__r + __pos, __s, __len2);
      if (__how_much)
 this->_S_copy(__r + __pos + __len2,
        _M_data() + __pos + __len1, __how_much);

      _M_dispose();
      _M_data(__r);
      _M_capacity(__new_capacity);
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    _M_erase(size_type __pos, size_type __n)
    {
      const size_type __how_much = length() - __pos - __n;

      if (__how_much && __n)
 this->_S_move(_M_data() + __pos, _M_data() + __pos + __n, __how_much);

      _M_set_length(length() - __n);
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    resize(size_type __n, _CharT __c)
    {
      const size_type __size = this->size();
      if (__size < __n)
 this->append(__n - __size, __c);
      else if (__n < __size)
 this->_M_set_length(__n);
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    _M_append(const _CharT* __s, size_type __n)
    {
      const size_type __len = __n + this->size();

      if (__len <= this->capacity())
 {
   if (__n)
     this->_S_copy(this->_M_data() + this->size(), __s, __n);
 }
      else
 this->_M_mutate(this->size(), size_type(0), __s, __n);

      this->_M_set_length(__len);
      return *this;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    template<typename _InputIterator>
      basic_string<_CharT, _Traits, _Alloc>&
      basic_string<_CharT, _Traits, _Alloc>::
      _M_replace_dispatch(const_iterator __i1, const_iterator __i2,
     _InputIterator __k1, _InputIterator __k2,
     std::__false_type)
      {


 const basic_string __s(__k1, __k2, this->get_allocator());
 const size_type __n1 = __i2 - __i1;
 return _M_replace(__i1 - begin(), __n1, __s._M_data(),
     __s.size());
      }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    _M_replace_aux(size_type __pos1, size_type __n1, size_type __n2,
     _CharT __c)
    {
      _M_check_length(__n1, __n2, "basic_string::_M_replace_aux");

      const size_type __old_size = this->size();
      const size_type __new_size = __old_size + __n2 - __n1;

      if (__new_size <= this->capacity())
 {
   pointer __p = this->_M_data() + __pos1;

   const size_type __how_much = __old_size - __pos1 - __n1;
   if (__how_much && __n1 != __n2)
     this->_S_move(__p + __n2, __p + __n1, __how_much);
 }
      else
 this->_M_mutate(__pos1, __n1, 0, __n2);

      if (__n2)
 this->_S_assign(this->_M_data() + __pos1, __n2, __c);

      this->_M_set_length(__new_size);
      return *this;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    _M_replace(size_type __pos, size_type __len1, const _CharT* __s,
        const size_type __len2)
    {
      _M_check_length(__len1, __len2, "basic_string::_M_replace");

      const size_type __old_size = this->size();
      const size_type __new_size = __old_size + __len2 - __len1;

      if (__new_size <= this->capacity())
 {
   pointer __p = this->_M_data() + __pos;

   const size_type __how_much = __old_size - __pos - __len1;
   if (_M_disjunct(__s))
     {
       if (__how_much && __len1 != __len2)
  this->_S_move(__p + __len2, __p + __len1, __how_much);
       if (__len2)
  this->_S_copy(__p, __s, __len2);
     }
   else
     {

       if (__len2 && __len2 <= __len1)
  this->_S_move(__p, __s, __len2);
       if (__how_much && __len1 != __len2)
  this->_S_move(__p + __len2, __p + __len1, __how_much);
       if (__len2 > __len1)
  {
    if (__s + __len2 <= __p + __len1)
      this->_S_move(__p, __s, __len2);
    else if (__s >= __p + __len1)
      this->_S_copy(__p, __s + __len2 - __len1, __len2);
    else
      {
        const size_type __nleft = (__p + __len1) - __s;
        this->_S_move(__p, __s, __nleft);
        this->_S_copy(__p + __nleft, __p + __len2,
        __len2 - __nleft);
      }
  }
     }
 }
      else
 this->_M_mutate(__pos, __len1, __s, __len2);

      this->_M_set_length(__new_size);
      return *this;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    copy(_CharT* __s, size_type __n, size_type __pos) const
    {
      _M_check(__pos, "basic_string::copy");
      __n = _M_limit(__pos, __n);
      ;
      if (__n)
 _S_copy(__s, _M_data() + __pos, __n);

      return __n;
    }
# 1158 "/usr/include/c++/10.2.0/bits/basic_string.tcc" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>
    operator+(const _CharT* __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    {
      ;
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef typename __string_type::size_type __size_type;
      typedef typename __gnu_cxx::__alloc_traits<_Alloc>::template
 rebind<_CharT>::other _Char_alloc_type;
      typedef __gnu_cxx::__alloc_traits<_Char_alloc_type> _Alloc_traits;
      const __size_type __len = _Traits::length(__lhs);
      __string_type __str(_Alloc_traits::_S_select_on_copy(
          __rhs.get_allocator()));
      __str.reserve(__len + __rhs.size());
      __str.append(__lhs, __len);
      __str.append(__rhs);
      return __str;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>
    operator+(_CharT __lhs, const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    {
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef typename __string_type::size_type __size_type;
      typedef typename __gnu_cxx::__alloc_traits<_Alloc>::template
 rebind<_CharT>::other _Char_alloc_type;
      typedef __gnu_cxx::__alloc_traits<_Char_alloc_type> _Alloc_traits;
      __string_type __str(_Alloc_traits::_S_select_on_copy(
          __rhs.get_allocator()));
      const __size_type __len = __rhs.size();
      __str.reserve(__len + 1);
      __str.append(__size_type(1), __lhs);
      __str.append(__rhs);
      return __str;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find(const _CharT* __s, size_type __pos, size_type __n) const
    noexcept
    {
      ;
      const size_type __size = this->size();

      if (__n == 0)
 return __pos <= __size ? __pos : npos;
      if (__pos >= __size)
 return npos;

      const _CharT __elem0 = __s[0];
      const _CharT* const __data = data();
      const _CharT* __first = __data + __pos;
      const _CharT* const __last = __data + __size;
      size_type __len = __size - __pos;

      while (__len >= __n)
 {

   __first = traits_type::find(__first, __len - __n + 1, __elem0);
   if (!__first)
     return npos;



   if (traits_type::compare(__first, __s, __n) == 0)
     return __first - __data;
   __len = __last - ++__first;
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find(_CharT __c, size_type __pos) const noexcept
    {
      size_type __ret = npos;
      const size_type __size = this->size();
      if (__pos < __size)
 {
   const _CharT* __data = _M_data();
   const size_type __n = __size - __pos;
   const _CharT* __p = traits_type::find(__data + __pos, __n, __c);
   if (__p)
     __ret = __p - __data;
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    rfind(const _CharT* __s, size_type __pos, size_type __n) const
    noexcept
    {
      ;
      const size_type __size = this->size();
      if (__n <= __size)
 {
   __pos = std::min(size_type(__size - __n), __pos);
   const _CharT* __data = _M_data();
   do
     {
       if (traits_type::compare(__data + __pos, __s, __n) == 0)
  return __pos;
     }
   while (__pos-- > 0);
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    rfind(_CharT __c, size_type __pos) const noexcept
    {
      size_type __size = this->size();
      if (__size)
 {
   if (--__size > __pos)
     __size = __pos;
   for (++__size; __size-- > 0; )
     if (traits_type::eq(_M_data()[__size], __c))
       return __size;
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_first_of(const _CharT* __s, size_type __pos, size_type __n) const
    noexcept
    {
      ;
      for (; __n && __pos < this->size(); ++__pos)
 {
   const _CharT* __p = traits_type::find(__s, __n, _M_data()[__pos]);
   if (__p)
     return __pos;
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_last_of(const _CharT* __s, size_type __pos, size_type __n) const
    noexcept
    {
      ;
      size_type __size = this->size();
      if (__size && __n)
 {
   if (--__size > __pos)
     __size = __pos;
   do
     {
       if (traits_type::find(__s, __n, _M_data()[__size]))
  return __size;
     }
   while (__size-- != 0);
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_first_not_of(const _CharT* __s, size_type __pos, size_type __n) const
    noexcept
    {
      ;
      for (; __pos < this->size(); ++__pos)
 if (!traits_type::find(__s, __n, _M_data()[__pos]))
   return __pos;
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_first_not_of(_CharT __c, size_type __pos) const noexcept
    {
      for (; __pos < this->size(); ++__pos)
 if (!traits_type::eq(_M_data()[__pos], __c))
   return __pos;
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_last_not_of(const _CharT* __s, size_type __pos, size_type __n) const
    noexcept
    {
      ;
      size_type __size = this->size();
      if (__size)
 {
   if (--__size > __pos)
     __size = __pos;
   do
     {
       if (!traits_type::find(__s, __n, _M_data()[__size]))
  return __size;
     }
   while (__size--);
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_last_not_of(_CharT __c, size_type __pos) const noexcept
    {
      size_type __size = this->size();
      if (__size)
 {
   if (--__size > __pos)
     __size = __pos;
   do
     {
       if (!traits_type::eq(_M_data()[__size], __c))
  return __size;
     }
   while (__size--);
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string<_CharT, _Traits, _Alloc>::
    compare(size_type __pos, size_type __n, const basic_string& __str) const
    {
      _M_check(__pos, "basic_string::compare");
      __n = _M_limit(__pos, __n);
      const size_type __osize = __str.size();
      const size_type __len = std::min(__n, __osize);
      int __r = traits_type::compare(_M_data() + __pos, __str.data(), __len);
      if (!__r)
 __r = _S_compare(__n, __osize);
      return __r;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string<_CharT, _Traits, _Alloc>::
    compare(size_type __pos1, size_type __n1, const basic_string& __str,
     size_type __pos2, size_type __n2) const
    {
      _M_check(__pos1, "basic_string::compare");
      __str._M_check(__pos2, "basic_string::compare");
      __n1 = _M_limit(__pos1, __n1);
      __n2 = __str._M_limit(__pos2, __n2);
      const size_type __len = std::min(__n1, __n2);
      int __r = traits_type::compare(_M_data() + __pos1,
         __str.data() + __pos2, __len);
      if (!__r)
 __r = _S_compare(__n1, __n2);
      return __r;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string<_CharT, _Traits, _Alloc>::
    compare(const _CharT* __s) const noexcept
    {
      ;
      const size_type __size = this->size();
      const size_type __osize = traits_type::length(__s);
      const size_type __len = std::min(__size, __osize);
      int __r = traits_type::compare(_M_data(), __s, __len);
      if (!__r)
 __r = _S_compare(__size, __osize);
      return __r;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string <_CharT, _Traits, _Alloc>::
    compare(size_type __pos, size_type __n1, const _CharT* __s) const
    {
      ;
      _M_check(__pos, "basic_string::compare");
      __n1 = _M_limit(__pos, __n1);
      const size_type __osize = traits_type::length(__s);
      const size_type __len = std::min(__n1, __osize);
      int __r = traits_type::compare(_M_data() + __pos, __s, __len);
      if (!__r)
 __r = _S_compare(__n1, __osize);
      return __r;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string <_CharT, _Traits, _Alloc>::
    compare(size_type __pos, size_type __n1, const _CharT* __s,
     size_type __n2) const
    {
      ;
      _M_check(__pos, "basic_string::compare");
      __n1 = _M_limit(__pos, __n1);
      const size_type __len = std::min(__n1, __n2);
      int __r = traits_type::compare(_M_data() + __pos, __s, __len);
      if (!__r)
 __r = _S_compare(__n1, __n2);
      return __r;
    }


  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __in,
        basic_string<_CharT, _Traits, _Alloc>& __str)
    {
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef typename __istream_type::ios_base __ios_base;
      typedef typename __istream_type::int_type __int_type;
      typedef typename __string_type::size_type __size_type;
      typedef ctype<_CharT> __ctype_type;
      typedef typename __ctype_type::ctype_base __ctype_base;

      __size_type __extracted = 0;
      typename __ios_base::iostate __err = __ios_base::goodbit;
      typename __istream_type::sentry __cerb(__in, false);
      if (__cerb)
 {
   try
     {

       __str.erase();
       _CharT __buf[128];
       __size_type __len = 0;
       const streamsize __w = __in.width();
       const __size_type __n = __w > 0 ? static_cast<__size_type>(__w)
                                : __str.max_size();
       const __ctype_type& __ct = use_facet<__ctype_type>(__in.getloc());
       const __int_type __eof = _Traits::eof();
       __int_type __c = __in.rdbuf()->sgetc();

       while (__extracted < __n
       && !_Traits::eq_int_type(__c, __eof)
       && !__ct.is(__ctype_base::space,
     _Traits::to_char_type(__c)))
  {
    if (__len == sizeof(__buf) / sizeof(_CharT))
      {
        __str.append(__buf, sizeof(__buf) / sizeof(_CharT));
        __len = 0;
      }
    __buf[__len++] = _Traits::to_char_type(__c);
    ++__extracted;
    __c = __in.rdbuf()->snextc();
  }
       __str.append(__buf, __len);

       if (_Traits::eq_int_type(__c, __eof))
  __err |= __ios_base::eofbit;
       __in.width(0);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       __in._M_setstate(__ios_base::badbit);
       throw;
     }
   catch(...)
     {



       __in._M_setstate(__ios_base::badbit);
     }
 }

      if (!__extracted)
 __err |= __ios_base::failbit;
      if (__err)
 __in.setstate(__err);
      return __in;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_istream<_CharT, _Traits>&
    getline(basic_istream<_CharT, _Traits>& __in,
     basic_string<_CharT, _Traits, _Alloc>& __str, _CharT __delim)
    {
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef typename __istream_type::ios_base __ios_base;
      typedef typename __istream_type::int_type __int_type;
      typedef typename __string_type::size_type __size_type;

      __size_type __extracted = 0;
      const __size_type __n = __str.max_size();
      typename __ios_base::iostate __err = __ios_base::goodbit;
      typename __istream_type::sentry __cerb(__in, true);
      if (__cerb)
 {
   try
     {
       __str.erase();
       const __int_type __idelim = _Traits::to_int_type(__delim);
       const __int_type __eof = _Traits::eof();
       __int_type __c = __in.rdbuf()->sgetc();

       while (__extracted < __n
       && !_Traits::eq_int_type(__c, __eof)
       && !_Traits::eq_int_type(__c, __idelim))
  {
    __str += _Traits::to_char_type(__c);
    ++__extracted;
    __c = __in.rdbuf()->snextc();
  }

       if (_Traits::eq_int_type(__c, __eof))
  __err |= __ios_base::eofbit;
       else if (_Traits::eq_int_type(__c, __idelim))
  {
    ++__extracted;
    __in.rdbuf()->sbumpc();
  }
       else
  __err |= __ios_base::failbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       __in._M_setstate(__ios_base::badbit);
       throw;
     }
   catch(...)
     {



       __in._M_setstate(__ios_base::badbit);
     }
 }
      if (!__extracted)
 __err |= __ios_base::failbit;
      if (__err)
 __in.setstate(__err);
      return __in;
    }
# 1618 "/usr/include/c++/10.2.0/bits/basic_string.tcc" 3
  extern template class basic_string<char>;







  extern template
    basic_istream<char>&
    operator>>(basic_istream<char>&, string&);
  extern template
    basic_ostream<char>&
    operator<<(basic_ostream<char>&, const string&);
  extern template
    basic_istream<char>&
    getline(basic_istream<char>&, string&, char);
  extern template
    basic_istream<char>&
    getline(basic_istream<char>&, string&);



  extern template class basic_string<wchar_t>;





  extern template
    basic_istream<wchar_t>&
    operator>>(basic_istream<wchar_t>&, wstring&);
  extern template
    basic_ostream<wchar_t>&
    operator<<(basic_ostream<wchar_t>&, const wstring&);
  extern template
    basic_istream<wchar_t>&
    getline(basic_istream<wchar_t>&, wstring&, wchar_t);
  extern template
    basic_istream<wchar_t>&
    getline(basic_istream<wchar_t>&, wstring&);




}
# 57 "/usr/include/c++/10.2.0/string" 2 3
# 41 "/usr/include/c++/10.2.0/bits/locale_classes.h" 2 3


namespace std __attribute__ ((__visibility__ ("default")))
{

# 62 "/usr/include/c++/10.2.0/bits/locale_classes.h" 3
  class locale
  {
  public:


    typedef int category;


    class facet;
    class id;
    class _Impl;

    friend class facet;
    friend class _Impl;

    template<typename _Facet>
      friend bool
      has_facet(const locale&) throw();

    template<typename _Facet>
      friend const _Facet&
      use_facet(const locale&);

    template<typename _Cache>
      friend struct __use_cache;
# 98 "/usr/include/c++/10.2.0/bits/locale_classes.h" 3
    static const category none = 0;
    static const category ctype = 1L << 0;
    static const category numeric = 1L << 1;
    static const category collate = 1L << 2;
    static const category time = 1L << 3;
    static const category monetary = 1L << 4;
    static const category messages = 1L << 5;
    static const category all = (ctype | numeric | collate |
        time | monetary | messages);
# 117 "/usr/include/c++/10.2.0/bits/locale_classes.h" 3
    locale() throw();
# 126 "/usr/include/c++/10.2.0/bits/locale_classes.h" 3
    locale(const locale& __other) throw();
# 136 "/usr/include/c++/10.2.0/bits/locale_classes.h" 3
    explicit
    locale(const char* __s);
# 151 "/usr/include/c++/10.2.0/bits/locale_classes.h" 3
    locale(const locale& __base, const char* __s, category __cat);
# 162 "/usr/include/c++/10.2.0/bits/locale_classes.h" 3
    explicit
    locale(const std::string& __s) : locale(__s.c_str()) { }
# 177 "/usr/include/c++/10.2.0/bits/locale_classes.h" 3
    locale(const locale& __base, const std::string& __s, category __cat)
    : locale(__base, __s.c_str(), __cat) { }
# 192 "/usr/include/c++/10.2.0/bits/locale_classes.h" 3
    locale(const locale& __base, const locale& __add, category __cat);
# 205 "/usr/include/c++/10.2.0/bits/locale_classes.h" 3
    template<typename _Facet>
      locale(const locale& __other, _Facet* __f);


    ~locale() throw();
# 219 "/usr/include/c++/10.2.0/bits/locale_classes.h" 3
    const locale&
    operator=(const locale& __other) throw();
# 234 "/usr/include/c++/10.2.0/bits/locale_classes.h" 3
    template<typename _Facet>
      locale
      combine(const locale& __other) const;






    __attribute ((__abi_tag__ ("cxx11")))
    string
    name() const;
# 254 "/usr/include/c++/10.2.0/bits/locale_classes.h" 3
    bool
    operator==(const locale& __other) const throw();
# 264 "/usr/include/c++/10.2.0/bits/locale_classes.h" 3
    bool
    operator!=(const locale& __other) const throw()
    { return !(this->operator==(__other)); }
# 284 "/usr/include/c++/10.2.0/bits/locale_classes.h" 3
    template<typename _Char, typename _Traits, typename _Alloc>
      bool
      operator()(const basic_string<_Char, _Traits, _Alloc>& __s1,
   const basic_string<_Char, _Traits, _Alloc>& __s2) const;
# 300 "/usr/include/c++/10.2.0/bits/locale_classes.h" 3
    static locale
    
# 301 "/usr/include/c++/10.2.0/bits/locale_classes.h"
   static
# 301 "/usr/include/c++/10.2.0/bits/locale_classes.h" 3
         (const locale& __loc);




    static const locale&
    classic();

  private:

    _Impl* _M_impl;


    static _Impl* _S_classic;


    static _Impl* _S_global;





    static const char* const* const _S_categories;
# 335 "/usr/include/c++/10.2.0/bits/locale_classes.h" 3
    enum { _S_categories_size = 6 + 6 };


    static __gthread_once_t _S_once;


    explicit
    locale(_Impl*) throw();

    static void
    _S_initialize();

    static void
    _S_initialize_once() throw();

    static category
    _S_normalize_category(category);

    void
    _M_coalesce(const locale& __base, const locale& __add, category __cat);


    static const id* const _S_twinned_facets[];

  };
# 373 "/usr/include/c++/10.2.0/bits/locale_classes.h" 3
  class locale::facet
  {
  private:
    friend class locale;
    friend class locale::_Impl;

    mutable _Atomic_word _M_refcount;


    static __c_locale _S_c_locale;


    static const char _S_c_name[2];


    static __gthread_once_t _S_once;


    static void
    _S_initialize_once();

  protected:
# 404 "/usr/include/c++/10.2.0/bits/locale_classes.h" 3
    explicit
    facet(size_t __refs = 0) throw() : _M_refcount(__refs ? 1 : 0)
    { }


    virtual
    ~facet();

    static void
    _S_create_c_locale(__c_locale& __cloc, const char* __s,
         __c_locale __old = 0);

    static __c_locale
    _S_clone_c_locale(__c_locale& __cloc) throw();

    static void
    _S_destroy_c_locale(__c_locale& __cloc);

    static __c_locale
    _S_lc_ctype_c_locale(__c_locale __cloc, const char* __s);



    static __c_locale
    _S_get_c_locale();

    __attribute__ ((__const__)) static const char*
    _S_get_c_name() throw();
# 440 "/usr/include/c++/10.2.0/bits/locale_classes.h" 3
    facet(const facet&) = delete;

    facet&
    operator=(const facet&) = delete;


  private:
    void
    _M_add_reference() const throw()
    { __gnu_cxx::__atomic_add_dispatch(&_M_refcount, 1); }

    void
    _M_remove_reference() const throw()
    {

      ;
      if (__gnu_cxx::__exchange_and_add_dispatch(&_M_refcount, -1) == 1)
 {
          ;
   try
     { delete this; }
   catch(...)
     { }
 }
    }

    const facet* _M_sso_shim(const id*) const;
    const facet* _M_cow_shim(const id*) const;

  protected:
    class __shim;
  };
# 485 "/usr/include/c++/10.2.0/bits/locale_classes.h" 3
  class locale::id
  {
  private:
    friend class locale;
    friend class locale::_Impl;

    template<typename _Facet>
      friend const _Facet&
      use_facet(const locale&);

    template<typename _Facet>
      friend bool
      has_facet(const locale&) throw();




    mutable size_t _M_index;


    static _Atomic_word _S_refcount;

    void
    operator=(const id&);

    id(const id&);

  public:



    id() { }

    size_t
    _M_id() const throw();
  };



  class locale::_Impl
  {
  public:

    friend class locale;
    friend class locale::facet;

    template<typename _Facet>
      friend bool
      has_facet(const locale&) throw();

    template<typename _Facet>
      friend const _Facet&
      use_facet(const locale&);

    template<typename _Cache>
      friend struct __use_cache;

  private:

    _Atomic_word _M_refcount;
    const facet** _M_facets;
    size_t _M_facets_size;
    const facet** _M_caches;
    char** _M_names;
    static const locale::id* const _S_id_ctype[];
    static const locale::id* const _S_id_numeric[];
    static const locale::id* const _S_id_collate[];
    static const locale::id* const _S_id_time[];
    static const locale::id* const _S_id_monetary[];
    static const locale::id* const _S_id_messages[];
    static const locale::id* const* const _S_facet_categories[];

    void
    _M_add_reference() throw()
    { __gnu_cxx::__atomic_add_dispatch(&_M_refcount, 1); }

    void
    _M_remove_reference() throw()
    {

      ;
      if (__gnu_cxx::__exchange_and_add_dispatch(&_M_refcount, -1) == 1)
 {
          ;
   try
     { delete this; }
   catch(...)
     { }
 }
    }

    _Impl(const _Impl&, size_t);
    _Impl(const char*, size_t);
    _Impl(size_t) throw();

   ~_Impl() throw();

    _Impl(const _Impl&);

    void
    operator=(const _Impl&);

    bool
    _M_check_same_name()
    {
      bool __ret = true;
      if (_M_names[1])

 for (size_t __i = 0; __ret && __i < _S_categories_size - 1; ++__i)
   __ret = __builtin_strcmp(_M_names[__i], _M_names[__i + 1]) == 0;
      return __ret;
    }

    void
    _M_replace_categories(const _Impl*, category);

    void
    _M_replace_category(const _Impl*, const locale::id* const*);

    void
    _M_replace_facet(const _Impl*, const locale::id*);

    void
    _M_install_facet(const locale::id*, const facet*);

    template<typename _Facet>
      void
      _M_init_facet(_Facet* __facet)
      { _M_install_facet(&_Facet::id, __facet); }

    template<typename _Facet>
      void
      _M_init_facet_unchecked(_Facet* __facet)
      {
 __facet->_M_add_reference();
 _M_facets[_Facet::id._M_id()] = __facet;
      }

    void
    _M_install_cache(const facet*, size_t);

    void _M_init_extra(facet**);
    void _M_init_extra(void*, void*, const char*, const char*);
  };
# 643 "/usr/include/c++/10.2.0/bits/locale_classes.h" 3
  template<typename _CharT>
    class __cxx11:: collate : public locale::facet
    {
    public:



      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;


    protected:


      __c_locale _M_c_locale_collate;

    public:

      static locale::id id;
# 670 "/usr/include/c++/10.2.0/bits/locale_classes.h" 3
      explicit
      collate(size_t __refs = 0)
      : facet(__refs), _M_c_locale_collate(_S_get_c_locale())
      { }
# 684 "/usr/include/c++/10.2.0/bits/locale_classes.h" 3
      explicit
      collate(__c_locale __cloc, size_t __refs = 0)
      : facet(__refs), _M_c_locale_collate(_S_clone_c_locale(__cloc))
      { }
# 701 "/usr/include/c++/10.2.0/bits/locale_classes.h" 3
      int
      compare(const _CharT* __lo1, const _CharT* __hi1,
       const _CharT* __lo2, const _CharT* __hi2) const
      { return this->do_compare(__lo1, __hi1, __lo2, __hi2); }
# 720 "/usr/include/c++/10.2.0/bits/locale_classes.h" 3
      string_type
      transform(const _CharT* __lo, const _CharT* __hi) const
      { return this->do_transform(__lo, __hi); }
# 734 "/usr/include/c++/10.2.0/bits/locale_classes.h" 3
      long
      hash(const _CharT* __lo, const _CharT* __hi) const
      { return this->do_hash(__lo, __hi); }


      int
      _M_compare(const _CharT*, const _CharT*) const throw();

      size_t
      _M_transform(_CharT*, const _CharT*, size_t) const throw();

  protected:

      virtual
      ~collate()
      { _S_destroy_c_locale(_M_c_locale_collate); }
# 763 "/usr/include/c++/10.2.0/bits/locale_classes.h" 3
      virtual int
      do_compare(const _CharT* __lo1, const _CharT* __hi1,
   const _CharT* __lo2, const _CharT* __hi2) const;
# 777 "/usr/include/c++/10.2.0/bits/locale_classes.h" 3
      virtual string_type
      do_transform(const _CharT* __lo, const _CharT* __hi) const;
# 790 "/usr/include/c++/10.2.0/bits/locale_classes.h" 3
      virtual long
      do_hash(const _CharT* __lo, const _CharT* __hi) const;
    };

  template<typename _CharT>
    locale::id collate<_CharT>::id;


  template<>
    int
    collate<char>::_M_compare(const char*, const char*) const throw();

  template<>
    size_t
    collate<char>::_M_transform(char*, const char*, size_t) const throw();


  template<>
    int
    collate<wchar_t>::_M_compare(const wchar_t*, const wchar_t*) const throw();

  template<>
    size_t
    collate<wchar_t>::_M_transform(wchar_t*, const wchar_t*, size_t) const throw();



  template<typename _CharT>
    class __cxx11:: collate_byname : public collate<_CharT>
    {
    public:


      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;


      explicit
      collate_byname(const char* __s, size_t __refs = 0)
      : collate<_CharT>(__refs)
      {
 if (__builtin_strcmp(__s, "C") != 0
     && __builtin_strcmp(__s, "POSIX") != 0)
   {
     this->_S_destroy_c_locale(this->_M_c_locale_collate);
     this->_S_create_c_locale(this->_M_c_locale_collate, __s);
   }
      }


      explicit
      collate_byname(const string& __s, size_t __refs = 0)
      : collate_byname(__s.c_str(), __refs) { }


    protected:
      virtual
      ~collate_byname() { }
    };


}

# 1 "/usr/include/c++/10.2.0/bits/locale_classes.tcc" 1 3
# 37 "/usr/include/c++/10.2.0/bits/locale_classes.tcc" 3
       
# 38 "/usr/include/c++/10.2.0/bits/locale_classes.tcc" 3

namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _Facet>
    locale::
    locale(const locale& __other, _Facet* __f)
    {
      _M_impl = new _Impl(*__other._M_impl, 1);

      try
 { _M_impl->_M_install_facet(&_Facet::id, __f); }
      catch(...)
 {
   _M_impl->_M_remove_reference();
   throw;
 }
      delete [] _M_impl->_M_names[0];
      _M_impl->_M_names[0] = 0;
    }

  template<typename _Facet>
    locale
    locale::
    combine(const locale& __other) const
    {
      _Impl* __tmp = new _Impl(*_M_impl, 1);
      try
 {
   __tmp->_M_replace_facet(__other._M_impl, &_Facet::id);
 }
      catch(...)
 {
   __tmp->_M_remove_reference();
   throw;
 }
      return locale(__tmp);
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    bool
    locale::
    operator()(const basic_string<_CharT, _Traits, _Alloc>& __s1,
        const basic_string<_CharT, _Traits, _Alloc>& __s2) const
    {
      typedef std::collate<_CharT> __collate_type;
      const __collate_type& __collate = use_facet<__collate_type>(*this);
      return (__collate.compare(__s1.data(), __s1.data() + __s1.length(),
    __s2.data(), __s2.data() + __s2.length()) < 0);
    }
# 102 "/usr/include/c++/10.2.0/bits/locale_classes.tcc" 3
  template<typename _Facet>
    bool
    has_facet(const locale& __loc) throw()
    {
      const size_t __i = _Facet::id._M_id();
      const locale::facet** __facets = __loc._M_impl->_M_facets;
      return (__i < __loc._M_impl->_M_facets_size

       && dynamic_cast<const _Facet*>(__facets[__i]));



    }
# 130 "/usr/include/c++/10.2.0/bits/locale_classes.tcc" 3
  template<typename _Facet>
    const _Facet&
    use_facet(const locale& __loc)
    {
      const size_t __i = _Facet::id._M_id();
      const locale::facet** __facets = __loc._M_impl->_M_facets;
      if (__i >= __loc._M_impl->_M_facets_size || !__facets[__i])
        __throw_bad_cast();

      return dynamic_cast<const _Facet&>(*__facets[__i]);



    }



  template<typename _CharT>
    int
    collate<_CharT>::_M_compare(const _CharT*, const _CharT*) const throw ()
    { return 0; }


  template<typename _CharT>
    size_t
    collate<_CharT>::_M_transform(_CharT*, const _CharT*, size_t) const throw ()
    { return 0; }

  template<typename _CharT>
    int
    collate<_CharT>::
    do_compare(const _CharT* __lo1, const _CharT* __hi1,
        const _CharT* __lo2, const _CharT* __hi2) const
    {


      const string_type __one(__lo1, __hi1);
      const string_type __two(__lo2, __hi2);

      const _CharT* __p = __one.c_str();
      const _CharT* __pend = __one.data() + __one.length();
      const _CharT* __q = __two.c_str();
      const _CharT* __qend = __two.data() + __two.length();




      for (;;)
 {
   const int __res = _M_compare(__p, __q);
   if (__res)
     return __res;

   __p += char_traits<_CharT>::length(__p);
   __q += char_traits<_CharT>::length(__q);
   if (__p == __pend && __q == __qend)
     return 0;
   else if (__p == __pend)
     return -1;
   else if (__q == __qend)
     return 1;

   __p++;
   __q++;
 }
    }

  template<typename _CharT>
    typename collate<_CharT>::string_type
    collate<_CharT>::
    do_transform(const _CharT* __lo, const _CharT* __hi) const
    {
      string_type __ret;


      const string_type __str(__lo, __hi);

      const _CharT* __p = __str.c_str();
      const _CharT* __pend = __str.data() + __str.length();

      size_t __len = (__hi - __lo) * 2;

      _CharT* __c = new _CharT[__len];

      try
 {



   for (;;)
     {

       size_t __res = _M_transform(__c, __p, __len);


       if (__res >= __len)
  {
    __len = __res + 1;
    delete [] __c, __c = 0;
    __c = new _CharT[__len];
    __res = _M_transform(__c, __p, __len);
  }

       __ret.append(__c, __res);
       __p += char_traits<_CharT>::length(__p);
       if (__p == __pend)
  break;

       __p++;
       __ret.push_back(_CharT());
     }
 }
      catch(...)
 {
   delete [] __c;
   throw;
 }

      delete [] __c;

      return __ret;
    }

  template<typename _CharT>
    long
    collate<_CharT>::
    do_hash(const _CharT* __lo, const _CharT* __hi) const
    {
      unsigned long __val = 0;
      for (; __lo < __hi; ++__lo)
 __val =
   *__lo + ((__val << 7)
     | (__val >> (__gnu_cxx::__numeric_traits<unsigned long>::
    __digits - 7)));
      return static_cast<long>(__val);
    }




  extern template class collate<char>;
  extern template class collate_byname<char>;

  extern template
    const collate<char>&
    use_facet<collate<char> >(const locale&);

  extern template
    bool
    has_facet<collate<char> >(const locale&);


  extern template class collate<wchar_t>;
  extern template class collate_byname<wchar_t>;

  extern template
    const collate<wchar_t>&
    use_facet<collate<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<collate<wchar_t> >(const locale&);




}
# 854 "/usr/include/c++/10.2.0/bits/locale_classes.h" 2 3
# 42 "/usr/include/c++/10.2.0/bits/ios_base.h" 2 3




# 1 "/usr/include/c++/10.2.0/system_error" 1 3
# 32 "/usr/include/c++/10.2.0/system_error" 3
       
# 33 "/usr/include/c++/10.2.0/system_error" 3






# 1 "/usr/include/c++/10.2.0/x86_64-pc-linux-gnu/bits/error_constants.h" 1 3
# 34 "/usr/include/c++/10.2.0/x86_64-pc-linux-gnu/bits/error_constants.h" 3
# 1 "/usr/include/c++/10.2.0/cerrno" 1 3
# 39 "/usr/include/c++/10.2.0/cerrno" 3
       
# 40 "/usr/include/c++/10.2.0/cerrno" 3
# 35 "/usr/include/c++/10.2.0/x86_64-pc-linux-gnu/bits/error_constants.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{


  enum class errc
    {
      address_family_not_supported = 97,
      address_in_use = 98,
      address_not_available = 99,
      already_connected = 106,
      argument_list_too_long = 7,
      argument_out_of_domain = 33,
      bad_address = 14,
      bad_file_descriptor = 9,


      bad_message = 74,


      broken_pipe = 32,
      connection_aborted = 103,
      connection_already_in_progress = 114,
      connection_refused = 111,
      connection_reset = 104,
      cross_device_link = 18,
      destination_address_required = 89,
      device_or_resource_busy = 16,
      directory_not_empty = 39,
      executable_format_error = 8,
      file_exists = 17,
      file_too_large = 27,
      filename_too_long = 36,
      function_not_supported = 38,
      host_unreachable = 113,


      identifier_removed = 43,


      illegal_byte_sequence = 84,
      inappropriate_io_control_operation = 25,
      interrupted = 4,
      invalid_argument = 22,
      invalid_seek = 29,
      io_error = 5,
      is_a_directory = 21,
      message_size = 90,
      network_down = 100,
      network_reset = 102,
      network_unreachable = 101,
      no_buffer_space = 105,
      no_child_process = 10,


      no_link = 67,


      no_lock_available = 37,


      no_message_available = 61,


      no_message = 42,
      no_protocol_option = 92,
      no_space_on_device = 28,


      no_stream_resources = 63,


      no_such_device_or_address = 6,
      no_such_device = 19,
      no_such_file_or_directory = 2,
      no_such_process = 3,
      not_a_directory = 20,
      not_a_socket = 88,


      not_a_stream = 60,


      not_connected = 107,
      not_enough_memory = 12,


      not_supported = 95,



      operation_canceled = 125,


      operation_in_progress = 115,
      operation_not_permitted = 1,
      operation_not_supported = 95,
      operation_would_block = 11,


      owner_dead = 130,


      permission_denied = 13,


      protocol_error = 71,


      protocol_not_supported = 93,
      read_only_file_system = 30,
      resource_deadlock_would_occur = 35,
      resource_unavailable_try_again = 11,
      result_out_of_range = 34,


      state_not_recoverable = 131,



      stream_timeout = 62,



      text_file_busy = 26,


      timed_out = 110,
      too_many_files_open_in_system = 23,
      too_many_files_open = 24,
      too_many_links = 31,
      too_many_symbolic_link_levels = 40,


      value_too_large = 75,


      wrong_protocol_type = 91
    };


}
# 40 "/usr/include/c++/10.2.0/system_error" 2 3

# 1 "/usr/include/c++/10.2.0/stdexcept" 1 3
# 36 "/usr/include/c++/10.2.0/stdexcept" 3
       
# 37 "/usr/include/c++/10.2.0/stdexcept" 3




namespace std __attribute__ ((__visibility__ ("default")))
{





  struct __cow_string
  {
    union {
      const char* _M_p;
      char _M_bytes[sizeof(const char*)];
    };

    __cow_string();
    __cow_string(const std::string&);
    __cow_string(const char*, size_t);
    __cow_string(const __cow_string&) noexcept;
    __cow_string& operator=(const __cow_string&) noexcept;
    ~__cow_string();

    __cow_string(__cow_string&&) noexcept;
    __cow_string& operator=(__cow_string&&) noexcept;

  };

  typedef basic_string<char> __sso_string;
# 113 "/usr/include/c++/10.2.0/stdexcept" 3
  class logic_error : public exception
  {
    __cow_string _M_msg;

  public:

    explicit
    logic_error(const string& __arg) ;


    explicit
    logic_error(const char*) ;

    logic_error(logic_error&&) noexcept;
    logic_error& operator=(logic_error&&) noexcept;



    logic_error(const logic_error&) noexcept;
    logic_error& operator=(const logic_error&) noexcept;





    virtual ~logic_error() noexcept;



    virtual const char*
    what() const noexcept;





  };



  class domain_error : public logic_error
  {
  public:
    explicit domain_error(const string& __arg) ;

    explicit domain_error(const char*) ;
    domain_error(const domain_error&) = default;
    domain_error& operator=(const domain_error&) = default;
    domain_error(domain_error&&) = default;
    domain_error& operator=(domain_error&&) = default;

    virtual ~domain_error() noexcept;
  };


  class invalid_argument : public logic_error
  {
  public:
    explicit invalid_argument(const string& __arg) ;

    explicit invalid_argument(const char*) ;
    invalid_argument(const invalid_argument&) = default;
    invalid_argument& operator=(const invalid_argument&) = default;
    invalid_argument(invalid_argument&&) = default;
    invalid_argument& operator=(invalid_argument&&) = default;

    virtual ~invalid_argument() noexcept;
  };



  class length_error : public logic_error
  {
  public:
    explicit length_error(const string& __arg) ;

    explicit length_error(const char*) ;
    length_error(const length_error&) = default;
    length_error& operator=(const length_error&) = default;
    length_error(length_error&&) = default;
    length_error& operator=(length_error&&) = default;

    virtual ~length_error() noexcept;
  };



  class out_of_range : public logic_error
  {
  public:
    explicit out_of_range(const string& __arg) ;

    explicit out_of_range(const char*) ;
    out_of_range(const out_of_range&) = default;
    out_of_range& operator=(const out_of_range&) = default;
    out_of_range(out_of_range&&) = default;
    out_of_range& operator=(out_of_range&&) = default;

    virtual ~out_of_range() noexcept;
  };






  class runtime_error : public exception
  {
    __cow_string _M_msg;

  public:

    explicit
    runtime_error(const string& __arg) ;


    explicit
    runtime_error(const char*) ;

    runtime_error(runtime_error&&) noexcept;
    runtime_error& operator=(runtime_error&&) noexcept;



    runtime_error(const runtime_error&) noexcept;
    runtime_error& operator=(const runtime_error&) noexcept;





    virtual ~runtime_error() noexcept;



    virtual const char*
    what() const noexcept;





  };


  class range_error : public runtime_error
  {
  public:
    explicit range_error(const string& __arg) ;

    explicit range_error(const char*) ;
    range_error(const range_error&) = default;
    range_error& operator=(const range_error&) = default;
    range_error(range_error&&) = default;
    range_error& operator=(range_error&&) = default;

    virtual ~range_error() noexcept;
  };


  class overflow_error : public runtime_error
  {
  public:
    explicit overflow_error(const string& __arg) ;

    explicit overflow_error(const char*) ;
    overflow_error(const overflow_error&) = default;
    overflow_error& operator=(const overflow_error&) = default;
    overflow_error(overflow_error&&) = default;
    overflow_error& operator=(overflow_error&&) = default;

    virtual ~overflow_error() noexcept;
  };


  class underflow_error : public runtime_error
  {
  public:
    explicit underflow_error(const string& __arg) ;

    explicit underflow_error(const char*) ;
    underflow_error(const underflow_error&) = default;
    underflow_error& operator=(const underflow_error&) = default;
    underflow_error(underflow_error&&) = default;
    underflow_error& operator=(underflow_error&&) = default;

    virtual ~underflow_error() noexcept;
  };




}
# 42 "/usr/include/c++/10.2.0/system_error" 2 3




namespace std __attribute__ ((__visibility__ ("default")))
{






  class error_code;
  class error_condition;
  class system_error;


  template<typename _Tp>
    struct is_error_code_enum : public false_type { };


  template<typename _Tp>
    struct is_error_condition_enum : public false_type { };

  template<>
    struct is_error_condition_enum<errc>
    : public true_type { };
# 78 "/usr/include/c++/10.2.0/system_error" 3
  inline namespace _V2 {
# 89 "/usr/include/c++/10.2.0/system_error" 3
  class error_category
  {
  public:
    constexpr error_category() noexcept = default;

    virtual ~error_category();

    error_category(const error_category&) = delete;
    error_category& operator=(const error_category&) = delete;

    virtual const char*
    name() const noexcept = 0;






  private:
    __attribute ((__abi_tag__ ("cxx11")))
    virtual __cow_string
    _M_message(int) const;

  public:
    __attribute ((__abi_tag__ ("cxx11")))
    virtual string
    message(int) const = 0;
# 125 "/usr/include/c++/10.2.0/system_error" 3
  public:
    virtual error_condition
    default_error_condition(int __i) const noexcept;

    virtual bool
    equivalent(int __i, const error_condition& __cond) const noexcept;

    virtual bool
    equivalent(const error_code& __code, int __i) const noexcept;

    bool
    operator==(const error_category& __other) const noexcept
    { return this == &__other; }






    bool
    operator!=(const error_category& __other) const noexcept
    { return this != &__other; }

    bool
    operator<(const error_category& __other) const noexcept
    { return less<const error_category*>()(this, &__other); }

  };




  __attribute__ ((__const__)) const error_category& generic_category() noexcept;


  __attribute__ ((__const__)) const error_category& system_category() noexcept;

  }

  error_code make_error_code(errc) noexcept;
# 180 "/usr/include/c++/10.2.0/system_error" 3
  struct error_code
  {
    error_code() noexcept
    : _M_value(0), _M_cat(&system_category()) { }

    error_code(int __v, const error_category& __cat) noexcept
    : _M_value(__v), _M_cat(&__cat) { }

    template<typename _ErrorCodeEnum, typename = typename
      enable_if<is_error_code_enum<_ErrorCodeEnum>::value>::type>
      error_code(_ErrorCodeEnum __e) noexcept
      { *this = make_error_code(__e); }

    void
    assign(int __v, const error_category& __cat) noexcept
    {
      _M_value = __v;
      _M_cat = &__cat;
    }

    void
    clear() noexcept
    { assign(0, system_category()); }


    template<typename _ErrorCodeEnum>
      typename enable_if<is_error_code_enum<_ErrorCodeEnum>::value,
    error_code&>::type
      operator=(_ErrorCodeEnum __e) noexcept
      { return *this = make_error_code(__e); }

    int
    value() const noexcept { return _M_value; }

    const error_category&
    category() const noexcept { return *_M_cat; }

    error_condition
    default_error_condition() const noexcept;

    __attribute ((__abi_tag__ ("cxx11")))
    string
    message() const
    { return category().message(value()); }

    explicit operator bool() const noexcept
    { return _M_value != 0; }


  private:
    int _M_value;
    const error_category* _M_cat;
  };





  inline error_code
  make_error_code(errc __e) noexcept
  { return error_code(static_cast<int>(__e), generic_category()); }
# 251 "/usr/include/c++/10.2.0/system_error" 3
  inline bool
  operator<(const error_code& __lhs, const error_code& __rhs) noexcept
  {
    return (__lhs.category() < __rhs.category()
     || (__lhs.category() == __rhs.category()
  && __lhs.value() < __rhs.value()));
  }


  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __os, const error_code& __e)
    { return (__os << __e.category().name() << ':' << __e.value()); }



  error_condition make_error_condition(errc) noexcept;
# 278 "/usr/include/c++/10.2.0/system_error" 3
  struct error_condition
  {
    error_condition() noexcept
    : _M_value(0), _M_cat(&generic_category()) { }

    error_condition(int __v, const error_category& __cat) noexcept
    : _M_value(__v), _M_cat(&__cat) { }

    template<typename _ErrorConditionEnum, typename = typename
  enable_if<is_error_condition_enum<_ErrorConditionEnum>::value>::type>
      error_condition(_ErrorConditionEnum __e) noexcept
      { *this = make_error_condition(__e); }

    void
    assign(int __v, const error_category& __cat) noexcept
    {
      _M_value = __v;
      _M_cat = &__cat;
    }


    template<typename _ErrorConditionEnum>
      typename enable_if<is_error_condition_enum
    <_ErrorConditionEnum>::value, error_condition&>::type
      operator=(_ErrorConditionEnum __e) noexcept
      { return *this = make_error_condition(__e); }

    void
    clear() noexcept
    { assign(0, generic_category()); }


    int
    value() const noexcept { return _M_value; }

    const error_category&
    category() const noexcept { return *_M_cat; }

    __attribute ((__abi_tag__ ("cxx11")))
    string
    message() const
    { return category().message(value()); }

    explicit operator bool() const noexcept
    { return _M_value != 0; }


  private:
    int _M_value;
    const error_category* _M_cat;
  };





  inline error_condition
  make_error_condition(errc __e) noexcept
  { return error_condition(static_cast<int>(__e), generic_category()); }




  inline bool
  operator==(const error_code& __lhs, const error_code& __rhs) noexcept
  { return (__lhs.category() == __rhs.category()
     && __lhs.value() == __rhs.value()); }



  inline bool
  operator==(const error_code& __lhs, const error_condition& __rhs) noexcept
  {
    return (__lhs.category().equivalent(__lhs.value(), __rhs)
     || __rhs.category().equivalent(__lhs, __rhs.value()));
  }


  inline bool
  operator==(const error_condition& __lhs,
      const error_condition& __rhs) noexcept
  {
    return (__lhs.category() == __rhs.category()
     && __lhs.value() == __rhs.value());
  }
# 378 "/usr/include/c++/10.2.0/system_error" 3
  inline bool
  operator<(const error_condition& __lhs,
     const error_condition& __rhs) noexcept
  {
    return (__lhs.category() < __rhs.category()
     || (__lhs.category() == __rhs.category()
  && __lhs.value() < __rhs.value()));
  }



  inline bool
  operator==(const error_condition& __lhs, const error_code& __rhs) noexcept
  {
    return (__rhs.category().equivalent(__rhs.value(), __lhs)
     || __lhs.category().equivalent(__rhs, __lhs.value()));
  }


  inline bool
  operator!=(const error_code& __lhs, const error_code& __rhs) noexcept
  { return !(__lhs == __rhs); }



  inline bool
  operator!=(const error_code& __lhs, const error_condition& __rhs) noexcept
  { return !(__lhs == __rhs); }



  inline bool
  operator!=(const error_condition& __lhs, const error_code& __rhs) noexcept
  { return !(__lhs == __rhs); }


  inline bool
  operator!=(const error_condition& __lhs,
      const error_condition& __rhs) noexcept
  { return !(__lhs == __rhs); }
# 428 "/usr/include/c++/10.2.0/system_error" 3
  class system_error : public std::runtime_error
  {
  private:
    error_code _M_code;

  public:
    system_error(error_code __ec = error_code())
    : runtime_error(__ec.message()), _M_code(__ec) { }

    system_error(error_code __ec, const string& __what)
    : runtime_error(__what + ": " + __ec.message()), _M_code(__ec) { }

    system_error(error_code __ec, const char* __what)
    : runtime_error(__what + (": " + __ec.message())), _M_code(__ec) { }

    system_error(int __v, const error_category& __ecat, const char* __what)
    : system_error(error_code(__v, __ecat), __what) { }

    system_error(int __v, const error_category& __ecat)
    : runtime_error(error_code(__v, __ecat).message()),
      _M_code(__v, __ecat) { }

    system_error(int __v, const error_category& __ecat, const string& __what)
    : runtime_error(__what + ": " + error_code(__v, __ecat).message()),
      _M_code(__v, __ecat) { }


    system_error (const system_error &) = default;
    system_error &operator= (const system_error &) = default;


    virtual ~system_error() noexcept;

    const error_code&
    code() const noexcept { return _M_code; }
  };


}



namespace std __attribute__ ((__visibility__ ("default")))
{






  template<>
    struct hash<error_code>
    : public __hash_base<size_t, error_code>
    {
      size_t
      operator()(const error_code& __e) const noexcept
      {
 const size_t __tmp = std::_Hash_impl::hash(__e.value());
 return std::_Hash_impl::__hash_combine(&__e.category(), __tmp);
      }
    };
# 508 "/usr/include/c++/10.2.0/system_error" 3

}
# 47 "/usr/include/c++/10.2.0/bits/ios_base.h" 2 3


namespace std __attribute__ ((__visibility__ ("default")))
{






  enum _Ios_Fmtflags
    {
      _S_boolalpha = 1L << 0,
      _S_dec = 1L << 1,
      _S_fixed = 1L << 2,
      _S_hex = 1L << 3,
      _S_internal = 1L << 4,
      _S_left = 1L << 5,
      _S_oct = 1L << 6,
      _S_right = 1L << 7,
      _S_scientific = 1L << 8,
      _S_showbase = 1L << 9,
      _S_showpoint = 1L << 10,
      _S_showpos = 1L << 11,
      _S_skipws = 1L << 12,
      _S_unitbuf = 1L << 13,
      _S_uppercase = 1L << 14,
      _S_adjustfield = _S_left | _S_right | _S_internal,
      _S_basefield = _S_dec | _S_oct | _S_hex,
      _S_floatfield = _S_scientific | _S_fixed,
      _S_ios_fmtflags_end = 1L << 16,
      _S_ios_fmtflags_max = 0x7fffffff,
      _S_ios_fmtflags_min = ~0x7fffffff
    };

  inline constexpr _Ios_Fmtflags
  operator&(_Ios_Fmtflags __a, _Ios_Fmtflags __b)
  { return _Ios_Fmtflags(static_cast<int>(__a) & static_cast<int>(__b)); }

  inline constexpr _Ios_Fmtflags
  operator|(_Ios_Fmtflags __a, _Ios_Fmtflags __b)
  { return _Ios_Fmtflags(static_cast<int>(__a) | static_cast<int>(__b)); }

  inline constexpr _Ios_Fmtflags
  operator^(_Ios_Fmtflags __a, _Ios_Fmtflags __b)
  { return _Ios_Fmtflags(static_cast<int>(__a) ^ static_cast<int>(__b)); }

  inline constexpr _Ios_Fmtflags
  operator~(_Ios_Fmtflags __a)
  { return _Ios_Fmtflags(~static_cast<int>(__a)); }

  inline const _Ios_Fmtflags&
  operator|=(_Ios_Fmtflags& __a, _Ios_Fmtflags __b)
  { return __a = __a | __b; }

  inline const _Ios_Fmtflags&
  operator&=(_Ios_Fmtflags& __a, _Ios_Fmtflags __b)
  { return __a = __a & __b; }

  inline const _Ios_Fmtflags&
  operator^=(_Ios_Fmtflags& __a, _Ios_Fmtflags __b)
  { return __a = __a ^ __b; }


  enum _Ios_Openmode
    {
      _S_app = 1L << 0,
      _S_ate = 1L << 1,
      _S_bin = 1L << 2,
      _S_in = 1L << 3,
      _S_out = 1L << 4,
      _S_trunc = 1L << 5,
      _S_ios_openmode_end = 1L << 16,
      _S_ios_openmode_max = 0x7fffffff,
      _S_ios_openmode_min = ~0x7fffffff
    };

  inline constexpr _Ios_Openmode
  operator&(_Ios_Openmode __a, _Ios_Openmode __b)
  { return _Ios_Openmode(static_cast<int>(__a) & static_cast<int>(__b)); }

  inline constexpr _Ios_Openmode
  operator|(_Ios_Openmode __a, _Ios_Openmode __b)
  { return _Ios_Openmode(static_cast<int>(__a) | static_cast<int>(__b)); }

  inline constexpr _Ios_Openmode
  operator^(_Ios_Openmode __a, _Ios_Openmode __b)
  { return _Ios_Openmode(static_cast<int>(__a) ^ static_cast<int>(__b)); }

  inline constexpr _Ios_Openmode
  operator~(_Ios_Openmode __a)
  { return _Ios_Openmode(~static_cast<int>(__a)); }

  inline const _Ios_Openmode&
  operator|=(_Ios_Openmode& __a, _Ios_Openmode __b)
  { return __a = __a | __b; }

  inline const _Ios_Openmode&
  operator&=(_Ios_Openmode& __a, _Ios_Openmode __b)
  { return __a = __a & __b; }

  inline const _Ios_Openmode&
  operator^=(_Ios_Openmode& __a, _Ios_Openmode __b)
  { return __a = __a ^ __b; }


  enum _Ios_Iostate
    {
      _S_goodbit = 0,
      _S_badbit = 1L << 0,
      _S_eofbit = 1L << 1,
      _S_failbit = 1L << 2,
      _S_ios_iostate_end = 1L << 16,
      _S_ios_iostate_max = 0x7fffffff,
      _S_ios_iostate_min = ~0x7fffffff
    };

  inline constexpr _Ios_Iostate
  operator&(_Ios_Iostate __a, _Ios_Iostate __b)
  { return _Ios_Iostate(static_cast<int>(__a) & static_cast<int>(__b)); }

  inline constexpr _Ios_Iostate
  operator|(_Ios_Iostate __a, _Ios_Iostate __b)
  { return _Ios_Iostate(static_cast<int>(__a) | static_cast<int>(__b)); }

  inline constexpr _Ios_Iostate
  operator^(_Ios_Iostate __a, _Ios_Iostate __b)
  { return _Ios_Iostate(static_cast<int>(__a) ^ static_cast<int>(__b)); }

  inline constexpr _Ios_Iostate
  operator~(_Ios_Iostate __a)
  { return _Ios_Iostate(~static_cast<int>(__a)); }

  inline const _Ios_Iostate&
  operator|=(_Ios_Iostate& __a, _Ios_Iostate __b)
  { return __a = __a | __b; }

  inline const _Ios_Iostate&
  operator&=(_Ios_Iostate& __a, _Ios_Iostate __b)
  { return __a = __a & __b; }

  inline const _Ios_Iostate&
  operator^=(_Ios_Iostate& __a, _Ios_Iostate __b)
  { return __a = __a ^ __b; }


  enum _Ios_Seekdir
    {
      _S_beg = 0,
      _S_cur = 1,
      _S_end = 2,
      _S_ios_seekdir_end = 1L << 16
    };



  enum class io_errc { stream = 1 };

  template <> struct is_error_code_enum<io_errc> : public true_type { };

  const error_category& iostream_category() noexcept;

  inline error_code
  make_error_code(io_errc __e) noexcept
  { return error_code(static_cast<int>(__e), iostream_category()); }

  inline error_condition
  make_error_condition(io_errc __e) noexcept
  { return error_condition(static_cast<int>(__e), iostream_category()); }
# 228 "/usr/include/c++/10.2.0/bits/ios_base.h" 3
  class ios_base
  {
# 246 "/usr/include/c++/10.2.0/bits/ios_base.h" 3
  public:
# 255 "/usr/include/c++/10.2.0/bits/ios_base.h" 3
    class __attribute ((__abi_tag__ ("cxx11"))) failure : public system_error
    {
    public:
      explicit
      failure(const string& __str);


      explicit
      failure(const string&, const error_code&);

      explicit
      failure(const char*, const error_code& = io_errc::stream);


      virtual
      ~failure() throw();

      virtual const char*
      what() const throw();
    };
# 323 "/usr/include/c++/10.2.0/bits/ios_base.h" 3
    typedef _Ios_Fmtflags fmtflags;


    static const fmtflags boolalpha = _S_boolalpha;


    static const fmtflags dec = _S_dec;


    static const fmtflags fixed = _S_fixed;


    static const fmtflags hex = _S_hex;




    static const fmtflags 
# 340 "/usr/include/c++/10.2.0/bits/ios_base.h"
                         static 
# 340 "/usr/include/c++/10.2.0/bits/ios_base.h" 3
                                  = _S_internal;



    static const fmtflags left = _S_left;


    static const fmtflags oct = _S_oct;



    static const fmtflags right = _S_right;


    static const fmtflags scientific = _S_scientific;



    static const fmtflags showbase = _S_showbase;



    static const fmtflags showpoint = _S_showpoint;


    static const fmtflags showpos = _S_showpos;


    static const fmtflags skipws = _S_skipws;


    static const fmtflags unitbuf = _S_unitbuf;



    static const fmtflags uppercase = _S_uppercase;


    static const fmtflags adjustfield = _S_adjustfield;


    static const fmtflags basefield = _S_basefield;


    static const fmtflags floatfield = _S_floatfield;
# 398 "/usr/include/c++/10.2.0/bits/ios_base.h" 3
    typedef _Ios_Iostate iostate;



    static const iostate badbit = _S_badbit;


    static const iostate eofbit = _S_eofbit;




    static const iostate failbit = _S_failbit;


    static const iostate goodbit = _S_goodbit;
# 429 "/usr/include/c++/10.2.0/bits/ios_base.h" 3
    typedef _Ios_Openmode openmode;


    static const openmode app = _S_app;


    static const openmode ate = _S_ate;




    static const openmode binary = _S_bin;


    static const openmode in = _S_in;


    static const openmode out = _S_out;


    static const openmode trunc = _S_trunc;
# 461 "/usr/include/c++/10.2.0/bits/ios_base.h" 3
    typedef _Ios_Seekdir seekdir;


    static const seekdir beg = _S_beg;


    static const seekdir cur = _S_cur;


    static const seekdir end = _S_end;



    typedef int io_state;
    typedef int open_mode;
    typedef int seek_dir;

    typedef std::streampos streampos;
    typedef std::streamoff streamoff;
# 489 "/usr/include/c++/10.2.0/bits/ios_base.h" 3
    enum event
    {
      erase_event,
      imbue_event,
      copyfmt_event
    };
# 506 "/usr/include/c++/10.2.0/bits/ios_base.h" 3
    typedef void (*event_callback) (event __e, ios_base& __b, int __i);
# 518 "/usr/include/c++/10.2.0/bits/ios_base.h" 3
    void
    register_callback(event_callback __fn, int __index);

  protected:
    streamsize _M_precision;
    streamsize _M_width;
    fmtflags _M_flags;
    iostate _M_exception;
    iostate _M_streambuf_state;



    struct _Callback_list
    {

      _Callback_list* _M_next;
      ios_base::event_callback _M_fn;
      int _M_index;
      _Atomic_word _M_refcount;

      _Callback_list(ios_base::event_callback __fn, int __index,
       _Callback_list* __cb)
      : _M_next(__cb), _M_fn(__fn), _M_index(__index), _M_refcount(0) { }

      void
      _M_add_reference() { __gnu_cxx::__atomic_add_dispatch(&_M_refcount, 1); }


      int
      _M_remove_reference()
      {

        ;
        int __res = __gnu_cxx::__exchange_and_add_dispatch(&_M_refcount, -1);
        if (__res == 0)
          {
            ;
          }
        return __res;
      }
    };

     _Callback_list* _M_callbacks;

    void
    _M_call_callbacks(event __ev) throw();

    void
    _M_dispose_callbacks(void) throw();


    struct _Words
    {
      void* _M_pword;
      long _M_iword;
      _Words() : _M_pword(0), _M_iword(0) { }
    };


    _Words _M_word_zero;



    enum { _S_local_word_size = 8 };
    _Words _M_local_word[_S_local_word_size];


    int _M_word_size;
    _Words* _M_word;

    _Words&
    _M_grow_words(int __index, bool __iword);


    locale _M_ios_locale;

    void
    _M_init() throw();

  public:





    class Init
    {
      friend class ios_base;
    public:
      Init();
      ~Init();


      Init(const Init&) = default;
      Init& operator=(const Init&) = default;


    private:
      static _Atomic_word _S_refcount;
      static bool _S_synced_with_stdio;
    };






    fmtflags
    flags() const
    { return _M_flags; }
# 636 "/usr/include/c++/10.2.0/bits/ios_base.h" 3
    fmtflags
    flags(fmtflags __fmtfl)
    {
      fmtflags __old = _M_flags;
      _M_flags = __fmtfl;
      return __old;
    }
# 652 "/usr/include/c++/10.2.0/bits/ios_base.h" 3
    fmtflags
    setf(fmtflags __fmtfl)
    {
      fmtflags __old = _M_flags;
      _M_flags |= __fmtfl;
      return __old;
    }
# 669 "/usr/include/c++/10.2.0/bits/ios_base.h" 3
    fmtflags
    setf(fmtflags __fmtfl, fmtflags __mask)
    {
      fmtflags __old = _M_flags;
      _M_flags &= ~__mask;
      _M_flags |= (__fmtfl & __mask);
      return __old;
    }







    void
    unsetf(fmtflags __mask)
    { _M_flags &= ~__mask; }
# 695 "/usr/include/c++/10.2.0/bits/ios_base.h" 3
    streamsize
    precision() const
    { return _M_precision; }






    streamsize
    precision(streamsize __prec)
    {
      streamsize __old = _M_precision;
      _M_precision = __prec;
      return __old;
    }







    streamsize
    width() const
    { return _M_width; }






    streamsize
    width(streamsize __wide)
    {
      streamsize __old = _M_width;
      _M_width = __wide;
      return __old;
    }
# 746 "/usr/include/c++/10.2.0/bits/ios_base.h" 3
    static bool
    sync_with_stdio(bool __sync = true);
# 758 "/usr/include/c++/10.2.0/bits/ios_base.h" 3
    locale
    imbue(const locale& __loc) throw();
# 769 "/usr/include/c++/10.2.0/bits/ios_base.h" 3
    locale
    getloc() const
    { return _M_ios_locale; }
# 780 "/usr/include/c++/10.2.0/bits/ios_base.h" 3
    const locale&
    _M_getloc() const
    { return _M_ios_locale; }
# 799 "/usr/include/c++/10.2.0/bits/ios_base.h" 3
    static int
    xalloc() throw();
# 815 "/usr/include/c++/10.2.0/bits/ios_base.h" 3
    long&
    iword(int __ix)
    {
      _Words& __word = ((unsigned)__ix < (unsigned)_M_word_size)
   ? _M_word[__ix] : _M_grow_words(__ix, true);
      return __word._M_iword;
    }
# 836 "/usr/include/c++/10.2.0/bits/ios_base.h" 3
    void*&
    pword(int __ix)
    {
      _Words& __word = ((unsigned)__ix < (unsigned)_M_word_size)
   ? _M_word[__ix] : _M_grow_words(__ix, false);
      return __word._M_pword;
    }
# 853 "/usr/include/c++/10.2.0/bits/ios_base.h" 3
    virtual ~ios_base();

  protected:
    ios_base() throw ();
# 867 "/usr/include/c++/10.2.0/bits/ios_base.h" 3
  public:
    ios_base(const ios_base&) = delete;

    ios_base&
    operator=(const ios_base&) = delete;

  protected:
    void
    _M_move(ios_base&) noexcept;

    void
    _M_swap(ios_base& __rhs) noexcept;

  };



  inline ios_base&
  boolalpha(ios_base& __base)
  {
    __base.setf(ios_base::boolalpha);
    return __base;
  }


  inline ios_base&
  noboolalpha(ios_base& __base)
  {
    __base.unsetf(ios_base::boolalpha);
    return __base;
  }


  inline ios_base&
  showbase(ios_base& __base)
  {
    __base.setf(ios_base::showbase);
    return __base;
  }


  inline ios_base&
  noshowbase(ios_base& __base)
  {
    __base.unsetf(ios_base::showbase);
    return __base;
  }


  inline ios_base&
  showpoint(ios_base& __base)
  {
    __base.setf(ios_base::showpoint);
    return __base;
  }


  inline ios_base&
  noshowpoint(ios_base& __base)
  {
    __base.unsetf(ios_base::showpoint);
    return __base;
  }


  inline ios_base&
  showpos(ios_base& __base)
  {
    __base.setf(ios_base::showpos);
    return __base;
  }


  inline ios_base&
  noshowpos(ios_base& __base)
  {
    __base.unsetf(ios_base::showpos);
    return __base;
  }


  inline ios_base&
  skipws(ios_base& __base)
  {
    __base.setf(ios_base::skipws);
    return __base;
  }


  inline ios_base&
  noskipws(ios_base& __base)
  {
    __base.unsetf(ios_base::skipws);
    return __base;
  }


  inline ios_base&
  uppercase(ios_base& __base)
  {
    __base.setf(ios_base::uppercase);
    return __base;
  }


  inline ios_base&
  nouppercase(ios_base& __base)
  {
    __base.unsetf(ios_base::uppercase);
    return __base;
  }


  inline ios_base&
  unitbuf(ios_base& __base)
  {
     __base.setf(ios_base::unitbuf);
     return __base;
  }


  inline ios_base&
  nounitbuf(ios_base& __base)
  {
     __base.unsetf(ios_base::unitbuf);
     return __base;
  }



  inline ios_base&
  
# 998 "/usr/include/c++/10.2.0/bits/ios_base.h"
 static
# 998 "/usr/include/c++/10.2.0/bits/ios_base.h" 3
         (ios_base& __base)
  {
     __base.setf(ios_base::
# 1000 "/usr/include/c++/10.2.0/bits/ios_base.h"
                          static
# 1000 "/usr/include/c++/10.2.0/bits/ios_base.h" 3
                                  , ios_base::adjustfield);
     return __base;
  }


  inline ios_base&
  left(ios_base& __base)
  {
    __base.setf(ios_base::left, ios_base::adjustfield);
    return __base;
  }


  inline ios_base&
  right(ios_base& __base)
  {
    __base.setf(ios_base::right, ios_base::adjustfield);
    return __base;
  }



  inline ios_base&
  dec(ios_base& __base)
  {
    __base.setf(ios_base::dec, ios_base::basefield);
    return __base;
  }


  inline ios_base&
  hex(ios_base& __base)
  {
    __base.setf(ios_base::hex, ios_base::basefield);
    return __base;
  }


  inline ios_base&
  oct(ios_base& __base)
  {
    __base.setf(ios_base::oct, ios_base::basefield);
    return __base;
  }



  inline ios_base&
  fixed(ios_base& __base)
  {
    __base.setf(ios_base::fixed, ios_base::floatfield);
    return __base;
  }


  inline ios_base&
  scientific(ios_base& __base)
  {
    __base.setf(ios_base::scientific, ios_base::floatfield);
    return __base;
  }






  inline ios_base&
  hexfloat(ios_base& __base)
  {
    __base.setf(ios_base::fixed | ios_base::scientific, ios_base::floatfield);
    return __base;
  }


  inline ios_base&
  defaultfloat(ios_base& __base)
  {
    __base.unsetf(ios_base::floatfield);
    return __base;
  }



}
# 43 "/usr/include/c++/10.2.0/ios" 2 3
# 1 "/usr/include/c++/10.2.0/streambuf" 1 3
# 36 "/usr/include/c++/10.2.0/streambuf" 3
       
# 37 "/usr/include/c++/10.2.0/streambuf" 3
# 45 "/usr/include/c++/10.2.0/streambuf" 3
namespace std __attribute__ ((__visibility__ ("default")))
{




  template<typename _CharT, typename _Traits>
    streamsize
    __copy_streambufs_eof(basic_streambuf<_CharT, _Traits>*,
     basic_streambuf<_CharT, _Traits>*, bool&);
# 121 "/usr/include/c++/10.2.0/streambuf" 3
  template<typename _CharT, typename _Traits>
    class basic_streambuf
    {
    public:






      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef typename traits_type::int_type int_type;
      typedef typename traits_type::pos_type pos_type;
      typedef typename traits_type::off_type off_type;




      typedef basic_streambuf<char_type, traits_type> __streambuf_type;


      friend class basic_ios<char_type, traits_type>;
      friend class basic_istream<char_type, traits_type>;
      friend class basic_ostream<char_type, traits_type>;
      friend class istreambuf_iterator<char_type, traits_type>;
      friend class ostreambuf_iterator<char_type, traits_type>;

      friend streamsize
      __copy_streambufs_eof<>(basic_streambuf*, basic_streambuf*, bool&);

      template<bool _IsMove, typename _CharT2>
        friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
            _CharT2*>::__type
        __copy_move_a2(istreambuf_iterator<_CharT2>,
         istreambuf_iterator<_CharT2>, _CharT2*);

      template<typename _CharT2>
        friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
      istreambuf_iterator<_CharT2> >::__type
        find(istreambuf_iterator<_CharT2>, istreambuf_iterator<_CharT2>,
      const _CharT2&);

      template<typename _CharT2, typename _Distance>
        friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
            void>::__type
        advance(istreambuf_iterator<_CharT2>&, _Distance);

      template<typename _CharT2, typename _Traits2>
        friend basic_istream<_CharT2, _Traits2>&
        operator>>(basic_istream<_CharT2, _Traits2>&, _CharT2*);

      template<typename _CharT2, typename _Traits2, typename _Alloc>
        friend basic_istream<_CharT2, _Traits2>&
        operator>>(basic_istream<_CharT2, _Traits2>&,
     basic_string<_CharT2, _Traits2, _Alloc>&);

      template<typename _CharT2, typename _Traits2, typename _Alloc>
        friend basic_istream<_CharT2, _Traits2>&
        getline(basic_istream<_CharT2, _Traits2>&,
  basic_string<_CharT2, _Traits2, _Alloc>&, _CharT2);

    protected:







      char_type* _M_in_beg;
      char_type* _M_in_cur;
      char_type* _M_in_end;
      char_type* _M_out_beg;
      char_type* _M_out_cur;
      char_type* _M_out_end;


      locale _M_buf_locale;

  public:

      virtual
      ~basic_streambuf()
      { }
# 215 "/usr/include/c++/10.2.0/streambuf" 3
      locale
      pubimbue(const locale& __loc)
      {
 locale __tmp(this->getloc());
 this->imbue(__loc);
 _M_buf_locale = __loc;
 return __tmp;
      }
# 232 "/usr/include/c++/10.2.0/streambuf" 3
      locale
      getloc() const
      { return _M_buf_locale; }
# 245 "/usr/include/c++/10.2.0/streambuf" 3
      basic_streambuf*
      pubsetbuf(char_type* __s, streamsize __n)
      { return this->setbuf(__s, __n); }
# 257 "/usr/include/c++/10.2.0/streambuf" 3
      pos_type
      pubseekoff(off_type __off, ios_base::seekdir __way,
   ios_base::openmode __mode = ios_base::in | ios_base::out)
      { return this->seekoff(__off, __way, __mode); }
# 269 "/usr/include/c++/10.2.0/streambuf" 3
      pos_type
      pubseekpos(pos_type __sp,
   ios_base::openmode __mode = ios_base::in | ios_base::out)
      { return this->seekpos(__sp, __mode); }




      int
      pubsync() { return this->sync(); }
# 290 "/usr/include/c++/10.2.0/streambuf" 3
      streamsize
      in_avail()
      {
 const streamsize __ret = this->egptr() - this->gptr();
 return __ret ? __ret : this->showmanyc();
      }
# 304 "/usr/include/c++/10.2.0/streambuf" 3
      int_type
      snextc()
      {
 int_type __ret = traits_type::eof();
 if (__builtin_expect(!traits_type::eq_int_type(this->sbumpc(),
             __ret), true))
   __ret = this->sgetc();
 return __ret;
      }
# 322 "/usr/include/c++/10.2.0/streambuf" 3
      int_type
      sbumpc()
      {
 int_type __ret;
 if (__builtin_expect(this->gptr() < this->egptr(), true))
   {
     __ret = traits_type::to_int_type(*this->gptr());
     this->gbump(1);
   }
 else
   __ret = this->uflow();
 return __ret;
      }
# 344 "/usr/include/c++/10.2.0/streambuf" 3
      int_type
      sgetc()
      {
 int_type __ret;
 if (__builtin_expect(this->gptr() < this->egptr(), true))
   __ret = traits_type::to_int_type(*this->gptr());
 else
   __ret = this->underflow();
 return __ret;
      }
# 363 "/usr/include/c++/10.2.0/streambuf" 3
      streamsize
      sgetn(char_type* __s, streamsize __n)
      { return this->xsgetn(__s, __n); }
# 378 "/usr/include/c++/10.2.0/streambuf" 3
      int_type
      sputbackc(char_type __c)
      {
 int_type __ret;
 const bool __testpos = this->eback() < this->gptr();
 if (__builtin_expect(!__testpos ||
        !traits_type::eq(__c, this->gptr()[-1]), false))
   __ret = this->pbackfail(traits_type::to_int_type(__c));
 else
   {
     this->gbump(-1);
     __ret = traits_type::to_int_type(*this->gptr());
   }
 return __ret;
      }
# 403 "/usr/include/c++/10.2.0/streambuf" 3
      int_type
      sungetc()
      {
 int_type __ret;
 if (__builtin_expect(this->eback() < this->gptr(), true))
   {
     this->gbump(-1);
     __ret = traits_type::to_int_type(*this->gptr());
   }
 else
   __ret = this->pbackfail();
 return __ret;
      }
# 430 "/usr/include/c++/10.2.0/streambuf" 3
      int_type
      sputc(char_type __c)
      {
 int_type __ret;
 if (__builtin_expect(this->pptr() < this->epptr(), true))
   {
     *this->pptr() = __c;
     this->pbump(1);
     __ret = traits_type::to_int_type(__c);
   }
 else
   __ret = this->overflow(traits_type::to_int_type(__c));
 return __ret;
      }
# 456 "/usr/include/c++/10.2.0/streambuf" 3
      streamsize
      sputn(const char_type* __s, streamsize __n)
      { return this->xsputn(__s, __n); }

    protected:
# 470 "/usr/include/c++/10.2.0/streambuf" 3
      basic_streambuf()
      : _M_in_beg(0), _M_in_cur(0), _M_in_end(0),
      _M_out_beg(0), _M_out_cur(0), _M_out_end(0),
      _M_buf_locale(locale())
      { }
# 488 "/usr/include/c++/10.2.0/streambuf" 3
      char_type*
      eback() const { return _M_in_beg; }

      char_type*
      gptr() const { return _M_in_cur; }

      char_type*
      egptr() const { return _M_in_end; }
# 504 "/usr/include/c++/10.2.0/streambuf" 3
      void
      gbump(int __n) { _M_in_cur += __n; }
# 515 "/usr/include/c++/10.2.0/streambuf" 3
      void
      setg(char_type* __gbeg, char_type* __gnext, char_type* __gend)
      {
 _M_in_beg = __gbeg;
 _M_in_cur = __gnext;
 _M_in_end = __gend;
      }
# 535 "/usr/include/c++/10.2.0/streambuf" 3
      char_type*
      pbase() const { return _M_out_beg; }

      char_type*
      pptr() const { return _M_out_cur; }

      char_type*
      epptr() const { return _M_out_end; }
# 551 "/usr/include/c++/10.2.0/streambuf" 3
      void
      pbump(int __n) { _M_out_cur += __n; }
# 561 "/usr/include/c++/10.2.0/streambuf" 3
      void
      setp(char_type* __pbeg, char_type* __pend)
      {
 _M_out_beg = _M_out_cur = __pbeg;
 _M_out_end = __pend;
      }
# 582 "/usr/include/c++/10.2.0/streambuf" 3
      virtual void
      imbue(const locale& __loc __attribute__ ((__unused__)))
      { }
# 597 "/usr/include/c++/10.2.0/streambuf" 3
      virtual basic_streambuf<char_type,_Traits>*
      setbuf(char_type*, streamsize)
      { return this; }
# 608 "/usr/include/c++/10.2.0/streambuf" 3
      virtual pos_type
      seekoff(off_type, ios_base::seekdir,
       ios_base::openmode = ios_base::in | ios_base::out)
      { return pos_type(off_type(-1)); }
# 620 "/usr/include/c++/10.2.0/streambuf" 3
      virtual pos_type
      seekpos(pos_type,
       ios_base::openmode = ios_base::in | ios_base::out)
      { return pos_type(off_type(-1)); }
# 633 "/usr/include/c++/10.2.0/streambuf" 3
      virtual int
      sync() { return 0; }
# 655 "/usr/include/c++/10.2.0/streambuf" 3
      virtual streamsize
      showmanyc() { return 0; }
# 671 "/usr/include/c++/10.2.0/streambuf" 3
      virtual streamsize
      xsgetn(char_type* __s, streamsize __n);
# 693 "/usr/include/c++/10.2.0/streambuf" 3
      virtual int_type
      underflow()
      { return traits_type::eof(); }
# 706 "/usr/include/c++/10.2.0/streambuf" 3
      virtual int_type
      uflow()
      {
 int_type __ret = traits_type::eof();
 const bool __testeof = traits_type::eq_int_type(this->underflow(),
       __ret);
 if (!__testeof)
   {
     __ret = traits_type::to_int_type(*this->gptr());
     this->gbump(1);
   }
 return __ret;
      }
# 730 "/usr/include/c++/10.2.0/streambuf" 3
      virtual int_type
      pbackfail(int_type __c __attribute__ ((__unused__)) = traits_type::eof())
      { return traits_type::eof(); }
# 748 "/usr/include/c++/10.2.0/streambuf" 3
      virtual streamsize
      xsputn(const char_type* __s, streamsize __n);
# 774 "/usr/include/c++/10.2.0/streambuf" 3
      virtual int_type
      overflow(int_type __c __attribute__ ((__unused__)) = traits_type::eof())
      { return traits_type::eof(); }



    public:
# 790 "/usr/include/c++/10.2.0/streambuf" 3
      [[__deprecated__("stossc is deprecated, use sbumpc instead")]]

      void
      stossc()
      {
 if (this->gptr() < this->egptr())
   this->gbump(1);
 else
   this->uflow();
      }



      void
      __safe_gbump(streamsize __n) { _M_in_cur += __n; }

      void
      __safe_pbump(streamsize __n) { _M_out_cur += __n; }




    protected:

      basic_streambuf(const basic_streambuf&);

      basic_streambuf&
      operator=(const basic_streambuf&);


      void
      swap(basic_streambuf& __sb)
      {
 std::swap(_M_in_beg, __sb._M_in_beg);
 std::swap(_M_in_cur, __sb._M_in_cur);
 std::swap(_M_in_end, __sb._M_in_end);
 std::swap(_M_out_beg, __sb._M_out_beg);
 std::swap(_M_out_cur, __sb._M_out_cur);
 std::swap(_M_out_end, __sb._M_out_end);
 std::swap(_M_buf_locale, __sb._M_buf_locale);
      }

    };


  template<typename _CharT, typename _Traits>
    std::basic_streambuf<_CharT, _Traits>::
    basic_streambuf(const basic_streambuf&) = default;

  template<typename _CharT, typename _Traits>
    std::basic_streambuf<_CharT, _Traits>&
    std::basic_streambuf<_CharT, _Traits>::
    operator=(const basic_streambuf&) = default;



  template<>
    streamsize
    __copy_streambufs_eof(basic_streambuf<char>* __sbin,
     basic_streambuf<char>* __sbout, bool& __ineof);

  template<>
    streamsize
    __copy_streambufs_eof(basic_streambuf<wchar_t>* __sbin,
     basic_streambuf<wchar_t>* __sbout, bool& __ineof);





}

# 1 "/usr/include/c++/10.2.0/bits/streambuf.tcc" 1 3
# 37 "/usr/include/c++/10.2.0/bits/streambuf.tcc" 3
       
# 38 "/usr/include/c++/10.2.0/bits/streambuf.tcc" 3

namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _CharT, typename _Traits>
    streamsize
    basic_streambuf<_CharT, _Traits>::
    xsgetn(char_type* __s, streamsize __n)
    {
      streamsize __ret = 0;
      while (__ret < __n)
 {
   const streamsize __buf_len = this->egptr() - this->gptr();
   if (__buf_len)
     {
       const streamsize __remaining = __n - __ret;
       const streamsize __len = std::min(__buf_len, __remaining);
       traits_type::copy(__s, this->gptr(), __len);
       __ret += __len;
       __s += __len;
       this->__safe_gbump(__len);
     }

   if (__ret < __n)
     {
       const int_type __c = this->uflow();
       if (!traits_type::eq_int_type(__c, traits_type::eof()))
  {
    traits_type::assign(*__s++, traits_type::to_char_type(__c));
    ++__ret;
  }
       else
  break;
     }
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    streamsize
    basic_streambuf<_CharT, _Traits>::
    xsputn(const char_type* __s, streamsize __n)
    {
      streamsize __ret = 0;
      while (__ret < __n)
 {
   const streamsize __buf_len = this->epptr() - this->pptr();
   if (__buf_len)
     {
       const streamsize __remaining = __n - __ret;
       const streamsize __len = std::min(__buf_len, __remaining);
       traits_type::copy(this->pptr(), __s, __len);
       __ret += __len;
       __s += __len;
       this->__safe_pbump(__len);
     }

   if (__ret < __n)
     {
       int_type __c = this->overflow(traits_type::to_int_type(*__s));
       if (!traits_type::eq_int_type(__c, traits_type::eof()))
  {
    ++__ret;
    ++__s;
  }
       else
  break;
     }
 }
      return __ret;
    }




  template<typename _CharT, typename _Traits>
    streamsize
    __copy_streambufs_eof(basic_streambuf<_CharT, _Traits>* __sbin,
     basic_streambuf<_CharT, _Traits>* __sbout,
     bool& __ineof)
    {
      streamsize __ret = 0;
      __ineof = true;
      typename _Traits::int_type __c = __sbin->sgetc();
      while (!_Traits::eq_int_type(__c, _Traits::eof()))
 {
   __c = __sbout->sputc(_Traits::to_char_type(__c));
   if (_Traits::eq_int_type(__c, _Traits::eof()))
     {
       __ineof = false;
       break;
     }
   ++__ret;
   __c = __sbin->snextc();
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    inline streamsize
    __copy_streambufs(basic_streambuf<_CharT, _Traits>* __sbin,
        basic_streambuf<_CharT, _Traits>* __sbout)
    {
      bool __ineof;
      return __copy_streambufs_eof(__sbin, __sbout, __ineof);
    }




  extern template class basic_streambuf<char>;
  extern template
    streamsize
    __copy_streambufs(basic_streambuf<char>*,
        basic_streambuf<char>*);
  extern template
    streamsize
    __copy_streambufs_eof(basic_streambuf<char>*,
     basic_streambuf<char>*, bool&);


  extern template class basic_streambuf<wchar_t>;
  extern template
    streamsize
    __copy_streambufs(basic_streambuf<wchar_t>*,
        basic_streambuf<wchar_t>*);
  extern template
    streamsize
    __copy_streambufs_eof(basic_streambuf<wchar_t>*,
     basic_streambuf<wchar_t>*, bool&);




}
# 863 "/usr/include/c++/10.2.0/streambuf" 2 3
# 44 "/usr/include/c++/10.2.0/ios" 2 3
# 1 "/usr/include/c++/10.2.0/bits/basic_ios.h" 1 3
# 33 "/usr/include/c++/10.2.0/bits/basic_ios.h" 3
       
# 34 "/usr/include/c++/10.2.0/bits/basic_ios.h" 3



# 1 "/usr/include/c++/10.2.0/bits/locale_facets.h" 1 3
# 37 "/usr/include/c++/10.2.0/bits/locale_facets.h" 3
       
# 38 "/usr/include/c++/10.2.0/bits/locale_facets.h" 3

# 1 "/usr/include/c++/10.2.0/cwctype" 1 3
# 39 "/usr/include/c++/10.2.0/cwctype" 3
       
# 40 "/usr/include/c++/10.2.0/cwctype" 3
# 50 "/usr/include/c++/10.2.0/cwctype" 3
# 1 "/usr/include/wctype.h" 1 3 4
# 38 "/usr/include/wctype.h" 3 4
# 1 "/usr/include/bits/wctype-wchar.h" 1 3 4
# 38 "/usr/include/bits/wctype-wchar.h" 3 4
typedef unsigned long int wctype_t;
# 56 "/usr/include/bits/wctype-wchar.h" 3 4
enum
{
  __ISwupper = 0,
  __ISwlower = 1,
  __ISwalpha = 2,
  __ISwdigit = 3,
  __ISwxdigit = 4,
  __ISwspace = 5,
  __ISwprint = 6,
  __ISwgraph = 7,
  __ISwblank = 8,
  __ISwcntrl = 9,
  __ISwpunct = 10,
  __ISwalnum = 11,

  _ISwupper = ((__ISwupper) < 8 ? (int) ((1UL << (__ISwupper)) << 24) : ((__ISwupper) < 16 ? (int) ((1UL << (__ISwupper)) << 8) : ((__ISwupper) < 24 ? (int) ((1UL << (__ISwupper)) >> 8) : (int) ((1UL << (__ISwupper)) >> 24)))),
  _ISwlower = ((__ISwlower) < 8 ? (int) ((1UL << (__ISwlower)) << 24) : ((__ISwlower) < 16 ? (int) ((1UL << (__ISwlower)) << 8) : ((__ISwlower) < 24 ? (int) ((1UL << (__ISwlower)) >> 8) : (int) ((1UL << (__ISwlower)) >> 24)))),
  _ISwalpha = ((__ISwalpha) < 8 ? (int) ((1UL << (__ISwalpha)) << 24) : ((__ISwalpha) < 16 ? (int) ((1UL << (__ISwalpha)) << 8) : ((__ISwalpha) < 24 ? (int) ((1UL << (__ISwalpha)) >> 8) : (int) ((1UL << (__ISwalpha)) >> 24)))),
  _ISwdigit = ((__ISwdigit) < 8 ? (int) ((1UL << (__ISwdigit)) << 24) : ((__ISwdigit) < 16 ? (int) ((1UL << (__ISwdigit)) << 8) : ((__ISwdigit) < 24 ? (int) ((1UL << (__ISwdigit)) >> 8) : (int) ((1UL << (__ISwdigit)) >> 24)))),
  _ISwxdigit = ((__ISwxdigit) < 8 ? (int) ((1UL << (__ISwxdigit)) << 24) : ((__ISwxdigit) < 16 ? (int) ((1UL << (__ISwxdigit)) << 8) : ((__ISwxdigit) < 24 ? (int) ((1UL << (__ISwxdigit)) >> 8) : (int) ((1UL << (__ISwxdigit)) >> 24)))),
  _ISwspace = ((__ISwspace) < 8 ? (int) ((1UL << (__ISwspace)) << 24) : ((__ISwspace) < 16 ? (int) ((1UL << (__ISwspace)) << 8) : ((__ISwspace) < 24 ? (int) ((1UL << (__ISwspace)) >> 8) : (int) ((1UL << (__ISwspace)) >> 24)))),
  _ISwprint = ((__ISwprint) < 8 ? (int) ((1UL << (__ISwprint)) << 24) : ((__ISwprint) < 16 ? (int) ((1UL << (__ISwprint)) << 8) : ((__ISwprint) < 24 ? (int) ((1UL << (__ISwprint)) >> 8) : (int) ((1UL << (__ISwprint)) >> 24)))),
  _ISwgraph = ((__ISwgraph) < 8 ? (int) ((1UL << (__ISwgraph)) << 24) : ((__ISwgraph) < 16 ? (int) ((1UL << (__ISwgraph)) << 8) : ((__ISwgraph) < 24 ? (int) ((1UL << (__ISwgraph)) >> 8) : (int) ((1UL << (__ISwgraph)) >> 24)))),
  _ISwblank = ((__ISwblank) < 8 ? (int) ((1UL << (__ISwblank)) << 24) : ((__ISwblank) < 16 ? (int) ((1UL << (__ISwblank)) << 8) : ((__ISwblank) < 24 ? (int) ((1UL << (__ISwblank)) >> 8) : (int) ((1UL << (__ISwblank)) >> 24)))),
  _ISwcntrl = ((__ISwcntrl) < 8 ? (int) ((1UL << (__ISwcntrl)) << 24) : ((__ISwcntrl) < 16 ? (int) ((1UL << (__ISwcntrl)) << 8) : ((__ISwcntrl) < 24 ? (int) ((1UL << (__ISwcntrl)) >> 8) : (int) ((1UL << (__ISwcntrl)) >> 24)))),
  _ISwpunct = ((__ISwpunct) < 8 ? (int) ((1UL << (__ISwpunct)) << 24) : ((__ISwpunct) < 16 ? (int) ((1UL << (__ISwpunct)) << 8) : ((__ISwpunct) < 24 ? (int) ((1UL << (__ISwpunct)) >> 8) : (int) ((1UL << (__ISwpunct)) >> 24)))),
  _ISwalnum = ((__ISwalnum) < 8 ? (int) ((1UL << (__ISwalnum)) << 24) : ((__ISwalnum) < 16 ? (int) ((1UL << (__ISwalnum)) << 8) : ((__ISwalnum) < 24 ? (int) ((1UL << (__ISwalnum)) >> 8) : (int) ((1UL << (__ISwalnum)) >> 24))))
};



extern "C" {







extern int iswalnum (wint_t __wc) throw ();





extern int iswalpha (wint_t __wc) throw ();


extern int iswcntrl (wint_t __wc) throw ();



extern int iswdigit (wint_t __wc) throw ();



extern int iswgraph (wint_t __wc) throw ();




extern int iswlower (wint_t __wc) throw ();


extern int iswprint (wint_t __wc) throw ();




extern int iswpunct (wint_t __wc) throw ();




extern int iswspace (wint_t __wc) throw ();




extern int iswupper (wint_t __wc) throw ();




extern int iswxdigit (wint_t __wc) throw ();





extern int iswblank (wint_t __wc) throw ();
# 155 "/usr/include/bits/wctype-wchar.h" 3 4
extern wctype_t wctype (const char *__property) throw ();



extern int iswctype (wint_t __wc, wctype_t __desc) throw ();






extern wint_t towlower (wint_t __wc) throw ();


extern wint_t towupper (wint_t __wc) throw ();

}
# 39 "/usr/include/wctype.h" 2 3 4





extern "C" {



typedef const __int32_t *wctrans_t;



extern wctrans_t wctrans (const char *__property) throw ();


extern wint_t towctrans (wint_t __wc, wctrans_t __desc) throw ();







extern int iswalnum_l (wint_t __wc, locale_t __locale) throw ();





extern int iswalpha_l (wint_t __wc, locale_t __locale) throw ();


extern int iswcntrl_l (wint_t __wc, locale_t __locale) throw ();



extern int iswdigit_l (wint_t __wc, locale_t __locale) throw ();



extern int iswgraph_l (wint_t __wc, locale_t __locale) throw ();




extern int iswlower_l (wint_t __wc, locale_t __locale) throw ();


extern int iswprint_l (wint_t __wc, locale_t __locale) throw ();




extern int iswpunct_l (wint_t __wc, locale_t __locale) throw ();




extern int iswspace_l (wint_t __wc, locale_t __locale) throw ();




extern int iswupper_l (wint_t __wc, locale_t __locale) throw ();




extern int iswxdigit_l (wint_t __wc, locale_t __locale) throw ();




extern int iswblank_l (wint_t __wc, locale_t __locale) throw ();



extern wctype_t wctype_l (const char *__property, locale_t __locale)
     throw ();



extern int iswctype_l (wint_t __wc, wctype_t __desc, locale_t __locale)
     throw ();






extern wint_t towlower_l (wint_t __wc, locale_t __locale) throw ();


extern wint_t towupper_l (wint_t __wc, locale_t __locale) throw ();



extern wctrans_t wctrans_l (const char *__property, locale_t __locale)
     throw ();


extern wint_t towctrans_l (wint_t __wc, wctrans_t __desc,
      locale_t __locale) throw ();



}
# 51 "/usr/include/c++/10.2.0/cwctype" 2 3
# 80 "/usr/include/c++/10.2.0/cwctype" 3
namespace std
{
  using ::wctrans_t;
  using ::wctype_t;
  using ::wint_t;

  using ::iswalnum;
  using ::iswalpha;

  using ::iswblank;

  using ::iswcntrl;
  using ::iswctype;
  using ::iswdigit;
  using ::iswgraph;
  using ::iswlower;
  using ::iswprint;
  using ::iswpunct;
  using ::iswspace;
  using ::iswupper;
  using ::iswxdigit;
  using ::towctrans;
  using ::towlower;
  using ::towupper;
  using ::wctrans;
  using ::wctype;
}
# 40 "/usr/include/c++/10.2.0/bits/locale_facets.h" 2 3
# 1 "/usr/include/c++/10.2.0/cctype" 1 3
# 39 "/usr/include/c++/10.2.0/cctype" 3
       
# 40 "/usr/include/c++/10.2.0/cctype" 3
# 41 "/usr/include/c++/10.2.0/bits/locale_facets.h" 2 3
# 1 "/usr/include/c++/10.2.0/x86_64-pc-linux-gnu/bits/ctype_base.h" 1 3
# 36 "/usr/include/c++/10.2.0/x86_64-pc-linux-gnu/bits/ctype_base.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{



  struct ctype_base
  {

    typedef const int* __to_type;



    typedef unsigned short mask;
    static const mask upper = _ISupper;
    static const mask lower = _ISlower;
    static const mask alpha = _ISalpha;
    static const mask digit = _ISdigit;
    static const mask xdigit = _ISxdigit;
    static const mask space = _ISspace;
    static const mask print = _ISprint;
    static const mask graph = _ISalpha | _ISdigit | _ISpunct;
    static const mask cntrl = _IScntrl;
    static const mask punct = _ISpunct;
    static const mask alnum = _ISalpha | _ISdigit;

    static const mask blank = _ISblank;

  };


}
# 42 "/usr/include/c++/10.2.0/bits/locale_facets.h" 2 3






# 1 "/usr/include/c++/10.2.0/bits/streambuf_iterator.h" 1 3
# 33 "/usr/include/c++/10.2.0/bits/streambuf_iterator.h" 3
       
# 34 "/usr/include/c++/10.2.0/bits/streambuf_iterator.h" 3




namespace std __attribute__ ((__visibility__ ("default")))
{

# 49 "/usr/include/c++/10.2.0/bits/streambuf_iterator.h" 3
  template<typename _CharT, typename _Traits>
    class istreambuf_iterator
    : public iterator<input_iterator_tag, _CharT, typename _Traits::off_type,
        _CharT*, _CharT>
    {
    public:
# 66 "/usr/include/c++/10.2.0/bits/streambuf_iterator.h" 3
      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef typename _Traits::int_type int_type;
      typedef basic_streambuf<_CharT, _Traits> streambuf_type;
      typedef basic_istream<_CharT, _Traits> istream_type;


      template<typename _CharT2>
 friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
        ostreambuf_iterator<_CharT2> >::__type
 copy(istreambuf_iterator<_CharT2>, istreambuf_iterator<_CharT2>,
      ostreambuf_iterator<_CharT2>);

      template<bool _IsMove, typename _CharT2>
 friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
            _CharT2*>::__type
 __copy_move_a2(istreambuf_iterator<_CharT2>,
         istreambuf_iterator<_CharT2>, _CharT2*);


      template<typename _CharT2, typename _Size>
 friend __enable_if_t<__is_char<_CharT2>::__value, _CharT2*>
 __copy_n_a(istreambuf_iterator<_CharT2>, _Size, _CharT2*);


      template<typename _CharT2>
 friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
        istreambuf_iterator<_CharT2> >::__type
 find(istreambuf_iterator<_CharT2>, istreambuf_iterator<_CharT2>,
      const _CharT2&);

      template<typename _CharT2, typename _Distance>
 friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
            void>::__type
 advance(istreambuf_iterator<_CharT2>&, _Distance);

    private:







      mutable streambuf_type* _M_sbuf;
      int_type _M_c;

    public:

      constexpr istreambuf_iterator() noexcept
      : _M_sbuf(0), _M_c(traits_type::eof()) { }







      istreambuf_iterator(const istreambuf_iterator&) noexcept = default;

      ~istreambuf_iterator() = default;



      istreambuf_iterator(istream_type& __s) noexcept
      : _M_sbuf(__s.rdbuf()), _M_c(traits_type::eof()) { }


      istreambuf_iterator(streambuf_type* __s) noexcept
      : _M_sbuf(__s), _M_c(traits_type::eof()) { }


      istreambuf_iterator&
      operator=(const istreambuf_iterator&) noexcept = default;





      char_type
      operator*() const
      {
 int_type __c = _M_get();
# 157 "/usr/include/c++/10.2.0/bits/streambuf_iterator.h" 3
 return traits_type::to_char_type(__c);
      }


      istreambuf_iterator&
      operator++()
      {



                        ;

 _M_sbuf->sbumpc();
 _M_c = traits_type::eof();
 return *this;
      }


      istreambuf_iterator
      operator++(int)
      {



                        ;

 istreambuf_iterator __old = *this;
 __old._M_c = _M_sbuf->sbumpc();
 _M_c = traits_type::eof();
 return __old;
      }





      bool
      equal(const istreambuf_iterator& __b) const
      { return _M_at_eof() == __b._M_at_eof(); }

    private:
      int_type
      _M_get() const
      {
 int_type __ret = _M_c;
 if (_M_sbuf && _S_is_eof(__ret) && _S_is_eof(__ret = _M_sbuf->sgetc()))
   _M_sbuf = 0;
 return __ret;
      }

      bool
      _M_at_eof() const
      { return _S_is_eof(_M_get()); }

      static bool
      _S_is_eof(int_type __c)
      {
 const int_type __eof = traits_type::eof();
 return traits_type::eq_int_type(__c, __eof);
      }






    };

  template<typename _CharT, typename _Traits>
    inline bool
    operator==(const istreambuf_iterator<_CharT, _Traits>& __a,
        const istreambuf_iterator<_CharT, _Traits>& __b)
    { return __a.equal(__b); }

  template<typename _CharT, typename _Traits>
    inline bool
    operator!=(const istreambuf_iterator<_CharT, _Traits>& __a,
        const istreambuf_iterator<_CharT, _Traits>& __b)
    { return !__a.equal(__b); }


  template<typename _CharT, typename _Traits>
    class ostreambuf_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    public:






      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef basic_streambuf<_CharT, _Traits> streambuf_type;
      typedef basic_ostream<_CharT, _Traits> ostream_type;


      template<typename _CharT2>
 friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
        ostreambuf_iterator<_CharT2> >::__type
 copy(istreambuf_iterator<_CharT2>, istreambuf_iterator<_CharT2>,
      ostreambuf_iterator<_CharT2>);

    private:
      streambuf_type* _M_sbuf;
      bool _M_failed;

    public:
# 274 "/usr/include/c++/10.2.0/bits/streambuf_iterator.h" 3
      ostreambuf_iterator(ostream_type& __s) noexcept
      : _M_sbuf(__s.rdbuf()), _M_failed(!_M_sbuf) { }


      ostreambuf_iterator(streambuf_type* __s) noexcept
      : _M_sbuf(__s), _M_failed(!_M_sbuf) { }


      ostreambuf_iterator&
      operator=(_CharT __c)
      {
 if (!_M_failed &&
     _Traits::eq_int_type(_M_sbuf->sputc(__c), _Traits::eof()))
   _M_failed = true;
 return *this;
      }


      ostreambuf_iterator&
      operator*()
      { return *this; }


      ostreambuf_iterator&
      operator++(int)
      { return *this; }


      ostreambuf_iterator&
      operator++()
      { return *this; }


      bool
      failed() const noexcept
      { return _M_failed; }

      ostreambuf_iterator&
      _M_put(const _CharT* __ws, streamsize __len)
      {
 if (__builtin_expect(!_M_failed, true)
     && __builtin_expect(this->_M_sbuf->sputn(__ws, __len) != __len,
    false))
   _M_failed = true;
 return *this;
      }
    };


  template<typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
        ostreambuf_iterator<_CharT> >::__type
    copy(istreambuf_iterator<_CharT> __first,
  istreambuf_iterator<_CharT> __last,
  ostreambuf_iterator<_CharT> __result)
    {
      if (__first._M_sbuf && !__last._M_sbuf && !__result._M_failed)
 {
   bool __ineof;
   __copy_streambufs_eof(__first._M_sbuf, __result._M_sbuf, __ineof);
   if (!__ineof)
     __result._M_failed = true;
 }
      return __result;
    }

  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
        ostreambuf_iterator<_CharT> >::__type
    __copy_move_a2(_CharT* __first, _CharT* __last,
     ostreambuf_iterator<_CharT> __result)
    {
      const streamsize __num = __last - __first;
      if (__num > 0)
 __result._M_put(__first, __num);
      return __result;
    }

  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
        ostreambuf_iterator<_CharT> >::__type
    __copy_move_a2(const _CharT* __first, const _CharT* __last,
     ostreambuf_iterator<_CharT> __result)
    {
      const streamsize __num = __last - __first;
      if (__num > 0)
 __result._M_put(__first, __num);
      return __result;
    }

  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
        _CharT*>::__type
    __copy_move_a2(istreambuf_iterator<_CharT> __first,
     istreambuf_iterator<_CharT> __last, _CharT* __result)
    {
      typedef istreambuf_iterator<_CharT> __is_iterator_type;
      typedef typename __is_iterator_type::traits_type traits_type;
      typedef typename __is_iterator_type::streambuf_type streambuf_type;
      typedef typename traits_type::int_type int_type;

      if (__first._M_sbuf && !__last._M_sbuf)
 {
   streambuf_type* __sb = __first._M_sbuf;
   int_type __c = __sb->sgetc();
   while (!traits_type::eq_int_type(__c, traits_type::eof()))
     {
       const streamsize __n = __sb->egptr() - __sb->gptr();
       if (__n > 1)
  {
    traits_type::copy(__result, __sb->gptr(), __n);
    __sb->__safe_gbump(__n);
    __result += __n;
    __c = __sb->underflow();
  }
       else
  {
    *__result++ = traits_type::to_char_type(__c);
    __c = __sb->snextc();
  }
     }
 }
      return __result;
    }


  template<typename _CharT, typename _Size>
    __enable_if_t<__is_char<_CharT>::__value, _CharT*>
    __copy_n_a(istreambuf_iterator<_CharT> __it, _Size __n, _CharT* __result)
    {
      if (__n == 0)
 return __result;

     

                            ;
      _CharT* __beg = __result;
      __result += __it._M_sbuf->sgetn(__beg, __n);
     

                            ;
      return __result;
    }


  template<typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
          istreambuf_iterator<_CharT> >::__type
    find(istreambuf_iterator<_CharT> __first,
  istreambuf_iterator<_CharT> __last, const _CharT& __val)
    {
      typedef istreambuf_iterator<_CharT> __is_iterator_type;
      typedef typename __is_iterator_type::traits_type traits_type;
      typedef typename __is_iterator_type::streambuf_type streambuf_type;
      typedef typename traits_type::int_type int_type;
      const int_type __eof = traits_type::eof();

      if (__first._M_sbuf && !__last._M_sbuf)
 {
   const int_type __ival = traits_type::to_int_type(__val);
   streambuf_type* __sb = __first._M_sbuf;
   int_type __c = __sb->sgetc();
   while (!traits_type::eq_int_type(__c, __eof)
   && !traits_type::eq_int_type(__c, __ival))
     {
       streamsize __n = __sb->egptr() - __sb->gptr();
       if (__n > 1)
  {
    const _CharT* __p = traits_type::find(__sb->gptr(),
       __n, __val);
    if (__p)
      __n = __p - __sb->gptr();
    __sb->__safe_gbump(__n);
    __c = __sb->sgetc();
  }
       else
  __c = __sb->snextc();
     }

   __first._M_c = __eof;
 }

      return __first;
    }

  template<typename _CharT, typename _Distance>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
        void>::__type
    advance(istreambuf_iterator<_CharT>& __i, _Distance __n)
    {
      if (__n == 0)
 return;

      ;
     

                           ;

      typedef istreambuf_iterator<_CharT> __is_iterator_type;
      typedef typename __is_iterator_type::traits_type traits_type;
      typedef typename __is_iterator_type::streambuf_type streambuf_type;
      typedef typename traits_type::int_type int_type;
      const int_type __eof = traits_type::eof();

      streambuf_type* __sb = __i._M_sbuf;
      while (__n > 0)
 {
   streamsize __size = __sb->egptr() - __sb->gptr();
   if (__size > __n)
     {
       __sb->__safe_gbump(__n);
       break;
     }

   __sb->__safe_gbump(__size);
   __n -= __size;
   if (traits_type::eq_int_type(__sb->underflow(), __eof))
     {
      

                      ;
       break;
     }
 }

      __i._M_c = __eof;
    }




}
# 49 "/usr/include/c++/10.2.0/bits/locale_facets.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{

# 71 "/usr/include/c++/10.2.0/bits/locale_facets.h" 3
  template<typename _Tp>
    void
    __convert_to_v(const char*, _Tp&, ios_base::iostate&,
     const __c_locale&) throw();


  template<>
    void
    __convert_to_v(const char*, float&, ios_base::iostate&,
     const __c_locale&) throw();

  template<>
    void
    __convert_to_v(const char*, double&, ios_base::iostate&,
     const __c_locale&) throw();

  template<>
    void
    __convert_to_v(const char*, long double&, ios_base::iostate&,
     const __c_locale&) throw();



  template<typename _CharT, typename _Traits>
    struct __pad
    {
      static void
      _S_pad(ios_base& __io, _CharT __fill, _CharT* __news,
      const _CharT* __olds, streamsize __newlen, streamsize __oldlen);
    };






  template<typename _CharT>
    _CharT*
    __add_grouping(_CharT* __s, _CharT __sep,
     const char* __gbeg, size_t __gsize,
     const _CharT* __first, const _CharT* __last);




  template<typename _CharT>
    inline
    ostreambuf_iterator<_CharT>
    __write(ostreambuf_iterator<_CharT> __s, const _CharT* __ws, int __len)
    {
      __s._M_put(__ws, __len);
      return __s;
    }


  template<typename _CharT, typename _OutIter>
    inline
    _OutIter
    __write(_OutIter __s, const _CharT* __ws, int __len)
    {
      for (int __j = 0; __j < __len; __j++, ++__s)
 *__s = __ws[__j];
      return __s;
    }
# 149 "/usr/include/c++/10.2.0/bits/locale_facets.h" 3
  template<typename _CharT>
    class __ctype_abstract_base : public locale::facet, public ctype_base
    {
    public:


      typedef _CharT char_type;
# 168 "/usr/include/c++/10.2.0/bits/locale_facets.h" 3
      bool
      is(mask __m, char_type __c) const
      { return this->do_is(__m, __c); }
# 185 "/usr/include/c++/10.2.0/bits/locale_facets.h" 3
      const char_type*
      is(const char_type *__lo, const char_type *__hi, mask *__vec) const
      { return this->do_is(__lo, __hi, __vec); }
# 201 "/usr/include/c++/10.2.0/bits/locale_facets.h" 3
      const char_type*
      scan_is(mask __m, const char_type* __lo, const char_type* __hi) const
      { return this->do_scan_is(__m, __lo, __hi); }
# 217 "/usr/include/c++/10.2.0/bits/locale_facets.h" 3
      const char_type*
      scan_not(mask __m, const char_type* __lo, const char_type* __hi) const
      { return this->do_scan_not(__m, __lo, __hi); }
# 231 "/usr/include/c++/10.2.0/bits/locale_facets.h" 3
      char_type
      toupper(char_type __c) const
      { return this->do_toupper(__c); }
# 246 "/usr/include/c++/10.2.0/bits/locale_facets.h" 3
      const char_type*
      toupper(char_type *__lo, const char_type* __hi) const
      { return this->do_toupper(__lo, __hi); }
# 260 "/usr/include/c++/10.2.0/bits/locale_facets.h" 3
      char_type
      tolower(char_type __c) const
      { return this->do_tolower(__c); }
# 275 "/usr/include/c++/10.2.0/bits/locale_facets.h" 3
      const char_type*
      tolower(char_type* __lo, const char_type* __hi) const
      { return this->do_tolower(__lo, __hi); }
# 292 "/usr/include/c++/10.2.0/bits/locale_facets.h" 3
      char_type
      widen(char __c) const
      { return this->do_widen(__c); }
# 311 "/usr/include/c++/10.2.0/bits/locale_facets.h" 3
      const char*
      widen(const char* __lo, const char* __hi, char_type* __to) const
      { return this->do_widen(__lo, __hi, __to); }
# 330 "/usr/include/c++/10.2.0/bits/locale_facets.h" 3
      char
      narrow(char_type __c, char __dfault) const
      { return this->do_narrow(__c, __dfault); }
# 352 "/usr/include/c++/10.2.0/bits/locale_facets.h" 3
      const char_type*
      narrow(const char_type* __lo, const char_type* __hi,
       char __dfault, char* __to) const
      { return this->do_narrow(__lo, __hi, __dfault, __to); }

    protected:
      explicit
      __ctype_abstract_base(size_t __refs = 0): facet(__refs) { }

      virtual
      ~__ctype_abstract_base() { }
# 377 "/usr/include/c++/10.2.0/bits/locale_facets.h" 3
      virtual bool
      do_is(mask __m, char_type __c) const = 0;
# 396 "/usr/include/c++/10.2.0/bits/locale_facets.h" 3
      virtual const char_type*
      do_is(const char_type* __lo, const char_type* __hi,
     mask* __vec) const = 0;
# 415 "/usr/include/c++/10.2.0/bits/locale_facets.h" 3
      virtual const char_type*
      do_scan_is(mask __m, const char_type* __lo,
   const char_type* __hi) const = 0;
# 434 "/usr/include/c++/10.2.0/bits/locale_facets.h" 3
      virtual const char_type*
      do_scan_not(mask __m, const char_type* __lo,
    const char_type* __hi) const = 0;
# 452 "/usr/include/c++/10.2.0/bits/locale_facets.h" 3
      virtual char_type
      do_toupper(char_type __c) const = 0;
# 469 "/usr/include/c++/10.2.0/bits/locale_facets.h" 3
      virtual const char_type*
      do_toupper(char_type* __lo, const char_type* __hi) const = 0;
# 485 "/usr/include/c++/10.2.0/bits/locale_facets.h" 3
      virtual char_type
      do_tolower(char_type __c) const = 0;
# 502 "/usr/include/c++/10.2.0/bits/locale_facets.h" 3
      virtual const char_type*
      do_tolower(char_type* __lo, const char_type* __hi) const = 0;
# 521 "/usr/include/c++/10.2.0/bits/locale_facets.h" 3
      virtual char_type
      do_widen(char __c) const = 0;
# 542 "/usr/include/c++/10.2.0/bits/locale_facets.h" 3
      virtual const char*
      do_widen(const char* __lo, const char* __hi, char_type* __to) const = 0;
# 563 "/usr/include/c++/10.2.0/bits/locale_facets.h" 3
      virtual char
      do_narrow(char_type __c, char __dfault) const = 0;
# 588 "/usr/include/c++/10.2.0/bits/locale_facets.h" 3
      virtual const char_type*
      do_narrow(const char_type* __lo, const char_type* __hi,
  char __dfault, char* __to) const = 0;
    };
# 611 "/usr/include/c++/10.2.0/bits/locale_facets.h" 3
  template<typename _CharT>
    class ctype : public __ctype_abstract_base<_CharT>
    {
    public:

      typedef _CharT char_type;
      typedef typename __ctype_abstract_base<_CharT>::mask mask;


      static locale::id id;

      explicit
      ctype(size_t __refs = 0) : __ctype_abstract_base<_CharT>(__refs) { }

   protected:
      virtual
      ~ctype();

      virtual bool
      do_is(mask __m, char_type __c) const;

      virtual const char_type*
      do_is(const char_type* __lo, const char_type* __hi, mask* __vec) const;

      virtual const char_type*
      do_scan_is(mask __m, const char_type* __lo, const char_type* __hi) const;

      virtual const char_type*
      do_scan_not(mask __m, const char_type* __lo,
    const char_type* __hi) const;

      virtual char_type
      do_toupper(char_type __c) const;

      virtual const char_type*
      do_toupper(char_type* __lo, const char_type* __hi) const;

      virtual char_type
      do_tolower(char_type __c) const;

      virtual const char_type*
      do_tolower(char_type* __lo, const char_type* __hi) const;

      virtual char_type
      do_widen(char __c) const;

      virtual const char*
      do_widen(const char* __lo, const char* __hi, char_type* __dest) const;

      virtual char
      do_narrow(char_type, char __dfault) const;

      virtual const char_type*
      do_narrow(const char_type* __lo, const char_type* __hi,
  char __dfault, char* __to) const;
    };

  template<typename _CharT>
    locale::id ctype<_CharT>::id;
# 680 "/usr/include/c++/10.2.0/bits/locale_facets.h" 3
  template<>
    class ctype<char> : public locale::facet, public ctype_base
    {
    public:


      typedef char char_type;

    protected:

      __c_locale _M_c_locale_ctype;
      bool _M_del;
      __to_type _M_toupper;
      __to_type _M_tolower;
      const mask* _M_table;
      mutable char _M_widen_ok;
      mutable char _M_widen[1 + static_cast<unsigned char>(-1)];
      mutable char _M_narrow[1 + static_cast<unsigned char>(-1)];
      mutable char _M_narrow_ok;


    public:

      static locale::id id;

      static const size_t table_size = 1 + static_cast<unsigned char>(-1);
# 717 "/usr/include/c++/10.2.0/bits/locale_facets.h" 3
      explicit
      ctype(const mask* __table = 0, bool __del = false, size_t __refs = 0);
# 730 "/usr/include/c++/10.2.0/bits/locale_facets.h" 3
      explicit
      ctype(__c_locale __cloc, const mask* __table = 0, bool __del = false,
     size_t __refs = 0);
# 743 "/usr/include/c++/10.2.0/bits/locale_facets.h" 3
      inline bool
      is(mask __m, char __c) const;
# 758 "/usr/include/c++/10.2.0/bits/locale_facets.h" 3
      inline const char*
      is(const char* __lo, const char* __hi, mask* __vec) const;
# 772 "/usr/include/c++/10.2.0/bits/locale_facets.h" 3
      inline const char*
      scan_is(mask __m, const char* __lo, const char* __hi) const;
# 786 "/usr/include/c++/10.2.0/bits/locale_facets.h" 3
      inline const char*
      scan_not(mask __m, const char* __lo, const char* __hi) const;
# 801 "/usr/include/c++/10.2.0/bits/locale_facets.h" 3
      char_type
      toupper(char_type __c) const
      { return this->do_toupper(__c); }
# 818 "/usr/include/c++/10.2.0/bits/locale_facets.h" 3
      const char_type*
      toupper(char_type *__lo, const char_type* __hi) const
      { return this->do_toupper(__lo, __hi); }
# 834 "/usr/include/c++/10.2.0/bits/locale_facets.h" 3
      char_type
      tolower(char_type __c) const
      { return this->do_tolower(__c); }
# 851 "/usr/include/c++/10.2.0/bits/locale_facets.h" 3
      const char_type*
      tolower(char_type* __lo, const char_type* __hi) const
      { return this->do_tolower(__lo, __hi); }
# 871 "/usr/include/c++/10.2.0/bits/locale_facets.h" 3
      char_type
      widen(char __c) const
      {
 if (_M_widen_ok)
   return _M_widen[static_cast<unsigned char>(__c)];
 this->_M_widen_init();
 return this->do_widen(__c);
      }
# 898 "/usr/include/c++/10.2.0/bits/locale_facets.h" 3
      const char*
      widen(const char* __lo, const char* __hi, char_type* __to) const
      {
 if (_M_widen_ok == 1)
   {
     if (__builtin_expect(__hi != __lo, true))
       __builtin_memcpy(__to, __lo, __hi - __lo);
     return __hi;
   }
 if (!_M_widen_ok)
   _M_widen_init();
 return this->do_widen(__lo, __hi, __to);
      }
# 930 "/usr/include/c++/10.2.0/bits/locale_facets.h" 3
      char
      narrow(char_type __c, char __dfault) const
      {
 if (_M_narrow[static_cast<unsigned char>(__c)])
   return _M_narrow[static_cast<unsigned char>(__c)];
 const char __t = do_narrow(__c, __dfault);
 if (__t != __dfault)
   _M_narrow[static_cast<unsigned char>(__c)] = __t;
 return __t;
      }
# 963 "/usr/include/c++/10.2.0/bits/locale_facets.h" 3
      const char_type*
      narrow(const char_type* __lo, const char_type* __hi,
      char __dfault, char* __to) const
      {
 if (__builtin_expect(_M_narrow_ok == 1, true))
   {
     if (__builtin_expect(__hi != __lo, true))
       __builtin_memcpy(__to, __lo, __hi - __lo);
     return __hi;
   }
 if (!_M_narrow_ok)
   _M_narrow_init();
 return this->do_narrow(__lo, __hi, __dfault, __to);
      }





      const mask*
      table() const throw()
      { return _M_table; }


      static const mask*
      classic_table() throw();
    protected:







      virtual
      ~ctype();
# 1013 "/usr/include/c++/10.2.0/bits/locale_facets.h" 3
      virtual char_type
      do_toupper(char_type __c) const;
# 1030 "/usr/include/c++/10.2.0/bits/locale_facets.h" 3
      virtual const char_type*
      do_toupper(char_type* __lo, const char_type* __hi) const;
# 1046 "/usr/include/c++/10.2.0/bits/locale_facets.h" 3
      virtual char_type
      do_tolower(char_type __c) const;
# 1063 "/usr/include/c++/10.2.0/bits/locale_facets.h" 3
      virtual const char_type*
      do_tolower(char_type* __lo, const char_type* __hi) const;
# 1083 "/usr/include/c++/10.2.0/bits/locale_facets.h" 3
      virtual char_type
      do_widen(char __c) const
      { return __c; }
# 1106 "/usr/include/c++/10.2.0/bits/locale_facets.h" 3
      virtual const char*
      do_widen(const char* __lo, const char* __hi, char_type* __to) const
      {
 if (__builtin_expect(__hi != __lo, true))
   __builtin_memcpy(__to, __lo, __hi - __lo);
 return __hi;
      }
# 1133 "/usr/include/c++/10.2.0/bits/locale_facets.h" 3
      virtual char
      do_narrow(char_type __c, char __dfault __attribute__((__unused__))) const
      { return __c; }
# 1159 "/usr/include/c++/10.2.0/bits/locale_facets.h" 3
      virtual const char_type*
      do_narrow(const char_type* __lo, const char_type* __hi,
  char __dfault __attribute__((__unused__)), char* __to) const
      {
 if (__builtin_expect(__hi != __lo, true))
   __builtin_memcpy(__to, __lo, __hi - __lo);
 return __hi;
      }

    private:
      void _M_narrow_init() const;
      void _M_widen_init() const;
    };
# 1185 "/usr/include/c++/10.2.0/bits/locale_facets.h" 3
  template<>
    class ctype<wchar_t> : public __ctype_abstract_base<wchar_t>
    {
    public:


      typedef wchar_t char_type;
      typedef wctype_t __wmask_type;

    protected:
      __c_locale _M_c_locale_ctype;


      bool _M_narrow_ok;
      char _M_narrow[128];
      wint_t _M_widen[1 + static_cast<unsigned char>(-1)];


      mask _M_bit[16];
      __wmask_type _M_wmask[16];

    public:


      static locale::id id;
# 1218 "/usr/include/c++/10.2.0/bits/locale_facets.h" 3
      explicit
      ctype(size_t __refs = 0);
# 1229 "/usr/include/c++/10.2.0/bits/locale_facets.h" 3
      explicit
      ctype(__c_locale __cloc, size_t __refs = 0);

    protected:
      __wmask_type
      _M_convert_to_wmask(const mask __m) const throw();


      virtual
      ~ctype();
# 1253 "/usr/include/c++/10.2.0/bits/locale_facets.h" 3
      virtual bool
      do_is(mask __m, char_type __c) const;
# 1272 "/usr/include/c++/10.2.0/bits/locale_facets.h" 3
      virtual const char_type*
      do_is(const char_type* __lo, const char_type* __hi, mask* __vec) const;
# 1290 "/usr/include/c++/10.2.0/bits/locale_facets.h" 3
      virtual const char_type*
      do_scan_is(mask __m, const char_type* __lo, const char_type* __hi) const;
# 1308 "/usr/include/c++/10.2.0/bits/locale_facets.h" 3
      virtual const char_type*
      do_scan_not(mask __m, const char_type* __lo,
    const char_type* __hi) const;
# 1325 "/usr/include/c++/10.2.0/bits/locale_facets.h" 3
      virtual char_type
      do_toupper(char_type __c) const;
# 1342 "/usr/include/c++/10.2.0/bits/locale_facets.h" 3
      virtual const char_type*
      do_toupper(char_type* __lo, const char_type* __hi) const;
# 1358 "/usr/include/c++/10.2.0/bits/locale_facets.h" 3
      virtual char_type
      do_tolower(char_type __c) const;
# 1375 "/usr/include/c++/10.2.0/bits/locale_facets.h" 3
      virtual const char_type*
      do_tolower(char_type* __lo, const char_type* __hi) const;
# 1395 "/usr/include/c++/10.2.0/bits/locale_facets.h" 3
      virtual char_type
      do_widen(char __c) const;
# 1417 "/usr/include/c++/10.2.0/bits/locale_facets.h" 3
      virtual const char*
      do_widen(const char* __lo, const char* __hi, char_type* __to) const;
# 1440 "/usr/include/c++/10.2.0/bits/locale_facets.h" 3
      virtual char
      do_narrow(char_type __c, char __dfault) const;
# 1466 "/usr/include/c++/10.2.0/bits/locale_facets.h" 3
      virtual const char_type*
      do_narrow(const char_type* __lo, const char_type* __hi,
  char __dfault, char* __to) const;


      void
      _M_initialize_ctype() throw();
    };



  template<typename _CharT>
    class ctype_byname : public ctype<_CharT>
    {
    public:
      typedef typename ctype<_CharT>::mask mask;

      explicit
      ctype_byname(const char* __s, size_t __refs = 0);


      explicit
      ctype_byname(const string& __s, size_t __refs = 0)
      : ctype_byname(__s.c_str(), __refs) { }


    protected:
      virtual
      ~ctype_byname() { }
    };


  template<>
    class ctype_byname<char> : public ctype<char>
    {
    public:
      explicit
      ctype_byname(const char* __s, size_t __refs = 0);


      explicit
      ctype_byname(const string& __s, size_t __refs = 0);


    protected:
      virtual
      ~ctype_byname();
    };


  template<>
    class ctype_byname<wchar_t> : public ctype<wchar_t>
    {
    public:
      explicit
      ctype_byname(const char* __s, size_t __refs = 0);


      explicit
      ctype_byname(const string& __s, size_t __refs = 0);


    protected:
      virtual
      ~ctype_byname();
    };



}


# 1 "/usr/include/c++/10.2.0/x86_64-pc-linux-gnu/bits/ctype_inline.h" 1 3
# 37 "/usr/include/c++/10.2.0/x86_64-pc-linux-gnu/bits/ctype_inline.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{


  bool
  ctype<char>::
  is(mask __m, char __c) const
  { return _M_table[static_cast<unsigned char>(__c)] & __m; }

  const char*
  ctype<char>::
  is(const char* __low, const char* __high, mask* __vec) const
  {
    while (__low < __high)
      *__vec++ = _M_table[static_cast<unsigned char>(*__low++)];
    return __high;
  }

  const char*
  ctype<char>::
  scan_is(mask __m, const char* __low, const char* __high) const
  {
    while (__low < __high
    && !(_M_table[static_cast<unsigned char>(*__low)] & __m))
      ++__low;
    return __low;
  }

  const char*
  ctype<char>::
  scan_not(mask __m, const char* __low, const char* __high) const
  {
    while (__low < __high
    && (_M_table[static_cast<unsigned char>(*__low)] & __m) != 0)
      ++__low;
    return __low;
  }


}
# 1539 "/usr/include/c++/10.2.0/bits/locale_facets.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{



  class __num_base
  {
  public:


    enum
      {
 _S_ominus,
 _S_oplus,
 _S_ox,
 _S_oX,
 _S_odigits,
 _S_odigits_end = _S_odigits + 16,
 _S_oudigits = _S_odigits_end,
 _S_oudigits_end = _S_oudigits + 16,
 _S_oe = _S_odigits + 14,
 _S_oE = _S_oudigits + 14,
 _S_oend = _S_oudigits_end
      };






    static const char* _S_atoms_out;



    static const char* _S_atoms_in;

    enum
    {
      _S_iminus,
      _S_iplus,
      _S_ix,
      _S_iX,
      _S_izero,
      _S_ie = _S_izero + 14,
      _S_iE = _S_izero + 20,
      _S_iend = 26
    };



    static void
    _S_format_float(const ios_base& __io, char* __fptr, char __mod) throw();
  };

  template<typename _CharT>
    struct __numpunct_cache : public locale::facet
    {
      const char* _M_grouping;
      size_t _M_grouping_size;
      bool _M_use_grouping;
      const _CharT* _M_truename;
      size_t _M_truename_size;
      const _CharT* _M_falsename;
      size_t _M_falsename_size;
      _CharT _M_decimal_point;
      _CharT _M_thousands_sep;





      _CharT _M_atoms_out[__num_base::_S_oend];





      _CharT _M_atoms_in[__num_base::_S_iend];

      bool _M_allocated;

      __numpunct_cache(size_t __refs = 0)
      : facet(__refs), _M_grouping(0), _M_grouping_size(0),
 _M_use_grouping(false),
 _M_truename(0), _M_truename_size(0), _M_falsename(0),
 _M_falsename_size(0), _M_decimal_point(_CharT()),
 _M_thousands_sep(_CharT()), _M_allocated(false)
 { }

      ~__numpunct_cache();

      void
      _M_cache(const locale& __loc);

    private:
      __numpunct_cache&
      operator=(const __numpunct_cache&);

      explicit
      __numpunct_cache(const __numpunct_cache&);
    };

  template<typename _CharT>
    __numpunct_cache<_CharT>::~__numpunct_cache()
    {
      if (_M_allocated)
 {
   delete [] _M_grouping;
   delete [] _M_truename;
   delete [] _M_falsename;
 }
    }

namespace __cxx11 {
# 1669 "/usr/include/c++/10.2.0/bits/locale_facets.h" 3
  template<typename _CharT>
    class numpunct : public locale::facet
    {
    public:



      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;

      typedef __numpunct_cache<_CharT> __cache_type;

    protected:
      __cache_type* _M_data;

    public:

      static locale::id id;






      explicit
      numpunct(size_t __refs = 0)
      : facet(__refs), _M_data(0)
      { _M_initialize_numpunct(); }
# 1707 "/usr/include/c++/10.2.0/bits/locale_facets.h" 3
      explicit
      numpunct(__cache_type* __cache, size_t __refs = 0)
      : facet(__refs), _M_data(__cache)
      { _M_initialize_numpunct(); }
# 1721 "/usr/include/c++/10.2.0/bits/locale_facets.h" 3
      explicit
      numpunct(__c_locale __cloc, size_t __refs = 0)
      : facet(__refs), _M_data(0)
      { _M_initialize_numpunct(__cloc); }
# 1735 "/usr/include/c++/10.2.0/bits/locale_facets.h" 3
      char_type
      decimal_point() const
      { return this->do_decimal_point(); }
# 1748 "/usr/include/c++/10.2.0/bits/locale_facets.h" 3
      char_type
      thousands_sep() const
      { return this->do_thousands_sep(); }
# 1779 "/usr/include/c++/10.2.0/bits/locale_facets.h" 3
      string
      grouping() const
      { return this->do_grouping(); }
# 1792 "/usr/include/c++/10.2.0/bits/locale_facets.h" 3
      string_type
      truename() const
      { return this->do_truename(); }
# 1805 "/usr/include/c++/10.2.0/bits/locale_facets.h" 3
      string_type
      falsename() const
      { return this->do_falsename(); }

    protected:

      virtual
      ~numpunct();
# 1822 "/usr/include/c++/10.2.0/bits/locale_facets.h" 3
      virtual char_type
      do_decimal_point() const
      { return _M_data->_M_decimal_point; }
# 1834 "/usr/include/c++/10.2.0/bits/locale_facets.h" 3
      virtual char_type
      do_thousands_sep() const
      { return _M_data->_M_thousands_sep; }
# 1847 "/usr/include/c++/10.2.0/bits/locale_facets.h" 3
      virtual string
      do_grouping() const
      { return _M_data->_M_grouping; }
# 1860 "/usr/include/c++/10.2.0/bits/locale_facets.h" 3
      virtual string_type
      do_truename() const
      { return _M_data->_M_truename; }
# 1873 "/usr/include/c++/10.2.0/bits/locale_facets.h" 3
      virtual string_type
      do_falsename() const
      { return _M_data->_M_falsename; }


      void
      _M_initialize_numpunct(__c_locale __cloc = 0);
    };

  template<typename _CharT>
    locale::id numpunct<_CharT>::id;

  template<>
    numpunct<char>::~numpunct();

  template<>
    void
    numpunct<char>::_M_initialize_numpunct(__c_locale __cloc);


  template<>
    numpunct<wchar_t>::~numpunct();

  template<>
    void
    numpunct<wchar_t>::_M_initialize_numpunct(__c_locale __cloc);



  template<typename _CharT>
    class numpunct_byname : public numpunct<_CharT>
    {
    public:
      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;

      explicit
      numpunct_byname(const char* __s, size_t __refs = 0)
      : numpunct<_CharT>(__refs)
      {
 if (__builtin_strcmp(__s, "C") != 0
     && __builtin_strcmp(__s, "POSIX") != 0)
   {
     __c_locale __tmp;
     this->_S_create_c_locale(__tmp, __s);
     this->_M_initialize_numpunct(__tmp);
     this->_S_destroy_c_locale(__tmp);
   }
      }


      explicit
      numpunct_byname(const string& __s, size_t __refs = 0)
      : numpunct_byname(__s.c_str(), __refs) { }


    protected:
      virtual
      ~numpunct_byname() { }
    };

}


# 1951 "/usr/include/c++/10.2.0/bits/locale_facets.h" 3
  template<typename _CharT, typename _InIter>
    class num_get : public locale::facet
    {
    public:



      typedef _CharT char_type;
      typedef _InIter iter_type;



      static locale::id id;
# 1972 "/usr/include/c++/10.2.0/bits/locale_facets.h" 3
      explicit
      num_get(size_t __refs = 0) : facet(__refs) { }
# 1998 "/usr/include/c++/10.2.0/bits/locale_facets.h" 3
      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, bool& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }
# 2035 "/usr/include/c++/10.2.0/bits/locale_facets.h" 3
      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, long& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, unsigned short& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, unsigned int& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, unsigned long& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }


      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, long long& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, unsigned long long& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }
# 2095 "/usr/include/c++/10.2.0/bits/locale_facets.h" 3
      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, float& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, double& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, long double& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }
# 2138 "/usr/include/c++/10.2.0/bits/locale_facets.h" 3
      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, void*& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

    protected:

      virtual ~num_get() { }

      __attribute ((__abi_tag__ ("cxx11")))
      iter_type
      _M_extract_float(iter_type, iter_type, ios_base&, ios_base::iostate&,
         string&) const;

      template<typename _ValueT>
 __attribute ((__abi_tag__ ("cxx11")))
 iter_type
 _M_extract_int(iter_type, iter_type, ios_base&, ios_base::iostate&,
         _ValueT&) const;

      template<typename _CharT2>
      typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value, int>::__type
 _M_find(const _CharT2*, size_t __len, _CharT2 __c) const
 {
   int __ret = -1;
   if (__len <= 10)
     {
       if (__c >= _CharT2('0') && __c < _CharT2(_CharT2('0') + __len))
  __ret = __c - _CharT2('0');
     }
   else
     {
       if (__c >= _CharT2('0') && __c <= _CharT2('9'))
  __ret = __c - _CharT2('0');
       else if (__c >= _CharT2('a') && __c <= _CharT2('f'))
  __ret = 10 + (__c - _CharT2('a'));
       else if (__c >= _CharT2('A') && __c <= _CharT2('F'))
  __ret = 10 + (__c - _CharT2('A'));
     }
   return __ret;
 }

      template<typename _CharT2>
      typename __gnu_cxx::__enable_if<!__is_char<_CharT2>::__value,
          int>::__type
 _M_find(const _CharT2* __zero, size_t __len, _CharT2 __c) const
 {
   int __ret = -1;
   const char_type* __q = char_traits<_CharT2>::find(__zero, __len, __c);
   if (__q)
     {
       __ret = __q - __zero;
       if (__ret > 15)
  __ret -= 6;
     }
   return __ret;
 }
# 2211 "/usr/include/c++/10.2.0/bits/locale_facets.h" 3
      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate&, bool&) const;

      virtual iter_type
      do_get(iter_type __beg, iter_type __end, ios_base& __io,
      ios_base::iostate& __err, long& __v) const
      { return _M_extract_int(__beg, __end, __io, __err, __v); }

      virtual iter_type
      do_get(iter_type __beg, iter_type __end, ios_base& __io,
      ios_base::iostate& __err, unsigned short& __v) const
      { return _M_extract_int(__beg, __end, __io, __err, __v); }

      virtual iter_type
      do_get(iter_type __beg, iter_type __end, ios_base& __io,
      ios_base::iostate& __err, unsigned int& __v) const
      { return _M_extract_int(__beg, __end, __io, __err, __v); }

      virtual iter_type
      do_get(iter_type __beg, iter_type __end, ios_base& __io,
      ios_base::iostate& __err, unsigned long& __v) const
      { return _M_extract_int(__beg, __end, __io, __err, __v); }


      virtual iter_type
      do_get(iter_type __beg, iter_type __end, ios_base& __io,
      ios_base::iostate& __err, long long& __v) const
      { return _M_extract_int(__beg, __end, __io, __err, __v); }

      virtual iter_type
      do_get(iter_type __beg, iter_type __end, ios_base& __io,
      ios_base::iostate& __err, unsigned long long& __v) const
      { return _M_extract_int(__beg, __end, __io, __err, __v); }


      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate&, float&) const;

      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate&,
      double&) const;







      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate&,
      long double&) const;


      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate&, void*&) const;
# 2274 "/usr/include/c++/10.2.0/bits/locale_facets.h" 3
    };

  template<typename _CharT, typename _InIter>
    locale::id num_get<_CharT, _InIter>::id;
# 2292 "/usr/include/c++/10.2.0/bits/locale_facets.h" 3
  template<typename _CharT, typename _OutIter>
    class num_put : public locale::facet
    {
    public:



      typedef _CharT char_type;
      typedef _OutIter iter_type;



      static locale::id id;
# 2313 "/usr/include/c++/10.2.0/bits/locale_facets.h" 3
      explicit
      num_put(size_t __refs = 0) : facet(__refs) { }
# 2331 "/usr/include/c++/10.2.0/bits/locale_facets.h" 3
      iter_type
      put(iter_type __s, ios_base& __io, char_type __fill, bool __v) const
      { return this->do_put(__s, __io, __fill, __v); }
# 2373 "/usr/include/c++/10.2.0/bits/locale_facets.h" 3
      iter_type
      put(iter_type __s, ios_base& __io, char_type __fill, long __v) const
      { return this->do_put(__s, __io, __fill, __v); }

      iter_type
      put(iter_type __s, ios_base& __io, char_type __fill,
   unsigned long __v) const
      { return this->do_put(__s, __io, __fill, __v); }


      iter_type
      put(iter_type __s, ios_base& __io, char_type __fill, long long __v) const
      { return this->do_put(__s, __io, __fill, __v); }

      iter_type
      put(iter_type __s, ios_base& __io, char_type __fill,
   unsigned long long __v) const
      { return this->do_put(__s, __io, __fill, __v); }
# 2436 "/usr/include/c++/10.2.0/bits/locale_facets.h" 3
      iter_type
      put(iter_type __s, ios_base& __io, char_type __fill, double __v) const
      { return this->do_put(__s, __io, __fill, __v); }

      iter_type
      put(iter_type __s, ios_base& __io, char_type __fill,
   long double __v) const
      { return this->do_put(__s, __io, __fill, __v); }
# 2461 "/usr/include/c++/10.2.0/bits/locale_facets.h" 3
      iter_type
      put(iter_type __s, ios_base& __io, char_type __fill,
   const void* __v) const
      { return this->do_put(__s, __io, __fill, __v); }

    protected:
      template<typename _ValueT>
 iter_type
 _M_insert_float(iter_type, ios_base& __io, char_type __fill,
   char __mod, _ValueT __v) const;

      void
      _M_group_float(const char* __grouping, size_t __grouping_size,
       char_type __sep, const char_type* __p, char_type* __new,
       char_type* __cs, int& __len) const;

      template<typename _ValueT>
 iter_type
 _M_insert_int(iter_type, ios_base& __io, char_type __fill,
        _ValueT __v) const;

      void
      _M_group_int(const char* __grouping, size_t __grouping_size,
     char_type __sep, ios_base& __io, char_type* __new,
     char_type* __cs, int& __len) const;

      void
      _M_pad(char_type __fill, streamsize __w, ios_base& __io,
      char_type* __new, const char_type* __cs, int& __len) const;


      virtual
      ~num_put() { }
# 2509 "/usr/include/c++/10.2.0/bits/locale_facets.h" 3
      virtual iter_type
      do_put(iter_type __s, ios_base& __io, char_type __fill, bool __v) const;

      virtual iter_type
      do_put(iter_type __s, ios_base& __io, char_type __fill, long __v) const
      { return _M_insert_int(__s, __io, __fill, __v); }

      virtual iter_type
      do_put(iter_type __s, ios_base& __io, char_type __fill,
      unsigned long __v) const
      { return _M_insert_int(__s, __io, __fill, __v); }


      virtual iter_type
      do_put(iter_type __s, ios_base& __io, char_type __fill,
      long long __v) const
      { return _M_insert_int(__s, __io, __fill, __v); }

      virtual iter_type
      do_put(iter_type __s, ios_base& __io, char_type __fill,
      unsigned long long __v) const
      { return _M_insert_int(__s, __io, __fill, __v); }


      virtual iter_type
      do_put(iter_type, ios_base&, char_type, double) const;






      virtual iter_type
      do_put(iter_type, ios_base&, char_type, long double) const;


      virtual iter_type
      do_put(iter_type, ios_base&, char_type, const void*) const;







    };

  template <typename _CharT, typename _OutIter>
    locale::id num_put<_CharT, _OutIter>::id;









  template<typename _CharT>
    inline bool
    isspace(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::space, __c); }


  template<typename _CharT>
    inline bool
    isprint(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::print, __c); }


  template<typename _CharT>
    inline bool
    iscntrl(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::cntrl, __c); }


  template<typename _CharT>
    inline bool
    isupper(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::upper, __c); }


  template<typename _CharT>
    inline bool
    islower(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::lower, __c); }


  template<typename _CharT>
    inline bool
    isalpha(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::alpha, __c); }


  template<typename _CharT>
    inline bool
    isdigit(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::digit, __c); }


  template<typename _CharT>
    inline bool
    ispunct(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::punct, __c); }


  template<typename _CharT>
    inline bool
    isxdigit(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::xdigit, __c); }


  template<typename _CharT>
    inline bool
    isalnum(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::alnum, __c); }


  template<typename _CharT>
    inline bool
    isgraph(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::graph, __c); }



  template<typename _CharT>
    inline bool
    isblank(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::blank, __c); }



  template<typename _CharT>
    inline _CharT
    toupper(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).toupper(__c); }


  template<typename _CharT>
    inline _CharT
    tolower(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).tolower(__c); }


}

# 1 "/usr/include/c++/10.2.0/bits/locale_facets.tcc" 1 3
# 33 "/usr/include/c++/10.2.0/bits/locale_facets.tcc" 3
       
# 34 "/usr/include/c++/10.2.0/bits/locale_facets.tcc" 3

namespace std __attribute__ ((__visibility__ ("default")))
{




  template<typename _Facet>
    struct __use_cache
    {
      const _Facet*
      operator() (const locale& __loc) const;
    };


  template<typename _CharT>
    struct __use_cache<__numpunct_cache<_CharT> >
    {
      const __numpunct_cache<_CharT>*
      operator() (const locale& __loc) const
      {
 const size_t __i = numpunct<_CharT>::id._M_id();
 const locale::facet** __caches = __loc._M_impl->_M_caches;
 if (!__caches[__i])
   {
     __numpunct_cache<_CharT>* __tmp = 0;
     try
       {
  __tmp = new __numpunct_cache<_CharT>;
  __tmp->_M_cache(__loc);
       }
     catch(...)
       {
  delete __tmp;
  throw;
       }
     __loc._M_impl->_M_install_cache(__tmp, __i);
   }
 return static_cast<const __numpunct_cache<_CharT>*>(__caches[__i]);
      }
    };

  template<typename _CharT>
    void
    __numpunct_cache<_CharT>::_M_cache(const locale& __loc)
    {
      const numpunct<_CharT>& __np = use_facet<numpunct<_CharT> >(__loc);

      char* __grouping = 0;
      _CharT* __truename = 0;
      _CharT* __falsename = 0;
      try
 {
   const string& __g = __np.grouping();
   _M_grouping_size = __g.size();
   __grouping = new char[_M_grouping_size];
   __g.copy(__grouping, _M_grouping_size);
   _M_use_grouping = (_M_grouping_size
        && static_cast<signed char>(__grouping[0]) > 0
        && (__grouping[0]
     != __gnu_cxx::__numeric_traits<char>::__max));

   const basic_string<_CharT>& __tn = __np.truename();
   _M_truename_size = __tn.size();
   __truename = new _CharT[_M_truename_size];
   __tn.copy(__truename, _M_truename_size);

   const basic_string<_CharT>& __fn = __np.falsename();
   _M_falsename_size = __fn.size();
   __falsename = new _CharT[_M_falsename_size];
   __fn.copy(__falsename, _M_falsename_size);

   _M_decimal_point = __np.decimal_point();
   _M_thousands_sep = __np.thousands_sep();

   const ctype<_CharT>& __ct = use_facet<ctype<_CharT> >(__loc);
   __ct.widen(__num_base::_S_atoms_out,
       __num_base::_S_atoms_out
       + __num_base::_S_oend, _M_atoms_out);
   __ct.widen(__num_base::_S_atoms_in,
       __num_base::_S_atoms_in
       + __num_base::_S_iend, _M_atoms_in);

   _M_grouping = __grouping;
   _M_truename = __truename;
   _M_falsename = __falsename;
   _M_allocated = true;
 }
      catch(...)
 {
   delete [] __grouping;
   delete [] __truename;
   delete [] __falsename;
   throw;
 }
    }
# 139 "/usr/include/c++/10.2.0/bits/locale_facets.tcc" 3
  __attribute__ ((__pure__)) bool
  __verify_grouping(const char* __grouping, size_t __grouping_size,
      const string& __grouping_tmp) throw ();



  template<typename _CharT, typename _InIter>
    __attribute ((__abi_tag__ ("cxx11")))
    _InIter
    num_get<_CharT, _InIter>::
    _M_extract_float(_InIter __beg, _InIter __end, ios_base& __io,
       ios_base::iostate& __err, string& __xtrc) const
    {
      typedef char_traits<_CharT> __traits_type;
      typedef __numpunct_cache<_CharT> __cache_type;
      __use_cache<__cache_type> __uc;
      const locale& __loc = __io._M_getloc();
      const __cache_type* __lc = __uc(__loc);
      const _CharT* __lit = __lc->_M_atoms_in;
      char_type __c = char_type();


      bool __testeof = __beg == __end;


      if (!__testeof)
 {
   __c = *__beg;
   const bool __plus = __c == __lit[__num_base::_S_iplus];
   if ((__plus || __c == __lit[__num_base::_S_iminus])
       && !(__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
       && !(__c == __lc->_M_decimal_point))
     {
       __xtrc += __plus ? '+' : '-';
       if (++__beg != __end)
  __c = *__beg;
       else
  __testeof = true;
     }
 }


      bool __found_mantissa = false;
      int __sep_pos = 0;
      while (!__testeof)
 {
   if ((__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
       || __c == __lc->_M_decimal_point)
     break;
   else if (__c == __lit[__num_base::_S_izero])
     {
       if (!__found_mantissa)
  {
    __xtrc += '0';
    __found_mantissa = true;
  }
       ++__sep_pos;

       if (++__beg != __end)
  __c = *__beg;
       else
  __testeof = true;
     }
   else
     break;
 }


      bool __found_dec = false;
      bool __found_sci = false;
      string __found_grouping;
      if (__lc->_M_use_grouping)
 __found_grouping.reserve(32);
      const char_type* __lit_zero = __lit + __num_base::_S_izero;

      if (!__lc->_M_allocated)

 while (!__testeof)
   {
     const int __digit = _M_find(__lit_zero, 10, __c);
     if (__digit != -1)
       {
  __xtrc += '0' + __digit;
  __found_mantissa = true;
       }
     else if (__c == __lc->_M_decimal_point
       && !__found_dec && !__found_sci)
       {
  __xtrc += '.';
  __found_dec = true;
       }
     else if ((__c == __lit[__num_base::_S_ie]
        || __c == __lit[__num_base::_S_iE])
       && !__found_sci && __found_mantissa)
       {

  __xtrc += 'e';
  __found_sci = true;


  if (++__beg != __end)
    {
      __c = *__beg;
      const bool __plus = __c == __lit[__num_base::_S_iplus];
      if (__plus || __c == __lit[__num_base::_S_iminus])
        __xtrc += __plus ? '+' : '-';
      else
        continue;
    }
  else
    {
      __testeof = true;
      break;
    }
       }
     else
       break;

     if (++__beg != __end)
       __c = *__beg;
     else
       __testeof = true;
   }
      else
 while (!__testeof)
   {


     if (__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
       {
  if (!__found_dec && !__found_sci)
    {


      if (__sep_pos)
        {
   __found_grouping += static_cast<char>(__sep_pos);
   __sep_pos = 0;
        }
      else
        {


   __xtrc.clear();
   break;
        }
    }
  else
    break;
       }
     else if (__c == __lc->_M_decimal_point)
       {
  if (!__found_dec && !__found_sci)
    {



      if (__found_grouping.size())
        __found_grouping += static_cast<char>(__sep_pos);
      __xtrc += '.';
      __found_dec = true;
    }
  else
    break;
       }
     else
       {
  const char_type* __q =
    __traits_type::find(__lit_zero, 10, __c);
  if (__q)
    {
      __xtrc += '0' + (__q - __lit_zero);
      __found_mantissa = true;
      ++__sep_pos;
    }
  else if ((__c == __lit[__num_base::_S_ie]
     || __c == __lit[__num_base::_S_iE])
    && !__found_sci && __found_mantissa)
    {

      if (__found_grouping.size() && !__found_dec)
        __found_grouping += static_cast<char>(__sep_pos);
      __xtrc += 'e';
      __found_sci = true;


      if (++__beg != __end)
        {
   __c = *__beg;
   const bool __plus = __c == __lit[__num_base::_S_iplus];
   if ((__plus || __c == __lit[__num_base::_S_iminus])
       && !(__lc->_M_use_grouping
     && __c == __lc->_M_thousands_sep)
       && !(__c == __lc->_M_decimal_point))
        __xtrc += __plus ? '+' : '-';
   else
     continue;
        }
      else
        {
   __testeof = true;
   break;
        }
    }
  else
    break;
       }

     if (++__beg != __end)
       __c = *__beg;
     else
       __testeof = true;
   }



      if (__found_grouping.size())
        {

   if (!__found_dec && !__found_sci)
     __found_grouping += static_cast<char>(__sep_pos);

          if (!std::__verify_grouping(__lc->_M_grouping,
          __lc->_M_grouping_size,
          __found_grouping))
     __err = ios_base::failbit;
        }

      return __beg;
    }

  template<typename _CharT, typename _InIter>
    template<typename _ValueT>
      __attribute ((__abi_tag__ ("cxx11")))
      _InIter
      num_get<_CharT, _InIter>::
      _M_extract_int(_InIter __beg, _InIter __end, ios_base& __io,
       ios_base::iostate& __err, _ValueT& __v) const
      {
        typedef char_traits<_CharT> __traits_type;
 using __gnu_cxx::__add_unsigned;
 typedef typename __add_unsigned<_ValueT>::__type __unsigned_type;
 typedef __numpunct_cache<_CharT> __cache_type;
 __use_cache<__cache_type> __uc;
 const locale& __loc = __io._M_getloc();
 const __cache_type* __lc = __uc(__loc);
 const _CharT* __lit = __lc->_M_atoms_in;
 char_type __c = char_type();


 const ios_base::fmtflags __basefield = __io.flags()
                                        & ios_base::basefield;
 const bool __oct = __basefield == ios_base::oct;
 int __base = __oct ? 8 : (__basefield == ios_base::hex ? 16 : 10);


 bool __testeof = __beg == __end;


 bool __negative = false;
 if (!__testeof)
   {
     __c = *__beg;
     __negative = __c == __lit[__num_base::_S_iminus];
     if ((__negative || __c == __lit[__num_base::_S_iplus])
  && !(__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
  && !(__c == __lc->_M_decimal_point))
       {
  if (++__beg != __end)
    __c = *__beg;
  else
    __testeof = true;
       }
   }



 bool __found_zero = false;
 int __sep_pos = 0;
 while (!__testeof)
   {
     if ((__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
  || __c == __lc->_M_decimal_point)
       break;
     else if (__c == __lit[__num_base::_S_izero]
       && (!__found_zero || __base == 10))
       {
  __found_zero = true;
  ++__sep_pos;
  if (__basefield == 0)
    __base = 8;
  if (__base == 8)
    __sep_pos = 0;
       }
     else if (__found_zero
       && (__c == __lit[__num_base::_S_ix]
    || __c == __lit[__num_base::_S_iX]))
       {
  if (__basefield == 0)
    __base = 16;
  if (__base == 16)
    {
      __found_zero = false;
      __sep_pos = 0;
    }
  else
    break;
       }
     else
       break;

     if (++__beg != __end)
       {
  __c = *__beg;
  if (!__found_zero)
    break;
       }
     else
       __testeof = true;
   }



 const size_t __len = (__base == 16 ? __num_base::_S_iend
         - __num_base::_S_izero : __base);


 typedef __gnu_cxx::__numeric_traits<_ValueT> __num_traits;
 string __found_grouping;
 if (__lc->_M_use_grouping)
   __found_grouping.reserve(32);
 bool __testfail = false;
 bool __testoverflow = false;
 const __unsigned_type __max =
   (__negative && __num_traits::__is_signed)
   ? -static_cast<__unsigned_type>(__num_traits::__min)
   : __num_traits::__max;
 const __unsigned_type __smax = __max / __base;
 __unsigned_type __result = 0;
 int __digit = 0;
 const char_type* __lit_zero = __lit + __num_base::_S_izero;

 if (!__lc->_M_allocated)

   while (!__testeof)
     {
       __digit = _M_find(__lit_zero, __len, __c);
       if (__digit == -1)
  break;

       if (__result > __smax)
  __testoverflow = true;
       else
  {
    __result *= __base;
    __testoverflow |= __result > __max - __digit;
    __result += __digit;
    ++__sep_pos;
  }

       if (++__beg != __end)
  __c = *__beg;
       else
  __testeof = true;
     }
 else
   while (!__testeof)
     {


       if (__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
  {


    if (__sep_pos)
      {
        __found_grouping += static_cast<char>(__sep_pos);
        __sep_pos = 0;
      }
    else
      {
        __testfail = true;
        break;
      }
  }
       else if (__c == __lc->_M_decimal_point)
  break;
       else
  {
    const char_type* __q =
      __traits_type::find(__lit_zero, __len, __c);
    if (!__q)
      break;

    __digit = __q - __lit_zero;
    if (__digit > 15)
      __digit -= 6;
    if (__result > __smax)
      __testoverflow = true;
    else
      {
        __result *= __base;
        __testoverflow |= __result > __max - __digit;
        __result += __digit;
        ++__sep_pos;
      }
  }

       if (++__beg != __end)
  __c = *__beg;
       else
  __testeof = true;
     }



 if (__found_grouping.size())
   {

     __found_grouping += static_cast<char>(__sep_pos);

     if (!std::__verify_grouping(__lc->_M_grouping,
     __lc->_M_grouping_size,
     __found_grouping))
       __err = ios_base::failbit;
   }



 if ((!__sep_pos && !__found_zero && !__found_grouping.size())
     || __testfail)
   {
     __v = 0;
     __err = ios_base::failbit;
   }
 else if (__testoverflow)
   {
     if (__negative && __num_traits::__is_signed)
       __v = __num_traits::__min;
     else
       __v = __num_traits::__max;
     __err = ios_base::failbit;
   }
 else
   __v = __negative ? -__result : __result;

 if (__testeof)
   __err |= ios_base::eofbit;
 return __beg;
      }



  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, bool& __v) const
    {
      if (!(__io.flags() & ios_base::boolalpha))
        {



   long __l = -1;
          __beg = _M_extract_int(__beg, __end, __io, __err, __l);
   if (__l == 0 || __l == 1)
     __v = bool(__l);
   else
     {


       __v = true;
       __err = ios_base::failbit;
       if (__beg == __end)
  __err |= ios_base::eofbit;
     }
        }
      else
        {

   typedef __numpunct_cache<_CharT> __cache_type;
   __use_cache<__cache_type> __uc;
   const locale& __loc = __io._M_getloc();
   const __cache_type* __lc = __uc(__loc);

   bool __testf = true;
   bool __testt = true;
   bool __donef = __lc->_M_falsename_size == 0;
   bool __donet = __lc->_M_truename_size == 0;
   bool __testeof = false;
   size_t __n = 0;
   while (!__donef || !__donet)
     {
       if (__beg == __end)
  {
    __testeof = true;
    break;
  }

       const char_type __c = *__beg;

       if (!__donef)
  __testf = __c == __lc->_M_falsename[__n];

       if (!__testf && __donet)
  break;

       if (!__donet)
  __testt = __c == __lc->_M_truename[__n];

       if (!__testt && __donef)
  break;

       if (!__testt && !__testf)
  break;

       ++__n;
       ++__beg;

       __donef = !__testf || __n >= __lc->_M_falsename_size;
       __donet = !__testt || __n >= __lc->_M_truename_size;
     }
   if (__testf && __n == __lc->_M_falsename_size && __n)
     {
       __v = false;
       if (__testt && __n == __lc->_M_truename_size)
  __err = ios_base::failbit;
       else
  __err = __testeof ? ios_base::eofbit : ios_base::goodbit;
     }
   else if (__testt && __n == __lc->_M_truename_size && __n)
     {
       __v = true;
       __err = __testeof ? ios_base::eofbit : ios_base::goodbit;
     }
   else
     {


       __v = false;
       __err = ios_base::failbit;
       if (__testeof)
  __err |= ios_base::eofbit;
     }
 }
      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
    ios_base::iostate& __err, float& __v) const
    {
      string __xtrc;
      __xtrc.reserve(32);
      __beg = _M_extract_float(__beg, __end, __io, __err, __xtrc);
      std::__convert_to_v(__xtrc.c_str(), __v, __err, _S_get_c_locale());
      if (__beg == __end)
 __err |= ios_base::eofbit;
      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, double& __v) const
    {
      string __xtrc;
      __xtrc.reserve(32);
      __beg = _M_extract_float(__beg, __end, __io, __err, __xtrc);
      std::__convert_to_v(__xtrc.c_str(), __v, __err, _S_get_c_locale());
      if (__beg == __end)
 __err |= ios_base::eofbit;
      return __beg;
    }
# 735 "/usr/include/c++/10.2.0/bits/locale_facets.tcc" 3
  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, long double& __v) const
    {
      string __xtrc;
      __xtrc.reserve(32);
      __beg = _M_extract_float(__beg, __end, __io, __err, __xtrc);
      std::__convert_to_v(__xtrc.c_str(), __v, __err, _S_get_c_locale());
      if (__beg == __end)
 __err |= ios_base::eofbit;
      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, void*& __v) const
    {

      typedef ios_base::fmtflags fmtflags;
      const fmtflags __fmt = __io.flags();
      __io.flags((__fmt & ~ios_base::basefield) | ios_base::hex);

      typedef __gnu_cxx::__conditional_type<(sizeof(void*)
          <= sizeof(unsigned long)),
 unsigned long, unsigned long long>::__type _UIntPtrType;

      _UIntPtrType __ul;
      __beg = _M_extract_int(__beg, __end, __io, __err, __ul);


      __io.flags(__fmt);

      __v = reinterpret_cast<void*>(__ul);
      return __beg;
    }



  template<typename _CharT, typename _OutIter>
    void
    num_put<_CharT, _OutIter>::
    _M_pad(_CharT __fill, streamsize __w, ios_base& __io,
    _CharT* __new, const _CharT* __cs, int& __len) const
    {


      __pad<_CharT, char_traits<_CharT> >::_S_pad(__io, __fill, __new,
        __cs, __w, __len);
      __len = static_cast<int>(__w);
    }



  template<typename _CharT, typename _ValueT>
    int
    __int_to_char(_CharT* __bufend, _ValueT __v, const _CharT* __lit,
    ios_base::fmtflags __flags, bool __dec)
    {
      _CharT* __buf = __bufend;
      if (__builtin_expect(__dec, true))
 {

   do
     {
       *--__buf = __lit[(__v % 10) + __num_base::_S_odigits];
       __v /= 10;
     }
   while (__v != 0);
 }
      else if ((__flags & ios_base::basefield) == ios_base::oct)
 {

   do
     {
       *--__buf = __lit[(__v & 0x7) + __num_base::_S_odigits];
       __v >>= 3;
     }
   while (__v != 0);
 }
      else
 {

   const bool __uppercase = __flags & ios_base::uppercase;
   const int __case_offset = __uppercase ? __num_base::_S_oudigits
                                         : __num_base::_S_odigits;
   do
     {
       *--__buf = __lit[(__v & 0xf) + __case_offset];
       __v >>= 4;
     }
   while (__v != 0);
 }
      return __bufend - __buf;
    }



  template<typename _CharT, typename _OutIter>
    void
    num_put<_CharT, _OutIter>::
    _M_group_int(const char* __grouping, size_t __grouping_size, _CharT __sep,
   ios_base&, _CharT* __new, _CharT* __cs, int& __len) const
    {
      _CharT* __p = std::__add_grouping(__new, __sep, __grouping,
     __grouping_size, __cs, __cs + __len);
      __len = __p - __new;
    }

  template<typename _CharT, typename _OutIter>
    template<typename _ValueT>
      _OutIter
      num_put<_CharT, _OutIter>::
      _M_insert_int(_OutIter __s, ios_base& __io, _CharT __fill,
      _ValueT __v) const
      {
 using __gnu_cxx::__add_unsigned;
 typedef typename __add_unsigned<_ValueT>::__type __unsigned_type;
 typedef __numpunct_cache<_CharT> __cache_type;
 __use_cache<__cache_type> __uc;
 const locale& __loc = __io._M_getloc();
 const __cache_type* __lc = __uc(__loc);
 const _CharT* __lit = __lc->_M_atoms_out;
 const ios_base::fmtflags __flags = __io.flags();


 const int __ilen = 5 * sizeof(_ValueT);
 _CharT* __cs = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
            * __ilen));



 const ios_base::fmtflags __basefield = __flags & ios_base::basefield;
 const bool __dec = (__basefield != ios_base::oct
       && __basefield != ios_base::hex);
 const __unsigned_type __u = ((__v > 0 || !__dec)
         ? __unsigned_type(__v)
         : -__unsigned_type(__v));
  int __len = __int_to_char(__cs + __ilen, __u, __lit, __flags, __dec);
 __cs += __ilen - __len;


 if (__lc->_M_use_grouping)
   {


     _CharT* __cs2 = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
          * (__len + 1)
          * 2));
     _M_group_int(__lc->_M_grouping, __lc->_M_grouping_size,
    __lc->_M_thousands_sep, __io, __cs2 + 2, __cs, __len);
     __cs = __cs2 + 2;
   }


 if (__builtin_expect(__dec, true))
   {

     if (__v >= 0)
       {
  if (bool(__flags & ios_base::showpos)
      && __gnu_cxx::__numeric_traits<_ValueT>::__is_signed)
    *--__cs = __lit[__num_base::_S_oplus], ++__len;
       }
     else
       *--__cs = __lit[__num_base::_S_ominus], ++__len;
   }
 else if (bool(__flags & ios_base::showbase) && __v)
   {
     if (__basefield == ios_base::oct)
       *--__cs = __lit[__num_base::_S_odigits], ++__len;
     else
       {

  const bool __uppercase = __flags & ios_base::uppercase;
  *--__cs = __lit[__num_base::_S_ox + __uppercase];

  *--__cs = __lit[__num_base::_S_odigits];
  __len += 2;
       }
   }


 const streamsize __w = __io.width();
 if (__w > static_cast<streamsize>(__len))
   {
     _CharT* __cs3 = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
          * __w));
     _M_pad(__fill, __w, __io, __cs3, __cs, __len);
     __cs = __cs3;
   }
 __io.width(0);



 return std::__write(__s, __cs, __len);
      }

  template<typename _CharT, typename _OutIter>
    void
    num_put<_CharT, _OutIter>::
    _M_group_float(const char* __grouping, size_t __grouping_size,
     _CharT __sep, const _CharT* __p, _CharT* __new,
     _CharT* __cs, int& __len) const
    {



      const int __declen = __p ? __p - __cs : __len;
      _CharT* __p2 = std::__add_grouping(__new, __sep, __grouping,
      __grouping_size,
      __cs, __cs + __declen);


      int __newlen = __p2 - __new;
      if (__p)
 {
   char_traits<_CharT>::copy(__p2, __p, __len - __declen);
   __newlen += __len - __declen;
 }
      __len = __newlen;
    }
# 971 "/usr/include/c++/10.2.0/bits/locale_facets.tcc" 3
  template<typename _CharT, typename _OutIter>
    template<typename _ValueT>
      _OutIter
      num_put<_CharT, _OutIter>::
      _M_insert_float(_OutIter __s, ios_base& __io, _CharT __fill, char __mod,
         _ValueT __v) const
      {
 typedef __numpunct_cache<_CharT> __cache_type;
 __use_cache<__cache_type> __uc;
 const locale& __loc = __io._M_getloc();
 const __cache_type* __lc = __uc(__loc);


 const streamsize __prec = __io.precision() < 0 ? 6 : __io.precision();

 const int __max_digits =
   __gnu_cxx::__numeric_traits<_ValueT>::__digits10;


 int __len;

 char __fbuf[16];
 __num_base::_S_format_float(__io, __fbuf, __mod);



 const bool __use_prec =
   (__io.flags() & ios_base::floatfield) != ios_base::floatfield;



 int __cs_size = __max_digits * 3;
 char* __cs = static_cast<char*>(__builtin_alloca(__cs_size));
 if (__use_prec)
   __len = std::__convert_from_v(_S_get_c_locale(), __cs, __cs_size,
     __fbuf, __prec, __v);
 else
   __len = std::__convert_from_v(_S_get_c_locale(), __cs, __cs_size,
     __fbuf, __v);


 if (__len >= __cs_size)
   {
     __cs_size = __len + 1;
     __cs = static_cast<char*>(__builtin_alloca(__cs_size));
     if (__use_prec)
       __len = std::__convert_from_v(_S_get_c_locale(), __cs, __cs_size,
         __fbuf, __prec, __v);
     else
       __len = std::__convert_from_v(_S_get_c_locale(), __cs, __cs_size,
         __fbuf, __v);
   }
# 1044 "/usr/include/c++/10.2.0/bits/locale_facets.tcc" 3
 const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);

 _CharT* __ws = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
            * __len));
 __ctype.widen(__cs, __cs + __len, __ws);


 _CharT* __wp = 0;
 const char* __p = char_traits<char>::find(__cs, __len, '.');
 if (__p)
   {
     __wp = __ws + (__p - __cs);
     *__wp = __lc->_M_decimal_point;
   }




 if (__lc->_M_use_grouping
     && (__wp || __len < 3 || (__cs[1] <= '9' && __cs[2] <= '9'
          && __cs[1] >= '0' && __cs[2] >= '0')))
   {


     _CharT* __ws2 = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
          * __len * 2));

     streamsize __off = 0;
     if (__cs[0] == '-' || __cs[0] == '+')
       {
  __off = 1;
  __ws2[0] = __ws[0];
  __len -= 1;
       }

     _M_group_float(__lc->_M_grouping, __lc->_M_grouping_size,
      __lc->_M_thousands_sep, __wp, __ws2 + __off,
      __ws + __off, __len);
     __len += __off;

     __ws = __ws2;
   }


 const streamsize __w = __io.width();
 if (__w > static_cast<streamsize>(__len))
   {
     _CharT* __ws3 = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
          * __w));
     _M_pad(__fill, __w, __io, __ws3, __ws, __len);
     __ws = __ws3;
   }
 __io.width(0);



 return std::__write(__s, __ws, __len);
      }

  template<typename _CharT, typename _OutIter>
    _OutIter
    num_put<_CharT, _OutIter>::
    do_put(iter_type __s, ios_base& __io, char_type __fill, bool __v) const
    {
      const ios_base::fmtflags __flags = __io.flags();
      if ((__flags & ios_base::boolalpha) == 0)
        {
          const long __l = __v;
          __s = _M_insert_int(__s, __io, __fill, __l);
        }
      else
        {
   typedef __numpunct_cache<_CharT> __cache_type;
   __use_cache<__cache_type> __uc;
   const locale& __loc = __io._M_getloc();
   const __cache_type* __lc = __uc(__loc);

   const _CharT* __name = __v ? __lc->_M_truename
                              : __lc->_M_falsename;
   int __len = __v ? __lc->_M_truename_size
                   : __lc->_M_falsename_size;

   const streamsize __w = __io.width();
   if (__w > static_cast<streamsize>(__len))
     {
       const streamsize __plen = __w - __len;
       _CharT* __ps
  = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
       * __plen));

       char_traits<_CharT>::assign(__ps, __plen, __fill);
       __io.width(0);

       if ((__flags & ios_base::adjustfield) == ios_base::left)
  {
    __s = std::__write(__s, __name, __len);
    __s = std::__write(__s, __ps, __plen);
  }
       else
  {
    __s = std::__write(__s, __ps, __plen);
    __s = std::__write(__s, __name, __len);
  }
       return __s;
     }
   __io.width(0);
   __s = std::__write(__s, __name, __len);
 }
      return __s;
    }

  template<typename _CharT, typename _OutIter>
    _OutIter
    num_put<_CharT, _OutIter>::
    do_put(iter_type __s, ios_base& __io, char_type __fill, double __v) const
    { return _M_insert_float(__s, __io, __fill, char(), __v); }
# 1169 "/usr/include/c++/10.2.0/bits/locale_facets.tcc" 3
  template<typename _CharT, typename _OutIter>
    _OutIter
    num_put<_CharT, _OutIter>::
    do_put(iter_type __s, ios_base& __io, char_type __fill,
    long double __v) const
    { return _M_insert_float(__s, __io, __fill, 'L', __v); }

  template<typename _CharT, typename _OutIter>
    _OutIter
    num_put<_CharT, _OutIter>::
    do_put(iter_type __s, ios_base& __io, char_type __fill,
           const void* __v) const
    {
      const ios_base::fmtflags __flags = __io.flags();
      const ios_base::fmtflags __fmt = ~(ios_base::basefield
      | ios_base::uppercase);
      __io.flags((__flags & __fmt) | (ios_base::hex | ios_base::showbase));

      typedef __gnu_cxx::__conditional_type<(sizeof(const void*)
          <= sizeof(unsigned long)),
 unsigned long, unsigned long long>::__type _UIntPtrType;

      __s = _M_insert_int(__s, __io, __fill,
     reinterpret_cast<_UIntPtrType>(__v));
      __io.flags(__flags);
      return __s;
    }


# 1206 "/usr/include/c++/10.2.0/bits/locale_facets.tcc" 3
  template<typename _CharT, typename _Traits>
    void
    __pad<_CharT, _Traits>::_S_pad(ios_base& __io, _CharT __fill,
       _CharT* __news, const _CharT* __olds,
       streamsize __newlen, streamsize __oldlen)
    {
      const size_t __plen = static_cast<size_t>(__newlen - __oldlen);
      const ios_base::fmtflags __adjust = __io.flags() & ios_base::adjustfield;


      if (__adjust == ios_base::left)
 {
   _Traits::copy(__news, __olds, __oldlen);
   _Traits::assign(__news + __oldlen, __plen, __fill);
   return;
 }

      size_t __mod = 0;
      if (__adjust == ios_base::
# 1224 "/usr/include/c++/10.2.0/bits/locale_facets.tcc"
                               static
# 1224 "/usr/include/c++/10.2.0/bits/locale_facets.tcc" 3
                                       )
 {



          const locale& __loc = __io._M_getloc();
   const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);

   if (__ctype.widen('-') == __olds[0]
       || __ctype.widen('+') == __olds[0])
     {
       __news[0] = __olds[0];
       __mod = 1;
       ++__news;
     }
   else if (__ctype.widen('0') == __olds[0]
     && __oldlen > 1
     && (__ctype.widen('x') == __olds[1]
         || __ctype.widen('X') == __olds[1]))
     {
       __news[0] = __olds[0];
       __news[1] = __olds[1];
       __mod = 2;
       __news += 2;
     }

 }
      _Traits::assign(__news, __plen, __fill);
      _Traits::copy(__news + __plen, __olds + __mod, __oldlen - __mod);
    }

  template<typename _CharT>
    _CharT*
    __add_grouping(_CharT* __s, _CharT __sep,
     const char* __gbeg, size_t __gsize,
     const _CharT* __first, const _CharT* __last)
    {
      size_t __idx = 0;
      size_t __ctr = 0;

      while (__last - __first > __gbeg[__idx]
      && static_cast<signed char>(__gbeg[__idx]) > 0
      && __gbeg[__idx] != __gnu_cxx::__numeric_traits<char>::__max)
 {
   __last -= __gbeg[__idx];
   __idx < __gsize - 1 ? ++__idx : ++__ctr;
 }

      while (__first != __last)
 *__s++ = *__first++;

      while (__ctr--)
 {
   *__s++ = __sep;
   for (char __i = __gbeg[__idx]; __i > 0; --__i)
     *__s++ = *__first++;
 }

      while (__idx--)
 {
   *__s++ = __sep;
   for (char __i = __gbeg[__idx]; __i > 0; --__i)
     *__s++ = *__first++;
 }

      return __s;
    }




  extern template class __cxx11:: numpunct<char>;
  extern template class __cxx11:: numpunct_byname<char>;
  extern template class num_get<char>;
  extern template class num_put<char>;
  extern template class ctype_byname<char>;

  extern template
    const ctype<char>&
    use_facet<ctype<char> >(const locale&);

  extern template
    const numpunct<char>&
    use_facet<numpunct<char> >(const locale&);

  extern template
    const num_put<char>&
    use_facet<num_put<char> >(const locale&);

  extern template
    const num_get<char>&
    use_facet<num_get<char> >(const locale&);

  extern template
    bool
    has_facet<ctype<char> >(const locale&);

  extern template
    bool
    has_facet<numpunct<char> >(const locale&);

  extern template
    bool
    has_facet<num_put<char> >(const locale&);

  extern template
    bool
    has_facet<num_get<char> >(const locale&);


  extern template class __cxx11:: numpunct<wchar_t>;
  extern template class __cxx11:: numpunct_byname<wchar_t>;
  extern template class num_get<wchar_t>;
  extern template class num_put<wchar_t>;
  extern template class ctype_byname<wchar_t>;

  extern template
    const ctype<wchar_t>&
    use_facet<ctype<wchar_t> >(const locale&);

  extern template
    const numpunct<wchar_t>&
    use_facet<numpunct<wchar_t> >(const locale&);

  extern template
    const num_put<wchar_t>&
    use_facet<num_put<wchar_t> >(const locale&);

  extern template
    const num_get<wchar_t>&
    use_facet<num_get<wchar_t> >(const locale&);

 extern template
    bool
    has_facet<ctype<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<numpunct<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<num_put<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<num_get<wchar_t> >(const locale&);




}
# 2656 "/usr/include/c++/10.2.0/bits/locale_facets.h" 2 3
# 38 "/usr/include/c++/10.2.0/bits/basic_ios.h" 2 3



namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _Facet>
    inline const _Facet&
    __check_facet(const _Facet* __f)
    {
      if (!__f)
 __throw_bad_cast();
      return *__f;
    }
# 66 "/usr/include/c++/10.2.0/bits/basic_ios.h" 3
  template<typename _CharT, typename _Traits>
    class basic_ios : public ios_base
    {
    public:






      typedef _CharT char_type;
      typedef typename _Traits::int_type int_type;
      typedef typename _Traits::pos_type pos_type;
      typedef typename _Traits::off_type off_type;
      typedef _Traits traits_type;






      typedef ctype<_CharT> __ctype_type;
      typedef num_put<_CharT, ostreambuf_iterator<_CharT, _Traits> >
           __num_put_type;
      typedef num_get<_CharT, istreambuf_iterator<_CharT, _Traits> >
           __num_get_type;



    protected:
      basic_ostream<_CharT, _Traits>* _M_tie;
      mutable char_type _M_fill;
      mutable bool _M_fill_init;
      basic_streambuf<_CharT, _Traits>* _M_streambuf;


      const __ctype_type* _M_ctype;

      const __num_put_type* _M_num_put;

      const __num_get_type* _M_num_get;

    public:
# 117 "/usr/include/c++/10.2.0/bits/basic_ios.h" 3
      explicit operator bool() const
      { return !this->fail(); }





      bool
      operator!() const
      { return this->fail(); }
# 136 "/usr/include/c++/10.2.0/bits/basic_ios.h" 3
      iostate
      rdstate() const
      { return _M_streambuf_state; }
# 147 "/usr/include/c++/10.2.0/bits/basic_ios.h" 3
      void
      clear(iostate __state = goodbit);







      void
      setstate(iostate __state)
      { this->clear(this->rdstate() | __state); }




      void
      _M_setstate(iostate __state)
      {


 _M_streambuf_state |= __state;
 if (this->exceptions() & __state)
   throw;
      }







      bool
      good() const
      { return this->rdstate() == 0; }







      bool
      eof() const
      { return (this->rdstate() & eofbit) != 0; }
# 200 "/usr/include/c++/10.2.0/bits/basic_ios.h" 3
      bool
      fail() const
      { return (this->rdstate() & (badbit | failbit)) != 0; }







      bool
      bad() const
      { return (this->rdstate() & badbit) != 0; }
# 221 "/usr/include/c++/10.2.0/bits/basic_ios.h" 3
      iostate
      exceptions() const
      { return _M_exception; }
# 256 "/usr/include/c++/10.2.0/bits/basic_ios.h" 3
      void
      exceptions(iostate __except)
      {
        _M_exception = __except;
        this->clear(_M_streambuf_state);
      }







      explicit
      basic_ios(basic_streambuf<_CharT, _Traits>* __sb)
      : ios_base(), _M_tie(0), _M_fill(), _M_fill_init(false), _M_streambuf(0),
 _M_ctype(0), _M_num_put(0), _M_num_get(0)
      { this->init(__sb); }







      virtual
      ~basic_ios() { }
# 294 "/usr/include/c++/10.2.0/bits/basic_ios.h" 3
      basic_ostream<_CharT, _Traits>*
      tie() const
      { return _M_tie; }
# 306 "/usr/include/c++/10.2.0/bits/basic_ios.h" 3
      basic_ostream<_CharT, _Traits>*
      tie(basic_ostream<_CharT, _Traits>* __tiestr)
      {
        basic_ostream<_CharT, _Traits>* __old = _M_tie;
        _M_tie = __tiestr;
        return __old;
      }







      basic_streambuf<_CharT, _Traits>*
      rdbuf() const
      { return _M_streambuf; }
# 346 "/usr/include/c++/10.2.0/bits/basic_ios.h" 3
      basic_streambuf<_CharT, _Traits>*
      rdbuf(basic_streambuf<_CharT, _Traits>* __sb);
# 360 "/usr/include/c++/10.2.0/bits/basic_ios.h" 3
      basic_ios&
      copyfmt(const basic_ios& __rhs);







      char_type
      fill() const
      {
 if (!_M_fill_init)
   {
     _M_fill = this->widen(' ');
     _M_fill_init = true;
   }
 return _M_fill;
      }
# 389 "/usr/include/c++/10.2.0/bits/basic_ios.h" 3
      char_type
      fill(char_type __ch)
      {
 char_type __old = this->fill();
 _M_fill = __ch;
 return __old;
      }
# 409 "/usr/include/c++/10.2.0/bits/basic_ios.h" 3
      locale
      imbue(const locale& __loc);
# 429 "/usr/include/c++/10.2.0/bits/basic_ios.h" 3
      char
      narrow(char_type __c, char __dfault) const
      { return __check_facet(_M_ctype).narrow(__c, __dfault); }
# 448 "/usr/include/c++/10.2.0/bits/basic_ios.h" 3
      char_type
      widen(char __c) const
      { return __check_facet(_M_ctype).widen(__c); }

    protected:







      basic_ios()
      : ios_base(), _M_tie(0), _M_fill(char_type()), _M_fill_init(false),
 _M_streambuf(0), _M_ctype(0), _M_num_put(0), _M_num_get(0)
      { }







      void
      init(basic_streambuf<_CharT, _Traits>* __sb);


      basic_ios(const basic_ios&) = delete;
      basic_ios& operator=(const basic_ios&) = delete;

      void
      move(basic_ios& __rhs)
      {
 ios_base::_M_move(__rhs);
 _M_cache_locale(_M_ios_locale);
 this->tie(__rhs.tie(nullptr));
 _M_fill = __rhs._M_fill;
 _M_fill_init = __rhs._M_fill_init;
 _M_streambuf = nullptr;
      }

      void
      move(basic_ios&& __rhs)
      { this->move(__rhs); }

      void
      swap(basic_ios& __rhs) noexcept
      {
 ios_base::_M_swap(__rhs);
 _M_cache_locale(_M_ios_locale);
 __rhs._M_cache_locale(__rhs._M_ios_locale);
 std::swap(_M_tie, __rhs._M_tie);
 std::swap(_M_fill, __rhs._M_fill);
 std::swap(_M_fill_init, __rhs._M_fill_init);
      }

      void
      set_rdbuf(basic_streambuf<_CharT, _Traits>* __sb)
      { _M_streambuf = __sb; }


      void
      _M_cache_locale(const locale& __loc);
    };


}

# 1 "/usr/include/c++/10.2.0/bits/basic_ios.tcc" 1 3
# 33 "/usr/include/c++/10.2.0/bits/basic_ios.tcc" 3
       
# 34 "/usr/include/c++/10.2.0/bits/basic_ios.tcc" 3

namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _CharT, typename _Traits>
    void
    basic_ios<_CharT, _Traits>::clear(iostate __state)
    {
      if (this->rdbuf())
 _M_streambuf_state = __state;
      else
   _M_streambuf_state = __state | badbit;
      if (this->exceptions() & this->rdstate())
 __throw_ios_failure(("basic_ios::clear"));
    }

  template<typename _CharT, typename _Traits>
    basic_streambuf<_CharT, _Traits>*
    basic_ios<_CharT, _Traits>::rdbuf(basic_streambuf<_CharT, _Traits>* __sb)
    {
      basic_streambuf<_CharT, _Traits>* __old = _M_streambuf;
      _M_streambuf = __sb;
      this->clear();
      return __old;
    }

  template<typename _CharT, typename _Traits>
    basic_ios<_CharT, _Traits>&
    basic_ios<_CharT, _Traits>::copyfmt(const basic_ios& __rhs)
    {


      if (this != &__rhs)
 {




   _Words* __words = (__rhs._M_word_size <= _S_local_word_size) ?
                      _M_local_word : new _Words[__rhs._M_word_size];


   _Callback_list* __cb = __rhs._M_callbacks;
   if (__cb)
     __cb->_M_add_reference();
   _M_call_callbacks(erase_event);
   if (_M_word != _M_local_word)
     {
       delete [] _M_word;
       _M_word = 0;
     }
   _M_dispose_callbacks();


   _M_callbacks = __cb;
   for (int __i = 0; __i < __rhs._M_word_size; ++__i)
     __words[__i] = __rhs._M_word[__i];
   _M_word = __words;
   _M_word_size = __rhs._M_word_size;

   this->flags(__rhs.flags());
   this->width(__rhs.width());
   this->precision(__rhs.precision());
   this->tie(__rhs.tie());
   this->fill(__rhs.fill());
   _M_ios_locale = __rhs.getloc();
   _M_cache_locale(_M_ios_locale);

   _M_call_callbacks(copyfmt_event);


   this->exceptions(__rhs.exceptions());
 }
      return *this;
    }


  template<typename _CharT, typename _Traits>
    locale
    basic_ios<_CharT, _Traits>::imbue(const locale& __loc)
    {
      locale __old(this->getloc());
      ios_base::imbue(__loc);
      _M_cache_locale(__loc);
      if (this->rdbuf() != 0)
 this->rdbuf()->pubimbue(__loc);
      return __old;
    }

  template<typename _CharT, typename _Traits>
    void
    basic_ios<_CharT, _Traits>::init(basic_streambuf<_CharT, _Traits>* __sb)
    {

      ios_base::_M_init();


      _M_cache_locale(_M_ios_locale);
# 146 "/usr/include/c++/10.2.0/bits/basic_ios.tcc" 3
      _M_fill = _CharT();
      _M_fill_init = false;

      _M_tie = 0;
      _M_exception = goodbit;
      _M_streambuf = __sb;
      _M_streambuf_state = __sb ? goodbit : badbit;
    }

  template<typename _CharT, typename _Traits>
    void
    basic_ios<_CharT, _Traits>::_M_cache_locale(const locale& __loc)
    {
      if (__builtin_expect(has_facet<__ctype_type>(__loc), true))
 _M_ctype = std::__addressof(use_facet<__ctype_type>(__loc));
      else
 _M_ctype = 0;

      if (__builtin_expect(has_facet<__num_put_type>(__loc), true))
 _M_num_put = std::__addressof(use_facet<__num_put_type>(__loc));
      else
 _M_num_put = 0;

      if (__builtin_expect(has_facet<__num_get_type>(__loc), true))
 _M_num_get = std::__addressof(use_facet<__num_get_type>(__loc));
      else
 _M_num_get = 0;
    }




  extern template class basic_ios<char>;


  extern template class basic_ios<wchar_t>;




}
# 517 "/usr/include/c++/10.2.0/bits/basic_ios.h" 2 3
# 45 "/usr/include/c++/10.2.0/ios" 2 3
# 39 "/usr/include/c++/10.2.0/istream" 2 3
# 1 "/usr/include/c++/10.2.0/ostream" 1 3
# 36 "/usr/include/c++/10.2.0/ostream" 3
       
# 37 "/usr/include/c++/10.2.0/ostream" 3




namespace std __attribute__ ((__visibility__ ("default")))
{

# 57 "/usr/include/c++/10.2.0/ostream" 3
  template<typename _CharT, typename _Traits>
    class basic_ostream : virtual public basic_ios<_CharT, _Traits>
    {
    public:

      typedef _CharT char_type;
      typedef typename _Traits::int_type int_type;
      typedef typename _Traits::pos_type pos_type;
      typedef typename _Traits::off_type off_type;
      typedef _Traits traits_type;


      typedef basic_streambuf<_CharT, _Traits> __streambuf_type;
      typedef basic_ios<_CharT, _Traits> __ios_type;
      typedef basic_ostream<_CharT, _Traits> __ostream_type;
      typedef num_put<_CharT, ostreambuf_iterator<_CharT, _Traits> >
             __num_put_type;
      typedef ctype<_CharT> __ctype_type;
# 83 "/usr/include/c++/10.2.0/ostream" 3
      explicit
      basic_ostream(__streambuf_type* __sb)
      { this->init(__sb); }






      virtual
      ~basic_ostream() { }


      class sentry;
      friend class sentry;
# 107 "/usr/include/c++/10.2.0/ostream" 3
      __ostream_type&
      operator<<(__ostream_type& (*__pf)(__ostream_type&))
      {



 return __pf(*this);
      }

      __ostream_type&
      operator<<(__ios_type& (*__pf)(__ios_type&))
      {



 __pf(*this);
 return *this;
      }

      __ostream_type&
      operator<<(ios_base& (*__pf) (ios_base&))
      {



 __pf(*this);
 return *this;
      }
# 165 "/usr/include/c++/10.2.0/ostream" 3
      __ostream_type&
      operator<<(long __n)
      { return _M_insert(__n); }

      __ostream_type&
      operator<<(unsigned long __n)
      { return _M_insert(__n); }

      __ostream_type&
      operator<<(bool __n)
      { return _M_insert(__n); }

      __ostream_type&
      operator<<(short __n);

      __ostream_type&
      operator<<(unsigned short __n)
      {


 return _M_insert(static_cast<unsigned long>(__n));
      }

      __ostream_type&
      operator<<(int __n);

      __ostream_type&
      operator<<(unsigned int __n)
      {


 return _M_insert(static_cast<unsigned long>(__n));
      }


      __ostream_type&
      operator<<(long long __n)
      { return _M_insert(__n); }

      __ostream_type&
      operator<<(unsigned long long __n)
      { return _M_insert(__n); }
# 219 "/usr/include/c++/10.2.0/ostream" 3
      __ostream_type&
      operator<<(double __f)
      { return _M_insert(__f); }

      __ostream_type&
      operator<<(float __f)
      {


 return _M_insert(static_cast<double>(__f));
      }

      __ostream_type&
      operator<<(long double __f)
      { return _M_insert(__f); }
# 244 "/usr/include/c++/10.2.0/ostream" 3
      __ostream_type&
      operator<<(const void* __p)
      { return _M_insert(__p); }
# 275 "/usr/include/c++/10.2.0/ostream" 3
      __ostream_type&
      operator<<(__streambuf_type* __sb);
# 308 "/usr/include/c++/10.2.0/ostream" 3
      __ostream_type&
      put(char_type __c);






      void
      _M_write(const char_type* __s, streamsize __n)
      {
 const streamsize __put = this->rdbuf()->sputn(__s, __n);
 if (__put != __n)
   this->setstate(ios_base::badbit);
      }
# 340 "/usr/include/c++/10.2.0/ostream" 3
      __ostream_type&
      write(const char_type* __s, streamsize __n);
# 353 "/usr/include/c++/10.2.0/ostream" 3
      __ostream_type&
      flush();
# 363 "/usr/include/c++/10.2.0/ostream" 3
      pos_type
      tellp();
# 374 "/usr/include/c++/10.2.0/ostream" 3
      __ostream_type&
      seekp(pos_type);
# 386 "/usr/include/c++/10.2.0/ostream" 3
       __ostream_type&
      seekp(off_type, ios_base::seekdir);

    protected:
      basic_ostream()
      { this->init(0); }



      basic_ostream(basic_iostream<_CharT, _Traits>&) { }

      basic_ostream(const basic_ostream&) = delete;

      basic_ostream(basic_ostream&& __rhs)
      : __ios_type()
      { __ios_type::move(__rhs); }



      basic_ostream& operator=(const basic_ostream&) = delete;

      basic_ostream&
      operator=(basic_ostream&& __rhs)
      {
 swap(__rhs);
 return *this;
      }

      void
      swap(basic_ostream& __rhs)
      { __ios_type::swap(__rhs); }


      template<typename _ValueT>
 __ostream_type&
 _M_insert(_ValueT __v);
    };
# 431 "/usr/include/c++/10.2.0/ostream" 3
  template <typename _CharT, typename _Traits>
    class basic_ostream<_CharT, _Traits>::sentry
    {

      bool _M_ok;
      basic_ostream<_CharT, _Traits>& _M_os;

    public:
# 450 "/usr/include/c++/10.2.0/ostream" 3
      explicit
      sentry(basic_ostream<_CharT, _Traits>& __os);

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"







      ~sentry()
      {

 if (bool(_M_os.flags() & ios_base::unitbuf) && !uncaught_exception())
   {

     if (_M_os.rdbuf() && _M_os.rdbuf()->pubsync() == -1)
       _M_os.setstate(ios_base::badbit);
   }
      }
#pragma GCC diagnostic pop
# 482 "/usr/include/c++/10.2.0/ostream" 3
      explicit

      operator bool() const
      { return _M_ok; }
    };
# 504 "/usr/include/c++/10.2.0/ostream" 3
  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __out, _CharT __c)
    { return __ostream_insert(__out, &__c, 1); }

  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __out, char __c)
    { return (__out << __out.widen(__c)); }


  template<typename _Traits>
    inline basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>& __out, char __c)
    { return __ostream_insert(__out, &__c, 1); }


  template<typename _Traits>
    inline basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>& __out, signed char __c)
    { return (__out << static_cast<char>(__c)); }

  template<typename _Traits>
    inline basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>& __out, unsigned char __c)
    { return (__out << static_cast<char>(__c)); }
# 587 "/usr/include/c++/10.2.0/ostream" 3
  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __out, const _CharT* __s)
    {
      if (!__s)
 __out.setstate(ios_base::badbit);
      else
 __ostream_insert(__out, __s,
    static_cast<streamsize>(_Traits::length(__s)));
      return __out;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits> &
    operator<<(basic_ostream<_CharT, _Traits>& __out, const char* __s);


  template<typename _Traits>
    inline basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>& __out, const char* __s)
    {
      if (!__s)
 __out.setstate(ios_base::badbit);
      else
 __ostream_insert(__out, __s,
    static_cast<streamsize>(_Traits::length(__s)));
      return __out;
    }


  template<typename _Traits>
    inline basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>& __out, const signed char* __s)
    { return (__out << reinterpret_cast<const char*>(__s)); }

  template<typename _Traits>
    inline basic_ostream<char, _Traits> &
    operator<<(basic_ostream<char, _Traits>& __out, const unsigned char* __s)
    { return (__out << reinterpret_cast<const char*>(__s)); }
# 679 "/usr/include/c++/10.2.0/ostream" 3
  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    endl(basic_ostream<_CharT, _Traits>& __os)
    { return flush(__os.put(__os.widen('\n'))); }
# 691 "/usr/include/c++/10.2.0/ostream" 3
  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    ends(basic_ostream<_CharT, _Traits>& __os)
    { return __os.put(_CharT()); }






  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    flush(basic_ostream<_CharT, _Traits>& __os)
    { return __os.flush(); }


  template<typename _Ch, typename _Up>
    basic_ostream<_Ch, _Up>&
    __is_convertible_to_basic_ostream_test(basic_ostream<_Ch, _Up>*);

  template<typename _Tp, typename = void>
    struct __is_convertible_to_basic_ostream_impl
    {
      using __ostream_type = void;
    };

  template<typename _Tp>
    using __do_is_convertible_to_basic_ostream_impl =
    decltype(__is_convertible_to_basic_ostream_test
      (declval<typename remove_reference<_Tp>::type*>()));

  template<typename _Tp>
    struct __is_convertible_to_basic_ostream_impl
    <_Tp,
     __void_t<__do_is_convertible_to_basic_ostream_impl<_Tp>>>
    {
      using __ostream_type =
 __do_is_convertible_to_basic_ostream_impl<_Tp>;
    };

  template<typename _Tp>
    struct __is_convertible_to_basic_ostream
    : __is_convertible_to_basic_ostream_impl<_Tp>
    {
    public:
      using type = __not_<is_void<
        typename __is_convertible_to_basic_ostream_impl<_Tp>::__ostream_type>>;
      constexpr static bool value = type::value;
    };

  template<typename _Ostream, typename _Tp, typename = void>
    struct __is_insertable : false_type {};

  template<typename _Ostream, typename _Tp>
    struct __is_insertable<_Ostream, _Tp,
      __void_t<decltype(declval<_Ostream&>()
          << declval<const _Tp&>())>>
        : true_type {};

  template<typename _Ostream>
    using __rvalue_ostream_type =
      typename __is_convertible_to_basic_ostream<
 _Ostream>::__ostream_type;
# 765 "/usr/include/c++/10.2.0/ostream" 3
  template<typename _Ostream, typename _Tp>
    inline
    typename enable_if<__and_<__not_<is_lvalue_reference<_Ostream>>,
         __is_convertible_to_basic_ostream<_Ostream>,
         __is_insertable<
    __rvalue_ostream_type<_Ostream>,
    const _Tp&>>::value,
         __rvalue_ostream_type<_Ostream>>::type
    operator<<(_Ostream&& __os, const _Tp& __x)
    {
      __rvalue_ostream_type<_Ostream> __ret_os = __os;
      __ret_os << __x;
      return __ret_os;
    }



}

# 1 "/usr/include/c++/10.2.0/bits/ostream.tcc" 1 3
# 37 "/usr/include/c++/10.2.0/bits/ostream.tcc" 3
       
# 38 "/usr/include/c++/10.2.0/bits/ostream.tcc" 3



namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>::sentry::
    sentry(basic_ostream<_CharT, _Traits>& __os)
    : _M_ok(false), _M_os(__os)
    {

      if (__os.tie() && __os.good())
 __os.tie()->flush();

      if (__os.good())
 _M_ok = true;
      else
 __os.setstate(ios_base::failbit);
    }

  template<typename _CharT, typename _Traits>
    template<typename _ValueT>
      basic_ostream<_CharT, _Traits>&
      basic_ostream<_CharT, _Traits>::
      _M_insert(_ValueT __v)
      {
 sentry __cerb(*this);
 if (__cerb)
   {
     ios_base::iostate __err = ios_base::goodbit;
     try
       {
  const __num_put_type& __np = __check_facet(this->_M_num_put);
  if (__np.put(*this, *this, this->fill(), __v).failed())
    __err |= ios_base::badbit;
       }
     catch(__cxxabiv1::__forced_unwind&)
       {
  this->_M_setstate(ios_base::badbit);
  throw;
       }
     catch(...)
       { this->_M_setstate(ios_base::badbit); }
     if (__err)
       this->setstate(__err);
   }
 return *this;
      }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    operator<<(short __n)
    {


      const ios_base::fmtflags __fmt = this->flags() & ios_base::basefield;
      if (__fmt == ios_base::oct || __fmt == ios_base::hex)
 return _M_insert(static_cast<long>(static_cast<unsigned short>(__n)));
      else
 return _M_insert(static_cast<long>(__n));
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    operator<<(int __n)
    {


      const ios_base::fmtflags __fmt = this->flags() & ios_base::basefield;
      if (__fmt == ios_base::oct || __fmt == ios_base::hex)
 return _M_insert(static_cast<long>(static_cast<unsigned int>(__n)));
      else
 return _M_insert(static_cast<long>(__n));
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    operator<<(__streambuf_type* __sbin)
    {
      ios_base::iostate __err = ios_base::goodbit;
      sentry __cerb(*this);
      if (__cerb && __sbin)
 {
   try
     {
       if (!__copy_streambufs(__sbin, this->rdbuf()))
  __err |= ios_base::failbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::failbit); }
 }
      else if (!__sbin)
 __err |= ios_base::badbit;
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    put(char_type __c)
    {






      sentry __cerb(*this);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       const int_type __put = this->rdbuf()->sputc(__c);
       if (traits_type::eq_int_type(__put, traits_type::eof()))
  __err |= ios_base::badbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    write(const _CharT* __s, streamsize __n)
    {







      sentry __cerb(*this);
      if (__cerb)
 {
   try
     { _M_write(__s, __n); }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    flush()
    {



      ios_base::iostate __err = ios_base::goodbit;
      try
 {
   if (this->rdbuf() && this->rdbuf()->pubsync() == -1)
     __err |= ios_base::badbit;
 }
      catch(__cxxabiv1::__forced_unwind&)
 {
   this->_M_setstate(ios_base::badbit);
   throw;
 }
      catch(...)
 { this->_M_setstate(ios_base::badbit); }
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    typename basic_ostream<_CharT, _Traits>::pos_type
    basic_ostream<_CharT, _Traits>::
    tellp()
    {
      pos_type __ret = pos_type(-1);
      try
 {
   if (!this->fail())
     __ret = this->rdbuf()->pubseekoff(0, ios_base::cur, ios_base::out);
 }
      catch(__cxxabiv1::__forced_unwind&)
 {
   this->_M_setstate(ios_base::badbit);
   throw;
 }
      catch(...)
 { this->_M_setstate(ios_base::badbit); }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    seekp(pos_type __pos)
    {
      ios_base::iostate __err = ios_base::goodbit;
      try
 {
   if (!this->fail())
     {


       const pos_type __p = this->rdbuf()->pubseekpos(__pos,
            ios_base::out);


       if (__p == pos_type(off_type(-1)))
  __err |= ios_base::failbit;
     }
 }
      catch(__cxxabiv1::__forced_unwind&)
 {
   this->_M_setstate(ios_base::badbit);
   throw;
 }
      catch(...)
 { this->_M_setstate(ios_base::badbit); }
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    seekp(off_type __off, ios_base::seekdir __dir)
    {
      ios_base::iostate __err = ios_base::goodbit;
      try
 {
   if (!this->fail())
     {


       const pos_type __p = this->rdbuf()->pubseekoff(__off, __dir,
            ios_base::out);


       if (__p == pos_type(off_type(-1)))
  __err |= ios_base::failbit;
     }
 }
      catch(__cxxabiv1::__forced_unwind&)
 {
   this->_M_setstate(ios_base::badbit);
   throw;
 }
      catch(...)
 { this->_M_setstate(ios_base::badbit); }
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __out, const char* __s)
    {
      if (!__s)
 __out.setstate(ios_base::badbit);
      else
 {


   const size_t __clen = char_traits<char>::length(__s);
   try
     {
       struct __ptr_guard
       {
  _CharT *__p;
  __ptr_guard (_CharT *__ip): __p(__ip) { }
  ~__ptr_guard() { delete[] __p; }
  _CharT* __get() { return __p; }
       } __pg (new _CharT[__clen]);

       _CharT *__ws = __pg.__get();
       for (size_t __i = 0; __i < __clen; ++__i)
  __ws[__i] = __out.widen(__s[__i]);
       __ostream_insert(__out, __ws, __clen);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       __out._M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { __out._M_setstate(ios_base::badbit); }
 }
      return __out;
    }




  extern template class basic_ostream<char>;
  extern template ostream& endl(ostream&);
  extern template ostream& ends(ostream&);
  extern template ostream& flush(ostream&);
  extern template ostream& operator<<(ostream&, char);
  extern template ostream& operator<<(ostream&, unsigned char);
  extern template ostream& operator<<(ostream&, signed char);
  extern template ostream& operator<<(ostream&, const char*);
  extern template ostream& operator<<(ostream&, const unsigned char*);
  extern template ostream& operator<<(ostream&, const signed char*);

  extern template ostream& ostream::_M_insert(long);
  extern template ostream& ostream::_M_insert(unsigned long);
  extern template ostream& ostream::_M_insert(bool);

  extern template ostream& ostream::_M_insert(long long);
  extern template ostream& ostream::_M_insert(unsigned long long);

  extern template ostream& ostream::_M_insert(double);
  extern template ostream& ostream::_M_insert(long double);
  extern template ostream& ostream::_M_insert(const void*);


  extern template class basic_ostream<wchar_t>;
  extern template wostream& endl(wostream&);
  extern template wostream& ends(wostream&);
  extern template wostream& flush(wostream&);
  extern template wostream& operator<<(wostream&, wchar_t);
  extern template wostream& operator<<(wostream&, char);
  extern template wostream& operator<<(wostream&, const wchar_t*);
  extern template wostream& operator<<(wostream&, const char*);

  extern template wostream& wostream::_M_insert(long);
  extern template wostream& wostream::_M_insert(unsigned long);
  extern template wostream& wostream::_M_insert(bool);

  extern template wostream& wostream::_M_insert(long long);
  extern template wostream& wostream::_M_insert(unsigned long long);

  extern template wostream& wostream::_M_insert(double);
  extern template wostream& wostream::_M_insert(long double);
  extern template wostream& wostream::_M_insert(const void*);




}
# 785 "/usr/include/c++/10.2.0/ostream" 2 3
# 40 "/usr/include/c++/10.2.0/istream" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{

# 57 "/usr/include/c++/10.2.0/istream" 3
  template<typename _CharT, typename _Traits>
    class basic_istream : virtual public basic_ios<_CharT, _Traits>
    {
    public:

      typedef _CharT char_type;
      typedef typename _Traits::int_type int_type;
      typedef typename _Traits::pos_type pos_type;
      typedef typename _Traits::off_type off_type;
      typedef _Traits traits_type;


      typedef basic_streambuf<_CharT, _Traits> __streambuf_type;
      typedef basic_ios<_CharT, _Traits> __ios_type;
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef num_get<_CharT, istreambuf_iterator<_CharT, _Traits> >
        __num_get_type;
      typedef ctype<_CharT> __ctype_type;

    protected:





      streamsize _M_gcount;

    public:







      explicit
      basic_istream(__streambuf_type* __sb)
      : _M_gcount(streamsize(0))
      { this->init(__sb); }






      virtual
      ~basic_istream()
      { _M_gcount = streamsize(0); }


      class sentry;
      friend class sentry;
# 119 "/usr/include/c++/10.2.0/istream" 3
      __istream_type&
      operator>>(__istream_type& (*__pf)(__istream_type&))
      { return __pf(*this); }

      __istream_type&
      operator>>(__ios_type& (*__pf)(__ios_type&))
      {
 __pf(*this);
 return *this;
      }

      __istream_type&
      operator>>(ios_base& (*__pf)(ios_base&))
      {
 __pf(*this);
 return *this;
      }
# 167 "/usr/include/c++/10.2.0/istream" 3
      __istream_type&
      operator>>(bool& __n)
      { return _M_extract(__n); }

      __istream_type&
      operator>>(short& __n);

      __istream_type&
      operator>>(unsigned short& __n)
      { return _M_extract(__n); }

      __istream_type&
      operator>>(int& __n);

      __istream_type&
      operator>>(unsigned int& __n)
      { return _M_extract(__n); }

      __istream_type&
      operator>>(long& __n)
      { return _M_extract(__n); }

      __istream_type&
      operator>>(unsigned long& __n)
      { return _M_extract(__n); }


      __istream_type&
      operator>>(long long& __n)
      { return _M_extract(__n); }

      __istream_type&
      operator>>(unsigned long long& __n)
      { return _M_extract(__n); }
# 213 "/usr/include/c++/10.2.0/istream" 3
      __istream_type&
      operator>>(float& __f)
      { return _M_extract(__f); }

      __istream_type&
      operator>>(double& __f)
      { return _M_extract(__f); }

      __istream_type&
      operator>>(long double& __f)
      { return _M_extract(__f); }
# 234 "/usr/include/c++/10.2.0/istream" 3
      __istream_type&
      operator>>(void*& __p)
      { return _M_extract(__p); }
# 258 "/usr/include/c++/10.2.0/istream" 3
      __istream_type&
      operator>>(__streambuf_type* __sb);
# 268 "/usr/include/c++/10.2.0/istream" 3
      streamsize
      gcount() const
      { return _M_gcount; }
# 301 "/usr/include/c++/10.2.0/istream" 3
      int_type
      get();
# 315 "/usr/include/c++/10.2.0/istream" 3
      __istream_type&
      get(char_type& __c);
# 342 "/usr/include/c++/10.2.0/istream" 3
      __istream_type&
      get(char_type* __s, streamsize __n, char_type __delim);
# 353 "/usr/include/c++/10.2.0/istream" 3
      __istream_type&
      get(char_type* __s, streamsize __n)
      { return this->get(__s, __n, this->widen('\n')); }
# 376 "/usr/include/c++/10.2.0/istream" 3
      __istream_type&
      get(__streambuf_type& __sb, char_type __delim);
# 386 "/usr/include/c++/10.2.0/istream" 3
      __istream_type&
      get(__streambuf_type& __sb)
      { return this->get(__sb, this->widen('\n')); }
# 415 "/usr/include/c++/10.2.0/istream" 3
      __istream_type&
      getline(char_type* __s, streamsize __n, char_type __delim);
# 426 "/usr/include/c++/10.2.0/istream" 3
      __istream_type&
      getline(char_type* __s, streamsize __n)
      { return this->getline(__s, __n, this->widen('\n')); }
# 450 "/usr/include/c++/10.2.0/istream" 3
      __istream_type&
      ignore(streamsize __n, int_type __delim);

      __istream_type&
      ignore(streamsize __n);

      __istream_type&
      ignore();
# 467 "/usr/include/c++/10.2.0/istream" 3
      int_type
      peek();
# 485 "/usr/include/c++/10.2.0/istream" 3
      __istream_type&
      read(char_type* __s, streamsize __n);
# 504 "/usr/include/c++/10.2.0/istream" 3
      streamsize
      readsome(char_type* __s, streamsize __n);
# 521 "/usr/include/c++/10.2.0/istream" 3
      __istream_type&
      putback(char_type __c);
# 537 "/usr/include/c++/10.2.0/istream" 3
      __istream_type&
      unget();
# 555 "/usr/include/c++/10.2.0/istream" 3
      int
      sync();
# 570 "/usr/include/c++/10.2.0/istream" 3
      pos_type
      tellg();
# 585 "/usr/include/c++/10.2.0/istream" 3
      __istream_type&
      seekg(pos_type);
# 601 "/usr/include/c++/10.2.0/istream" 3
      __istream_type&
      seekg(off_type, ios_base::seekdir);


    protected:
      basic_istream()
      : _M_gcount(streamsize(0))
      { this->init(0); }


      basic_istream(const basic_istream&) = delete;

      basic_istream(basic_istream&& __rhs)
      : __ios_type(), _M_gcount(__rhs._M_gcount)
      {
 __ios_type::move(__rhs);
 __rhs._M_gcount = 0;
      }



      basic_istream& operator=(const basic_istream&) = delete;

      basic_istream&
      operator=(basic_istream&& __rhs)
      {
 swap(__rhs);
 return *this;
      }

      void
      swap(basic_istream& __rhs)
      {
 __ios_type::swap(__rhs);
 std::swap(_M_gcount, __rhs._M_gcount);
      }


      template<typename _ValueT>
 __istream_type&
 _M_extract(_ValueT& __v);
    };


  template<>
    basic_istream<char>&
    basic_istream<char>::
    getline(char_type* __s, streamsize __n, char_type __delim);

  template<>
    basic_istream<char>&
    basic_istream<char>::
    ignore(streamsize __n);

  template<>
    basic_istream<char>&
    basic_istream<char>::
    ignore(streamsize __n, int_type __delim);


  template<>
    basic_istream<wchar_t>&
    basic_istream<wchar_t>::
    getline(char_type* __s, streamsize __n, char_type __delim);

  template<>
    basic_istream<wchar_t>&
    basic_istream<wchar_t>::
    ignore(streamsize __n);

  template<>
    basic_istream<wchar_t>&
    basic_istream<wchar_t>::
    ignore(streamsize __n, int_type __delim);
# 685 "/usr/include/c++/10.2.0/istream" 3
  template<typename _CharT, typename _Traits>
    class basic_istream<_CharT, _Traits>::sentry
    {

      bool _M_ok;

    public:

      typedef _Traits traits_type;
      typedef basic_streambuf<_CharT, _Traits> __streambuf_type;
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef typename __istream_type::__ctype_type __ctype_type;
      typedef typename _Traits::int_type __int_type;
# 721 "/usr/include/c++/10.2.0/istream" 3
      explicit
      sentry(basic_istream<_CharT, _Traits>& __is, bool __noskipws = false);
# 732 "/usr/include/c++/10.2.0/istream" 3
      explicit

      operator bool() const
      { return _M_ok; }
    };
# 750 "/usr/include/c++/10.2.0/istream" 3
  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __in, _CharT& __c);

  template<class _Traits>
    inline basic_istream<char, _Traits>&
    operator>>(basic_istream<char, _Traits>& __in, unsigned char& __c)
    { return (__in >> reinterpret_cast<char&>(__c)); }

  template<class _Traits>
    inline basic_istream<char, _Traits>&
    operator>>(basic_istream<char, _Traits>& __in, signed char& __c)
    { return (__in >> reinterpret_cast<char&>(__c)); }
# 792 "/usr/include/c++/10.2.0/istream" 3
  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __in, _CharT* __s);


  template<>
    basic_istream<char>&
    operator>>(basic_istream<char>& __in, char* __s);

  template<class _Traits>
    inline basic_istream<char, _Traits>&
    operator>>(basic_istream<char, _Traits>& __in, unsigned char* __s)
    { return (__in >> reinterpret_cast<char*>(__s)); }

  template<class _Traits>
    inline basic_istream<char, _Traits>&
    operator>>(basic_istream<char, _Traits>& __in, signed char* __s)
    { return (__in >> reinterpret_cast<char*>(__s)); }
# 823 "/usr/include/c++/10.2.0/istream" 3
  template<typename _CharT, typename _Traits>
    class basic_iostream
    : public basic_istream<_CharT, _Traits>,
      public basic_ostream<_CharT, _Traits>
    {
    public:



      typedef _CharT char_type;
      typedef typename _Traits::int_type int_type;
      typedef typename _Traits::pos_type pos_type;
      typedef typename _Traits::off_type off_type;
      typedef _Traits traits_type;


      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef basic_ostream<_CharT, _Traits> __ostream_type;







      explicit
      basic_iostream(basic_streambuf<_CharT, _Traits>* __sb)
      : __istream_type(__sb), __ostream_type(__sb) { }




      virtual
      ~basic_iostream() { }

    protected:
      basic_iostream()
      : __istream_type(), __ostream_type() { }


      basic_iostream(const basic_iostream&) = delete;

      basic_iostream(basic_iostream&& __rhs)
      : __istream_type(std::move(__rhs)), __ostream_type(*this)
      { }



      basic_iostream& operator=(const basic_iostream&) = delete;

      basic_iostream&
      operator=(basic_iostream&& __rhs)
      {
 swap(__rhs);
 return *this;
      }

      void
      swap(basic_iostream& __rhs)
      { __istream_type::swap(__rhs); }

    };
# 906 "/usr/include/c++/10.2.0/istream" 3
  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    ws(basic_istream<_CharT, _Traits>& __is);


  template<typename _Ch, typename _Up>
    basic_istream<_Ch, _Up>&
    __is_convertible_to_basic_istream_test(basic_istream<_Ch, _Up>*);

  template<typename _Tp, typename = void>
    struct __is_convertible_to_basic_istream_impl
    {
      using __istream_type = void;
    };

  template<typename _Tp>
    using __do_is_convertible_to_basic_istream_impl =
    decltype(__is_convertible_to_basic_istream_test
      (declval<typename remove_reference<_Tp>::type*>()));

  template<typename _Tp>
    struct __is_convertible_to_basic_istream_impl
    <_Tp,
     __void_t<__do_is_convertible_to_basic_istream_impl<_Tp>>>
    {
      using __istream_type =
 __do_is_convertible_to_basic_istream_impl<_Tp>;
    };

  template<typename _Tp>
    struct __is_convertible_to_basic_istream
    : __is_convertible_to_basic_istream_impl<_Tp>
    {
    public:
      using type = __not_<is_void<
        typename __is_convertible_to_basic_istream_impl<_Tp>::__istream_type>>;
      constexpr static bool value = type::value;
    };

  template<typename _Istream, typename _Tp, typename = void>
    struct __is_extractable : false_type {};

  template<typename _Istream, typename _Tp>
    struct __is_extractable<_Istream, _Tp,
       __void_t<decltype(declval<_Istream&>()
           >> declval<_Tp>())>>
    : true_type {};

  template<typename _Istream>
    using __rvalue_istream_type =
      typename __is_convertible_to_basic_istream<
 _Istream>::__istream_type;
# 972 "/usr/include/c++/10.2.0/istream" 3
  template<typename _Istream, typename _Tp>
    inline
    typename enable_if<__and_<__not_<is_lvalue_reference<_Istream>>,
         __is_convertible_to_basic_istream<_Istream>,
         __is_extractable<
    __rvalue_istream_type<_Istream>,
    _Tp&&>>::value,
         __rvalue_istream_type<_Istream>>::type
    operator>>(_Istream&& __is, _Tp&& __x)
    {
      __rvalue_istream_type<_Istream> __ret_is = __is;
      __ret_is >> std::forward<_Tp>(__x);
      return __ret_is;
    }



}

# 1 "/usr/include/c++/10.2.0/bits/istream.tcc" 1 3
# 37 "/usr/include/c++/10.2.0/bits/istream.tcc" 3
       
# 38 "/usr/include/c++/10.2.0/bits/istream.tcc" 3



namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>::sentry::
    sentry(basic_istream<_CharT, _Traits>& __in, bool __noskip) : _M_ok(false)
    {
      ios_base::iostate __err = ios_base::goodbit;
      if (__in.good())
 try
   {
     if (__in.tie())
       __in.tie()->flush();
     if (!__noskip && bool(__in.flags() & ios_base::skipws))
       {
  const __int_type __eof = traits_type::eof();
  __streambuf_type* __sb = __in.rdbuf();
  __int_type __c = __sb->sgetc();

  const __ctype_type& __ct = __check_facet(__in._M_ctype);
  while (!traits_type::eq_int_type(__c, __eof)
         && __ct.is(ctype_base::space,
      traits_type::to_char_type(__c)))
    __c = __sb->snextc();




  if (traits_type::eq_int_type(__c, __eof))
    __err |= ios_base::eofbit;
       }
   }
 catch(__cxxabiv1::__forced_unwind&)
   {
     __in._M_setstate(ios_base::badbit);
     throw;
   }
 catch(...)
   { __in._M_setstate(ios_base::badbit); }

      if (__in.good() && __err == ios_base::goodbit)
 _M_ok = true;
      else
 {
   __err |= ios_base::failbit;
   __in.setstate(__err);
 }
    }

  template<typename _CharT, typename _Traits>
    template<typename _ValueT>
      basic_istream<_CharT, _Traits>&
      basic_istream<_CharT, _Traits>::
      _M_extract(_ValueT& __v)
      {
 sentry __cerb(*this, false);
 if (__cerb)
   {
     ios_base::iostate __err = ios_base::goodbit;
     try
       {
  const __num_get_type& __ng = __check_facet(this->_M_num_get);
  __ng.get(*this, 0, *this, __err, __v);
       }
     catch(__cxxabiv1::__forced_unwind&)
       {
  this->_M_setstate(ios_base::badbit);
  throw;
       }
     catch(...)
       { this->_M_setstate(ios_base::badbit); }
     if (__err)
       this->setstate(__err);
   }
 return *this;
      }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    operator>>(short& __n)
    {


      sentry __cerb(*this, false);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       long __l;
       const __num_get_type& __ng = __check_facet(this->_M_num_get);
       __ng.get(*this, 0, *this, __err, __l);



       if (__l < __gnu_cxx::__numeric_traits<short>::__min)
  {
    __err |= ios_base::failbit;
    __n = __gnu_cxx::__numeric_traits<short>::__min;
  }
       else if (__l > __gnu_cxx::__numeric_traits<short>::__max)
  {
    __err |= ios_base::failbit;
    __n = __gnu_cxx::__numeric_traits<short>::__max;
  }
       else
  __n = short(__l);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    operator>>(int& __n)
    {


      sentry __cerb(*this, false);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       long __l;
       const __num_get_type& __ng = __check_facet(this->_M_num_get);
       __ng.get(*this, 0, *this, __err, __l);



       if (__l < __gnu_cxx::__numeric_traits<int>::__min)
  {
    __err |= ios_base::failbit;
    __n = __gnu_cxx::__numeric_traits<int>::__min;
  }
       else if (__l > __gnu_cxx::__numeric_traits<int>::__max)
  {
    __err |= ios_base::failbit;
    __n = __gnu_cxx::__numeric_traits<int>::__max;
  }
       else
  __n = int(__l);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    operator>>(__streambuf_type* __sbout)
    {
      ios_base::iostate __err = ios_base::goodbit;
      sentry __cerb(*this, false);
      if (__cerb && __sbout)
 {
   try
     {
       bool __ineof;
       if (!__copy_streambufs_eof(this->rdbuf(), __sbout, __ineof))
  __err |= ios_base::failbit;
       if (__ineof)
  __err |= ios_base::eofbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::failbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::failbit); }
 }
      else if (!__sbout)
 __err |= ios_base::failbit;
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    typename basic_istream<_CharT, _Traits>::int_type
    basic_istream<_CharT, _Traits>::
    get(void)
    {
      const int_type __eof = traits_type::eof();
      int_type __c = __eof;
      _M_gcount = 0;
      ios_base::iostate __err = ios_base::goodbit;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   try
     {
       __c = this->rdbuf()->sbumpc();

       if (!traits_type::eq_int_type(__c, __eof))
  _M_gcount = 1;
       else
  __err |= ios_base::eofbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
 }
      if (!_M_gcount)
 __err |= ios_base::failbit;
      if (__err)
 this->setstate(__err);
      return __c;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    get(char_type& __c)
    {
      _M_gcount = 0;
      ios_base::iostate __err = ios_base::goodbit;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   try
     {
       const int_type __cb = this->rdbuf()->sbumpc();

       if (!traits_type::eq_int_type(__cb, traits_type::eof()))
  {
    _M_gcount = 1;
    __c = traits_type::to_char_type(__cb);
  }
       else
  __err |= ios_base::eofbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
 }
      if (!_M_gcount)
 __err |= ios_base::failbit;
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    get(char_type* __s, streamsize __n, char_type __delim)
    {
      _M_gcount = 0;
      ios_base::iostate __err = ios_base::goodbit;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   try
     {
       const int_type __idelim = traits_type::to_int_type(__delim);
       const int_type __eof = traits_type::eof();
       __streambuf_type* __sb = this->rdbuf();
       int_type __c = __sb->sgetc();

       while (_M_gcount + 1 < __n
       && !traits_type::eq_int_type(__c, __eof)
       && !traits_type::eq_int_type(__c, __idelim))
  {
    *__s++ = traits_type::to_char_type(__c);
    ++_M_gcount;
    __c = __sb->snextc();
  }
       if (traits_type::eq_int_type(__c, __eof))
  __err |= ios_base::eofbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
 }


      if (__n > 0)
 *__s = char_type();
      if (!_M_gcount)
 __err |= ios_base::failbit;
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    get(__streambuf_type& __sb, char_type __delim)
    {
      _M_gcount = 0;
      ios_base::iostate __err = ios_base::goodbit;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   try
     {
       const int_type __idelim = traits_type::to_int_type(__delim);
       const int_type __eof = traits_type::eof();
       __streambuf_type* __this_sb = this->rdbuf();
       int_type __c = __this_sb->sgetc();
       char_type __c2 = traits_type::to_char_type(__c);

       while (!traits_type::eq_int_type(__c, __eof)
       && !traits_type::eq_int_type(__c, __idelim)
       && !traits_type::eq_int_type(__sb.sputc(__c2), __eof))
  {
    ++_M_gcount;
    __c = __this_sb->snextc();
    __c2 = traits_type::to_char_type(__c);
  }
       if (traits_type::eq_int_type(__c, __eof))
  __err |= ios_base::eofbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
 }
      if (!_M_gcount)
 __err |= ios_base::failbit;
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    getline(char_type* __s, streamsize __n, char_type __delim)
    {
      _M_gcount = 0;
      ios_base::iostate __err = ios_base::goodbit;
      sentry __cerb(*this, true);
      if (__cerb)
        {
          try
            {
              const int_type __idelim = traits_type::to_int_type(__delim);
              const int_type __eof = traits_type::eof();
              __streambuf_type* __sb = this->rdbuf();
              int_type __c = __sb->sgetc();

              while (_M_gcount + 1 < __n
                     && !traits_type::eq_int_type(__c, __eof)
                     && !traits_type::eq_int_type(__c, __idelim))
                {
                  *__s++ = traits_type::to_char_type(__c);
                  __c = __sb->snextc();
                  ++_M_gcount;
                }
              if (traits_type::eq_int_type(__c, __eof))
                __err |= ios_base::eofbit;
              else
                {
                  if (traits_type::eq_int_type(__c, __idelim))
                    {
                      __sb->sbumpc();
                      ++_M_gcount;
                    }
                  else
                    __err |= ios_base::failbit;
                }
            }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
          catch(...)
            { this->_M_setstate(ios_base::badbit); }
        }


      if (__n > 0)
 *__s = char_type();
      if (!_M_gcount)
        __err |= ios_base::failbit;
      if (__err)
        this->setstate(__err);
      return *this;
    }




  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    ignore(void)
    {
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       const int_type __eof = traits_type::eof();
       __streambuf_type* __sb = this->rdbuf();

       if (traits_type::eq_int_type(__sb->sbumpc(), __eof))
  __err |= ios_base::eofbit;
       else
  _M_gcount = 1;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    ignore(streamsize __n)
    {
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb && __n > 0)
        {
          ios_base::iostate __err = ios_base::goodbit;
          try
            {
              const int_type __eof = traits_type::eof();
              __streambuf_type* __sb = this->rdbuf();
              int_type __c = __sb->sgetc();
# 521 "/usr/include/c++/10.2.0/bits/istream.tcc" 3
       bool __large_ignore = false;
       while (true)
  {
    while (_M_gcount < __n
    && !traits_type::eq_int_type(__c, __eof))
      {
        ++_M_gcount;
        __c = __sb->snextc();
      }
    if (__n == __gnu_cxx::__numeric_traits<streamsize>::__max
        && !traits_type::eq_int_type(__c, __eof))
      {
        _M_gcount =
   __gnu_cxx::__numeric_traits<streamsize>::__min;
        __large_ignore = true;
      }
    else
      break;
  }

       if (__large_ignore)
  _M_gcount = __gnu_cxx::__numeric_traits<streamsize>::__max;

       if (traits_type::eq_int_type(__c, __eof))
                __err |= ios_base::eofbit;
            }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
          catch(...)
            { this->_M_setstate(ios_base::badbit); }
          if (__err)
            this->setstate(__err);
        }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    ignore(streamsize __n, int_type __delim)
    {
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb && __n > 0)
        {
          ios_base::iostate __err = ios_base::goodbit;
          try
            {
              const int_type __eof = traits_type::eof();
              __streambuf_type* __sb = this->rdbuf();
              int_type __c = __sb->sgetc();


       bool __large_ignore = false;
       while (true)
  {
    while (_M_gcount < __n
    && !traits_type::eq_int_type(__c, __eof)
    && !traits_type::eq_int_type(__c, __delim))
      {
        ++_M_gcount;
        __c = __sb->snextc();
      }
    if (__n == __gnu_cxx::__numeric_traits<streamsize>::__max
        && !traits_type::eq_int_type(__c, __eof)
        && !traits_type::eq_int_type(__c, __delim))
      {
        _M_gcount =
   __gnu_cxx::__numeric_traits<streamsize>::__min;
        __large_ignore = true;
      }
    else
      break;
  }

       if (__large_ignore)
  _M_gcount = __gnu_cxx::__numeric_traits<streamsize>::__max;

              if (traits_type::eq_int_type(__c, __eof))
                __err |= ios_base::eofbit;
       else if (traits_type::eq_int_type(__c, __delim))
  {
    if (_M_gcount
        < __gnu_cxx::__numeric_traits<streamsize>::__max)
      ++_M_gcount;
    __sb->sbumpc();
  }
            }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
          catch(...)
            { this->_M_setstate(ios_base::badbit); }
          if (__err)
            this->setstate(__err);
        }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    typename basic_istream<_CharT, _Traits>::int_type
    basic_istream<_CharT, _Traits>::
    peek(void)
    {
      int_type __c = traits_type::eof();
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       __c = this->rdbuf()->sgetc();
       if (traits_type::eq_int_type(__c, traits_type::eof()))
  __err |= ios_base::eofbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return __c;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    read(char_type* __s, streamsize __n)
    {
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       _M_gcount = this->rdbuf()->sgetn(__s, __n);
       if (_M_gcount != __n)
  __err |= (ios_base::eofbit | ios_base::failbit);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    streamsize
    basic_istream<_CharT, _Traits>::
    readsome(char_type* __s, streamsize __n)
    {
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {

       const streamsize __num = this->rdbuf()->in_avail();
       if (__num > 0)
  _M_gcount = this->rdbuf()->sgetn(__s, std::min(__num, __n));
       else if (__num == -1)
  __err |= ios_base::eofbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return _M_gcount;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    putback(char_type __c)
    {


      _M_gcount = 0;

      this->clear(this->rdstate() & ~ios_base::eofbit);
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       const int_type __eof = traits_type::eof();
       __streambuf_type* __sb = this->rdbuf();
       if (!__sb
    || traits_type::eq_int_type(__sb->sputbackc(__c), __eof))
  __err |= ios_base::badbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    unget(void)
    {


      _M_gcount = 0;

      this->clear(this->rdstate() & ~ios_base::eofbit);
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       const int_type __eof = traits_type::eof();
       __streambuf_type* __sb = this->rdbuf();
       if (!__sb
    || traits_type::eq_int_type(__sb->sungetc(), __eof))
  __err |= ios_base::badbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    int
    basic_istream<_CharT, _Traits>::
    sync(void)
    {


      int __ret = -1;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       __streambuf_type* __sb = this->rdbuf();
       if (__sb)
  {
    if (__sb->pubsync() == -1)
      __err |= ios_base::badbit;
    else
      __ret = 0;
  }
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    typename basic_istream<_CharT, _Traits>::pos_type
    basic_istream<_CharT, _Traits>::
    tellg(void)
    {


      pos_type __ret = pos_type(-1);
      sentry __cerb(*this, true);
      if (__cerb)
 {
   try
     {
       if (!this->fail())
  __ret = this->rdbuf()->pubseekoff(0, ios_base::cur,
        ios_base::in);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    seekg(pos_type __pos)
    {



      this->clear(this->rdstate() & ~ios_base::eofbit);
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       if (!this->fail())
  {

    const pos_type __p = this->rdbuf()->pubseekpos(__pos,
         ios_base::in);


    if (__p == pos_type(off_type(-1)))
      __err |= ios_base::failbit;
  }
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    seekg(off_type __off, ios_base::seekdir __dir)
    {



      this->clear(this->rdstate() & ~ios_base::eofbit);
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       if (!this->fail())
  {

    const pos_type __p = this->rdbuf()->pubseekoff(__off, __dir,
         ios_base::in);


    if (__p == pos_type(off_type(-1)))
      __err |= ios_base::failbit;
  }
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }


  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __in, _CharT& __c)
    {
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef typename __istream_type::int_type __int_type;

      typename __istream_type::sentry __cerb(__in, false);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       const __int_type __cb = __in.rdbuf()->sbumpc();
       if (!_Traits::eq_int_type(__cb, _Traits::eof()))
  __c = _Traits::to_char_type(__cb);
       else
  __err |= (ios_base::eofbit | ios_base::failbit);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       __in._M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { __in._M_setstate(ios_base::badbit); }
   if (__err)
     __in.setstate(__err);
 }
      return __in;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __in, _CharT* __s)
    {
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef basic_streambuf<_CharT, _Traits> __streambuf_type;
      typedef typename _Traits::int_type int_type;
      typedef _CharT char_type;
      typedef ctype<_CharT> __ctype_type;

      streamsize __extracted = 0;
      ios_base::iostate __err = ios_base::goodbit;
      typename __istream_type::sentry __cerb(__in, false);
      if (__cerb)
 {
   try
     {

       streamsize __num = __in.width();
       if (__num <= 0)
  __num = __gnu_cxx::__numeric_traits<streamsize>::__max;

       const __ctype_type& __ct = use_facet<__ctype_type>(__in.getloc());

       const int_type __eof = _Traits::eof();
       __streambuf_type* __sb = __in.rdbuf();
       int_type __c = __sb->sgetc();

       while (__extracted < __num - 1
       && !_Traits::eq_int_type(__c, __eof)
       && !__ct.is(ctype_base::space,
     _Traits::to_char_type(__c)))
  {
    *__s++ = _Traits::to_char_type(__c);
    ++__extracted;
    __c = __sb->snextc();
  }
       if (_Traits::eq_int_type(__c, __eof))
  __err |= ios_base::eofbit;



       *__s = char_type();
       __in.width(0);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       __in._M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { __in._M_setstate(ios_base::badbit); }
 }
      if (!__extracted)
 __err |= ios_base::failbit;
      if (__err)
 __in.setstate(__err);
      return __in;
    }


  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    ws(basic_istream<_CharT, _Traits>& __in)
    {
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef basic_streambuf<_CharT, _Traits> __streambuf_type;
      typedef typename __istream_type::int_type __int_type;
      typedef ctype<_CharT> __ctype_type;

      const __ctype_type& __ct = use_facet<__ctype_type>(__in.getloc());
      const __int_type __eof = _Traits::eof();
      __streambuf_type* __sb = __in.rdbuf();
      __int_type __c = __sb->sgetc();

      while (!_Traits::eq_int_type(__c, __eof)
      && __ct.is(ctype_base::space, _Traits::to_char_type(__c)))
 __c = __sb->snextc();

       if (_Traits::eq_int_type(__c, __eof))
  __in.setstate(ios_base::eofbit);
      return __in;
    }




  extern template class basic_istream<char>;
  extern template istream& ws(istream&);
  extern template istream& operator>>(istream&, char&);
  extern template istream& operator>>(istream&, char*);
  extern template istream& operator>>(istream&, unsigned char&);
  extern template istream& operator>>(istream&, signed char&);
  extern template istream& operator>>(istream&, unsigned char*);
  extern template istream& operator>>(istream&, signed char*);

  extern template istream& istream::_M_extract(unsigned short&);
  extern template istream& istream::_M_extract(unsigned int&);
  extern template istream& istream::_M_extract(long&);
  extern template istream& istream::_M_extract(unsigned long&);
  extern template istream& istream::_M_extract(bool&);

  extern template istream& istream::_M_extract(long long&);
  extern template istream& istream::_M_extract(unsigned long long&);

  extern template istream& istream::_M_extract(float&);
  extern template istream& istream::_M_extract(double&);
  extern template istream& istream::_M_extract(long double&);
  extern template istream& istream::_M_extract(void*&);

  extern template class basic_iostream<char>;


  extern template class basic_istream<wchar_t>;
  extern template wistream& ws(wistream&);
  extern template wistream& operator>>(wistream&, wchar_t&);
  extern template wistream& operator>>(wistream&, wchar_t*);

  extern template wistream& wistream::_M_extract(unsigned short&);
  extern template wistream& wistream::_M_extract(unsigned int&);
  extern template wistream& wistream::_M_extract(long&);
  extern template wistream& wistream::_M_extract(unsigned long&);
  extern template wistream& wistream::_M_extract(bool&);

  extern template wistream& wistream::_M_extract(long long&);
  extern template wistream& wistream::_M_extract(unsigned long long&);

  extern template wistream& wistream::_M_extract(float&);
  extern template wistream& wistream::_M_extract(double&);
  extern template wistream& wistream::_M_extract(long double&);
  extern template wistream& wistream::_M_extract(void*&);

  extern template class basic_iostream<wchar_t>;




}
# 992 "/usr/include/c++/10.2.0/istream" 2 3
# 11 "/usr/include/json/config.h" 2 3 4
# 1 "/usr/include/c++/10.2.0/memory" 1 3 4
# 47 "/usr/include/c++/10.2.0/memory" 3 4
       
# 48 "/usr/include/c++/10.2.0/memory" 3
# 66 "/usr/include/c++/10.2.0/memory" 3
# 1 "/usr/include/c++/10.2.0/bits/stl_uninitialized.h" 1 3
# 69 "/usr/include/c++/10.2.0/bits/stl_uninitialized.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{








  template<bool _TrivialValueTypes>
    struct __uninitialized_copy
    {
      template<typename _InputIterator, typename _ForwardIterator>
        static _ForwardIterator
        __uninit_copy(_InputIterator __first, _InputIterator __last,
        _ForwardIterator __result)
        {
   _ForwardIterator __cur = __result;
   try
     {
       for (; __first != __last; ++__first, (void)++__cur)
  std::_Construct(std::__addressof(*__cur), *__first);
       return __cur;
     }
   catch(...)
     {
       std::_Destroy(__result, __cur);
       throw;
     }
 }
    };

  template<>
    struct __uninitialized_copy<true>
    {
      template<typename _InputIterator, typename _ForwardIterator>
        static _ForwardIterator
        __uninit_copy(_InputIterator __first, _InputIterator __last,
        _ForwardIterator __result)
        { return std::copy(__first, __last, __result); }
    };
# 123 "/usr/include/c++/10.2.0/bits/stl_uninitialized.h" 3
  template<typename _InputIterator, typename _ForwardIterator>
    inline _ForwardIterator
    uninitialized_copy(_InputIterator __first, _InputIterator __last,
         _ForwardIterator __result)
    {
      typedef typename iterator_traits<_InputIterator>::value_type
 _ValueType1;
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType2;





      static_assert(is_constructible<_ValueType2, decltype(*__first)>::value,
   "result type must be constructible from value type of input range");

      typedef typename iterator_traits<_InputIterator>::reference _RefType1;
      typedef typename iterator_traits<_ForwardIterator>::reference _RefType2;


      const bool __assignable = is_assignable<_RefType2, _RefType1>::value;


      return std::__uninitialized_copy<__is_trivial(_ValueType1)
           && __is_trivial(_ValueType2)
           && __assignable>::
 __uninit_copy(__first, __last, __result);
    }



  template<bool _TrivialValueType>
    struct __uninitialized_fill
    {
      template<typename _ForwardIterator, typename _Tp>
        static void
        __uninit_fill(_ForwardIterator __first, _ForwardIterator __last,
        const _Tp& __x)
        {
   _ForwardIterator __cur = __first;
   try
     {
       for (; __cur != __last; ++__cur)
  std::_Construct(std::__addressof(*__cur), __x);
     }
   catch(...)
     {
       std::_Destroy(__first, __cur);
       throw;
     }
 }
    };

  template<>
    struct __uninitialized_fill<true>
    {
      template<typename _ForwardIterator, typename _Tp>
        static void
        __uninit_fill(_ForwardIterator __first, _ForwardIterator __last,
        const _Tp& __x)
        { std::fill(__first, __last, __x); }
    };
# 198 "/usr/include/c++/10.2.0/bits/stl_uninitialized.h" 3
  template<typename _ForwardIterator, typename _Tp>
    inline void
    uninitialized_fill(_ForwardIterator __first, _ForwardIterator __last,
         const _Tp& __x)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;





      static_assert(is_constructible<_ValueType, const _Tp&>::value,
   "result type must be constructible from input type");



      const bool __assignable = is_copy_assignable<_ValueType>::value;


      std::__uninitialized_fill<__is_trivial(_ValueType) && __assignable>::
 __uninit_fill(__first, __last, __x);
    }



  template<bool _TrivialValueType>
    struct __uninitialized_fill_n
    {
      template<typename _ForwardIterator, typename _Size, typename _Tp>
        static _ForwardIterator
        __uninit_fill_n(_ForwardIterator __first, _Size __n,
   const _Tp& __x)
        {
   _ForwardIterator __cur = __first;
   try
     {
       for (; __n > 0; --__n, (void) ++__cur)
  std::_Construct(std::__addressof(*__cur), __x);
       return __cur;
     }
   catch(...)
     {
       std::_Destroy(__first, __cur);
       throw;
     }
 }
    };

  template<>
    struct __uninitialized_fill_n<true>
    {
      template<typename _ForwardIterator, typename _Size, typename _Tp>
        static _ForwardIterator
        __uninit_fill_n(_ForwardIterator __first, _Size __n,
   const _Tp& __x)
        { return std::fill_n(__first, __n, __x); }
    };
# 270 "/usr/include/c++/10.2.0/bits/stl_uninitialized.h" 3
  template<typename _ForwardIterator, typename _Size, typename _Tp>
    inline _ForwardIterator
    uninitialized_fill_n(_ForwardIterator __first, _Size __n, const _Tp& __x)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;





      static_assert(is_constructible<_ValueType, const _Tp&>::value,
   "result type must be constructible from input type");



      const bool __assignable = is_copy_assignable<_ValueType>::value;

      return __uninitialized_fill_n<__is_trivial(_ValueType) && __assignable>::
 __uninit_fill_n(__first, __n, __x);
    }
# 300 "/usr/include/c++/10.2.0/bits/stl_uninitialized.h" 3
  template<typename _InputIterator, typename _ForwardIterator,
    typename _Allocator>
    _ForwardIterator
    __uninitialized_copy_a(_InputIterator __first, _InputIterator __last,
      _ForwardIterator __result, _Allocator& __alloc)
    {
      _ForwardIterator __cur = __result;
      try
 {
   typedef __gnu_cxx::__alloc_traits<_Allocator> __traits;
   for (; __first != __last; ++__first, (void)++__cur)
     __traits::construct(__alloc, std::__addressof(*__cur), *__first);
   return __cur;
 }
      catch(...)
 {
   std::_Destroy(__result, __cur, __alloc);
   throw;
 }
    }

  template<typename _InputIterator, typename _ForwardIterator, typename _Tp>
    inline _ForwardIterator
    __uninitialized_copy_a(_InputIterator __first, _InputIterator __last,
      _ForwardIterator __result, allocator<_Tp>&)
    { return std::uninitialized_copy(__first, __last, __result); }

  template<typename _InputIterator, typename _ForwardIterator,
    typename _Allocator>
    inline _ForwardIterator
    __uninitialized_move_a(_InputIterator __first, _InputIterator __last,
      _ForwardIterator __result, _Allocator& __alloc)
    {
      return std::__uninitialized_copy_a(std::make_move_iterator(__first),
      std::make_move_iterator(__last),
      __result, __alloc);
    }

  template<typename _InputIterator, typename _ForwardIterator,
    typename _Allocator>
    inline _ForwardIterator
    __uninitialized_move_if_noexcept_a(_InputIterator __first,
           _InputIterator __last,
           _ForwardIterator __result,
           _Allocator& __alloc)
    {
      return std::__uninitialized_copy_a
 (std::__make_move_if_noexcept_iterator(__first),
  std::__make_move_if_noexcept_iterator(__last), __result, __alloc);
    }

  template<typename _ForwardIterator, typename _Tp, typename _Allocator>
    void
    __uninitialized_fill_a(_ForwardIterator __first, _ForwardIterator __last,
      const _Tp& __x, _Allocator& __alloc)
    {
      _ForwardIterator __cur = __first;
      try
 {
   typedef __gnu_cxx::__alloc_traits<_Allocator> __traits;
   for (; __cur != __last; ++__cur)
     __traits::construct(__alloc, std::__addressof(*__cur), __x);
 }
      catch(...)
 {
   std::_Destroy(__first, __cur, __alloc);
   throw;
 }
    }

  template<typename _ForwardIterator, typename _Tp, typename _Tp2>
    inline void
    __uninitialized_fill_a(_ForwardIterator __first, _ForwardIterator __last,
      const _Tp& __x, allocator<_Tp2>&)
    { std::uninitialized_fill(__first, __last, __x); }

  template<typename _ForwardIterator, typename _Size, typename _Tp,
    typename _Allocator>
    _ForwardIterator
    __uninitialized_fill_n_a(_ForwardIterator __first, _Size __n,
        const _Tp& __x, _Allocator& __alloc)
    {
      _ForwardIterator __cur = __first;
      try
 {
   typedef __gnu_cxx::__alloc_traits<_Allocator> __traits;
   for (; __n > 0; --__n, (void) ++__cur)
     __traits::construct(__alloc, std::__addressof(*__cur), __x);
   return __cur;
 }
      catch(...)
 {
   std::_Destroy(__first, __cur, __alloc);
   throw;
 }
    }

  template<typename _ForwardIterator, typename _Size, typename _Tp,
    typename _Tp2>
    inline _ForwardIterator
    __uninitialized_fill_n_a(_ForwardIterator __first, _Size __n,
        const _Tp& __x, allocator<_Tp2>&)
    { return std::uninitialized_fill_n(__first, __n, __x); }
# 414 "/usr/include/c++/10.2.0/bits/stl_uninitialized.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _ForwardIterator, typename _Allocator>
    inline _ForwardIterator
    __uninitialized_copy_move(_InputIterator1 __first1,
         _InputIterator1 __last1,
         _InputIterator2 __first2,
         _InputIterator2 __last2,
         _ForwardIterator __result,
         _Allocator& __alloc)
    {
      _ForwardIterator __mid = std::__uninitialized_copy_a(__first1, __last1,
          __result,
          __alloc);
      try
 {
   return std::__uninitialized_move_a(__first2, __last2, __mid, __alloc);
 }
      catch(...)
 {
   std::_Destroy(__result, __mid, __alloc);
   throw;
 }
    }





  template<typename _InputIterator1, typename _InputIterator2,
    typename _ForwardIterator, typename _Allocator>
    inline _ForwardIterator
    __uninitialized_move_copy(_InputIterator1 __first1,
         _InputIterator1 __last1,
         _InputIterator2 __first2,
         _InputIterator2 __last2,
         _ForwardIterator __result,
         _Allocator& __alloc)
    {
      _ForwardIterator __mid = std::__uninitialized_move_a(__first1, __last1,
          __result,
          __alloc);
      try
 {
   return std::__uninitialized_copy_a(__first2, __last2, __mid, __alloc);
 }
      catch(...)
 {
   std::_Destroy(__result, __mid, __alloc);
   throw;
 }
    }




  template<typename _ForwardIterator, typename _Tp, typename _InputIterator,
    typename _Allocator>
    inline _ForwardIterator
    __uninitialized_fill_move(_ForwardIterator __result, _ForwardIterator __mid,
         const _Tp& __x, _InputIterator __first,
         _InputIterator __last, _Allocator& __alloc)
    {
      std::__uninitialized_fill_a(__result, __mid, __x, __alloc);
      try
 {
   return std::__uninitialized_move_a(__first, __last, __mid, __alloc);
 }
      catch(...)
 {
   std::_Destroy(__result, __mid, __alloc);
   throw;
 }
    }




  template<typename _InputIterator, typename _ForwardIterator, typename _Tp,
    typename _Allocator>
    inline void
    __uninitialized_move_fill(_InputIterator __first1, _InputIterator __last1,
         _ForwardIterator __first2,
         _ForwardIterator __last2, const _Tp& __x,
         _Allocator& __alloc)
    {
      _ForwardIterator __mid2 = std::__uninitialized_move_a(__first1, __last1,
           __first2,
           __alloc);
      try
 {
   std::__uninitialized_fill_a(__mid2, __last2, __x, __alloc);
 }
      catch(...)
 {
   std::_Destroy(__first2, __mid2, __alloc);
   throw;
 }
    }
# 521 "/usr/include/c++/10.2.0/bits/stl_uninitialized.h" 3
  template<bool _TrivialValueType>
    struct __uninitialized_default_1
    {
      template<typename _ForwardIterator>
        static void
        __uninit_default(_ForwardIterator __first, _ForwardIterator __last)
        {
   _ForwardIterator __cur = __first;
   try
     {
       for (; __cur != __last; ++__cur)
  std::_Construct(std::__addressof(*__cur));
     }
   catch(...)
     {
       std::_Destroy(__first, __cur);
       throw;
     }
 }
    };

  template<>
    struct __uninitialized_default_1<true>
    {
      template<typename _ForwardIterator>
        static void
        __uninit_default(_ForwardIterator __first, _ForwardIterator __last)
        {
   typedef typename iterator_traits<_ForwardIterator>::value_type
     _ValueType;

   std::fill(__first, __last, _ValueType());
 }
    };

  template<bool _TrivialValueType>
    struct __uninitialized_default_n_1
    {
      template<typename _ForwardIterator, typename _Size>
        static _ForwardIterator
        __uninit_default_n(_ForwardIterator __first, _Size __n)
        {
   _ForwardIterator __cur = __first;
   try
     {
       for (; __n > 0; --__n, (void) ++__cur)
  std::_Construct(std::__addressof(*__cur));
       return __cur;
     }
   catch(...)
     {
       std::_Destroy(__first, __cur);
       throw;
     }
 }
    };

  template<>
    struct __uninitialized_default_n_1<true>
    {
      template<typename _ForwardIterator, typename _Size>
        static _ForwardIterator
        __uninit_default_n(_ForwardIterator __first, _Size __n)
        {
   typedef typename iterator_traits<_ForwardIterator>::value_type
     _ValueType;

   return std::fill_n(__first, __n, _ValueType());
 }
    };




  template<typename _ForwardIterator>
    inline void
    __uninitialized_default(_ForwardIterator __first,
       _ForwardIterator __last)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;

      const bool __assignable = is_copy_assignable<_ValueType>::value;

      std::__uninitialized_default_1<__is_trivial(_ValueType)
         && __assignable>::
 __uninit_default(__first, __last);
    }



  template<typename _ForwardIterator, typename _Size>
    inline _ForwardIterator
    __uninitialized_default_n(_ForwardIterator __first, _Size __n)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;

      const bool __assignable = is_copy_assignable<_ValueType>::value;

      return __uninitialized_default_n_1<__is_trivial(_ValueType)
           && __assignable>::
 __uninit_default_n(__first, __n);
    }





  template<typename _ForwardIterator, typename _Allocator>
    void
    __uninitialized_default_a(_ForwardIterator __first,
         _ForwardIterator __last,
         _Allocator& __alloc)
    {
      _ForwardIterator __cur = __first;
      try
 {
   typedef __gnu_cxx::__alloc_traits<_Allocator> __traits;
   for (; __cur != __last; ++__cur)
     __traits::construct(__alloc, std::__addressof(*__cur));
 }
      catch(...)
 {
   std::_Destroy(__first, __cur, __alloc);
   throw;
 }
    }

  template<typename _ForwardIterator, typename _Tp>
    inline void
    __uninitialized_default_a(_ForwardIterator __first,
         _ForwardIterator __last,
         allocator<_Tp>&)
    { std::__uninitialized_default(__first, __last); }





  template<typename _ForwardIterator, typename _Size, typename _Allocator>
    _ForwardIterator
    __uninitialized_default_n_a(_ForwardIterator __first, _Size __n,
    _Allocator& __alloc)
    {
      _ForwardIterator __cur = __first;
      try
 {
   typedef __gnu_cxx::__alloc_traits<_Allocator> __traits;
   for (; __n > 0; --__n, (void) ++__cur)
     __traits::construct(__alloc, std::__addressof(*__cur));
   return __cur;
 }
      catch(...)
 {
   std::_Destroy(__first, __cur, __alloc);
   throw;
 }
    }

  template<typename _ForwardIterator, typename _Size, typename _Tp>
    inline _ForwardIterator
    __uninitialized_default_n_a(_ForwardIterator __first, _Size __n,
    allocator<_Tp>&)
    { return std::__uninitialized_default_n(__first, __n); }

  template<bool _TrivialValueType>
    struct __uninitialized_default_novalue_1
    {
      template<typename _ForwardIterator>
 static void
 __uninit_default_novalue(_ForwardIterator __first,
     _ForwardIterator __last)
 {
   _ForwardIterator __cur = __first;
   try
     {
       for (; __cur != __last; ++__cur)
  std::_Construct_novalue(std::__addressof(*__cur));
     }
   catch(...)
     {
       std::_Destroy(__first, __cur);
       throw;
     }
 }
    };

  template<>
    struct __uninitialized_default_novalue_1<true>
    {
      template<typename _ForwardIterator>
        static void
        __uninit_default_novalue(_ForwardIterator __first,
     _ForwardIterator __last)
 {
 }
    };

  template<bool _TrivialValueType>
    struct __uninitialized_default_novalue_n_1
    {
      template<typename _ForwardIterator, typename _Size>
 static _ForwardIterator
 __uninit_default_novalue_n(_ForwardIterator __first, _Size __n)
 {
   _ForwardIterator __cur = __first;
   try
     {
       for (; __n > 0; --__n, (void) ++__cur)
  std::_Construct_novalue(std::__addressof(*__cur));
       return __cur;
     }
   catch(...)
     {
       std::_Destroy(__first, __cur);
       throw;
     }
 }
    };

  template<>
    struct __uninitialized_default_novalue_n_1<true>
    {
      template<typename _ForwardIterator, typename _Size>
 static _ForwardIterator
 __uninit_default_novalue_n(_ForwardIterator __first, _Size __n)
 { return std::next(__first, __n); }
    };




  template<typename _ForwardIterator>
    inline void
    __uninitialized_default_novalue(_ForwardIterator __first,
        _ForwardIterator __last)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;

      std::__uninitialized_default_novalue_1<
 is_trivially_default_constructible<_ValueType>::value>::
 __uninit_default_novalue(__first, __last);
    }



  template<typename _ForwardIterator, typename _Size>
    inline _ForwardIterator
    __uninitialized_default_novalue_n(_ForwardIterator __first, _Size __n)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;

      return __uninitialized_default_novalue_n_1<
 is_trivially_default_constructible<_ValueType>::value>::
 __uninit_default_novalue_n(__first, __n);
    }

  template<typename _InputIterator, typename _Size,
    typename _ForwardIterator>
    _ForwardIterator
    __uninitialized_copy_n(_InputIterator __first, _Size __n,
      _ForwardIterator __result, input_iterator_tag)
    {
      _ForwardIterator __cur = __result;
      try
 {
   for (; __n > 0; --__n, (void) ++__first, ++__cur)
     std::_Construct(std::__addressof(*__cur), *__first);
   return __cur;
 }
      catch(...)
 {
   std::_Destroy(__result, __cur);
   throw;
 }
    }

  template<typename _RandomAccessIterator, typename _Size,
    typename _ForwardIterator>
    inline _ForwardIterator
    __uninitialized_copy_n(_RandomAccessIterator __first, _Size __n,
      _ForwardIterator __result,
      random_access_iterator_tag)
    { return std::uninitialized_copy(__first, __first + __n, __result); }

  template<typename _InputIterator, typename _Size,
    typename _ForwardIterator>
    pair<_InputIterator, _ForwardIterator>
    __uninitialized_copy_n_pair(_InputIterator __first, _Size __n,
      _ForwardIterator __result, input_iterator_tag)
    {
      _ForwardIterator __cur = __result;
      try
 {
   for (; __n > 0; --__n, (void) ++__first, ++__cur)
     std::_Construct(std::__addressof(*__cur), *__first);
   return {__first, __cur};
 }
      catch(...)
 {
   std::_Destroy(__result, __cur);
   throw;
 }
    }

  template<typename _RandomAccessIterator, typename _Size,
    typename _ForwardIterator>
    inline pair<_RandomAccessIterator, _ForwardIterator>
    __uninitialized_copy_n_pair(_RandomAccessIterator __first, _Size __n,
      _ForwardIterator __result,
      random_access_iterator_tag)
    {
      auto __second_res = uninitialized_copy(__first, __first + __n, __result);
      auto __first_res = std::next(__first, __n);
      return {__first_res, __second_res};
    }
# 852 "/usr/include/c++/10.2.0/bits/stl_uninitialized.h" 3
  template<typename _InputIterator, typename _Size, typename _ForwardIterator>
    inline _ForwardIterator
    uninitialized_copy_n(_InputIterator __first, _Size __n,
    _ForwardIterator __result)
    { return std::__uninitialized_copy_n(__first, __n, __result,
      std::__iterator_category(__first)); }


  template<typename _InputIterator, typename _Size, typename _ForwardIterator>
    inline pair<_InputIterator, _ForwardIterator>
    __uninitialized_copy_n_pair(_InputIterator __first, _Size __n,
         _ForwardIterator __result)
    {
      return
 std::__uninitialized_copy_n_pair(__first, __n, __result,
      std::__iterator_category(__first));
    }
# 966 "/usr/include/c++/10.2.0/bits/stl_uninitialized.h" 3
  template<typename _Tp, typename _Up, typename _Allocator>
    inline void
    __relocate_object_a(_Tp* __restrict __dest, _Up* __restrict __orig,
   _Allocator& __alloc)
    noexcept(noexcept(std::allocator_traits<_Allocator>::construct(__alloc,
    __dest, std::move(*__orig)))
      && noexcept(std::allocator_traits<_Allocator>::destroy(
       __alloc, std::__addressof(*__orig))))
    {
      typedef std::allocator_traits<_Allocator> __traits;
      __traits::construct(__alloc, __dest, std::move(*__orig));
      __traits::destroy(__alloc, std::__addressof(*__orig));
    }



  template<typename _Tp, typename = void>
    struct __is_bitwise_relocatable
    : is_trivial<_Tp> { };

  template <typename _Tp, typename _Up>
    inline __enable_if_t<std::__is_bitwise_relocatable<_Tp>::value, _Tp*>
    __relocate_a_1(_Tp* __first, _Tp* __last,
     _Tp* __result, allocator<_Up>&) noexcept
    {
      ptrdiff_t __count = __last - __first;
      if (__count > 0)
 __builtin_memmove(__result, __first, __count * sizeof(_Tp));
      return __result + __count;
    }

  template <typename _InputIterator, typename _ForwardIterator,
     typename _Allocator>
    inline _ForwardIterator
    __relocate_a_1(_InputIterator __first, _InputIterator __last,
     _ForwardIterator __result, _Allocator& __alloc)
    noexcept(noexcept(std::__relocate_object_a(std::addressof(*__result),
            std::addressof(*__first),
            __alloc)))
    {
      typedef typename iterator_traits<_InputIterator>::value_type
 _ValueType;
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType2;
      static_assert(std::is_same<_ValueType, _ValueType2>::value,
   "relocation is only possible for values of the same type");
      _ForwardIterator __cur = __result;
      for (; __first != __last; ++__first, (void)++__cur)
 std::__relocate_object_a(std::__addressof(*__cur),
     std::__addressof(*__first), __alloc);
      return __cur;
    }

  template <typename _InputIterator, typename _ForwardIterator,
     typename _Allocator>
    inline _ForwardIterator
    __relocate_a(_InputIterator __first, _InputIterator __last,
   _ForwardIterator __result, _Allocator& __alloc)
    noexcept(noexcept(__relocate_a_1(std::__niter_base(__first),
         std::__niter_base(__last),
         std::__niter_base(__result), __alloc)))
    {
      return __relocate_a_1(std::__niter_base(__first),
       std::__niter_base(__last),
       std::__niter_base(__result), __alloc);
    }







}
# 67 "/usr/include/c++/10.2.0/memory" 2 3
# 1 "/usr/include/c++/10.2.0/bits/stl_tempbuf.h" 1 3
# 62 "/usr/include/c++/10.2.0/bits/stl_tempbuf.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{


  namespace __detail
  {
    template<typename _Tp>
      inline void
      __return_temporary_buffer(_Tp* __p,
    size_t __len __attribute__((__unused__)))
      {



 ::operator delete(__p);

      }
  }
# 98 "/usr/include/c++/10.2.0/bits/stl_tempbuf.h" 3
  template<typename _Tp>
    pair<_Tp*, ptrdiff_t>
    get_temporary_buffer(ptrdiff_t __len) noexcept
    {
      const ptrdiff_t __max =
 __gnu_cxx::__numeric_traits<ptrdiff_t>::__max / sizeof(_Tp);
      if (__len > __max)
 __len = __max;

      while (__len > 0)
 {
   _Tp* __tmp = static_cast<_Tp*>(::operator new(__len * sizeof(_Tp),
       std::nothrow));
   if (__tmp != 0)
     return std::pair<_Tp*, ptrdiff_t>(__tmp, __len);
   __len /= 2;
 }
      return std::pair<_Tp*, ptrdiff_t>(static_cast<_Tp*>(0), 0);
    }
# 125 "/usr/include/c++/10.2.0/bits/stl_tempbuf.h" 3
  template<typename _Tp>
    inline void
    return_temporary_buffer(_Tp* __p)
    { ::operator delete(__p); }






  template<typename _ForwardIterator, typename _Tp>
    class _Temporary_buffer
    {

     

    public:
      typedef _Tp value_type;
      typedef value_type* pointer;
      typedef pointer iterator;
      typedef ptrdiff_t size_type;

    protected:
      size_type _M_original_len;
      size_type _M_len;
      pointer _M_buffer;

    public:

      size_type
      size() const
      { return _M_len; }


      size_type
      requested_size() const
      { return _M_original_len; }


      iterator
      begin()
      { return _M_buffer; }


      iterator
      end()
      { return _M_buffer + _M_len; }





      _Temporary_buffer(_ForwardIterator __seed, size_type __original_len);

      ~_Temporary_buffer()
      {
 std::_Destroy(_M_buffer, _M_buffer + _M_len);
 std::__detail::__return_temporary_buffer(_M_buffer, _M_len);
      }

    private:

      _Temporary_buffer(const _Temporary_buffer&);

      void
      operator=(const _Temporary_buffer&);
    };


  template<bool>
    struct __uninitialized_construct_buf_dispatch
    {
      template<typename _Pointer, typename _ForwardIterator>
        static void
        __ucr(_Pointer __first, _Pointer __last,
       _ForwardIterator __seed)
        {
   if (__first == __last)
     return;

   _Pointer __cur = __first;
   try
     {
       std::_Construct(std::__addressof(*__first),
         std::move(*__seed));
       _Pointer __prev = __cur;
       ++__cur;
       for(; __cur != __last; ++__cur, ++__prev)
  std::_Construct(std::__addressof(*__cur),
    std::move(*__prev));
       *__seed = std::move(*__prev);
     }
   catch(...)
     {
       std::_Destroy(__first, __cur);
       throw;
     }
 }
    };

  template<>
    struct __uninitialized_construct_buf_dispatch<true>
    {
      template<typename _Pointer, typename _ForwardIterator>
        static void
        __ucr(_Pointer, _Pointer, _ForwardIterator) { }
    };
# 243 "/usr/include/c++/10.2.0/bits/stl_tempbuf.h" 3
  template<typename _Pointer, typename _ForwardIterator>
    inline void
    __uninitialized_construct_buf(_Pointer __first, _Pointer __last,
      _ForwardIterator __seed)
    {
      typedef typename std::iterator_traits<_Pointer>::value_type
 _ValueType;

      std::__uninitialized_construct_buf_dispatch<
        __has_trivial_constructor(_ValueType)>::
   __ucr(__first, __last, __seed);
    }

  template<typename _ForwardIterator, typename _Tp>
    _Temporary_buffer<_ForwardIterator, _Tp>::
    _Temporary_buffer(_ForwardIterator __seed, size_type __original_len)
    : _M_original_len(__original_len), _M_len(0), _M_buffer(0)
    {
      std::pair<pointer, size_type> __p(
  std::get_temporary_buffer<value_type>(_M_original_len));

      if (__p.first)
 {
   try
     {
       std::__uninitialized_construct_buf(__p.first, __p.first + __p.second,
       __seed);
       _M_buffer = __p.first;
       _M_len = __p.second;
     }
   catch(...)
     {
       std::__detail::__return_temporary_buffer(__p.first, __p.second);
       throw;
     }
 }
    }


}
# 68 "/usr/include/c++/10.2.0/memory" 2 3
# 1 "/usr/include/c++/10.2.0/bits/stl_raw_storage_iter.h" 1 3
# 59 "/usr/include/c++/10.2.0/bits/stl_raw_storage_iter.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{






  template <class _OutputIterator, class _Tp>
    class raw_storage_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    protected:
      _OutputIterator _M_iter;

    public:
      explicit
      raw_storage_iterator(_OutputIterator __x)
      : _M_iter(__x) {}

      raw_storage_iterator&
      operator*() { return *this; }

      raw_storage_iterator&
      operator=(const _Tp& __element)
      {
 std::_Construct(std::__addressof(*_M_iter), __element);
 return *this;
      }




      raw_storage_iterator&
      operator=(_Tp&& __element)
      {
 std::_Construct(std::__addressof(*_M_iter), std::move(__element));
 return *this;
      }


      raw_storage_iterator&
      operator++()
      {
 ++_M_iter;
 return *this;
      }

      raw_storage_iterator
      operator++(int)
      {
 raw_storage_iterator __tmp = *this;
 ++_M_iter;
 return __tmp;
      }



      _OutputIterator base() const { return _M_iter; }
    };


}
# 69 "/usr/include/c++/10.2.0/memory" 2 3
# 1 "/usr/include/c++/10.2.0/bits/ranges_uninitialized.h" 1 3
# 70 "/usr/include/c++/10.2.0/memory" 2 3






# 1 "/usr/include/c++/10.2.0/ext/concurrence.h" 1 3
# 32 "/usr/include/c++/10.2.0/ext/concurrence.h" 3
       
# 33 "/usr/include/c++/10.2.0/ext/concurrence.h" 3







namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{







  enum _Lock_policy { _S_single, _S_mutex, _S_atomic };



  static const _Lock_policy __default_lock_policy =



  _S_atomic;






  class __concurrence_lock_error : public std::exception
  {
  public:
    virtual char const*
    what() const throw()
    { return "__gnu_cxx::__concurrence_lock_error"; }
  };

  class __concurrence_unlock_error : public std::exception
  {
  public:
    virtual char const*
    what() const throw()
    { return "__gnu_cxx::__concurrence_unlock_error"; }
  };

  class __concurrence_broadcast_error : public std::exception
  {
  public:
    virtual char const*
    what() const throw()
    { return "__gnu_cxx::__concurrence_broadcast_error"; }
  };

  class __concurrence_wait_error : public std::exception
  {
  public:
    virtual char const*
    what() const throw()
    { return "__gnu_cxx::__concurrence_wait_error"; }
  };


  inline void
  __throw_concurrence_lock_error()
  { (throw (__concurrence_lock_error())); }

  inline void
  __throw_concurrence_unlock_error()
  { (throw (__concurrence_unlock_error())); }


  inline void
  __throw_concurrence_broadcast_error()
  { (throw (__concurrence_broadcast_error())); }

  inline void
  __throw_concurrence_wait_error()
  { (throw (__concurrence_wait_error())); }


  class __mutex
  {
  private:

    __gthread_mutex_t _M_mutex = { { 0, 0, 0, 0, PTHREAD_MUTEX_TIMED_NP, 0, 0, { 0, 0 } } };




    __mutex(const __mutex&);
    __mutex& operator=(const __mutex&);

  public:
    __mutex()
    {




    }
# 144 "/usr/include/c++/10.2.0/ext/concurrence.h" 3
    void lock()
    {

      if (__gthread_active_p())
 {
   if (__gthread_mutex_lock(&_M_mutex) != 0)
     __throw_concurrence_lock_error();
 }

    }

    void unlock()
    {

      if (__gthread_active_p())
 {
   if (__gthread_mutex_unlock(&_M_mutex) != 0)
     __throw_concurrence_unlock_error();
 }

    }

    __gthread_mutex_t* gthread_mutex(void)
      { return &_M_mutex; }
  };

  class __recursive_mutex
  {
  private:

    __gthread_recursive_mutex_t _M_mutex = { { 0, 0, 0, 0, PTHREAD_MUTEX_RECURSIVE_NP, 0, 0, { 0, 0 } } };




    __recursive_mutex(const __recursive_mutex&);
    __recursive_mutex& operator=(const __recursive_mutex&);

  public:
    __recursive_mutex()
    {




    }
# 199 "/usr/include/c++/10.2.0/ext/concurrence.h" 3
    void lock()
    {

      if (__gthread_active_p())
 {
   if (__gthread_recursive_mutex_lock(&_M_mutex) != 0)
     __throw_concurrence_lock_error();
 }

    }

    void unlock()
    {

      if (__gthread_active_p())
 {
   if (__gthread_recursive_mutex_unlock(&_M_mutex) != 0)
     __throw_concurrence_unlock_error();
 }

    }

    __gthread_recursive_mutex_t* gthread_recursive_mutex(void)
    { return &_M_mutex; }
  };




  class __scoped_lock
  {
  public:
    typedef __mutex __mutex_type;

  private:
    __mutex_type& _M_device;

    __scoped_lock(const __scoped_lock&);
    __scoped_lock& operator=(const __scoped_lock&);

  public:
    explicit __scoped_lock(__mutex_type& __name) : _M_device(__name)
    { _M_device.lock(); }

    ~__scoped_lock() throw()
    { _M_device.unlock(); }
  };


  class __cond
  {
  private:

    __gthread_cond_t _M_cond = { { {0}, {0}, {0, 0}, {0, 0}, 0, 0, {0, 0} } };




    __cond(const __cond&);
    __cond& operator=(const __cond&);

  public:
    __cond()
    {




    }
# 277 "/usr/include/c++/10.2.0/ext/concurrence.h" 3
    void broadcast()
    {

      if (__gthread_active_p())
 {
   if (__gthread_cond_broadcast(&_M_cond) != 0)
     __throw_concurrence_broadcast_error();
 }

    }

    void wait(__mutex *mutex)
    {

      {
   if (__gthread_cond_wait(&_M_cond, mutex->gthread_mutex()) != 0)
     __throw_concurrence_wait_error();
      }

    }

    void wait_recursive(__recursive_mutex *mutex)
    {

      {
   if (__gthread_cond_wait_recursive(&_M_cond,
         mutex->gthread_recursive_mutex())
       != 0)
     __throw_concurrence_wait_error();
      }

    }
  };



}
# 77 "/usr/include/c++/10.2.0/memory" 2 3


# 1 "/usr/include/c++/10.2.0/bits/uses_allocator.h" 1 3
# 35 "/usr/include/c++/10.2.0/bits/uses_allocator.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{



  struct __erased_type { };




  template<typename _Alloc, typename _Tp>
    using __is_erased_or_convertible
      = __or_<is_convertible<_Alloc, _Tp>, is_same<_Tp, __erased_type>>;


  struct allocator_arg_t { explicit allocator_arg_t() = default; };

  constexpr allocator_arg_t allocator_arg =
    allocator_arg_t();

  template<typename _Tp, typename _Alloc, typename = __void_t<>>
    struct __uses_allocator_helper
    : false_type { };

  template<typename _Tp, typename _Alloc>
    struct __uses_allocator_helper<_Tp, _Alloc,
       __void_t<typename _Tp::allocator_type>>
    : __is_erased_or_convertible<_Alloc, typename _Tp::allocator_type>::type
    { };


  template<typename _Tp, typename _Alloc>
    struct uses_allocator
    : __uses_allocator_helper<_Tp, _Alloc>::type
    { };

  struct __uses_alloc_base { };

  struct __uses_alloc0 : __uses_alloc_base
  {
    struct _Sink { void operator=(const void*) { } } _M_a;
  };

  template<typename _Alloc>
    struct __uses_alloc1 : __uses_alloc_base { const _Alloc* _M_a; };

  template<typename _Alloc>
    struct __uses_alloc2 : __uses_alloc_base { const _Alloc* _M_a; };

  template<bool, typename _Tp, typename _Alloc, typename... _Args>
    struct __uses_alloc;

  template<typename _Tp, typename _Alloc, typename... _Args>
    struct __uses_alloc<true, _Tp, _Alloc, _Args...>
    : conditional<
        is_constructible<_Tp, allocator_arg_t, const _Alloc&, _Args...>::value,
        __uses_alloc1<_Alloc>,
        __uses_alloc2<_Alloc>>::type
    {


      static_assert(__or_<
   is_constructible<_Tp, allocator_arg_t, const _Alloc&, _Args...>,
   is_constructible<_Tp, _Args..., const _Alloc&>>::value,
   "construction with an allocator must be possible"
   " if uses_allocator is true");
    };

  template<typename _Tp, typename _Alloc, typename... _Args>
    struct __uses_alloc<false, _Tp, _Alloc, _Args...>
    : __uses_alloc0 { };

  template<typename _Tp, typename _Alloc, typename... _Args>
    using __uses_alloc_t =
      __uses_alloc<uses_allocator<_Tp, _Alloc>::value, _Tp, _Alloc, _Args...>;

  template<typename _Tp, typename _Alloc, typename... _Args>
   
    inline __uses_alloc_t<_Tp, _Alloc, _Args...>
    __use_alloc(const _Alloc& __a)
    {
      __uses_alloc_t<_Tp, _Alloc, _Args...> __ret;
      __ret._M_a = std::__addressof(__a);
      return __ret;
    }

  template<typename _Tp, typename _Alloc, typename... _Args>
    void
    __use_alloc(const _Alloc&&) = delete;







  template<template<typename...> class _Predicate,
    typename _Tp, typename _Alloc, typename... _Args>
    struct __is_uses_allocator_predicate
    : conditional<uses_allocator<_Tp, _Alloc>::value,
      __or_<_Predicate<_Tp, allocator_arg_t, _Alloc, _Args...>,
     _Predicate<_Tp, _Args..., _Alloc>>,
      _Predicate<_Tp, _Args...>>::type { };

  template<typename _Tp, typename _Alloc, typename... _Args>
    struct __is_uses_allocator_constructible
    : __is_uses_allocator_predicate<is_constructible, _Tp, _Alloc, _Args...>
    { };







  template<typename _Tp, typename _Alloc, typename... _Args>
    struct __is_nothrow_uses_allocator_constructible
    : __is_uses_allocator_predicate<is_nothrow_constructible,
        _Tp, _Alloc, _Args...>
    { };
# 164 "/usr/include/c++/10.2.0/bits/uses_allocator.h" 3
  template<typename _Tp, typename... _Args>
    void __uses_allocator_construct_impl(__uses_alloc0 __a, _Tp* __ptr,
      _Args&&... __args)
    { ::new ((void*)__ptr) _Tp(std::forward<_Args>(__args)...); }

  template<typename _Tp, typename _Alloc, typename... _Args>
    void __uses_allocator_construct_impl(__uses_alloc1<_Alloc> __a, _Tp* __ptr,
      _Args&&... __args)
    {
      ::new ((void*)__ptr) _Tp(allocator_arg, *__a._M_a,
          std::forward<_Args>(__args)...);
    }

  template<typename _Tp, typename _Alloc, typename... _Args>
    void __uses_allocator_construct_impl(__uses_alloc2<_Alloc> __a, _Tp* __ptr,
      _Args&&... __args)
    { ::new ((void*)__ptr) _Tp(std::forward<_Args>(__args)..., *__a._M_a); }

  template<typename _Tp, typename _Alloc, typename... _Args>
    void __uses_allocator_construct(const _Alloc& __a, _Tp* __ptr,
        _Args&&... __args)
    {
      std::__uses_allocator_construct_impl(
   std::__use_alloc<_Tp, _Alloc, _Args...>(__a), __ptr,
   std::forward<_Args>(__args)...);
    }


}
# 80 "/usr/include/c++/10.2.0/memory" 2 3



# 1 "/usr/include/c++/10.2.0/bits/unique_ptr.h" 1 3
# 36 "/usr/include/c++/10.2.0/bits/unique_ptr.h" 3
# 1 "/usr/include/c++/10.2.0/utility" 1 3
# 58 "/usr/include/c++/10.2.0/utility" 3
       
# 59 "/usr/include/c++/10.2.0/utility" 3
# 69 "/usr/include/c++/10.2.0/utility" 3
# 1 "/usr/include/c++/10.2.0/bits/stl_relops.h" 1 3
# 67 "/usr/include/c++/10.2.0/bits/stl_relops.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{


  namespace rel_ops
  {
# 85 "/usr/include/c++/10.2.0/bits/stl_relops.h" 3
    template <class _Tp>
      inline bool
      operator!=(const _Tp& __x, const _Tp& __y)
      { return !(__x == __y); }
# 98 "/usr/include/c++/10.2.0/bits/stl_relops.h" 3
    template <class _Tp>
      inline bool
      operator>(const _Tp& __x, const _Tp& __y)
      { return __y < __x; }
# 111 "/usr/include/c++/10.2.0/bits/stl_relops.h" 3
    template <class _Tp>
      inline bool
      operator<=(const _Tp& __x, const _Tp& __y)
      { return !(__y < __x); }
# 124 "/usr/include/c++/10.2.0/bits/stl_relops.h" 3
    template <class _Tp>
      inline bool
      operator>=(const _Tp& __x, const _Tp& __y)
      { return !(__x < __y); }
  }


}
# 70 "/usr/include/c++/10.2.0/utility" 2 3
# 82 "/usr/include/c++/10.2.0/utility" 3
namespace std __attribute__ ((__visibility__ ("default")))
{



  template<typename _Tp>
    struct tuple_size;





  template<typename _Tp,
    typename _Up = typename remove_cv<_Tp>::type,
    typename = typename enable_if<is_same<_Tp, _Up>::value>::type,
    size_t = tuple_size<_Tp>::value>
    using __enable_if_has_tuple_size = _Tp;

  template<typename _Tp>
    struct tuple_size<const __enable_if_has_tuple_size<_Tp>>
    : public tuple_size<_Tp> { };

  template<typename _Tp>
    struct tuple_size<volatile __enable_if_has_tuple_size<_Tp>>
    : public tuple_size<_Tp> { };

  template<typename _Tp>
    struct tuple_size<const volatile __enable_if_has_tuple_size<_Tp>>
    : public tuple_size<_Tp> { };


  template<std::size_t __i, typename _Tp>
    struct tuple_element;


  template<std::size_t __i, typename _Tp>
    using __tuple_element_t = typename tuple_element<__i, _Tp>::type;

  template<std::size_t __i, typename _Tp>
    struct tuple_element<__i, const _Tp>
    {
      typedef typename add_const<__tuple_element_t<__i, _Tp>>::type type;
    };

  template<std::size_t __i, typename _Tp>
    struct tuple_element<__i, volatile _Tp>
    {
      typedef typename add_volatile<__tuple_element_t<__i, _Tp>>::type type;
    };

  template<std::size_t __i, typename _Tp>
    struct tuple_element<__i, const volatile _Tp>
    {
      typedef typename add_cv<__tuple_element_t<__i, _Tp>>::type type;
    };
# 151 "/usr/include/c++/10.2.0/utility" 3
  template<typename _T1, typename _T2>
    struct __is_tuple_like_impl<std::pair<_T1, _T2>> : true_type
    { };


  template<class _Tp1, class _Tp2>
    struct tuple_size<std::pair<_Tp1, _Tp2>>
    : public integral_constant<std::size_t, 2> { };


  template<class _Tp1, class _Tp2>
    struct tuple_element<0, std::pair<_Tp1, _Tp2>>
    { typedef _Tp1 type; };


  template<class _Tp1, class _Tp2>
    struct tuple_element<1, std::pair<_Tp1, _Tp2>>
    { typedef _Tp2 type; };

  template<std::size_t _Int>
    struct __pair_get;

  template<>
    struct __pair_get<0>
    {
      template<typename _Tp1, typename _Tp2>
        static constexpr _Tp1&
        __get(std::pair<_Tp1, _Tp2>& __pair) noexcept
        { return __pair.first; }

      template<typename _Tp1, typename _Tp2>
        static constexpr _Tp1&&
        __move_get(std::pair<_Tp1, _Tp2>&& __pair) noexcept
        { return std::forward<_Tp1>(__pair.first); }

      template<typename _Tp1, typename _Tp2>
        static constexpr const _Tp1&
        __const_get(const std::pair<_Tp1, _Tp2>& __pair) noexcept
        { return __pair.first; }

      template<typename _Tp1, typename _Tp2>
        static constexpr const _Tp1&&
        __const_move_get(const std::pair<_Tp1, _Tp2>&& __pair) noexcept
        { return std::forward<const _Tp1>(__pair.first); }
    };

  template<>
    struct __pair_get<1>
    {
      template<typename _Tp1, typename _Tp2>
        static constexpr _Tp2&
        __get(std::pair<_Tp1, _Tp2>& __pair) noexcept
        { return __pair.second; }

      template<typename _Tp1, typename _Tp2>
        static constexpr _Tp2&&
        __move_get(std::pair<_Tp1, _Tp2>&& __pair) noexcept
        { return std::forward<_Tp2>(__pair.second); }

      template<typename _Tp1, typename _Tp2>
        static constexpr const _Tp2&
        __const_get(const std::pair<_Tp1, _Tp2>& __pair) noexcept
        { return __pair.second; }

      template<typename _Tp1, typename _Tp2>
        static constexpr const _Tp2&&
        __const_move_get(const std::pair<_Tp1, _Tp2>&& __pair) noexcept
        { return std::forward<const _Tp2>(__pair.second); }
    };

  template<std::size_t _Int, class _Tp1, class _Tp2>
    constexpr typename tuple_element<_Int, std::pair<_Tp1, _Tp2>>::type&
    get(std::pair<_Tp1, _Tp2>& __in) noexcept
    { return __pair_get<_Int>::__get(__in); }

  template<std::size_t _Int, class _Tp1, class _Tp2>
    constexpr typename tuple_element<_Int, std::pair<_Tp1, _Tp2>>::type&&
    get(std::pair<_Tp1, _Tp2>&& __in) noexcept
    { return __pair_get<_Int>::__move_get(std::move(__in)); }

  template<std::size_t _Int, class _Tp1, class _Tp2>
    constexpr const typename tuple_element<_Int, std::pair<_Tp1, _Tp2>>::type&
    get(const std::pair<_Tp1, _Tp2>& __in) noexcept
    { return __pair_get<_Int>::__const_get(__in); }

  template<std::size_t _Int, class _Tp1, class _Tp2>
    constexpr const typename tuple_element<_Int, std::pair<_Tp1, _Tp2>>::type&&
    get(const std::pair<_Tp1, _Tp2>&& __in) noexcept
    { return __pair_get<_Int>::__const_move_get(std::move(__in)); }
# 298 "/usr/include/c++/10.2.0/utility" 3
  template<size_t... _Indexes> struct _Index_tuple { };
# 307 "/usr/include/c++/10.2.0/utility" 3
  template<size_t _Num>
    struct _Build_index_tuple
    {






      using __type = _Index_tuple<__integer_pack(_Num)...>;

    };
# 473 "/usr/include/c++/10.2.0/utility" 3

}
# 37 "/usr/include/c++/10.2.0/bits/unique_ptr.h" 2 3
# 1 "/usr/include/c++/10.2.0/tuple" 1 3
# 32 "/usr/include/c++/10.2.0/tuple" 3
       
# 33 "/usr/include/c++/10.2.0/tuple" 3






# 1 "/usr/include/c++/10.2.0/array" 1 3
# 32 "/usr/include/c++/10.2.0/array" 3
       
# 33 "/usr/include/c++/10.2.0/array" 3
# 43 "/usr/include/c++/10.2.0/array" 3
namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _Tp, std::size_t _Nm>
    struct __array_traits
    {
      typedef _Tp _Type[_Nm];
      typedef __is_swappable<_Tp> _Is_swappable;
      typedef __is_nothrow_swappable<_Tp> _Is_nothrow_swappable;

      static constexpr _Tp&
      _S_ref(const _Type& __t, std::size_t __n) noexcept
      { return const_cast<_Tp&>(__t[__n]); }

      static constexpr _Tp*
      _S_ptr(const _Type& __t) noexcept
      { return const_cast<_Tp*>(__t); }
    };

 template<typename _Tp>
   struct __array_traits<_Tp, 0>
   {
     struct _Type { };
     typedef true_type _Is_swappable;
     typedef true_type _Is_nothrow_swappable;

     static constexpr _Tp&
     _S_ref(const _Type&, std::size_t) noexcept
     { return *static_cast<_Tp*>(nullptr); }

     static constexpr _Tp*
     _S_ptr(const _Type&) noexcept
     { return nullptr; }
   };
# 93 "/usr/include/c++/10.2.0/array" 3
  template<typename _Tp, std::size_t _Nm>
    struct array
    {
      typedef _Tp value_type;
      typedef value_type* pointer;
      typedef const value_type* const_pointer;
      typedef value_type& reference;
      typedef const value_type& const_reference;
      typedef value_type* iterator;
      typedef const value_type* const_iterator;
      typedef std::size_t size_type;
      typedef std::ptrdiff_t difference_type;
      typedef std::reverse_iterator<iterator> reverse_iterator;
      typedef std::reverse_iterator<const_iterator> const_reverse_iterator;


      typedef std::__array_traits<_Tp, _Nm> _AT_Type;
      typename _AT_Type::_Type _M_elems;




      void
      fill(const value_type& __u)
      { std::fill_n(begin(), size(), __u); }

      void
      swap(array& __other)
      noexcept(_AT_Type::_Is_nothrow_swappable::value)
      { std::swap_ranges(begin(), end(), __other.begin()); }


      iterator
      begin() noexcept
      { return iterator(data()); }

      const_iterator
      begin() const noexcept
      { return const_iterator(data()); }

      iterator
      end() noexcept
      { return iterator(data() + _Nm); }

      const_iterator
      end() const noexcept
      { return const_iterator(data() + _Nm); }

      reverse_iterator
      rbegin() noexcept
      { return reverse_iterator(end()); }

      const_reverse_iterator
      rbegin() const noexcept
      { return const_reverse_iterator(end()); }

      reverse_iterator
      rend() noexcept
      { return reverse_iterator(begin()); }

      const_reverse_iterator
      rend() const noexcept
      { return const_reverse_iterator(begin()); }

      const_iterator
      cbegin() const noexcept
      { return const_iterator(data()); }

      const_iterator
      cend() const noexcept
      { return const_iterator(data() + _Nm); }

      const_reverse_iterator
      crbegin() const noexcept
      { return const_reverse_iterator(end()); }

      const_reverse_iterator
      crend() const noexcept
      { return const_reverse_iterator(begin()); }


      constexpr size_type
      size() const noexcept { return _Nm; }

      constexpr size_type
      max_size() const noexcept { return _Nm; }

      constexpr bool
      empty() const noexcept { return size() == 0; }


      reference
      operator[](size_type __n) noexcept
      { return _AT_Type::_S_ref(_M_elems, __n); }

      constexpr const_reference
      operator[](size_type __n) const noexcept
      { return _AT_Type::_S_ref(_M_elems, __n); }

      reference
      at(size_type __n)
      {
 if (__n >= _Nm)
   std::__throw_out_of_range_fmt(("array::at: __n (which is %zu) " ">= _Nm (which is %zu)")
                                 ,
     __n, _Nm);
 return _AT_Type::_S_ref(_M_elems, __n);
      }

      constexpr const_reference
      at(size_type __n) const
      {


 return __n < _Nm ? _AT_Type::_S_ref(_M_elems, __n)
   : (std::__throw_out_of_range_fmt(("array::at: __n (which is %zu) " ">= _Nm (which is %zu)")
                                    ,
        __n, _Nm),
      _AT_Type::_S_ref(_M_elems, 0));
      }

      reference
      front() noexcept
      { return *begin(); }

      constexpr const_reference
      front() const noexcept
      { return _AT_Type::_S_ref(_M_elems, 0); }

      reference
      back() noexcept
      { return _Nm ? *(end() - 1) : *end(); }

      constexpr const_reference
      back() const noexcept
      {
 return _Nm ? _AT_Type::_S_ref(_M_elems, _Nm - 1)
             : _AT_Type::_S_ref(_M_elems, 0);
      }

      pointer
      data() noexcept
      { return _AT_Type::_S_ptr(_M_elems); }

      const_pointer
      data() const noexcept
      { return _AT_Type::_S_ptr(_M_elems); }
    };
# 250 "/usr/include/c++/10.2.0/array" 3
  template<typename _Tp, std::size_t _Nm>
   
    inline bool
    operator==(const array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)
    { return std::equal(__one.begin(), __one.end(), __two.begin()); }
# 275 "/usr/include/c++/10.2.0/array" 3
  template<typename _Tp, std::size_t _Nm>
   
    inline bool
    operator!=(const array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)
    { return !(__one == __two); }

  template<typename _Tp, std::size_t _Nm>
   
    inline bool
    operator<(const array<_Tp, _Nm>& __a, const array<_Tp, _Nm>& __b)
    {
      return std::lexicographical_compare(__a.begin(), __a.end(),
       __b.begin(), __b.end());
    }

  template<typename _Tp, std::size_t _Nm>
   
    inline bool
    operator>(const array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)
    { return __two < __one; }

  template<typename _Tp, std::size_t _Nm>
   
    inline bool
    operator<=(const array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)
    { return !(__one > __two); }

  template<typename _Tp, std::size_t _Nm>
   
    inline bool
    operator>=(const array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)
    { return !(__one < __two); }



  template<typename _Tp, std::size_t _Nm>
   
    inline






    void

    swap(array<_Tp, _Nm>& __one, array<_Tp, _Nm>& __two)
    noexcept(noexcept(__one.swap(__two)))
    { __one.swap(__two); }
# 332 "/usr/include/c++/10.2.0/array" 3
  template<std::size_t _Int, typename _Tp, std::size_t _Nm>
    constexpr _Tp&
    get(array<_Tp, _Nm>& __arr) noexcept
    {
      static_assert(_Int < _Nm, "array index is within bounds");
      return std::__array_traits<_Tp, _Nm>::
 _S_ref(__arr._M_elems, _Int);
    }

  template<std::size_t _Int, typename _Tp, std::size_t _Nm>
    constexpr _Tp&&
    get(array<_Tp, _Nm>&& __arr) noexcept
    {
      static_assert(_Int < _Nm, "array index is within bounds");
      return std::move(std::get<_Int>(__arr));
    }

  template<std::size_t _Int, typename _Tp, std::size_t _Nm>
    constexpr const _Tp&
    get(const array<_Tp, _Nm>& __arr) noexcept
    {
      static_assert(_Int < _Nm, "array index is within bounds");
      return std::__array_traits<_Tp, _Nm>::
 _S_ref(__arr._M_elems, _Int);
    }

  template<std::size_t _Int, typename _Tp, std::size_t _Nm>
    constexpr const _Tp&&
    get(const array<_Tp, _Nm>&& __arr) noexcept
    {
      static_assert(_Int < _Nm, "array index is within bounds");
      return std::move(std::get<_Int>(__arr));
    }
# 404 "/usr/include/c++/10.2.0/array" 3

}

namespace std __attribute__ ((__visibility__ ("default")))
{





  template<typename _Tp>
    struct tuple_size;


  template<typename _Tp, std::size_t _Nm>
    struct tuple_size<std::array<_Tp, _Nm>>
    : public integral_constant<std::size_t, _Nm> { };


  template<std::size_t _Int, typename _Tp>
    struct tuple_element;


  template<std::size_t _Int, typename _Tp, std::size_t _Nm>
    struct tuple_element<_Int, std::array<_Tp, _Nm>>
    {
      static_assert(_Int < _Nm, "index is out of bounds");
      typedef _Tp type;
    };

  template<typename _Tp, std::size_t _Nm>
    struct __is_tuple_like_impl<std::array<_Tp, _Nm>> : true_type
    { };


}
# 40 "/usr/include/c++/10.2.0/tuple" 2 3

# 1 "/usr/include/c++/10.2.0/bits/invoke.h" 1 3
# 33 "/usr/include/c++/10.2.0/bits/invoke.h" 3
       
# 34 "/usr/include/c++/10.2.0/bits/invoke.h" 3







namespace std __attribute__ ((__visibility__ ("default")))
{

# 52 "/usr/include/c++/10.2.0/bits/invoke.h" 3
  template<typename _Tp, typename _Up = typename __inv_unwrap<_Tp>::type>
    constexpr _Up&&
    __invfwd(typename remove_reference<_Tp>::type& __t) noexcept
    { return static_cast<_Up&&>(__t); }

  template<typename _Res, typename _Fn, typename... _Args>
    constexpr _Res
    __invoke_impl(__invoke_other, _Fn&& __f, _Args&&... __args)
    { return std::forward<_Fn>(__f)(std::forward<_Args>(__args)...); }

  template<typename _Res, typename _MemFun, typename _Tp, typename... _Args>
    constexpr _Res
    __invoke_impl(__invoke_memfun_ref, _MemFun&& __f, _Tp&& __t,
    _Args&&... __args)
    { return (__invfwd<_Tp>(__t).*__f)(std::forward<_Args>(__args)...); }

  template<typename _Res, typename _MemFun, typename _Tp, typename... _Args>
    constexpr _Res
    __invoke_impl(__invoke_memfun_deref, _MemFun&& __f, _Tp&& __t,
    _Args&&... __args)
    {
      return ((*std::forward<_Tp>(__t)).*__f)(std::forward<_Args>(__args)...);
    }

  template<typename _Res, typename _MemPtr, typename _Tp>
    constexpr _Res
    __invoke_impl(__invoke_memobj_ref, _MemPtr&& __f, _Tp&& __t)
    { return __invfwd<_Tp>(__t).*__f; }

  template<typename _Res, typename _MemPtr, typename _Tp>
    constexpr _Res
    __invoke_impl(__invoke_memobj_deref, _MemPtr&& __f, _Tp&& __t)
    { return (*std::forward<_Tp>(__t)).*__f; }


  template<typename _Callable, typename... _Args>
    constexpr typename __invoke_result<_Callable, _Args...>::type
    __invoke(_Callable&& __fn, _Args&&... __args)
    noexcept(__is_nothrow_invocable<_Callable, _Args...>::value)
    {
      using __result = __invoke_result<_Callable, _Args...>;
      using __type = typename __result::type;
      using __tag = typename __result::__invoke_type;
      return std::__invoke_impl<__type>(__tag{}, std::forward<_Callable>(__fn),
     std::forward<_Args>(__args)...);
    }
# 118 "/usr/include/c++/10.2.0/bits/invoke.h" 3
  template<typename _Res, typename _Callable, typename... _Args>
    using __can_invoke_as_void = __enable_if_t<
      __and_<is_void<_Res>, __is_invocable<_Callable, _Args...>>::value,
      _Res
    >;

  template<typename _Res, typename _Callable, typename... _Args>
    using __can_invoke_as_nonvoid = __enable_if_t<
      __and_<__not_<is_void<_Res>>,
      is_convertible<typename __invoke_result<_Callable, _Args...>::type,
       _Res>
      >::value,
      _Res
    >;


  template<typename _Res, typename _Callable, typename... _Args>
    constexpr __can_invoke_as_nonvoid<_Res, _Callable, _Args...>
    __invoke_r(_Callable&& __fn, _Args&&... __args)
    {
      using __result = __invoke_result<_Callable, _Args...>;
      using __type = typename __result::type;
      using __tag = typename __result::__invoke_type;
      return std::__invoke_impl<__type>(__tag{}, std::forward<_Callable>(__fn),
     std::forward<_Args>(__args)...);
    }


  template<typename _Res, typename _Callable, typename... _Args>
    __can_invoke_as_void<_Res, _Callable, _Args...>
    __invoke_r(_Callable&& __fn, _Args&&... __args)
    {
      using __result = __invoke_result<_Callable, _Args...>;
      using __type = typename __result::type;
      using __tag = typename __result::__invoke_type;
      std::__invoke_impl<__type>(__tag{}, std::forward<_Callable>(__fn),
     std::forward<_Args>(__args)...);
    }



}
# 42 "/usr/include/c++/10.2.0/tuple" 2 3





namespace std __attribute__ ((__visibility__ ("default")))
{







  template<typename... _Elements>
    class tuple;

  template<typename _Tp>
    struct __is_empty_non_tuple : is_empty<_Tp> { };


  template<typename _El0, typename... _El>
    struct __is_empty_non_tuple<tuple<_El0, _El...>> : false_type { };


  template<typename _Tp>
    using __empty_not_final
    = typename conditional<__is_final(_Tp), false_type,
      __is_empty_non_tuple<_Tp>>::type;

  template<std::size_t _Idx, typename _Head,
    bool = __empty_not_final<_Head>::value>
    struct _Head_base;

  template<std::size_t _Idx, typename _Head>
    struct _Head_base<_Idx, _Head, true>
    : public _Head
    {
      constexpr _Head_base()
      : _Head() { }

      constexpr _Head_base(const _Head& __h)
      : _Head(__h) { }

      constexpr _Head_base(const _Head_base&) = default;
      constexpr _Head_base(_Head_base&&) = default;

      template<typename _UHead>
        constexpr _Head_base(_UHead&& __h)
 : _Head(std::forward<_UHead>(__h)) { }

      _Head_base(allocator_arg_t, __uses_alloc0)
      : _Head() { }

      template<typename _Alloc>
 _Head_base(allocator_arg_t, __uses_alloc1<_Alloc> __a)
 : _Head(allocator_arg, *__a._M_a) { }

      template<typename _Alloc>
 _Head_base(allocator_arg_t, __uses_alloc2<_Alloc> __a)
 : _Head(*__a._M_a) { }

      template<typename _UHead>
 _Head_base(__uses_alloc0, _UHead&& __uhead)
 : _Head(std::forward<_UHead>(__uhead)) { }

      template<typename _Alloc, typename _UHead>
 _Head_base(__uses_alloc1<_Alloc> __a, _UHead&& __uhead)
 : _Head(allocator_arg, *__a._M_a, std::forward<_UHead>(__uhead)) { }

      template<typename _Alloc, typename _UHead>
 _Head_base(__uses_alloc2<_Alloc> __a, _UHead&& __uhead)
 : _Head(std::forward<_UHead>(__uhead), *__a._M_a) { }

      static constexpr _Head&
      _M_head(_Head_base& __b) noexcept { return __b; }

      static constexpr const _Head&
      _M_head(const _Head_base& __b) noexcept { return __b; }
    };

  template<std::size_t _Idx, typename _Head>
    struct _Head_base<_Idx, _Head, false>
    {
      constexpr _Head_base()
      : _M_head_impl() { }

      constexpr _Head_base(const _Head& __h)
      : _M_head_impl(__h) { }

      constexpr _Head_base(const _Head_base&) = default;
      constexpr _Head_base(_Head_base&&) = default;

      template<typename _UHead>
        constexpr _Head_base(_UHead&& __h)
 : _M_head_impl(std::forward<_UHead>(__h)) { }

     
      _Head_base(allocator_arg_t, __uses_alloc0)
      : _M_head_impl() { }

      template<typename _Alloc>
 _Head_base(allocator_arg_t, __uses_alloc1<_Alloc> __a)
 : _M_head_impl(allocator_arg, *__a._M_a) { }

      template<typename _Alloc>
 _Head_base(allocator_arg_t, __uses_alloc2<_Alloc> __a)
 : _M_head_impl(*__a._M_a) { }

      template<typename _UHead>

 _Head_base(__uses_alloc0, _UHead&& __uhead)
 : _M_head_impl(std::forward<_UHead>(__uhead)) { }

      template<typename _Alloc, typename _UHead>
 _Head_base(__uses_alloc1<_Alloc> __a, _UHead&& __uhead)
 : _M_head_impl(allocator_arg, *__a._M_a, std::forward<_UHead>(__uhead))
 { }

      template<typename _Alloc, typename _UHead>
 _Head_base(__uses_alloc2<_Alloc> __a, _UHead&& __uhead)
 : _M_head_impl(std::forward<_UHead>(__uhead), *__a._M_a) { }

      static constexpr _Head&
      _M_head(_Head_base& __b) noexcept { return __b._M_head_impl; }

      static constexpr const _Head&
      _M_head(const _Head_base& __b) noexcept { return __b._M_head_impl; }

      _Head _M_head_impl;
    };
# 182 "/usr/include/c++/10.2.0/tuple" 3
  template<std::size_t _Idx, typename... _Elements>
    struct _Tuple_impl;






  template<std::size_t _Idx, typename _Head, typename... _Tail>
    struct _Tuple_impl<_Idx, _Head, _Tail...>
    : public _Tuple_impl<_Idx + 1, _Tail...>,
      private _Head_base<_Idx, _Head>
    {
      template<std::size_t, typename...> friend class _Tuple_impl;

      typedef _Tuple_impl<_Idx + 1, _Tail...> _Inherited;
      typedef _Head_base<_Idx, _Head> _Base;

      static constexpr _Head&
      _M_head(_Tuple_impl& __t) noexcept { return _Base::_M_head(__t); }

      static constexpr const _Head&
      _M_head(const _Tuple_impl& __t) noexcept { return _Base::_M_head(__t); }

      static constexpr _Inherited&
      _M_tail(_Tuple_impl& __t) noexcept { return __t; }

      static constexpr const _Inherited&
      _M_tail(const _Tuple_impl& __t) noexcept { return __t; }

      constexpr _Tuple_impl()
      : _Inherited(), _Base() { }

      explicit
      constexpr _Tuple_impl(const _Head& __head, const _Tail&... __tail)
      : _Inherited(__tail...), _Base(__head) { }

      template<typename _UHead, typename... _UTail, typename = typename
               enable_if<sizeof...(_Tail) == sizeof...(_UTail)>::type>
        explicit
        constexpr _Tuple_impl(_UHead&& __head, _UTail&&... __tail)
 : _Inherited(std::forward<_UTail>(__tail)...),
   _Base(std::forward<_UHead>(__head)) { }

      constexpr _Tuple_impl(const _Tuple_impl&) = default;



      _Tuple_impl& operator=(const _Tuple_impl&) = delete;

      constexpr
      _Tuple_impl(_Tuple_impl&& __in)
      noexcept(__and_<is_nothrow_move_constructible<_Head>,
               is_nothrow_move_constructible<_Inherited>>::value)
      : _Inherited(std::move(_M_tail(__in))),
 _Base(std::forward<_Head>(_M_head(__in))) { }

      template<typename... _UElements>
        constexpr _Tuple_impl(const _Tuple_impl<_Idx, _UElements...>& __in)
 : _Inherited(_Tuple_impl<_Idx, _UElements...>::_M_tail(__in)),
   _Base(_Tuple_impl<_Idx, _UElements...>::_M_head(__in)) { }

      template<typename _UHead, typename... _UTails>
        constexpr _Tuple_impl(_Tuple_impl<_Idx, _UHead, _UTails...>&& __in)
 : _Inherited(std::move
       (_Tuple_impl<_Idx, _UHead, _UTails...>::_M_tail(__in))),
   _Base(std::forward<_UHead>
  (_Tuple_impl<_Idx, _UHead, _UTails...>::_M_head(__in))) { }

      template<typename _Alloc>

 _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a)
 : _Inherited(__tag, __a),
          _Base(__tag, __use_alloc<_Head>(__a)) { }

      template<typename _Alloc>
 _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
      const _Head& __head, const _Tail&... __tail)
 : _Inherited(__tag, __a, __tail...),
          _Base(__use_alloc<_Head, _Alloc, _Head>(__a), __head) { }

      template<typename _Alloc, typename _UHead, typename... _UTail,
               typename = typename enable_if<sizeof...(_Tail)
          == sizeof...(_UTail)>::type>

 _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
             _UHead&& __head, _UTail&&... __tail)
 : _Inherited(__tag, __a, std::forward<_UTail>(__tail)...),
          _Base(__use_alloc<_Head, _Alloc, _UHead>(__a),
         std::forward<_UHead>(__head)) { }

      template<typename _Alloc>

        _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
             const _Tuple_impl& __in)
 : _Inherited(__tag, __a, _M_tail(__in)),
          _Base(__use_alloc<_Head, _Alloc, _Head>(__a), _M_head(__in)) { }

      template<typename _Alloc>

 _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
             _Tuple_impl&& __in)
 : _Inherited(__tag, __a, std::move(_M_tail(__in))),
   _Base(__use_alloc<_Head, _Alloc, _Head>(__a),
         std::forward<_Head>(_M_head(__in))) { }

      template<typename _Alloc, typename... _UElements>

 _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
             const _Tuple_impl<_Idx, _UElements...>& __in)
 : _Inherited(__tag, __a,
       _Tuple_impl<_Idx, _UElements...>::_M_tail(__in)),
   _Base(__use_alloc<_Head, _Alloc, _Head>(__a),
  _Tuple_impl<_Idx, _UElements...>::_M_head(__in)) { }

      template<typename _Alloc, typename _UHead, typename... _UTails>

 _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
             _Tuple_impl<_Idx, _UHead, _UTails...>&& __in)
 : _Inherited(__tag, __a, std::move
       (_Tuple_impl<_Idx, _UHead, _UTails...>::_M_tail(__in))),
   _Base(__use_alloc<_Head, _Alloc, _UHead>(__a),
                std::forward<_UHead>
  (_Tuple_impl<_Idx, _UHead, _UTails...>::_M_head(__in))) { }

      template<typename... _UElements>

        void
        _M_assign(const _Tuple_impl<_Idx, _UElements...>& __in)
        {
   _M_head(*this) = _Tuple_impl<_Idx, _UElements...>::_M_head(__in);
   _M_tail(*this)._M_assign(
       _Tuple_impl<_Idx, _UElements...>::_M_tail(__in));
 }

      template<typename _UHead, typename... _UTails>

        void
        _M_assign(_Tuple_impl<_Idx, _UHead, _UTails...>&& __in)
        {
   _M_head(*this) = std::forward<_UHead>
     (_Tuple_impl<_Idx, _UHead, _UTails...>::_M_head(__in));
   _M_tail(*this)._M_assign(
       std::move(_Tuple_impl<_Idx, _UHead, _UTails...>::_M_tail(__in)));
 }

    protected:
     
      void
      _M_swap(_Tuple_impl& __in)
      {
 using std::swap;
 swap(_M_head(*this), _M_head(__in));
 _Inherited::_M_swap(_M_tail(__in));
      }
    };


  template<std::size_t _Idx, typename _Head>
    struct _Tuple_impl<_Idx, _Head>
    : private _Head_base<_Idx, _Head>
    {
      template<std::size_t, typename...> friend class _Tuple_impl;

      typedef _Head_base<_Idx, _Head> _Base;

      static constexpr _Head&
      _M_head(_Tuple_impl& __t) noexcept { return _Base::_M_head(__t); }

      static constexpr const _Head&
      _M_head(const _Tuple_impl& __t) noexcept { return _Base::_M_head(__t); }

      constexpr _Tuple_impl()
      : _Base() { }

      explicit
      constexpr _Tuple_impl(const _Head& __head)
      : _Base(__head) { }

      template<typename _UHead>
        explicit
        constexpr _Tuple_impl(_UHead&& __head)
 : _Base(std::forward<_UHead>(__head)) { }

      constexpr _Tuple_impl(const _Tuple_impl&) = default;



      _Tuple_impl& operator=(const _Tuple_impl&) = delete;

      constexpr
      _Tuple_impl(_Tuple_impl&& __in)
      noexcept(is_nothrow_move_constructible<_Head>::value)
      : _Base(std::forward<_Head>(_M_head(__in))) { }

      template<typename _UHead>
        constexpr _Tuple_impl(const _Tuple_impl<_Idx, _UHead>& __in)
 : _Base(_Tuple_impl<_Idx, _UHead>::_M_head(__in)) { }

      template<typename _UHead>
        constexpr _Tuple_impl(_Tuple_impl<_Idx, _UHead>&& __in)
 : _Base(std::forward<_UHead>(_Tuple_impl<_Idx, _UHead>::_M_head(__in)))
 { }

      template<typename _Alloc>

 _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a)
 : _Base(__tag, __use_alloc<_Head>(__a)) { }

      template<typename _Alloc>
 _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
      const _Head& __head)
 : _Base(__use_alloc<_Head, _Alloc, _Head>(__a), __head) { }

      template<typename _Alloc, typename _UHead>

 _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
             _UHead&& __head)
 : _Base(__use_alloc<_Head, _Alloc, _UHead>(__a),
         std::forward<_UHead>(__head)) { }

      template<typename _Alloc>

        _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
             const _Tuple_impl& __in)
 : _Base(__use_alloc<_Head, _Alloc, _Head>(__a), _M_head(__in)) { }

      template<typename _Alloc>

 _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
             _Tuple_impl&& __in)
 : _Base(__use_alloc<_Head, _Alloc, _Head>(__a),
         std::forward<_Head>(_M_head(__in))) { }

      template<typename _Alloc, typename _UHead>

 _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
             const _Tuple_impl<_Idx, _UHead>& __in)
 : _Base(__use_alloc<_Head, _Alloc, _Head>(__a),
  _Tuple_impl<_Idx, _UHead>::_M_head(__in)) { }

      template<typename _Alloc, typename _UHead>

 _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
             _Tuple_impl<_Idx, _UHead>&& __in)
 : _Base(__use_alloc<_Head, _Alloc, _UHead>(__a),
                std::forward<_UHead>(_Tuple_impl<_Idx, _UHead>::_M_head(__in)))
 { }

      template<typename _UHead>

        void
        _M_assign(const _Tuple_impl<_Idx, _UHead>& __in)
        {
   _M_head(*this) = _Tuple_impl<_Idx, _UHead>::_M_head(__in);
 }

      template<typename _UHead>

        void
        _M_assign(_Tuple_impl<_Idx, _UHead>&& __in)
        {
   _M_head(*this)
     = std::forward<_UHead>(_Tuple_impl<_Idx, _UHead>::_M_head(__in));
 }

    protected:
     
      void
      _M_swap(_Tuple_impl& __in)
      {
 using std::swap;
 swap(_M_head(*this), _M_head(__in));
      }
    };



  template<bool, typename... _Types>
    struct _TupleConstraints
    {



      template<typename... _UTypes>
 static constexpr bool __is_implicitly_constructible()
 {
   return __and_<is_constructible<_Types, _UTypes>...,
   is_convertible<_UTypes, _Types>...
   >::value;
 }




      template<typename... _UTypes>
 static constexpr bool __is_explicitly_constructible()
 {
   return __and_<is_constructible<_Types, _UTypes>...,
   __not_<__and_<is_convertible<_UTypes, _Types>...>>
   >::value;
 }

      static constexpr bool __is_implicitly_default_constructible()
      {
 return __and_<std::__is_implicitly_default_constructible<_Types>...
        >::value;
      }

      static constexpr bool __is_explicitly_default_constructible()
      {
 return __and_<is_default_constructible<_Types>...,
        __not_<__and_<
   std::__is_implicitly_default_constructible<_Types>...>
        >>::value;
      }
    };



  template<typename... _Types>
    struct _TupleConstraints<false, _Types...>
    {
      template<typename... _UTypes>
 static constexpr bool __is_implicitly_constructible()
 { return false; }

      template<typename... _UTypes>
 static constexpr bool __is_explicitly_constructible()
 { return false; }
    };


  template<typename... _Elements>
    class tuple : public _Tuple_impl<0, _Elements...>
    {
      typedef _Tuple_impl<0, _Elements...> _Inherited;

      template<bool _Cond>
 using _TCC = _TupleConstraints<_Cond, _Elements...>;


      template<bool _Dummy>
 using _ImplicitDefaultCtor = __enable_if_t<
   _TCC<_Dummy>::__is_implicitly_default_constructible(),
   bool>;


      template<bool _Dummy>
 using _ExplicitDefaultCtor = __enable_if_t<
   _TCC<_Dummy>::__is_explicitly_default_constructible(),
   bool>;


      template<bool _Cond, typename... _Args>
 using _ImplicitCtor = __enable_if_t<
   _TCC<_Cond>::template __is_implicitly_constructible<_Args...>(),
   bool>;


      template<bool _Cond, typename... _Args>
 using _ExplicitCtor = __enable_if_t<
   _TCC<_Cond>::template __is_explicitly_constructible<_Args...>(),
   bool>;

      template<typename... _UElements>
 static constexpr
 __enable_if_t<sizeof...(_UElements) == sizeof...(_Elements), bool>
 __assignable()
 { return __and_<is_assignable<_Elements&, _UElements>...>::value; }


      template<typename... _UElements>
 static constexpr bool __nothrow_assignable()
 {
   return
     __and_<is_nothrow_assignable<_Elements&, _UElements>...>::value;
 }


      template<typename... _UElements>
 static constexpr bool __nothrow_constructible()
 {
   return
     __and_<is_nothrow_constructible<_Elements, _UElements>...>::value;
 }


      template<typename _Up>
 static constexpr bool __valid_args()
 {
   return sizeof...(_Elements) == 1
     && !is_same<tuple, __remove_cvref_t<_Up>>::value;
 }


      template<typename, typename, typename... _Tail>
 static constexpr bool __valid_args()
 { return (sizeof...(_Tail) + 2) == sizeof...(_Elements); }
# 591 "/usr/include/c++/10.2.0/tuple" 3
      template<typename _Tuple, typename = tuple,
        typename = __remove_cvref_t<_Tuple>>
 struct _UseOtherCtor
 : false_type
 { };


      template<typename _Tuple, typename _Tp, typename _Up>
 struct _UseOtherCtor<_Tuple, tuple<_Tp>, tuple<_Up>>
 : __or_<is_convertible<_Tuple, _Tp>, is_constructible<_Tp, _Tuple>>
 { };


      template<typename _Tuple, typename _Tp>
 struct _UseOtherCtor<_Tuple, tuple<_Tp>, tuple<_Tp>>
 : true_type
 { };




      template<typename _Tuple>
 static constexpr bool __use_other_ctor()
 { return _UseOtherCtor<_Tuple>::value; }

    public:
      template<typename _Dummy = void,
        _ImplicitDefaultCtor<is_void<_Dummy>::value> = true>
 constexpr
 tuple()
 noexcept(__and_<is_nothrow_default_constructible<_Elements>...>::value)
 : _Inherited() { }

      template<typename _Dummy = void,
        _ExplicitDefaultCtor<is_void<_Dummy>::value> = false>
 explicit constexpr
 tuple()
 noexcept(__and_<is_nothrow_default_constructible<_Elements>...>::value)
 : _Inherited() { }

      template<bool _NotEmpty = (sizeof...(_Elements) >= 1),
        _ImplicitCtor<_NotEmpty, const _Elements&...> = true>
 constexpr
 tuple(const _Elements&... __elements)
 noexcept(__nothrow_constructible<const _Elements&...>())
 : _Inherited(__elements...) { }

      template<bool _NotEmpty = (sizeof...(_Elements) >= 1),
        _ExplicitCtor<_NotEmpty, const _Elements&...> = false>
 explicit constexpr
 tuple(const _Elements&... __elements)
 noexcept(__nothrow_constructible<const _Elements&...>())
 : _Inherited(__elements...) { }

      template<typename... _UElements,
        bool _Valid = __valid_args<_UElements...>(),
        _ImplicitCtor<_Valid, _UElements...> = true>
 constexpr
 tuple(_UElements&&... __elements)
 noexcept(__nothrow_constructible<_UElements...>())
 : _Inherited(std::forward<_UElements>(__elements)...) { }

      template<typename... _UElements,
        bool _Valid = __valid_args<_UElements...>(),
        _ExplicitCtor<_Valid, _UElements...> = false>
 explicit constexpr
 tuple(_UElements&&... __elements)
 noexcept(__nothrow_constructible<_UElements...>())
 : _Inherited(std::forward<_UElements>(__elements)...) { }

      constexpr tuple(const tuple&) = default;

      constexpr tuple(tuple&&) = default;

      template<typename... _UElements,
        bool _Valid = (sizeof...(_Elements) == sizeof...(_UElements))
      && !__use_other_ctor<const tuple<_UElements...>&>(),
        _ImplicitCtor<_Valid, const _UElements&...> = true>
 constexpr
 tuple(const tuple<_UElements...>& __in)
 noexcept(__nothrow_constructible<const _UElements&...>())
 : _Inherited(static_cast<const _Tuple_impl<0, _UElements...>&>(__in))
 { }

      template<typename... _UElements,
        bool _Valid = (sizeof...(_Elements) == sizeof...(_UElements))
      && !__use_other_ctor<const tuple<_UElements...>&>(),
        _ExplicitCtor<_Valid, const _UElements&...> = false>
 explicit constexpr
 tuple(const tuple<_UElements...>& __in)
 noexcept(__nothrow_constructible<const _UElements&...>())
 : _Inherited(static_cast<const _Tuple_impl<0, _UElements...>&>(__in))
 { }

      template<typename... _UElements,
        bool _Valid = (sizeof...(_Elements) == sizeof...(_UElements))
        && !__use_other_ctor<tuple<_UElements...>&&>(),
        _ImplicitCtor<_Valid, _UElements...> = true>
 constexpr
 tuple(tuple<_UElements...>&& __in)
 noexcept(__nothrow_constructible<_UElements...>())
 : _Inherited(static_cast<_Tuple_impl<0, _UElements...>&&>(__in)) { }

      template<typename... _UElements,
        bool _Valid = (sizeof...(_Elements) == sizeof...(_UElements))
        && !__use_other_ctor<tuple<_UElements...>&&>(),
        _ExplicitCtor<_Valid, _UElements...> = false>
 explicit constexpr
 tuple(tuple<_UElements...>&& __in)
 noexcept(__nothrow_constructible<_UElements...>())
 : _Inherited(static_cast<_Tuple_impl<0, _UElements...>&&>(__in)) { }



      template<typename _Alloc,
        _ImplicitDefaultCtor<is_object<_Alloc>::value> = true>

 tuple(allocator_arg_t __tag, const _Alloc& __a)
 : _Inherited(__tag, __a) { }

      template<typename _Alloc, bool _NotEmpty = (sizeof...(_Elements) >= 1),
        _ImplicitCtor<_NotEmpty, const _Elements&...> = true>

 tuple(allocator_arg_t __tag, const _Alloc& __a,
       const _Elements&... __elements)
 : _Inherited(__tag, __a, __elements...) { }

      template<typename _Alloc, bool _NotEmpty = (sizeof...(_Elements) >= 1),
        _ExplicitCtor<_NotEmpty, const _Elements&...> = false>

 explicit
 tuple(allocator_arg_t __tag, const _Alloc& __a,
       const _Elements&... __elements)
 : _Inherited(__tag, __a, __elements...) { }

      template<typename _Alloc, typename... _UElements,
        bool _Valid = __valid_args<_UElements...>(),
        _ImplicitCtor<_Valid, _UElements...> = true>

 tuple(allocator_arg_t __tag, const _Alloc& __a,
       _UElements&&... __elements)
 : _Inherited(__tag, __a, std::forward<_UElements>(__elements)...)
 { }

      template<typename _Alloc, typename... _UElements,
   bool _Valid = __valid_args<_UElements...>(),
        _ExplicitCtor<_Valid, _UElements...> = false>

 explicit
 tuple(allocator_arg_t __tag, const _Alloc& __a,
       _UElements&&... __elements)
 : _Inherited(__tag, __a, std::forward<_UElements>(__elements)...)
 { }

      template<typename _Alloc>

 tuple(allocator_arg_t __tag, const _Alloc& __a, const tuple& __in)
 : _Inherited(__tag, __a, static_cast<const _Inherited&>(__in)) { }

      template<typename _Alloc>

 tuple(allocator_arg_t __tag, const _Alloc& __a, tuple&& __in)
 : _Inherited(__tag, __a, static_cast<_Inherited&&>(__in)) { }

      template<typename _Alloc, typename... _UElements,
        bool _Valid = (sizeof...(_Elements) == sizeof...(_UElements))
        && !__use_other_ctor<const tuple<_UElements...>&>(),
        _ImplicitCtor<_Valid, const _UElements&...> = true>

 tuple(allocator_arg_t __tag, const _Alloc& __a,
       const tuple<_UElements...>& __in)
 : _Inherited(__tag, __a,
              static_cast<const _Tuple_impl<0, _UElements...>&>(__in))
 { }

      template<typename _Alloc, typename... _UElements,
        bool _Valid = (sizeof...(_Elements) == sizeof...(_UElements))
        && !__use_other_ctor<const tuple<_UElements...>&>(),
        _ExplicitCtor<_Valid, const _UElements&...> = false>

 explicit
 tuple(allocator_arg_t __tag, const _Alloc& __a,
       const tuple<_UElements...>& __in)
 : _Inherited(__tag, __a,
              static_cast<const _Tuple_impl<0, _UElements...>&>(__in))
 { }

      template<typename _Alloc, typename... _UElements,
        bool _Valid = (sizeof...(_Elements) == sizeof...(_UElements))
        && !__use_other_ctor<tuple<_UElements...>&&>(),
        _ImplicitCtor<_Valid, _UElements...> = true>

 tuple(allocator_arg_t __tag, const _Alloc& __a,
       tuple<_UElements...>&& __in)
 : _Inherited(__tag, __a,
              static_cast<_Tuple_impl<0, _UElements...>&&>(__in))
 { }

      template<typename _Alloc, typename... _UElements,
        bool _Valid = (sizeof...(_Elements) == sizeof...(_UElements))
        && !__use_other_ctor<tuple<_UElements...>&&>(),
        _ExplicitCtor<_Valid, _UElements...> = false>

 explicit
 tuple(allocator_arg_t __tag, const _Alloc& __a,
       tuple<_UElements...>&& __in)
 : _Inherited(__tag, __a,
              static_cast<_Tuple_impl<0, _UElements...>&&>(__in))
 { }



     
      tuple&
      operator=(typename conditional<__assignable<const _Elements&...>(),
         const tuple&,
         const __nonesuch&>::type __in)
      noexcept(__nothrow_assignable<const _Elements&...>())
      {
 this->_M_assign(__in);
 return *this;
      }

     
      tuple&
      operator=(typename conditional<__assignable<_Elements...>(),
         tuple&&,
         __nonesuch&&>::type __in)
      noexcept(__nothrow_assignable<_Elements...>())
      {
 this->_M_assign(std::move(__in));
 return *this;
      }

      template<typename... _UElements>

 __enable_if_t<__assignable<const _UElements&...>(), tuple&>
 operator=(const tuple<_UElements...>& __in)
 noexcept(__nothrow_assignable<const _UElements&...>())
 {
   this->_M_assign(__in);
   return *this;
 }

      template<typename... _UElements>

 __enable_if_t<__assignable<_UElements...>(), tuple&>
 operator=(tuple<_UElements...>&& __in)
 noexcept(__nothrow_assignable<_UElements...>())
 {
   this->_M_assign(std::move(__in));
   return *this;
 }


     
      void
      swap(tuple& __in)
      noexcept(__and_<__is_nothrow_swappable<_Elements>...>::value)
      { _Inherited::_M_swap(__in); }
    };
# 867 "/usr/include/c++/10.2.0/tuple" 3
  template<>
    class tuple<>
    {
    public:
      void swap(tuple&) noexcept { }


      tuple() = default;

      template<typename _Alloc>

 tuple(allocator_arg_t, const _Alloc&) noexcept { }
      template<typename _Alloc>

 tuple(allocator_arg_t, const _Alloc&, const tuple&) noexcept { }
    };



  template<typename _T1, typename _T2>
    class tuple<_T1, _T2> : public _Tuple_impl<0, _T1, _T2>
    {
      typedef _Tuple_impl<0, _T1, _T2> _Inherited;


      template<bool _Dummy, typename _U1, typename _U2>
 using _ImplicitDefaultCtor = __enable_if_t<
   _TupleConstraints<_Dummy, _U1, _U2>::
     __is_implicitly_default_constructible(),
   bool>;


      template<bool _Dummy, typename _U1, typename _U2>
 using _ExplicitDefaultCtor = __enable_if_t<
   _TupleConstraints<_Dummy, _U1, _U2>::
     __is_explicitly_default_constructible(),
   bool>;

      template<bool _Dummy>
 using _TCC = _TupleConstraints<_Dummy, _T1, _T2>;


      template<bool _Cond, typename _U1, typename _U2>
 using _ImplicitCtor = __enable_if_t<
   _TCC<_Cond>::template __is_implicitly_constructible<_U1, _U2>(),
   bool>;


      template<bool _Cond, typename _U1, typename _U2>
 using _ExplicitCtor = __enable_if_t<
   _TCC<_Cond>::template __is_explicitly_constructible<_U1, _U2>(),
   bool>;

      template<typename _U1, typename _U2>
 static constexpr bool __assignable()
 {
   return __and_<is_assignable<_T1&, _U1>,
   is_assignable<_T2&, _U2>>::value;
 }

      template<typename _U1, typename _U2>
 static constexpr bool __nothrow_assignable()
 {
   return __and_<is_nothrow_assignable<_T1&, _U1>,
   is_nothrow_assignable<_T2&, _U2>>::value;
 }

      template<typename _U1, typename _U2>
 static constexpr bool __nothrow_constructible()
 {
   return __and_<is_nothrow_constructible<_T1, _U1>,
       is_nothrow_constructible<_T2, _U2>>::value;
 }

      static constexpr bool __nothrow_default_constructible()
      {
 return __and_<is_nothrow_default_constructible<_T1>,
        is_nothrow_default_constructible<_T2>>::value;
      }

      template<typename _U1>
 static constexpr bool __is_alloc_arg()
 { return is_same<__remove_cvref_t<_U1>, allocator_arg_t>::value; }

    public:
      template<bool _Dummy = true,
        _ImplicitDefaultCtor<_Dummy, _T1, _T2> = true>
 constexpr
 tuple()
 noexcept(__nothrow_default_constructible())
 : _Inherited() { }

      template<bool _Dummy = true,
        _ExplicitDefaultCtor<_Dummy, _T1, _T2> = false>
 explicit constexpr
 tuple()
 noexcept(__nothrow_default_constructible())
 : _Inherited() { }

      template<bool _Dummy = true,
        _ImplicitCtor<_Dummy, const _T1&, const _T2&> = true>
 constexpr
 tuple(const _T1& __a1, const _T2& __a2)
 noexcept(__nothrow_constructible<const _T1&, const _T2&>())
 : _Inherited(__a1, __a2) { }

      template<bool _Dummy = true,
        _ExplicitCtor<_Dummy, const _T1&, const _T2&> = false>
 explicit constexpr
 tuple(const _T1& __a1, const _T2& __a2)
 noexcept(__nothrow_constructible<const _T1&, const _T2&>())
 : _Inherited(__a1, __a2) { }

      template<typename _U1, typename _U2,
        _ImplicitCtor<!__is_alloc_arg<_U1>(), _U1, _U2> = true>
 constexpr
 tuple(_U1&& __a1, _U2&& __a2)
 noexcept(__nothrow_constructible<_U1, _U2>())
 : _Inherited(std::forward<_U1>(__a1), std::forward<_U2>(__a2)) { }

      template<typename _U1, typename _U2,
        _ExplicitCtor<!__is_alloc_arg<_U1>(), _U1, _U2> = false>
 explicit constexpr
 tuple(_U1&& __a1, _U2&& __a2)
 noexcept(__nothrow_constructible<_U1, _U2>())
 : _Inherited(std::forward<_U1>(__a1), std::forward<_U2>(__a2)) { }

      constexpr tuple(const tuple&) = default;

      constexpr tuple(tuple&&) = default;

      template<typename _U1, typename _U2,
        _ImplicitCtor<true, const _U1&, const _U2&> = true>
 constexpr
 tuple(const tuple<_U1, _U2>& __in)
 noexcept(__nothrow_constructible<const _U1&, const _U2&>())
 : _Inherited(static_cast<const _Tuple_impl<0, _U1, _U2>&>(__in)) { }

      template<typename _U1, typename _U2,
        _ExplicitCtor<true, const _U1&, const _U2&> = false>
 explicit constexpr
 tuple(const tuple<_U1, _U2>& __in)
 noexcept(__nothrow_constructible<const _U1&, const _U2&>())
 : _Inherited(static_cast<const _Tuple_impl<0, _U1, _U2>&>(__in)) { }

      template<typename _U1, typename _U2,
        _ImplicitCtor<true, _U1, _U2> = true>
 constexpr
 tuple(tuple<_U1, _U2>&& __in)
 noexcept(__nothrow_constructible<_U1, _U2>())
 : _Inherited(static_cast<_Tuple_impl<0, _U1, _U2>&&>(__in)) { }

      template<typename _U1, typename _U2,
        _ExplicitCtor<true, _U1, _U2> = false>
 explicit constexpr
 tuple(tuple<_U1, _U2>&& __in)
 noexcept(__nothrow_constructible<_U1, _U2>())
 : _Inherited(static_cast<_Tuple_impl<0, _U1, _U2>&&>(__in)) { }

      template<typename _U1, typename _U2,
        _ImplicitCtor<true, const _U1&, const _U2&> = true>
 constexpr
 tuple(const pair<_U1, _U2>& __in)
 noexcept(__nothrow_constructible<const _U1&, const _U2&>())
 : _Inherited(__in.first, __in.second) { }

      template<typename _U1, typename _U2,
        _ExplicitCtor<true, const _U1&, const _U2&> = false>
 explicit constexpr
 tuple(const pair<_U1, _U2>& __in)
 noexcept(__nothrow_constructible<const _U1&, const _U2&>())
 : _Inherited(__in.first, __in.second) { }

      template<typename _U1, typename _U2,
        _ImplicitCtor<true, _U1, _U2> = true>
 constexpr
 tuple(pair<_U1, _U2>&& __in)
 noexcept(__nothrow_constructible<_U1, _U2>())
 : _Inherited(std::forward<_U1>(__in.first),
       std::forward<_U2>(__in.second)) { }

      template<typename _U1, typename _U2,
        _ExplicitCtor<true, _U1, _U2> = false>
 explicit constexpr
 tuple(pair<_U1, _U2>&& __in)
 noexcept(__nothrow_constructible<_U1, _U2>())
 : _Inherited(std::forward<_U1>(__in.first),
       std::forward<_U2>(__in.second)) { }



      template<typename _Alloc,
        _ImplicitDefaultCtor<is_object<_Alloc>::value, _T1, _T2> = true>

 tuple(allocator_arg_t __tag, const _Alloc& __a)
 : _Inherited(__tag, __a) { }

      template<typename _Alloc, bool _Dummy = true,
        _ImplicitCtor<_Dummy, const _T1&, const _T2&> = true>

 tuple(allocator_arg_t __tag, const _Alloc& __a,
       const _T1& __a1, const _T2& __a2)
 : _Inherited(__tag, __a, __a1, __a2) { }

      template<typename _Alloc, bool _Dummy = true,
        _ExplicitCtor<_Dummy, const _T1&, const _T2&> = false>
 explicit

 tuple(allocator_arg_t __tag, const _Alloc& __a,
       const _T1& __a1, const _T2& __a2)
 : _Inherited(__tag, __a, __a1, __a2) { }

      template<typename _Alloc, typename _U1, typename _U2,
        _ImplicitCtor<true, _U1, _U2> = true>

 tuple(allocator_arg_t __tag, const _Alloc& __a, _U1&& __a1, _U2&& __a2)
 : _Inherited(__tag, __a, std::forward<_U1>(__a1),
              std::forward<_U2>(__a2)) { }

      template<typename _Alloc, typename _U1, typename _U2,
        _ExplicitCtor<true, _U1, _U2> = false>
 explicit

 tuple(allocator_arg_t __tag, const _Alloc& __a,
       _U1&& __a1, _U2&& __a2)
 : _Inherited(__tag, __a, std::forward<_U1>(__a1),
              std::forward<_U2>(__a2)) { }

      template<typename _Alloc>

 tuple(allocator_arg_t __tag, const _Alloc& __a, const tuple& __in)
 : _Inherited(__tag, __a, static_cast<const _Inherited&>(__in)) { }

      template<typename _Alloc>

 tuple(allocator_arg_t __tag, const _Alloc& __a, tuple&& __in)
 : _Inherited(__tag, __a, static_cast<_Inherited&&>(__in)) { }

      template<typename _Alloc, typename _U1, typename _U2,
        _ImplicitCtor<true, const _U1&, const _U2&> = true>

 tuple(allocator_arg_t __tag, const _Alloc& __a,
       const tuple<_U1, _U2>& __in)
 : _Inherited(__tag, __a,
              static_cast<const _Tuple_impl<0, _U1, _U2>&>(__in))
 { }

      template<typename _Alloc, typename _U1, typename _U2,
        _ExplicitCtor<true, const _U1&, const _U2&> = false>
 explicit

 tuple(allocator_arg_t __tag, const _Alloc& __a,
       const tuple<_U1, _U2>& __in)
 : _Inherited(__tag, __a,
              static_cast<const _Tuple_impl<0, _U1, _U2>&>(__in))
 { }

      template<typename _Alloc, typename _U1, typename _U2,
        _ImplicitCtor<true, _U1, _U2> = true>

 tuple(allocator_arg_t __tag, const _Alloc& __a, tuple<_U1, _U2>&& __in)
 : _Inherited(__tag, __a, static_cast<_Tuple_impl<0, _U1, _U2>&&>(__in))
 { }

      template<typename _Alloc, typename _U1, typename _U2,
        _ExplicitCtor<true, _U1, _U2> = false>
 explicit

 tuple(allocator_arg_t __tag, const _Alloc& __a, tuple<_U1, _U2>&& __in)
 : _Inherited(__tag, __a, static_cast<_Tuple_impl<0, _U1, _U2>&&>(__in))
 { }

      template<typename _Alloc, typename _U1, typename _U2,
        _ImplicitCtor<true, const _U1&, const _U2&> = true>

 tuple(allocator_arg_t __tag, const _Alloc& __a,
       const pair<_U1, _U2>& __in)
 : _Inherited(__tag, __a, __in.first, __in.second) { }

      template<typename _Alloc, typename _U1, typename _U2,
        _ExplicitCtor<true, const _U1&, const _U2&> = false>
 explicit

 tuple(allocator_arg_t __tag, const _Alloc& __a,
       const pair<_U1, _U2>& __in)
 : _Inherited(__tag, __a, __in.first, __in.second) { }

      template<typename _Alloc, typename _U1, typename _U2,
        _ImplicitCtor<true, _U1, _U2> = true>

 tuple(allocator_arg_t __tag, const _Alloc& __a, pair<_U1, _U2>&& __in)
 : _Inherited(__tag, __a, std::forward<_U1>(__in.first),
       std::forward<_U2>(__in.second)) { }

      template<typename _Alloc, typename _U1, typename _U2,
        _ExplicitCtor<true, _U1, _U2> = false>
 explicit

 tuple(allocator_arg_t __tag, const _Alloc& __a, pair<_U1, _U2>&& __in)
 : _Inherited(__tag, __a, std::forward<_U1>(__in.first),
       std::forward<_U2>(__in.second)) { }



     
      tuple&
      operator=(typename conditional<__assignable<const _T1&, const _T2&>(),
         const tuple&,
         const __nonesuch&>::type __in)
      noexcept(__nothrow_assignable<const _T1&, const _T2&>())
      {
 this->_M_assign(__in);
 return *this;
      }

     
      tuple&
      operator=(typename conditional<__assignable<_T1, _T2>(),
         tuple&&,
         __nonesuch&&>::type __in)
      noexcept(__nothrow_assignable<_T1, _T2>())
      {
 this->_M_assign(std::move(__in));
 return *this;
      }

      template<typename _U1, typename _U2>

 __enable_if_t<__assignable<const _U1&, const _U2&>(), tuple&>
 operator=(const tuple<_U1, _U2>& __in)
 noexcept(__nothrow_assignable<const _U1&, const _U2&>())
 {
   this->_M_assign(__in);
   return *this;
 }

      template<typename _U1, typename _U2>

 __enable_if_t<__assignable<_U1, _U2>(), tuple&>
 operator=(tuple<_U1, _U2>&& __in)
 noexcept(__nothrow_assignable<_U1, _U2>())
 {
   this->_M_assign(std::move(__in));
   return *this;
 }

      template<typename _U1, typename _U2>

 __enable_if_t<__assignable<const _U1&, const _U2&>(), tuple&>
 operator=(const pair<_U1, _U2>& __in)
 noexcept(__nothrow_assignable<const _U1&, const _U2&>())
 {
   this->_M_head(*this) = __in.first;
   this->_M_tail(*this)._M_head(*this) = __in.second;
   return *this;
 }

      template<typename _U1, typename _U2>

 __enable_if_t<__assignable<_U1, _U2>(), tuple&>
 operator=(pair<_U1, _U2>&& __in)
 noexcept(__nothrow_assignable<_U1, _U2>())
 {
   this->_M_head(*this) = std::forward<_U1>(__in.first);
   this->_M_tail(*this)._M_head(*this) = std::forward<_U2>(__in.second);
   return *this;
 }

     
      void
      swap(tuple& __in)
      noexcept(__and_<__is_nothrow_swappable<_T1>,
        __is_nothrow_swappable<_T2>>::value)
      { _Inherited::_M_swap(__in); }
    };



  template<typename... _Elements>
    struct tuple_size<tuple<_Elements...>>
    : public integral_constant<std::size_t, sizeof...(_Elements)> { };
# 1258 "/usr/include/c++/10.2.0/tuple" 3
  template<std::size_t __i, typename _Head, typename... _Tail>
    struct tuple_element<__i, tuple<_Head, _Tail...> >
    : tuple_element<__i - 1, tuple<_Tail...> > { };




  template<typename _Head, typename... _Tail>
    struct tuple_element<0, tuple<_Head, _Tail...> >
    {
      typedef _Head type;
    };




  template<size_t __i>
    struct tuple_element<__i, tuple<>>
    {
      static_assert(__i < tuple_size<tuple<>>::value,
   "tuple index is in range");
    };

  template<std::size_t __i, typename _Head, typename... _Tail>
    constexpr _Head&
    __get_helper(_Tuple_impl<__i, _Head, _Tail...>& __t) noexcept
    { return _Tuple_impl<__i, _Head, _Tail...>::_M_head(__t); }

  template<std::size_t __i, typename _Head, typename... _Tail>
    constexpr const _Head&
    __get_helper(const _Tuple_impl<__i, _Head, _Tail...>& __t) noexcept
    { return _Tuple_impl<__i, _Head, _Tail...>::_M_head(__t); }


  template<std::size_t __i, typename... _Elements>
    constexpr __tuple_element_t<__i, tuple<_Elements...>>&
    get(tuple<_Elements...>& __t) noexcept
    { return std::__get_helper<__i>(__t); }


  template<std::size_t __i, typename... _Elements>
    constexpr const __tuple_element_t<__i, tuple<_Elements...>>&
    get(const tuple<_Elements...>& __t) noexcept
    { return std::__get_helper<__i>(__t); }


  template<std::size_t __i, typename... _Elements>
    constexpr __tuple_element_t<__i, tuple<_Elements...>>&&
    get(tuple<_Elements...>&& __t) noexcept
    {
      typedef __tuple_element_t<__i, tuple<_Elements...>> __element_type;
      return std::forward<__element_type&&>(std::get<__i>(__t));
    }


  template<std::size_t __i, typename... _Elements>
    constexpr const __tuple_element_t<__i, tuple<_Elements...>>&&
    get(const tuple<_Elements...>&& __t) noexcept
    {
      typedef __tuple_element_t<__i, tuple<_Elements...>> __element_type;
      return std::forward<const __element_type&&>(std::get<__i>(__t));
    }
# 1362 "/usr/include/c++/10.2.0/tuple" 3
  template<typename _Tp, typename _Up, size_t __i, size_t __size>
    struct __tuple_compare
    {
      static constexpr bool
      __eq(const _Tp& __t, const _Up& __u)
      {
 return bool(std::get<__i>(__t) == std::get<__i>(__u))
   && __tuple_compare<_Tp, _Up, __i + 1, __size>::__eq(__t, __u);
      }

      static constexpr bool
      __less(const _Tp& __t, const _Up& __u)
      {
 return bool(std::get<__i>(__t) < std::get<__i>(__u))
   || (!bool(std::get<__i>(__u) < std::get<__i>(__t))
       && __tuple_compare<_Tp, _Up, __i + 1, __size>::__less(__t, __u));
      }
    };

  template<typename _Tp, typename _Up, size_t __size>
    struct __tuple_compare<_Tp, _Up, __size, __size>
    {
      static constexpr bool
      __eq(const _Tp&, const _Up&) { return true; }

      static constexpr bool
      __less(const _Tp&, const _Up&) { return false; }
    };

  template<typename... _TElements, typename... _UElements>
    constexpr bool
    operator==(const tuple<_TElements...>& __t,
        const tuple<_UElements...>& __u)
    {
      static_assert(sizeof...(_TElements) == sizeof...(_UElements),
   "tuple objects can only be compared if they have equal sizes.");
      using __compare = __tuple_compare<tuple<_TElements...>,
     tuple<_UElements...>,
     0, sizeof...(_TElements)>;
      return __compare::__eq(__t, __u);
    }
# 1433 "/usr/include/c++/10.2.0/tuple" 3
  template<typename... _TElements, typename... _UElements>
    constexpr bool
    operator<(const tuple<_TElements...>& __t,
       const tuple<_UElements...>& __u)
    {
      static_assert(sizeof...(_TElements) == sizeof...(_UElements),
   "tuple objects can only be compared if they have equal sizes.");
      using __compare = __tuple_compare<tuple<_TElements...>,
     tuple<_UElements...>,
     0, sizeof...(_TElements)>;
      return __compare::__less(__t, __u);
    }

  template<typename... _TElements, typename... _UElements>
    constexpr bool
    operator!=(const tuple<_TElements...>& __t,
        const tuple<_UElements...>& __u)
    { return !(__t == __u); }

  template<typename... _TElements, typename... _UElements>
    constexpr bool
    operator>(const tuple<_TElements...>& __t,
       const tuple<_UElements...>& __u)
    { return __u < __t; }

  template<typename... _TElements, typename... _UElements>
    constexpr bool
    operator<=(const tuple<_TElements...>& __t,
        const tuple<_UElements...>& __u)
    { return !(__u < __t); }

  template<typename... _TElements, typename... _UElements>
    constexpr bool
    operator>=(const tuple<_TElements...>& __t,
        const tuple<_UElements...>& __u)
    { return !(__t < __u); }



  template<typename... _Elements>
    constexpr tuple<typename __decay_and_strip<_Elements>::__type...>
    make_tuple(_Elements&&... __args)
    {
      typedef tuple<typename __decay_and_strip<_Elements>::__type...>
 __result_type;
      return __result_type(std::forward<_Elements>(__args)...);
    }




  template<typename... _Elements>
    constexpr tuple<_Elements&&...>
    forward_as_tuple(_Elements&&... __args) noexcept
    { return tuple<_Elements&&...>(std::forward<_Elements>(__args)...); }

  template<size_t, typename, typename, size_t>
    struct __make_tuple_impl;

  template<size_t _Idx, typename _Tuple, typename... _Tp, size_t _Nm>
    struct __make_tuple_impl<_Idx, tuple<_Tp...>, _Tuple, _Nm>
    : __make_tuple_impl<_Idx + 1,
   tuple<_Tp..., __tuple_element_t<_Idx, _Tuple>>,
   _Tuple, _Nm>
    { };

  template<std::size_t _Nm, typename _Tuple, typename... _Tp>
    struct __make_tuple_impl<_Nm, tuple<_Tp...>, _Tuple, _Nm>
    {
      typedef tuple<_Tp...> __type;
    };

  template<typename _Tuple>
    struct __do_make_tuple
    : __make_tuple_impl<0, tuple<>, _Tuple, std::tuple_size<_Tuple>::value>
    { };


  template<typename _Tuple>
    struct __make_tuple
    : public __do_make_tuple<__remove_cvref_t<_Tuple>>
    { };


  template<typename...>
    struct __combine_tuples;

  template<>
    struct __combine_tuples<>
    {
      typedef tuple<> __type;
    };

  template<typename... _Ts>
    struct __combine_tuples<tuple<_Ts...>>
    {
      typedef tuple<_Ts...> __type;
    };

  template<typename... _T1s, typename... _T2s, typename... _Rem>
    struct __combine_tuples<tuple<_T1s...>, tuple<_T2s...>, _Rem...>
    {
      typedef typename __combine_tuples<tuple<_T1s..., _T2s...>,
     _Rem...>::__type __type;
    };


  template<typename... _Tpls>
    struct __tuple_cat_result
    {
      typedef typename __combine_tuples
        <typename __make_tuple<_Tpls>::__type...>::__type __type;
    };



  template<typename...>
    struct __make_1st_indices;

  template<>
    struct __make_1st_indices<>
    {
      typedef std::_Index_tuple<> __type;
    };

  template<typename _Tp, typename... _Tpls>
    struct __make_1st_indices<_Tp, _Tpls...>
    {
      typedef typename std::_Build_index_tuple<std::tuple_size<
 typename std::remove_reference<_Tp>::type>::value>::__type __type;
    };




  template<typename _Ret, typename _Indices, typename... _Tpls>
    struct __tuple_concater;

  template<typename _Ret, std::size_t... _Is, typename _Tp, typename... _Tpls>
    struct __tuple_concater<_Ret, std::_Index_tuple<_Is...>, _Tp, _Tpls...>
    {
      template<typename... _Us>
        static constexpr _Ret
        _S_do(_Tp&& __tp, _Tpls&&... __tps, _Us&&... __us)
        {
   typedef typename __make_1st_indices<_Tpls...>::__type __idx;
   typedef __tuple_concater<_Ret, __idx, _Tpls...> __next;
   return __next::_S_do(std::forward<_Tpls>(__tps)...,
          std::forward<_Us>(__us)...,
          std::get<_Is>(std::forward<_Tp>(__tp))...);
 }
    };

  template<typename _Ret>
    struct __tuple_concater<_Ret, std::_Index_tuple<>>
    {
      template<typename... _Us>
 static constexpr _Ret
 _S_do(_Us&&... __us)
        {
   return _Ret(std::forward<_Us>(__us)...);
 }
    };


  template<typename... _Tpls, typename = typename
           enable_if<__and_<__is_tuple_like<_Tpls>...>::value>::type>
    constexpr auto
    tuple_cat(_Tpls&&... __tpls)
    -> typename __tuple_cat_result<_Tpls...>::__type
    {
      typedef typename __tuple_cat_result<_Tpls...>::__type __ret;
      typedef typename __make_1st_indices<_Tpls...>::__type __idx;
      typedef __tuple_concater<__ret, __idx, _Tpls...> __concater;
      return __concater::_S_do(std::forward<_Tpls>(__tpls)...);
    }




  template<typename... _Elements>
    constexpr tuple<_Elements&...>
    tie(_Elements&... __args) noexcept
    { return tuple<_Elements&...>(__args...); }


  template<typename... _Elements>
   
    inline





    void

    swap(tuple<_Elements...>& __x, tuple<_Elements...>& __y)
    noexcept(noexcept(__x.swap(__y)))
    { __x.swap(__y); }
# 1644 "/usr/include/c++/10.2.0/tuple" 3
  struct _Swallow_assign
  {
    template<class _Tp>
      const _Swallow_assign&
      operator=(const _Tp&) const
      { return *this; }
  };



  constexpr _Swallow_assign ignore{};


  template<typename... _Types, typename _Alloc>
    struct uses_allocator<tuple<_Types...>, _Alloc> : true_type { };
# 1669 "/usr/include/c++/10.2.0/tuple" 3
  template<class _T1, class _T2>
    template<typename... _Args1, typename... _Args2>
     
      inline
      pair<_T1, _T2>::
      pair(piecewise_construct_t,
    tuple<_Args1...> __first, tuple<_Args2...> __second)
      : pair(__first, __second,
      typename _Build_index_tuple<sizeof...(_Args1)>::__type(),
      typename _Build_index_tuple<sizeof...(_Args2)>::__type())
      { }

  template<class _T1, class _T2>
    template<typename... _Args1, std::size_t... _Indexes1,
             typename... _Args2, std::size_t... _Indexes2>
      inline
      pair<_T1, _T2>::
      pair(tuple<_Args1...>& __tuple1, tuple<_Args2...>& __tuple2,
    _Index_tuple<_Indexes1...>, _Index_tuple<_Indexes2...>)
      : first(std::forward<_Args1>(std::get<_Indexes1>(__tuple1))...),
        second(std::forward<_Args2>(std::get<_Indexes2>(__tuple2))...)
      { }
# 1759 "/usr/include/c++/10.2.0/tuple" 3

}
# 38 "/usr/include/c++/10.2.0/bits/unique_ptr.h" 2 3







namespace std __attribute__ ((__visibility__ ("default")))
{








#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
  template<typename> class auto_ptr;
#pragma GCC diagnostic pop



  template<typename _Tp>
    struct default_delete
    {

      constexpr default_delete() noexcept = default;






      template<typename _Up,
        typename = _Require<is_convertible<_Up*, _Tp*>>>
        default_delete(const default_delete<_Up>&) noexcept { }


      void
      operator()(_Tp* __ptr) const
      {
 static_assert(!is_void<_Tp>::value,
        "can't delete pointer to incomplete type");
 static_assert(sizeof(_Tp)>0,
        "can't delete pointer to incomplete type");
 delete __ptr;
      }
    };





  template<typename _Tp>
    struct default_delete<_Tp[]>
    {
    public:

      constexpr default_delete() noexcept = default;
# 109 "/usr/include/c++/10.2.0/bits/unique_ptr.h" 3
      template<typename _Up,
        typename = _Require<is_convertible<_Up(*)[], _Tp(*)[]>>>
        default_delete(const default_delete<_Up[]>&) noexcept { }


      template<typename _Up>
 typename enable_if<is_convertible<_Up(*)[], _Tp(*)[]>::value>::type
 operator()(_Up* __ptr) const
 {
   static_assert(sizeof(_Tp)>0,
   "can't delete pointer to incomplete type");
   delete [] __ptr;
 }
    };




  template <typename _Tp, typename _Dp>
    class __uniq_ptr_impl
    {
      template <typename _Up, typename _Ep, typename = void>
 struct _Ptr
 {
   using type = _Up*;
 };

      template <typename _Up, typename _Ep>
 struct
 _Ptr<_Up, _Ep, __void_t<typename remove_reference<_Ep>::type::pointer>>
 {
   using type = typename remove_reference<_Ep>::type::pointer;
 };

    public:
      using _DeleterConstraint = enable_if<
        __and_<__not_<is_pointer<_Dp>>,
        is_default_constructible<_Dp>>::value>;

      using pointer = typename _Ptr<_Tp, _Dp>::type;

      static_assert( !is_rvalue_reference<_Dp>::value,
       "unique_ptr's deleter type must be a function object type"
       " or an lvalue reference type" );

      __uniq_ptr_impl() = default;
      __uniq_ptr_impl(pointer __p) : _M_t() { _M_ptr() = __p; }

      template<typename _Del>
      __uniq_ptr_impl(pointer __p, _Del&& __d)
 : _M_t(__p, std::forward<_Del>(__d)) { }

      __uniq_ptr_impl(__uniq_ptr_impl&& __u) noexcept
      : _M_t(std::move(__u._M_t))
      { __u._M_ptr() = nullptr; }

      __uniq_ptr_impl& operator=(__uniq_ptr_impl&& __u) noexcept
      {
 reset(__u.release());
 _M_deleter() = std::forward<_Dp>(__u._M_deleter());
 return *this;
      }

      pointer& _M_ptr() { return std::get<0>(_M_t); }
      pointer _M_ptr() const { return std::get<0>(_M_t); }
      _Dp& _M_deleter() { return std::get<1>(_M_t); }
      const _Dp& _M_deleter() const { return std::get<1>(_M_t); }

      void reset(pointer __p) noexcept
      {
 const pointer __old_p = _M_ptr();
 _M_ptr() = __p;
 if (__old_p)
   _M_deleter()(__old_p);
      }

      pointer release() noexcept
      {
 pointer __p = _M_ptr();
 _M_ptr() = nullptr;
 return __p;
      }

      void
      swap(__uniq_ptr_impl& __rhs) noexcept
      {
 using std::swap;
 swap(this->_M_ptr(), __rhs._M_ptr());
 swap(this->_M_deleter(), __rhs._M_deleter());
      }

    private:
      tuple<pointer, _Dp> _M_t;
    };


  template <typename _Tp, typename _Dp,
     bool = is_move_constructible<_Dp>::value,
     bool = is_move_assignable<_Dp>::value>
    struct __uniq_ptr_data : __uniq_ptr_impl<_Tp, _Dp>
    {
      using __uniq_ptr_impl<_Tp, _Dp>::__uniq_ptr_impl;
      __uniq_ptr_data(__uniq_ptr_data&&) = default;
      __uniq_ptr_data& operator=(__uniq_ptr_data&&) = default;
    };

  template <typename _Tp, typename _Dp>
    struct __uniq_ptr_data<_Tp, _Dp, true, false> : __uniq_ptr_impl<_Tp, _Dp>
    {
      using __uniq_ptr_impl<_Tp, _Dp>::__uniq_ptr_impl;
      __uniq_ptr_data(__uniq_ptr_data&&) = default;
      __uniq_ptr_data& operator=(__uniq_ptr_data&&) = delete;
    };

  template <typename _Tp, typename _Dp>
    struct __uniq_ptr_data<_Tp, _Dp, false, true> : __uniq_ptr_impl<_Tp, _Dp>
    {
      using __uniq_ptr_impl<_Tp, _Dp>::__uniq_ptr_impl;
      __uniq_ptr_data(__uniq_ptr_data&&) = delete;
      __uniq_ptr_data& operator=(__uniq_ptr_data&&) = default;
    };

  template <typename _Tp, typename _Dp>
    struct __uniq_ptr_data<_Tp, _Dp, false, false> : __uniq_ptr_impl<_Tp, _Dp>
    {
      using __uniq_ptr_impl<_Tp, _Dp>::__uniq_ptr_impl;
      __uniq_ptr_data(__uniq_ptr_data&&) = delete;
      __uniq_ptr_data& operator=(__uniq_ptr_data&&) = delete;
    };



  template <typename _Tp, typename _Dp = default_delete<_Tp>>
    class unique_ptr
    {
      template <typename _Up>
 using _DeleterConstraint =
   typename __uniq_ptr_impl<_Tp, _Up>::_DeleterConstraint::type;

      __uniq_ptr_data<_Tp, _Dp> _M_t;

    public:
      using pointer = typename __uniq_ptr_impl<_Tp, _Dp>::pointer;
      using element_type = _Tp;
      using deleter_type = _Dp;

    private:


      template<typename _Up, typename _Ep>
 using __safe_conversion_up = __and_<
   is_convertible<typename unique_ptr<_Up, _Ep>::pointer, pointer>,
   __not_<is_array<_Up>>
        >;

    public:



      template<typename _Del = _Dp, typename = _DeleterConstraint<_Del>>
 constexpr unique_ptr() noexcept
 : _M_t()
 { }







      template<typename _Del = _Dp, typename = _DeleterConstraint<_Del>>
 explicit
 unique_ptr(pointer __p) noexcept
 : _M_t(__p)
        { }
# 292 "/usr/include/c++/10.2.0/bits/unique_ptr.h" 3
      template<typename _Del = deleter_type,
        typename = _Require<is_copy_constructible<_Del>>>
 unique_ptr(pointer __p, const deleter_type& __d) noexcept
 : _M_t(__p, __d) { }
# 304 "/usr/include/c++/10.2.0/bits/unique_ptr.h" 3
      template<typename _Del = deleter_type,
        typename = _Require<is_move_constructible<_Del>>>
 unique_ptr(pointer __p,
     __enable_if_t<!is_lvalue_reference<_Del>::value,
     _Del&&> __d) noexcept
 : _M_t(__p, std::move(__d))
 { }

      template<typename _Del = deleter_type,
        typename _DelUnref = typename remove_reference<_Del>::type>
 unique_ptr(pointer,
     __enable_if_t<is_lvalue_reference<_Del>::value,
     _DelUnref&&>) = delete;


      template<typename _Del = _Dp, typename = _DeleterConstraint<_Del>>
 constexpr unique_ptr(nullptr_t) noexcept
 : _M_t()
 { }




      unique_ptr(unique_ptr&&) = default;







      template<typename _Up, typename _Ep, typename = _Require<
               __safe_conversion_up<_Up, _Ep>,
        typename conditional<is_reference<_Dp>::value,
        is_same<_Ep, _Dp>,
        is_convertible<_Ep, _Dp>>::type>>
 unique_ptr(unique_ptr<_Up, _Ep>&& __u) noexcept
 : _M_t(__u.release(), std::forward<_Ep>(__u.get_deleter()))
 { }


#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"

      template<typename _Up, typename = _Require<
        is_convertible<_Up*, _Tp*>, is_same<_Dp, default_delete<_Tp>>>>
 unique_ptr(auto_ptr<_Up>&& __u) noexcept;
#pragma GCC diagnostic pop



      ~unique_ptr() noexcept
      {
 static_assert(__is_invocable<deleter_type&, pointer>::value,
        "unique_ptr's deleter must be invocable with a pointer");
 auto& __ptr = _M_t._M_ptr();
 if (__ptr != nullptr)
   get_deleter()(std::move(__ptr));
 __ptr = pointer();
      }







      unique_ptr& operator=(unique_ptr&&) = default;
# 380 "/usr/include/c++/10.2.0/bits/unique_ptr.h" 3
      template<typename _Up, typename _Ep>
        typename enable_if< __and_<
          __safe_conversion_up<_Up, _Ep>,
          is_assignable<deleter_type&, _Ep&&>
          >::value,
          unique_ptr&>::type
 operator=(unique_ptr<_Up, _Ep>&& __u) noexcept
 {
   reset(__u.release());
   get_deleter() = std::forward<_Ep>(__u.get_deleter());
   return *this;
 }


      unique_ptr&
      operator=(nullptr_t) noexcept
      {
 reset();
 return *this;
      }




      typename add_lvalue_reference<element_type>::type
      operator*() const
      {
 ;
 return *get();
      }


      pointer
      operator->() const noexcept
      {
 ;
 return get();
      }


      pointer
      get() const noexcept
      { return _M_t._M_ptr(); }


      deleter_type&
      get_deleter() noexcept
      { return _M_t._M_deleter(); }


      const deleter_type&
      get_deleter() const noexcept
      { return _M_t._M_deleter(); }


      explicit operator bool() const noexcept
      { return get() == pointer() ? false : true; }




      pointer
      release() noexcept
      { return _M_t.release(); }







      void
      reset(pointer __p = pointer()) noexcept
      {
 static_assert(__is_invocable<deleter_type&, pointer>::value,
        "unique_ptr's deleter must be invocable with a pointer");
 _M_t.reset(std::move(__p));
      }


      void
      swap(unique_ptr& __u) noexcept
      {
 static_assert(__is_swappable<_Dp>::value, "deleter must be swappable");
 _M_t.swap(__u._M_t);
      }


      unique_ptr(const unique_ptr&) = delete;
      unique_ptr& operator=(const unique_ptr&) = delete;
  };





  template<typename _Tp, typename _Dp>
    class unique_ptr<_Tp[], _Dp>
    {
      template <typename _Up>
      using _DeleterConstraint =
 typename __uniq_ptr_impl<_Tp, _Up>::_DeleterConstraint::type;

      __uniq_ptr_data<_Tp, _Dp> _M_t;

      template<typename _Up>
 using __remove_cv = typename remove_cv<_Up>::type;


      template<typename _Up>
 using __is_derived_Tp
   = __and_< is_base_of<_Tp, _Up>,
      __not_<is_same<__remove_cv<_Tp>, __remove_cv<_Up>>> >;

    public:
      using pointer = typename __uniq_ptr_impl<_Tp, _Dp>::pointer;
      using element_type = _Tp;
      using deleter_type = _Dp;



      template<typename _Up, typename _Ep,
               typename _UPtr = unique_ptr<_Up, _Ep>,
        typename _UP_pointer = typename _UPtr::pointer,
        typename _UP_element_type = typename _UPtr::element_type>
 using __safe_conversion_up = __and_<
          is_array<_Up>,
          is_same<pointer, element_type*>,
          is_same<_UP_pointer, _UP_element_type*>,
          is_convertible<_UP_element_type(*)[], element_type(*)[]>
        >;


      template<typename _Up>
        using __safe_conversion_raw = __and_<
          __or_<__or_<is_same<_Up, pointer>,
                      is_same<_Up, nullptr_t>>,
                __and_<is_pointer<_Up>,
                       is_same<pointer, element_type*>,
                       is_convertible<
                         typename remove_pointer<_Up>::type(*)[],
                         element_type(*)[]>
                >
          >
        >;




      template<typename _Del = _Dp, typename = _DeleterConstraint<_Del>>
 constexpr unique_ptr() noexcept
 : _M_t()
 { }
# 541 "/usr/include/c++/10.2.0/bits/unique_ptr.h" 3
      template<typename _Up,
        typename _Vp = _Dp,
        typename = _DeleterConstraint<_Vp>,
        typename = typename enable_if<
                 __safe_conversion_raw<_Up>::value, bool>::type>
 explicit
 unique_ptr(_Up __p) noexcept
 : _M_t(__p)
        { }
# 559 "/usr/include/c++/10.2.0/bits/unique_ptr.h" 3
      template<typename _Up, typename _Del = deleter_type,
        typename = _Require<__safe_conversion_raw<_Up>,
       is_copy_constructible<_Del>>>
      unique_ptr(_Up __p, const deleter_type& __d) noexcept
      : _M_t(__p, __d) { }
# 573 "/usr/include/c++/10.2.0/bits/unique_ptr.h" 3
      template<typename _Up, typename _Del = deleter_type,
        typename = _Require<__safe_conversion_raw<_Up>,
       is_move_constructible<_Del>>>
 unique_ptr(_Up __p,
     __enable_if_t<!is_lvalue_reference<_Del>::value,
     _Del&&> __d) noexcept
 : _M_t(std::move(__p), std::move(__d))
 { }

      template<typename _Up, typename _Del = deleter_type,
        typename _DelUnref = typename remove_reference<_Del>::type,
        typename = _Require<__safe_conversion_raw<_Up>>>
 unique_ptr(_Up,
     __enable_if_t<is_lvalue_reference<_Del>::value,
     _DelUnref&&>) = delete;


      unique_ptr(unique_ptr&&) = default;


      template<typename _Del = _Dp, typename = _DeleterConstraint<_Del>>
 constexpr unique_ptr(nullptr_t) noexcept
 : _M_t()
        { }

      template<typename _Up, typename _Ep, typename = _Require<
        __safe_conversion_up<_Up, _Ep>,
        typename conditional<is_reference<_Dp>::value,
        is_same<_Ep, _Dp>,
        is_convertible<_Ep, _Dp>>::type>>
 unique_ptr(unique_ptr<_Up, _Ep>&& __u) noexcept
 : _M_t(__u.release(), std::forward<_Ep>(__u.get_deleter()))
 { }


      ~unique_ptr()
      {
 auto& __ptr = _M_t._M_ptr();
 if (__ptr != nullptr)
   get_deleter()(__ptr);
 __ptr = pointer();
      }







      unique_ptr&
      operator=(unique_ptr&&) = default;
# 632 "/usr/include/c++/10.2.0/bits/unique_ptr.h" 3
      template<typename _Up, typename _Ep>
 typename
 enable_if<__and_<__safe_conversion_up<_Up, _Ep>,
                         is_assignable<deleter_type&, _Ep&&>
                  >::value,
                  unique_ptr&>::type
 operator=(unique_ptr<_Up, _Ep>&& __u) noexcept
 {
   reset(__u.release());
   get_deleter() = std::forward<_Ep>(__u.get_deleter());
   return *this;
 }


      unique_ptr&
      operator=(nullptr_t) noexcept
      {
 reset();
 return *this;
      }




      typename std::add_lvalue_reference<element_type>::type
      operator[](size_t __i) const
      {
 ;
 return get()[__i];
      }


      pointer
      get() const noexcept
      { return _M_t._M_ptr(); }


      deleter_type&
      get_deleter() noexcept
      { return _M_t._M_deleter(); }


      const deleter_type&
      get_deleter() const noexcept
      { return _M_t._M_deleter(); }


      explicit operator bool() const noexcept
      { return get() == pointer() ? false : true; }




      pointer
      release() noexcept
      { return _M_t.release(); }







      template <typename _Up,
                typename = _Require<
                  __or_<is_same<_Up, pointer>,
                        __and_<is_same<pointer, element_type*>,
                               is_pointer<_Up>,
                               is_convertible<
                                 typename remove_pointer<_Up>::type(*)[],
                                 element_type(*)[]
                               >
                        >
                  >
               >>
      void
      reset(_Up __p) noexcept
      { _M_t.reset(std::move(__p)); }

      void reset(nullptr_t = nullptr) noexcept
      { reset(pointer()); }


      void
      swap(unique_ptr& __u) noexcept
      {
 static_assert(__is_swappable<_Dp>::value, "deleter must be swappable");
 _M_t.swap(__u._M_t);
      }


      unique_ptr(const unique_ptr&) = delete;
      unique_ptr& operator=(const unique_ptr&) = delete;
    };




  template<typename _Tp, typename _Dp>
    inline




    void

    swap(unique_ptr<_Tp, _Dp>& __x,
  unique_ptr<_Tp, _Dp>& __y) noexcept
    { __x.swap(__y); }
# 750 "/usr/include/c++/10.2.0/bits/unique_ptr.h" 3
  template<typename _Tp, typename _Dp,
    typename _Up, typename _Ep>
    inline bool
    operator==(const unique_ptr<_Tp, _Dp>& __x,
        const unique_ptr<_Up, _Ep>& __y)
    { return __x.get() == __y.get(); }


  template<typename _Tp, typename _Dp>
    inline bool
    operator==(const unique_ptr<_Tp, _Dp>& __x, nullptr_t) noexcept
    { return !__x; }



  template<typename _Tp, typename _Dp>
    inline bool
    operator==(nullptr_t, const unique_ptr<_Tp, _Dp>& __x) noexcept
    { return !__x; }


  template<typename _Tp, typename _Dp,
    typename _Up, typename _Ep>
    inline bool
    operator!=(const unique_ptr<_Tp, _Dp>& __x,
        const unique_ptr<_Up, _Ep>& __y)
    { return __x.get() != __y.get(); }


  template<typename _Tp, typename _Dp>
    inline bool
    operator!=(const unique_ptr<_Tp, _Dp>& __x, nullptr_t) noexcept
    { return (bool)__x; }


  template<typename _Tp, typename _Dp>
    inline bool
    operator!=(nullptr_t, const unique_ptr<_Tp, _Dp>& __x) noexcept
    { return (bool)__x; }



  template<typename _Tp, typename _Dp,
    typename _Up, typename _Ep>
    inline bool
    operator<(const unique_ptr<_Tp, _Dp>& __x,
       const unique_ptr<_Up, _Ep>& __y)
    {
      typedef typename
 std::common_type<typename unique_ptr<_Tp, _Dp>::pointer,
                  typename unique_ptr<_Up, _Ep>::pointer>::type _CT;
      return std::less<_CT>()(__x.get(), __y.get());
    }


  template<typename _Tp, typename _Dp>
    inline bool
    operator<(const unique_ptr<_Tp, _Dp>& __x, nullptr_t)
    {
      return std::less<typename unique_ptr<_Tp, _Dp>::pointer>()(__x.get(),
         nullptr);
    }


  template<typename _Tp, typename _Dp>
    inline bool
    operator<(nullptr_t, const unique_ptr<_Tp, _Dp>& __x)
    {
      return std::less<typename unique_ptr<_Tp, _Dp>::pointer>()(nullptr,
         __x.get());
    }


  template<typename _Tp, typename _Dp,
    typename _Up, typename _Ep>
    inline bool
    operator<=(const unique_ptr<_Tp, _Dp>& __x,
        const unique_ptr<_Up, _Ep>& __y)
    { return !(__y < __x); }


  template<typename _Tp, typename _Dp>
    inline bool
    operator<=(const unique_ptr<_Tp, _Dp>& __x, nullptr_t)
    { return !(nullptr < __x); }


  template<typename _Tp, typename _Dp>
    inline bool
    operator<=(nullptr_t, const unique_ptr<_Tp, _Dp>& __x)
    { return !(__x < nullptr); }


  template<typename _Tp, typename _Dp,
    typename _Up, typename _Ep>
    inline bool
    operator>(const unique_ptr<_Tp, _Dp>& __x,
       const unique_ptr<_Up, _Ep>& __y)
    { return (__y < __x); }


  template<typename _Tp, typename _Dp>
    inline bool
    operator>(const unique_ptr<_Tp, _Dp>& __x, nullptr_t)
    {
      return std::less<typename unique_ptr<_Tp, _Dp>::pointer>()(nullptr,
         __x.get());
    }


  template<typename _Tp, typename _Dp>
    inline bool
    operator>(nullptr_t, const unique_ptr<_Tp, _Dp>& __x)
    {
      return std::less<typename unique_ptr<_Tp, _Dp>::pointer>()(__x.get(),
         nullptr);
    }


  template<typename _Tp, typename _Dp,
    typename _Up, typename _Ep>
    inline bool
    operator>=(const unique_ptr<_Tp, _Dp>& __x,
        const unique_ptr<_Up, _Ep>& __y)
    { return !(__x < __y); }


  template<typename _Tp, typename _Dp>
    inline bool
    operator>=(const unique_ptr<_Tp, _Dp>& __x, nullptr_t)
    { return !(__x < nullptr); }


  template<typename _Tp, typename _Dp>
    inline bool
    operator>=(nullptr_t, const unique_ptr<_Tp, _Dp>& __x)
    { return !(nullptr < __x); }
# 912 "/usr/include/c++/10.2.0/bits/unique_ptr.h" 3
  template<typename _Up, typename _Ptr = typename _Up::pointer,
    bool = __poison_hash<_Ptr>::__enable_hash_call>
    struct __uniq_ptr_hash

    : private __poison_hash<_Ptr>

    {
      size_t
      operator()(const _Up& __u) const
      noexcept(noexcept(std::declval<hash<_Ptr>>()(std::declval<_Ptr>())))
      { return hash<_Ptr>()(__u.get()); }
    };

  template<typename _Up, typename _Ptr>
    struct __uniq_ptr_hash<_Up, _Ptr, false>
    : private __poison_hash<_Ptr>
    { };



  template<typename _Tp, typename _Dp>
    struct hash<unique_ptr<_Tp, _Dp>>
    : public __hash_base<size_t, unique_ptr<_Tp, _Dp>>,
      public __uniq_ptr_hash<unique_ptr<_Tp, _Dp>>
    { };
# 1008 "/usr/include/c++/10.2.0/bits/unique_ptr.h" 3

}
# 84 "/usr/include/c++/10.2.0/memory" 2 3
# 1 "/usr/include/c++/10.2.0/bits/shared_ptr.h" 1 3
# 52 "/usr/include/c++/10.2.0/bits/shared_ptr.h" 3
# 1 "/usr/include/c++/10.2.0/bits/shared_ptr_base.h" 1 3
# 53 "/usr/include/c++/10.2.0/bits/shared_ptr_base.h" 3
# 1 "/usr/include/c++/10.2.0/bits/allocated_ptr.h" 1 3
# 40 "/usr/include/c++/10.2.0/bits/allocated_ptr.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{



  template<typename _Alloc>
    struct __allocated_ptr
    {
      using pointer = typename allocator_traits<_Alloc>::pointer;
      using value_type = typename allocator_traits<_Alloc>::value_type;


      __allocated_ptr(_Alloc& __a, pointer __ptr) noexcept
      : _M_alloc(std::__addressof(__a)), _M_ptr(__ptr)
      { }


      template<typename _Ptr,
        typename _Req = _Require<is_same<_Ptr, value_type*>>>
      __allocated_ptr(_Alloc& __a, _Ptr __ptr)
      : _M_alloc(std::__addressof(__a)),
 _M_ptr(pointer_traits<pointer>::pointer_to(*__ptr))
      { }


      __allocated_ptr(__allocated_ptr&& __gd) noexcept
      : _M_alloc(__gd._M_alloc), _M_ptr(__gd._M_ptr)
      { __gd._M_ptr = nullptr; }


      ~__allocated_ptr()
      {
 if (_M_ptr != nullptr)
   std::allocator_traits<_Alloc>::deallocate(*_M_alloc, _M_ptr, 1);
      }


      __allocated_ptr&
      operator=(std::nullptr_t) noexcept
      {
 _M_ptr = nullptr;
 return *this;
      }


      value_type* get() { return std::__to_address(_M_ptr); }

    private:
      _Alloc* _M_alloc;
      pointer _M_ptr;
    };


  template<typename _Alloc>
    __allocated_ptr<_Alloc>
    __allocate_guarded(_Alloc& __a)
    {
      return { __a, std::allocator_traits<_Alloc>::allocate(__a, 1) };
    }


}
# 54 "/usr/include/c++/10.2.0/bits/shared_ptr_base.h" 2 3
# 1 "/usr/include/c++/10.2.0/bits/refwrap.h" 1 3
# 33 "/usr/include/c++/10.2.0/bits/refwrap.h" 3
       
# 34 "/usr/include/c++/10.2.0/bits/refwrap.h" 3
# 43 "/usr/include/c++/10.2.0/bits/refwrap.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{

# 54 "/usr/include/c++/10.2.0/bits/refwrap.h" 3
  template<typename _Res, typename... _ArgTypes>
    struct _Maybe_unary_or_binary_function { };


  template<typename _Res, typename _T1>
    struct _Maybe_unary_or_binary_function<_Res, _T1>
    : std::unary_function<_T1, _Res> { };


  template<typename _Res, typename _T1, typename _T2>
    struct _Maybe_unary_or_binary_function<_Res, _T1, _T2>
    : std::binary_function<_T1, _T2, _Res> { };

  template<typename _Signature>
    struct _Mem_fn_traits;

  template<typename _Res, typename _Class, typename... _ArgTypes>
    struct _Mem_fn_traits_base
    {
      using __result_type = _Res;
      using __maybe_type
 = _Maybe_unary_or_binary_function<_Res, _Class*, _ArgTypes...>;
      using __arity = integral_constant<size_t, sizeof...(_ArgTypes)>;
    };
# 99 "/usr/include/c++/10.2.0/bits/refwrap.h" 3
template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) > : _Mem_fn_traits_base<_Res, _Class, _ArgTypes...> { using __vararg = false_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes... ...) > : _Mem_fn_traits_base<_Res, _Class, _ArgTypes...> { using __vararg = true_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) const > : _Mem_fn_traits_base<_Res, const _Class, _ArgTypes...> { using __vararg = false_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes... ...) const > : _Mem_fn_traits_base<_Res, const _Class, _ArgTypes...> { using __vararg = true_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) volatile > : _Mem_fn_traits_base<_Res, volatile _Class, _ArgTypes...> { using __vararg = false_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes... ...) volatile > : _Mem_fn_traits_base<_Res, volatile _Class, _ArgTypes...> { using __vararg = true_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) const volatile > : _Mem_fn_traits_base<_Res, const volatile _Class, _ArgTypes...> { using __vararg = false_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes... ...) const volatile > : _Mem_fn_traits_base<_Res, const volatile _Class, _ArgTypes...> { using __vararg = true_type; };
template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) &> : _Mem_fn_traits_base<_Res, _Class, _ArgTypes...> { using __vararg = false_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes... ...) &> : _Mem_fn_traits_base<_Res, _Class, _ArgTypes...> { using __vararg = true_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) const &> : _Mem_fn_traits_base<_Res, const _Class, _ArgTypes...> { using __vararg = false_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes... ...) const &> : _Mem_fn_traits_base<_Res, const _Class, _ArgTypes...> { using __vararg = true_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) volatile &> : _Mem_fn_traits_base<_Res, volatile _Class, _ArgTypes...> { using __vararg = false_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes... ...) volatile &> : _Mem_fn_traits_base<_Res, volatile _Class, _ArgTypes...> { using __vararg = true_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) const volatile &> : _Mem_fn_traits_base<_Res, const volatile _Class, _ArgTypes...> { using __vararg = false_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes... ...) const volatile &> : _Mem_fn_traits_base<_Res, const volatile _Class, _ArgTypes...> { using __vararg = true_type; };
template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) &&> : _Mem_fn_traits_base<_Res, _Class, _ArgTypes...> { using __vararg = false_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes... ...) &&> : _Mem_fn_traits_base<_Res, _Class, _ArgTypes...> { using __vararg = true_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) const &&> : _Mem_fn_traits_base<_Res, const _Class, _ArgTypes...> { using __vararg = false_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes... ...) const &&> : _Mem_fn_traits_base<_Res, const _Class, _ArgTypes...> { using __vararg = true_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) volatile &&> : _Mem_fn_traits_base<_Res, volatile _Class, _ArgTypes...> { using __vararg = false_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes... ...) volatile &&> : _Mem_fn_traits_base<_Res, volatile _Class, _ArgTypes...> { using __vararg = true_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) const volatile &&> : _Mem_fn_traits_base<_Res, const volatile _Class, _ArgTypes...> { using __vararg = false_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes... ...) const volatile &&> : _Mem_fn_traits_base<_Res, const volatile _Class, _ArgTypes...> { using __vararg = true_type; };
# 113 "/usr/include/c++/10.2.0/bits/refwrap.h" 3
  template<typename _Functor, typename = __void_t<>>
    struct _Maybe_get_result_type
    { };

  template<typename _Functor>
    struct _Maybe_get_result_type<_Functor,
      __void_t<typename _Functor::result_type>>
    { typedef typename _Functor::result_type result_type; };





  template<typename _Functor>
    struct _Weak_result_type_impl
    : _Maybe_get_result_type<_Functor>
    { };


  template<typename _Res, typename... _ArgTypes >
    struct _Weak_result_type_impl<_Res(_ArgTypes...) >
    { typedef _Res result_type; };


  template<typename _Res, typename... _ArgTypes >
    struct _Weak_result_type_impl<_Res(_ArgTypes......) >
    { typedef _Res result_type; };


  template<typename _Res, typename... _ArgTypes >
    struct _Weak_result_type_impl<_Res(*)(_ArgTypes...) >
    { typedef _Res result_type; };


  template<typename _Res, typename... _ArgTypes >
    struct
    _Weak_result_type_impl<_Res(*)(_ArgTypes......) >
    { typedef _Res result_type; };


  template<typename _Functor,
    bool = is_member_function_pointer<_Functor>::value>
    struct _Weak_result_type_memfun
    : _Weak_result_type_impl<_Functor>
    { };


  template<typename _MemFunPtr>
    struct _Weak_result_type_memfun<_MemFunPtr, true>
    {
      using result_type = typename _Mem_fn_traits<_MemFunPtr>::__result_type;
    };


  template<typename _Func, typename _Class>
    struct _Weak_result_type_memfun<_Func _Class::*, false>
    { };





  template<typename _Functor>
    struct _Weak_result_type
    : _Weak_result_type_memfun<typename remove_cv<_Functor>::type>
    { };



  template<typename _Tp, typename = __void_t<>>
    struct _Refwrap_base_arg1
    { };


  template<typename _Tp>
    struct _Refwrap_base_arg1<_Tp,
         __void_t<typename _Tp::argument_type>>
    {
      typedef typename _Tp::argument_type argument_type;
    };


  template<typename _Tp, typename = __void_t<>>
    struct _Refwrap_base_arg2
    { };


  template<typename _Tp>
    struct _Refwrap_base_arg2<_Tp,
         __void_t<typename _Tp::first_argument_type,
           typename _Tp::second_argument_type>>
    {
      typedef typename _Tp::first_argument_type first_argument_type;
      typedef typename _Tp::second_argument_type second_argument_type;
    };







  template<typename _Tp>
    struct _Reference_wrapper_base
    : _Weak_result_type<_Tp>, _Refwrap_base_arg1<_Tp>, _Refwrap_base_arg2<_Tp>
    { };


  template<typename _Res, typename _T1 >
    struct _Reference_wrapper_base<_Res(_T1) >
    : unary_function<_T1, _Res>
    { };

  template<typename _Res, typename _T1>
    struct _Reference_wrapper_base<_Res(_T1) const>
    : unary_function<_T1, _Res>
    { };

  template<typename _Res, typename _T1>
    struct _Reference_wrapper_base<_Res(_T1) volatile>
    : unary_function<_T1, _Res>
    { };

  template<typename _Res, typename _T1>
    struct _Reference_wrapper_base<_Res(_T1) const volatile>
    : unary_function<_T1, _Res>
    { };


  template<typename _Res, typename _T1, typename _T2 >
    struct _Reference_wrapper_base<_Res(_T1, _T2) >
    : binary_function<_T1, _T2, _Res>
    { };

  template<typename _Res, typename _T1, typename _T2>
    struct _Reference_wrapper_base<_Res(_T1, _T2) const>
    : binary_function<_T1, _T2, _Res>
    { };

  template<typename _Res, typename _T1, typename _T2>
    struct _Reference_wrapper_base<_Res(_T1, _T2) volatile>
    : binary_function<_T1, _T2, _Res>
    { };

  template<typename _Res, typename _T1, typename _T2>
    struct _Reference_wrapper_base<_Res(_T1, _T2) const volatile>
    : binary_function<_T1, _T2, _Res>
    { };


  template<typename _Res, typename _T1 >
    struct _Reference_wrapper_base<_Res(*)(_T1) >
    : unary_function<_T1, _Res>
    { };


  template<typename _Res, typename _T1, typename _T2 >
    struct _Reference_wrapper_base<_Res(*)(_T1, _T2) >
    : binary_function<_T1, _T2, _Res>
    { };

  template<typename _Tp, bool = is_member_function_pointer<_Tp>::value>
    struct _Reference_wrapper_base_memfun
    : _Reference_wrapper_base<_Tp>
    { };

  template<typename _MemFunPtr>
    struct _Reference_wrapper_base_memfun<_MemFunPtr, true>
    : _Mem_fn_traits<_MemFunPtr>::__maybe_type
    {
      using result_type = typename _Mem_fn_traits<_MemFunPtr>::__result_type;
    };
# 293 "/usr/include/c++/10.2.0/bits/refwrap.h" 3
  template<typename _Tp>
    class reference_wrapper



    : public _Reference_wrapper_base_memfun<typename remove_cv<_Tp>::type>

    {
      _Tp* _M_data;

     
      static _Tp* _S_fun(_Tp& __r) noexcept { return std::__addressof(__r); }

      static void _S_fun(_Tp&&) = delete;

      template<typename _Up, typename _Up2 = __remove_cvref_t<_Up>>
 using __not_same
   = typename enable_if<!is_same<reference_wrapper, _Up2>::value>::type;

    public:
      typedef _Tp type;




      template<typename _Up, typename = __not_same<_Up>, typename
  = decltype(reference_wrapper::_S_fun(std::declval<_Up>()))>

 reference_wrapper(_Up&& __uref)
 noexcept(noexcept(reference_wrapper::_S_fun(std::declval<_Up>())))
 : _M_data(reference_wrapper::_S_fun(std::forward<_Up>(__uref)))
 { }

      reference_wrapper(const reference_wrapper&) = default;

      reference_wrapper&
      operator=(const reference_wrapper&) = default;

     
      operator _Tp&() const noexcept
      { return this->get(); }

     
      _Tp&
      get() const noexcept
      { return *_M_data; }

      template<typename... _Args>

 typename result_of<_Tp&(_Args&&...)>::type
 operator()(_Args&&... __args) const
 {




   return std::__invoke(get(), std::forward<_Args>(__args)...);
 }
    };
# 361 "/usr/include/c++/10.2.0/bits/refwrap.h" 3
  template<typename _Tp>
   
    inline reference_wrapper<_Tp>
    ref(_Tp& __t) noexcept
    { return reference_wrapper<_Tp>(__t); }


  template<typename _Tp>
   
    inline reference_wrapper<const _Tp>
    cref(const _Tp& __t) noexcept
    { return reference_wrapper<const _Tp>(__t); }

  template<typename _Tp>
    void ref(const _Tp&&) = delete;

  template<typename _Tp>
    void cref(const _Tp&&) = delete;


  template<typename _Tp>
   
    inline reference_wrapper<_Tp>
    ref(reference_wrapper<_Tp> __t) noexcept
    { return __t; }


  template<typename _Tp>
   
    inline reference_wrapper<const _Tp>
    cref(reference_wrapper<_Tp> __t) noexcept
    { return { __t.get() }; }




}
# 55 "/usr/include/c++/10.2.0/bits/shared_ptr_base.h" 2 3

# 1 "/usr/include/c++/10.2.0/ext/aligned_buffer.h" 1 3
# 32 "/usr/include/c++/10.2.0/ext/aligned_buffer.h" 3
       
# 33 "/usr/include/c++/10.2.0/ext/aligned_buffer.h" 3







namespace __gnu_cxx
{




  template<typename _Tp>
    struct __aligned_membuf
    {





      struct _Tp2 { _Tp _M_t; };

      alignas(__alignof__(_Tp2::_M_t)) unsigned char _M_storage[sizeof(_Tp)];

      __aligned_membuf() = default;


      __aligned_membuf(std::nullptr_t) { }

      void*
      _M_addr() noexcept
      { return static_cast<void*>(&_M_storage); }

      const void*
      _M_addr() const noexcept
      { return static_cast<const void*>(&_M_storage); }

      _Tp*
      _M_ptr() noexcept
      { return static_cast<_Tp*>(_M_addr()); }

      const _Tp*
      _M_ptr() const noexcept
      { return static_cast<const _Tp*>(_M_addr()); }
    };
# 89 "/usr/include/c++/10.2.0/ext/aligned_buffer.h" 3
  template<typename _Tp>
    struct __aligned_buffer
    : std::aligned_storage<sizeof(_Tp), __alignof__(_Tp)>
    {
      typename
 std::aligned_storage<sizeof(_Tp), __alignof__(_Tp)>::type _M_storage;

      __aligned_buffer() = default;


      __aligned_buffer(std::nullptr_t) { }

      void*
      _M_addr() noexcept
      {
        return static_cast<void*>(&_M_storage);
      }

      const void*
      _M_addr() const noexcept
      {
        return static_cast<const void*>(&_M_storage);
      }

      _Tp*
      _M_ptr() noexcept
      { return static_cast<_Tp*>(_M_addr()); }

      const _Tp*
      _M_ptr() const noexcept
      { return static_cast<const _Tp*>(_M_addr()); }
    };


}
# 57 "/usr/include/c++/10.2.0/bits/shared_ptr_base.h" 2 3




namespace std __attribute__ ((__visibility__ ("default")))
{



#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
  template<typename> class auto_ptr;
#pragma GCC diagnostic pop






  class bad_weak_ptr : public std::exception
  {
  public:
    virtual char const* what() const noexcept;

    virtual ~bad_weak_ptr() noexcept;
  };


  inline void
  __throw_bad_weak_ptr()
  { (throw (bad_weak_ptr())); }

  using __gnu_cxx::_Lock_policy;
  using __gnu_cxx::__default_lock_policy;
  using __gnu_cxx::_S_single;
  using __gnu_cxx::_S_mutex;
  using __gnu_cxx::_S_atomic;


  template<_Lock_policy _Lp>
    class _Mutex_base
    {
    protected:

      enum { _S_need_barriers = 0 };
    };

  template<>
    class _Mutex_base<_S_mutex>
    : public __gnu_cxx::__mutex
    {
    protected:



      enum { _S_need_barriers = 1 };
    };

  template<_Lock_policy _Lp = __default_lock_policy>
    class _Sp_counted_base
    : public _Mutex_base<_Lp>
    {
    public:
      _Sp_counted_base() noexcept
      : _M_use_count(1), _M_weak_count(1) { }

      virtual
      ~_Sp_counted_base() noexcept
      { }



      virtual void
      _M_dispose() noexcept = 0;


      virtual void
      _M_destroy() noexcept
      { delete this; }

      virtual void*
      _M_get_deleter(const std::type_info&) noexcept = 0;

      void
      _M_add_ref_copy()
      { __gnu_cxx::__atomic_add_dispatch(&_M_use_count, 1); }

      void
      _M_add_ref_lock();

      bool
      _M_add_ref_lock_nothrow();

      void
      _M_release() noexcept
      {

        ;
 if (__gnu_cxx::__exchange_and_add_dispatch(&_M_use_count, -1) == 1)
   {
            ;
     _M_dispose();




     if (_Mutex_base<_Lp>::_S_need_barriers)
       {
  __atomic_thread_fence (4);
       }


            ;
     if (__gnu_cxx::__exchange_and_add_dispatch(&_M_weak_count,
             -1) == 1)
              {
                ;
         _M_destroy();
              }
   }
      }

      void
      _M_weak_add_ref() noexcept
      { __gnu_cxx::__atomic_add_dispatch(&_M_weak_count, 1); }

      void
      _M_weak_release() noexcept
      {

        ;
 if (__gnu_cxx::__exchange_and_add_dispatch(&_M_weak_count, -1) == 1)
   {
            ;
     if (_Mutex_base<_Lp>::_S_need_barriers)
       {


  __atomic_thread_fence (4);
       }
     _M_destroy();
   }
      }

      long
      _M_get_use_count() const noexcept
      {


        return __atomic_load_n(&_M_use_count, 0);
      }

    private:
      _Sp_counted_base(_Sp_counted_base const&) = delete;
      _Sp_counted_base& operator=(_Sp_counted_base const&) = delete;

      _Atomic_word _M_use_count;
      _Atomic_word _M_weak_count;
    };

  template<>
    inline void
    _Sp_counted_base<_S_single>::
    _M_add_ref_lock()
    {
      if (_M_use_count == 0)
 __throw_bad_weak_ptr();
      ++_M_use_count;
    }

  template<>
    inline void
    _Sp_counted_base<_S_mutex>::
    _M_add_ref_lock()
    {
      __gnu_cxx::__scoped_lock sentry(*this);
      if (__gnu_cxx::__exchange_and_add_dispatch(&_M_use_count, 1) == 0)
 {
   _M_use_count = 0;
   __throw_bad_weak_ptr();
 }
    }

  template<>
    inline void
    _Sp_counted_base<_S_atomic>::
    _M_add_ref_lock()
    {

      _Atomic_word __count = _M_get_use_count();
      do
 {
   if (__count == 0)
     __throw_bad_weak_ptr();


 }
      while (!__atomic_compare_exchange_n(&_M_use_count, &__count, __count + 1,
       true, 4,
       0));
    }

  template<>
    inline bool
    _Sp_counted_base<_S_single>::
    _M_add_ref_lock_nothrow()
    {
      if (_M_use_count == 0)
 return false;
      ++_M_use_count;
      return true;
    }

  template<>
    inline bool
    _Sp_counted_base<_S_mutex>::
    _M_add_ref_lock_nothrow()
    {
      __gnu_cxx::__scoped_lock sentry(*this);
      if (__gnu_cxx::__exchange_and_add_dispatch(&_M_use_count, 1) == 0)
 {
   _M_use_count = 0;
   return false;
 }
      return true;
    }

  template<>
    inline bool
    _Sp_counted_base<_S_atomic>::
    _M_add_ref_lock_nothrow()
    {

      _Atomic_word __count = _M_get_use_count();
      do
 {
   if (__count == 0)
     return false;


 }
      while (!__atomic_compare_exchange_n(&_M_use_count, &__count, __count + 1,
       true, 4,
       0));
      return true;
    }

  template<>
    inline void
    _Sp_counted_base<_S_single>::_M_add_ref_copy()
    { ++_M_use_count; }

  template<>
    inline void
    _Sp_counted_base<_S_single>::_M_release() noexcept
    {
      if (--_M_use_count == 0)
        {
          _M_dispose();
          if (--_M_weak_count == 0)
            _M_destroy();
        }
    }

  template<>
    inline void
    _Sp_counted_base<_S_single>::_M_weak_add_ref() noexcept
    { ++_M_weak_count; }

  template<>
    inline void
    _Sp_counted_base<_S_single>::_M_weak_release() noexcept
    {
      if (--_M_weak_count == 0)
        _M_destroy();
    }

  template<>
    inline long
    _Sp_counted_base<_S_single>::_M_get_use_count() const noexcept
    { return _M_use_count; }



  template<typename _Tp, _Lock_policy _Lp = __default_lock_policy>
    class __shared_ptr;

  template<typename _Tp, _Lock_policy _Lp = __default_lock_policy>
    class __weak_ptr;

  template<typename _Tp, _Lock_policy _Lp = __default_lock_policy>
    class __enable_shared_from_this;

  template<typename _Tp>
    class shared_ptr;

  template<typename _Tp>
    class weak_ptr;

  template<typename _Tp>
    struct owner_less;

  template<typename _Tp>
    class enable_shared_from_this;

  template<_Lock_policy _Lp = __default_lock_policy>
    class __weak_count;

  template<_Lock_policy _Lp = __default_lock_policy>
    class __shared_count;



  template<typename _Ptr, _Lock_policy _Lp>
    class _Sp_counted_ptr final : public _Sp_counted_base<_Lp>
    {
    public:
      explicit
      _Sp_counted_ptr(_Ptr __p) noexcept
      : _M_ptr(__p) { }

      virtual void
      _M_dispose() noexcept
      { delete _M_ptr; }

      virtual void
      _M_destroy() noexcept
      { delete this; }

      virtual void*
      _M_get_deleter(const std::type_info&) noexcept
      { return nullptr; }

      _Sp_counted_ptr(const _Sp_counted_ptr&) = delete;
      _Sp_counted_ptr& operator=(const _Sp_counted_ptr&) = delete;

    private:
      _Ptr _M_ptr;
    };

  template<>
    inline void
    _Sp_counted_ptr<nullptr_t, _S_single>::_M_dispose() noexcept { }

  template<>
    inline void
    _Sp_counted_ptr<nullptr_t, _S_mutex>::_M_dispose() noexcept { }

  template<>
    inline void
    _Sp_counted_ptr<nullptr_t, _S_atomic>::_M_dispose() noexcept { }

  template<int _Nm, typename _Tp,
    bool __use_ebo = !__is_final(_Tp) && __is_empty(_Tp)>
    struct _Sp_ebo_helper;


  template<int _Nm, typename _Tp>
    struct _Sp_ebo_helper<_Nm, _Tp, true> : private _Tp
    {
      explicit _Sp_ebo_helper(const _Tp& __tp) : _Tp(__tp) { }
      explicit _Sp_ebo_helper(_Tp&& __tp) : _Tp(std::move(__tp)) { }

      static _Tp&
      _S_get(_Sp_ebo_helper& __eboh) { return static_cast<_Tp&>(__eboh); }
    };


  template<int _Nm, typename _Tp>
    struct _Sp_ebo_helper<_Nm, _Tp, false>
    {
      explicit _Sp_ebo_helper(const _Tp& __tp) : _M_tp(__tp) { }
      explicit _Sp_ebo_helper(_Tp&& __tp) : _M_tp(std::move(__tp)) { }

      static _Tp&
      _S_get(_Sp_ebo_helper& __eboh)
      { return __eboh._M_tp; }

    private:
      _Tp _M_tp;
    };


  template<typename _Ptr, typename _Deleter, typename _Alloc, _Lock_policy _Lp>
    class _Sp_counted_deleter final : public _Sp_counted_base<_Lp>
    {
      class _Impl : _Sp_ebo_helper<0, _Deleter>, _Sp_ebo_helper<1, _Alloc>
      {
 typedef _Sp_ebo_helper<0, _Deleter> _Del_base;
 typedef _Sp_ebo_helper<1, _Alloc> _Alloc_base;

      public:
 _Impl(_Ptr __p, _Deleter __d, const _Alloc& __a) noexcept
 : _M_ptr(__p), _Del_base(std::move(__d)), _Alloc_base(__a)
 { }

 _Deleter& _M_del() noexcept { return _Del_base::_S_get(*this); }
 _Alloc& _M_alloc() noexcept { return _Alloc_base::_S_get(*this); }

 _Ptr _M_ptr;
      };

    public:
      using __allocator_type = __alloc_rebind<_Alloc, _Sp_counted_deleter>;


      _Sp_counted_deleter(_Ptr __p, _Deleter __d) noexcept
      : _M_impl(__p, std::move(__d), _Alloc()) { }


      _Sp_counted_deleter(_Ptr __p, _Deleter __d, const _Alloc& __a) noexcept
      : _M_impl(__p, std::move(__d), __a) { }

      ~_Sp_counted_deleter() noexcept { }

      virtual void
      _M_dispose() noexcept
      { _M_impl._M_del()(_M_impl._M_ptr); }

      virtual void
      _M_destroy() noexcept
      {
 __allocator_type __a(_M_impl._M_alloc());
 __allocated_ptr<__allocator_type> __guard_ptr{ __a, this };
 this->~_Sp_counted_deleter();
      }

      virtual void*
      _M_get_deleter(const std::type_info& __ti) noexcept
      {



        return __ti == typeid(_Deleter)
   ? std::__addressof(_M_impl._M_del())
   : nullptr;



      }

    private:
      _Impl _M_impl;
    };



  struct _Sp_make_shared_tag
  {
  private:
    template<typename _Tp, typename _Alloc, _Lock_policy _Lp>
      friend class _Sp_counted_ptr_inplace;

    static const type_info&
    _S_ti() noexcept __attribute__ ((__visibility__ ("default")))
    {
      alignas(type_info) static constexpr char __tag[sizeof(type_info)] = { };
      return reinterpret_cast<const type_info&>(__tag);
    }

    static bool _S_eq(const type_info&) noexcept;
  };

  template<typename _Alloc>
    struct _Sp_alloc_shared_tag
    {
      const _Alloc& _M_a;
    };

  template<typename _Tp, typename _Alloc, _Lock_policy _Lp>
    class _Sp_counted_ptr_inplace final : public _Sp_counted_base<_Lp>
    {
      class _Impl : _Sp_ebo_helper<0, _Alloc>
      {
 typedef _Sp_ebo_helper<0, _Alloc> _A_base;

      public:
 explicit _Impl(_Alloc __a) noexcept : _A_base(__a) { }

 _Alloc& _M_alloc() noexcept { return _A_base::_S_get(*this); }

 __gnu_cxx::__aligned_buffer<_Tp> _M_storage;
      };

    public:
      using __allocator_type = __alloc_rebind<_Alloc, _Sp_counted_ptr_inplace>;


      template<typename... _Args>
 _Sp_counted_ptr_inplace(_Alloc __a, _Args&&... __args)
 : _M_impl(__a)
 {


   allocator_traits<_Alloc>::construct(__a, _M_ptr(),
       std::forward<_Args>(__args)...);
 }

      ~_Sp_counted_ptr_inplace() noexcept { }

      virtual void
      _M_dispose() noexcept
      {
 allocator_traits<_Alloc>::destroy(_M_impl._M_alloc(), _M_ptr());
      }


      virtual void
      _M_destroy() noexcept
      {
 __allocator_type __a(_M_impl._M_alloc());
 __allocated_ptr<__allocator_type> __guard_ptr{ __a, this };
 this->~_Sp_counted_ptr_inplace();
      }

    private:
      friend class __shared_count<_Lp>;



      virtual void*
      _M_get_deleter(const std::type_info& __ti) noexcept override
      {
 auto __ptr = const_cast<typename remove_cv<_Tp>::type*>(_M_ptr());




 if (&__ti == &_Sp_make_shared_tag::_S_ti()
     ||

     __ti == typeid(_Sp_make_shared_tag)



    )
   return __ptr;
 return nullptr;
      }

      _Tp* _M_ptr() noexcept { return _M_impl._M_storage._M_ptr(); }

      _Impl _M_impl;
    };


  struct __sp_array_delete
  {
    template<typename _Yp>
      void operator()(_Yp* __p) const { delete[] __p; }
  };

  template<_Lock_policy _Lp>
    class __shared_count
    {
      template<typename _Tp>
 struct __not_alloc_shared_tag { using type = void; };

      template<typename _Tp>
 struct __not_alloc_shared_tag<_Sp_alloc_shared_tag<_Tp>> { };

    public:
      constexpr __shared_count() noexcept : _M_pi(0)
      { }

      template<typename _Ptr>
        explicit
 __shared_count(_Ptr __p) : _M_pi(0)
 {
   try
     {
       _M_pi = new _Sp_counted_ptr<_Ptr, _Lp>(__p);
     }
   catch(...)
     {
       delete __p;
       throw;
     }
 }

      template<typename _Ptr>
 __shared_count(_Ptr __p, false_type)
 : __shared_count(__p)
 { }

      template<typename _Ptr>
 __shared_count(_Ptr __p, true_type)
 : __shared_count(__p, __sp_array_delete{}, allocator<void>())
 { }

      template<typename _Ptr, typename _Deleter,
        typename = typename __not_alloc_shared_tag<_Deleter>::type>
 __shared_count(_Ptr __p, _Deleter __d)
 : __shared_count(__p, std::move(__d), allocator<void>())
 { }

      template<typename _Ptr, typename _Deleter, typename _Alloc,
        typename = typename __not_alloc_shared_tag<_Deleter>::type>
 __shared_count(_Ptr __p, _Deleter __d, _Alloc __a) : _M_pi(0)
 {
   typedef _Sp_counted_deleter<_Ptr, _Deleter, _Alloc, _Lp> _Sp_cd_type;
   try
     {
       typename _Sp_cd_type::__allocator_type __a2(__a);
       auto __guard = std::__allocate_guarded(__a2);
       _Sp_cd_type* __mem = __guard.get();
       ::new (__mem) _Sp_cd_type(__p, std::move(__d), std::move(__a));
       _M_pi = __mem;
       __guard = nullptr;
     }
   catch(...)
     {
       __d(__p);
       throw;
     }
 }

      template<typename _Tp, typename _Alloc, typename... _Args>
 __shared_count(_Tp*& __p, _Sp_alloc_shared_tag<_Alloc> __a,
         _Args&&... __args)
 {
   typedef _Sp_counted_ptr_inplace<_Tp, _Alloc, _Lp> _Sp_cp_type;
   typename _Sp_cp_type::__allocator_type __a2(__a._M_a);
   auto __guard = std::__allocate_guarded(__a2);
   _Sp_cp_type* __mem = __guard.get();
   auto __pi = ::new (__mem)
     _Sp_cp_type(__a._M_a, std::forward<_Args>(__args)...);
   __guard = nullptr;
   _M_pi = __pi;
   __p = __pi->_M_ptr();
 }


#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"

      template<typename _Tp>
        explicit
 __shared_count(std::auto_ptr<_Tp>&& __r);
#pragma GCC diagnostic pop



      template<typename _Tp, typename _Del>
        explicit
 __shared_count(std::unique_ptr<_Tp, _Del>&& __r) : _M_pi(0)
 {


   if (__r.get() == nullptr)
     return;

   using _Ptr = typename unique_ptr<_Tp, _Del>::pointer;
   using _Del2 = typename conditional<is_reference<_Del>::value,
       reference_wrapper<typename remove_reference<_Del>::type>,
       _Del>::type;
   using _Sp_cd_type
     = _Sp_counted_deleter<_Ptr, _Del2, allocator<void>, _Lp>;
   using _Alloc = allocator<_Sp_cd_type>;
   using _Alloc_traits = allocator_traits<_Alloc>;
   _Alloc __a;
   _Sp_cd_type* __mem = _Alloc_traits::allocate(__a, 1);
   _Alloc_traits::construct(__a, __mem, __r.release(),
       __r.get_deleter());
   _M_pi = __mem;
 }


      explicit __shared_count(const __weak_count<_Lp>& __r);


      explicit __shared_count(const __weak_count<_Lp>& __r, std::nothrow_t);

      ~__shared_count() noexcept
      {
 if (_M_pi != nullptr)
   _M_pi->_M_release();
      }

      __shared_count(const __shared_count& __r) noexcept
      : _M_pi(__r._M_pi)
      {
 if (_M_pi != 0)
   _M_pi->_M_add_ref_copy();
      }

      __shared_count&
      operator=(const __shared_count& __r) noexcept
      {
 _Sp_counted_base<_Lp>* __tmp = __r._M_pi;
 if (__tmp != _M_pi)
   {
     if (__tmp != 0)
       __tmp->_M_add_ref_copy();
     if (_M_pi != 0)
       _M_pi->_M_release();
     _M_pi = __tmp;
   }
 return *this;
      }

      void
      _M_swap(__shared_count& __r) noexcept
      {
 _Sp_counted_base<_Lp>* __tmp = __r._M_pi;
 __r._M_pi = _M_pi;
 _M_pi = __tmp;
      }

      long
      _M_get_use_count() const noexcept
      { return _M_pi != 0 ? _M_pi->_M_get_use_count() : 0; }

      bool
      _M_unique() const noexcept
      { return this->_M_get_use_count() == 1; }

      void*
      _M_get_deleter(const std::type_info& __ti) const noexcept
      { return _M_pi ? _M_pi->_M_get_deleter(__ti) : nullptr; }

      bool
      _M_less(const __shared_count& __rhs) const noexcept
      { return std::less<_Sp_counted_base<_Lp>*>()(this->_M_pi, __rhs._M_pi); }

      bool
      _M_less(const __weak_count<_Lp>& __rhs) const noexcept
      { return std::less<_Sp_counted_base<_Lp>*>()(this->_M_pi, __rhs._M_pi); }


      friend inline bool
      operator==(const __shared_count& __a, const __shared_count& __b) noexcept
      { return __a._M_pi == __b._M_pi; }

    private:
      friend class __weak_count<_Lp>;

      _Sp_counted_base<_Lp>* _M_pi;
    };


  template<_Lock_policy _Lp>
    class __weak_count
    {
    public:
      constexpr __weak_count() noexcept : _M_pi(nullptr)
      { }

      __weak_count(const __shared_count<_Lp>& __r) noexcept
      : _M_pi(__r._M_pi)
      {
 if (_M_pi != nullptr)
   _M_pi->_M_weak_add_ref();
      }

      __weak_count(const __weak_count& __r) noexcept
      : _M_pi(__r._M_pi)
      {
 if (_M_pi != nullptr)
   _M_pi->_M_weak_add_ref();
      }

      __weak_count(__weak_count&& __r) noexcept
      : _M_pi(__r._M_pi)
      { __r._M_pi = nullptr; }

      ~__weak_count() noexcept
      {
 if (_M_pi != nullptr)
   _M_pi->_M_weak_release();
      }

      __weak_count&
      operator=(const __shared_count<_Lp>& __r) noexcept
      {
 _Sp_counted_base<_Lp>* __tmp = __r._M_pi;
 if (__tmp != nullptr)
   __tmp->_M_weak_add_ref();
 if (_M_pi != nullptr)
   _M_pi->_M_weak_release();
 _M_pi = __tmp;
 return *this;
      }

      __weak_count&
      operator=(const __weak_count& __r) noexcept
      {
 _Sp_counted_base<_Lp>* __tmp = __r._M_pi;
 if (__tmp != nullptr)
   __tmp->_M_weak_add_ref();
 if (_M_pi != nullptr)
   _M_pi->_M_weak_release();
 _M_pi = __tmp;
 return *this;
      }

      __weak_count&
      operator=(__weak_count&& __r) noexcept
      {
 if (_M_pi != nullptr)
   _M_pi->_M_weak_release();
 _M_pi = __r._M_pi;
        __r._M_pi = nullptr;
 return *this;
      }

      void
      _M_swap(__weak_count& __r) noexcept
      {
 _Sp_counted_base<_Lp>* __tmp = __r._M_pi;
 __r._M_pi = _M_pi;
 _M_pi = __tmp;
      }

      long
      _M_get_use_count() const noexcept
      { return _M_pi != nullptr ? _M_pi->_M_get_use_count() : 0; }

      bool
      _M_less(const __weak_count& __rhs) const noexcept
      { return std::less<_Sp_counted_base<_Lp>*>()(this->_M_pi, __rhs._M_pi); }

      bool
      _M_less(const __shared_count<_Lp>& __rhs) const noexcept
      { return std::less<_Sp_counted_base<_Lp>*>()(this->_M_pi, __rhs._M_pi); }


      friend inline bool
      operator==(const __weak_count& __a, const __weak_count& __b) noexcept
      { return __a._M_pi == __b._M_pi; }

    private:
      friend class __shared_count<_Lp>;

      _Sp_counted_base<_Lp>* _M_pi;
    };


  template<_Lock_policy _Lp>
    inline
    __shared_count<_Lp>::__shared_count(const __weak_count<_Lp>& __r)
    : _M_pi(__r._M_pi)
    {
      if (_M_pi != nullptr)
 _M_pi->_M_add_ref_lock();
      else
 __throw_bad_weak_ptr();
    }


  template<_Lock_policy _Lp>
    inline
    __shared_count<_Lp>::
    __shared_count(const __weak_count<_Lp>& __r, std::nothrow_t)
    : _M_pi(__r._M_pi)
    {
      if (_M_pi != nullptr)
 if (!_M_pi->_M_add_ref_lock_nothrow())
   _M_pi = nullptr;
    }







  template<typename _Yp_ptr, typename _Tp_ptr>
    struct __sp_compatible_with
    : false_type
    { };

  template<typename _Yp, typename _Tp>
    struct __sp_compatible_with<_Yp*, _Tp*>
    : is_convertible<_Yp*, _Tp*>::type
    { };

  template<typename _Up, size_t _Nm>
    struct __sp_compatible_with<_Up(*)[_Nm], _Up(*)[]>
    : true_type
    { };

  template<typename _Up, size_t _Nm>
    struct __sp_compatible_with<_Up(*)[_Nm], const _Up(*)[]>
    : true_type
    { };

  template<typename _Up, size_t _Nm>
    struct __sp_compatible_with<_Up(*)[_Nm], volatile _Up(*)[]>
    : true_type
    { };

  template<typename _Up, size_t _Nm>
    struct __sp_compatible_with<_Up(*)[_Nm], const volatile _Up(*)[]>
    : true_type
    { };


  template<typename _Up, size_t _Nm, typename _Yp, typename = void>
    struct __sp_is_constructible_arrN
    : false_type
    { };

  template<typename _Up, size_t _Nm, typename _Yp>
    struct __sp_is_constructible_arrN<_Up, _Nm, _Yp, __void_t<_Yp[_Nm]>>
    : is_convertible<_Yp(*)[_Nm], _Up(*)[_Nm]>::type
    { };


  template<typename _Up, typename _Yp, typename = void>
    struct __sp_is_constructible_arr
    : false_type
    { };

  template<typename _Up, typename _Yp>
    struct __sp_is_constructible_arr<_Up, _Yp, __void_t<_Yp[]>>
    : is_convertible<_Yp(*)[], _Up(*)[]>::type
    { };


  template<typename _Tp, typename _Yp>
    struct __sp_is_constructible;


  template<typename _Up, size_t _Nm, typename _Yp>
    struct __sp_is_constructible<_Up[_Nm], _Yp>
    : __sp_is_constructible_arrN<_Up, _Nm, _Yp>::type
    { };


  template<typename _Up, typename _Yp>
    struct __sp_is_constructible<_Up[], _Yp>
    : __sp_is_constructible_arr<_Up, _Yp>::type
    { };


  template<typename _Tp, typename _Yp>
    struct __sp_is_constructible
    : is_convertible<_Yp*, _Tp*>::type
    { };



  template<typename _Tp, _Lock_policy _Lp,
    bool = is_array<_Tp>::value, bool = is_void<_Tp>::value>
    class __shared_ptr_access
    {
    public:
      using element_type = _Tp;

      element_type&
      operator*() const noexcept
      {
 ;
 return *_M_get();
      }

      element_type*
      operator->() const noexcept
      {
 ;
 return _M_get();
      }

    private:
      element_type*
      _M_get() const noexcept
      { return static_cast<const __shared_ptr<_Tp, _Lp>*>(this)->get(); }
    };


  template<typename _Tp, _Lock_policy _Lp>
    class __shared_ptr_access<_Tp, _Lp, false, true>
    {
    public:
      using element_type = _Tp;

      element_type*
      operator->() const noexcept
      {
 auto __ptr = static_cast<const __shared_ptr<_Tp, _Lp>*>(this)->get();
 ;
 return __ptr;
      }
    };


  template<typename _Tp, _Lock_policy _Lp>
    class __shared_ptr_access<_Tp, _Lp, true, false>
    {
    public:
      using element_type = typename remove_extent<_Tp>::type;


      [[__deprecated__("shared_ptr<T[]>::operator* is absent from C++17")]]
      element_type&
      operator*() const noexcept
      {
 ;
 return *_M_get();
      }

      [[__deprecated__("shared_ptr<T[]>::operator-> is absent from C++17")]]
      element_type*
      operator->() const noexcept
      {
 ;
 return _M_get();
      }


      element_type&
      operator[](ptrdiff_t __i) const
      {
 ;
 ;
 return _M_get()[__i];
      }

    private:
      element_type*
      _M_get() const noexcept
      { return static_cast<const __shared_ptr<_Tp, _Lp>*>(this)->get(); }
    };

  template<typename _Tp, _Lock_policy _Lp>
    class __shared_ptr
    : public __shared_ptr_access<_Tp, _Lp>
    {
    public:
      using element_type = typename remove_extent<_Tp>::type;

    private:

      template<typename _Yp>
 using _SafeConv
   = typename enable_if<__sp_is_constructible<_Tp, _Yp>::value>::type;


      template<typename _Yp, typename _Res = void>
 using _Compatible = typename
   enable_if<__sp_compatible_with<_Yp*, _Tp*>::value, _Res>::type;


      template<typename _Yp>
 using _Assignable = _Compatible<_Yp, __shared_ptr&>;


      template<typename _Yp, typename _Del, typename _Res = void,
        typename _Ptr = typename unique_ptr<_Yp, _Del>::pointer>
 using _UniqCompatible = typename enable_if<__and_<
   __sp_compatible_with<_Yp*, _Tp*>, is_convertible<_Ptr, element_type*>
   >::value, _Res>::type;


      template<typename _Yp, typename _Del>
 using _UniqAssignable = _UniqCompatible<_Yp, _Del, __shared_ptr&>;

    public:





      constexpr __shared_ptr() noexcept
      : _M_ptr(0), _M_refcount()
      { }

      template<typename _Yp, typename = _SafeConv<_Yp>>
 explicit
 __shared_ptr(_Yp* __p)
 : _M_ptr(__p), _M_refcount(__p, typename is_array<_Tp>::type())
 {
   static_assert( !is_void<_Yp>::value, "incomplete type" );
   static_assert( sizeof(_Yp) > 0, "incomplete type" );
   _M_enable_shared_from_this_with(__p);
 }

      template<typename _Yp, typename _Deleter, typename = _SafeConv<_Yp>>
 __shared_ptr(_Yp* __p, _Deleter __d)
 : _M_ptr(__p), _M_refcount(__p, std::move(__d))
 {
   static_assert(__is_invocable<_Deleter&, _Yp*&>::value,
       "deleter expression d(p) is well-formed");
   _M_enable_shared_from_this_with(__p);
 }

      template<typename _Yp, typename _Deleter, typename _Alloc,
        typename = _SafeConv<_Yp>>
 __shared_ptr(_Yp* __p, _Deleter __d, _Alloc __a)
 : _M_ptr(__p), _M_refcount(__p, std::move(__d), std::move(__a))
 {
   static_assert(__is_invocable<_Deleter&, _Yp*&>::value,
       "deleter expression d(p) is well-formed");
   _M_enable_shared_from_this_with(__p);
 }

      template<typename _Deleter>
 __shared_ptr(nullptr_t __p, _Deleter __d)
 : _M_ptr(0), _M_refcount(__p, std::move(__d))
 { }

      template<typename _Deleter, typename _Alloc>
        __shared_ptr(nullptr_t __p, _Deleter __d, _Alloc __a)
 : _M_ptr(0), _M_refcount(__p, std::move(__d), std::move(__a))
 { }


      template<typename _Yp>
 __shared_ptr(const __shared_ptr<_Yp, _Lp>& __r,
       element_type* __p) noexcept
 : _M_ptr(__p), _M_refcount(__r._M_refcount)
 { }


      template<typename _Yp>
 __shared_ptr(__shared_ptr<_Yp, _Lp>&& __r,
       element_type* __p) noexcept
 : _M_ptr(__p), _M_refcount()
 {
   _M_refcount._M_swap(__r._M_refcount);
   __r._M_ptr = 0;
 }

      __shared_ptr(const __shared_ptr&) noexcept = default;
      __shared_ptr& operator=(const __shared_ptr&) noexcept = default;
      ~__shared_ptr() = default;

      template<typename _Yp, typename = _Compatible<_Yp>>
 __shared_ptr(const __shared_ptr<_Yp, _Lp>& __r) noexcept
 : _M_ptr(__r._M_ptr), _M_refcount(__r._M_refcount)
 { }

      __shared_ptr(__shared_ptr&& __r) noexcept
      : _M_ptr(__r._M_ptr), _M_refcount()
      {
 _M_refcount._M_swap(__r._M_refcount);
 __r._M_ptr = 0;
      }

      template<typename _Yp, typename = _Compatible<_Yp>>
 __shared_ptr(__shared_ptr<_Yp, _Lp>&& __r) noexcept
 : _M_ptr(__r._M_ptr), _M_refcount()
 {
   _M_refcount._M_swap(__r._M_refcount);
   __r._M_ptr = 0;
 }

      template<typename _Yp, typename = _Compatible<_Yp>>
 explicit __shared_ptr(const __weak_ptr<_Yp, _Lp>& __r)
 : _M_refcount(__r._M_refcount)
 {


   _M_ptr = __r._M_ptr;
 }


      template<typename _Yp, typename _Del,
        typename = _UniqCompatible<_Yp, _Del>>
 __shared_ptr(unique_ptr<_Yp, _Del>&& __r)
 : _M_ptr(__r.get()), _M_refcount()
 {
   auto __raw = __to_address(__r.get());
   _M_refcount = __shared_count<_Lp>(std::move(__r));
   _M_enable_shared_from_this_with(__raw);
 }


    protected:

      template<typename _Tp1, typename _Del,
        typename enable_if<__and_<
   __not_<is_array<_Tp>>, is_array<_Tp1>,
          is_convertible<typename unique_ptr<_Tp1, _Del>::pointer, _Tp*>
        >::value, bool>::type = true>
 __shared_ptr(unique_ptr<_Tp1, _Del>&& __r, __sp_array_delete)
 : _M_ptr(__r.get()), _M_refcount()
 {
   auto __raw = __to_address(__r.get());
   _M_refcount = __shared_count<_Lp>(std::move(__r));
   _M_enable_shared_from_this_with(__raw);
 }
    public:



#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"

      template<typename _Yp, typename = _Compatible<_Yp>>
 __shared_ptr(auto_ptr<_Yp>&& __r);
#pragma GCC diagnostic pop


      constexpr __shared_ptr(nullptr_t) noexcept : __shared_ptr() { }

      template<typename _Yp>
 _Assignable<_Yp>
 operator=(const __shared_ptr<_Yp, _Lp>& __r) noexcept
 {
   _M_ptr = __r._M_ptr;
   _M_refcount = __r._M_refcount;
   return *this;
 }


#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
      template<typename _Yp>
 _Assignable<_Yp>
 operator=(auto_ptr<_Yp>&& __r)
 {
   __shared_ptr(std::move(__r)).swap(*this);
   return *this;
 }
#pragma GCC diagnostic pop


      __shared_ptr&
      operator=(__shared_ptr&& __r) noexcept
      {
 __shared_ptr(std::move(__r)).swap(*this);
 return *this;
      }

      template<class _Yp>
 _Assignable<_Yp>
 operator=(__shared_ptr<_Yp, _Lp>&& __r) noexcept
 {
   __shared_ptr(std::move(__r)).swap(*this);
   return *this;
 }

      template<typename _Yp, typename _Del>
 _UniqAssignable<_Yp, _Del>
 operator=(unique_ptr<_Yp, _Del>&& __r)
 {
   __shared_ptr(std::move(__r)).swap(*this);
   return *this;
 }

      void
      reset() noexcept
      { __shared_ptr().swap(*this); }

      template<typename _Yp>
 _SafeConv<_Yp>
 reset(_Yp* __p)
 {

   ;
   __shared_ptr(__p).swap(*this);
 }

      template<typename _Yp, typename _Deleter>
 _SafeConv<_Yp>
 reset(_Yp* __p, _Deleter __d)
 { __shared_ptr(__p, std::move(__d)).swap(*this); }

      template<typename _Yp, typename _Deleter, typename _Alloc>
 _SafeConv<_Yp>
 reset(_Yp* __p, _Deleter __d, _Alloc __a)
        { __shared_ptr(__p, std::move(__d), std::move(__a)).swap(*this); }


      element_type*
      get() const noexcept
      { return _M_ptr; }


      explicit operator bool() const
      { return _M_ptr == 0 ? false : true; }


      bool
      unique() const noexcept
      { return _M_refcount._M_unique(); }


      long
      use_count() const noexcept
      { return _M_refcount._M_get_use_count(); }


      void
      swap(__shared_ptr<_Tp, _Lp>& __other) noexcept
      {
 std::swap(_M_ptr, __other._M_ptr);
 _M_refcount._M_swap(__other._M_refcount);
      }
# 1356 "/usr/include/c++/10.2.0/bits/shared_ptr_base.h" 3
      template<typename _Tp1>
 bool
 owner_before(__shared_ptr<_Tp1, _Lp> const& __rhs) const noexcept
 { return _M_refcount._M_less(__rhs._M_refcount); }

      template<typename _Tp1>
 bool
 owner_before(__weak_ptr<_Tp1, _Lp> const& __rhs) const noexcept
 { return _M_refcount._M_less(__rhs._M_refcount); }


    protected:

      template<typename _Alloc, typename... _Args>
 __shared_ptr(_Sp_alloc_shared_tag<_Alloc> __tag, _Args&&... __args)
 : _M_ptr(), _M_refcount(_M_ptr, __tag, std::forward<_Args>(__args)...)
 { _M_enable_shared_from_this_with(_M_ptr); }

      template<typename _Tp1, _Lock_policy _Lp1, typename _Alloc,
        typename... _Args>
 friend __shared_ptr<_Tp1, _Lp1>
 __allocate_shared(const _Alloc& __a, _Args&&... __args);



      __shared_ptr(const __weak_ptr<_Tp, _Lp>& __r, std::nothrow_t)
      : _M_refcount(__r._M_refcount, std::nothrow)
      {
 _M_ptr = _M_refcount._M_get_use_count() ? __r._M_ptr : nullptr;
      }

      friend class __weak_ptr<_Tp, _Lp>;

    private:

      template<typename _Yp>
 using __esft_base_t = decltype(__enable_shared_from_this_base(
       std::declval<const __shared_count<_Lp>&>(),
       std::declval<_Yp*>()));


      template<typename _Yp, typename = void>
 struct __has_esft_base
 : false_type { };

      template<typename _Yp>
 struct __has_esft_base<_Yp, __void_t<__esft_base_t<_Yp>>>
 : __not_<is_array<_Tp>> { };

      template<typename _Yp, typename _Yp2 = typename remove_cv<_Yp>::type>
 typename enable_if<__has_esft_base<_Yp2>::value>::type
 _M_enable_shared_from_this_with(_Yp* __p) noexcept
 {
   if (auto __base = __enable_shared_from_this_base(_M_refcount, __p))
     __base->_M_weak_assign(const_cast<_Yp2*>(__p), _M_refcount);
 }

      template<typename _Yp, typename _Yp2 = typename remove_cv<_Yp>::type>
 typename enable_if<!__has_esft_base<_Yp2>::value>::type
 _M_enable_shared_from_this_with(_Yp*) noexcept
 { }

      void*
      _M_get_deleter(const std::type_info& __ti) const noexcept
      { return _M_refcount._M_get_deleter(__ti); }

      template<typename _Tp1, _Lock_policy _Lp1> friend class __shared_ptr;
      template<typename _Tp1, _Lock_policy _Lp1> friend class __weak_ptr;

      template<typename _Del, typename _Tp1, _Lock_policy _Lp1>
 friend _Del* get_deleter(const __shared_ptr<_Tp1, _Lp1>&) noexcept;

      template<typename _Del, typename _Tp1>
 friend _Del* get_deleter(const shared_ptr<_Tp1>&) noexcept;

      element_type* _M_ptr;
      __shared_count<_Lp> _M_refcount;
    };



  template<typename _Tp1, typename _Tp2, _Lock_policy _Lp>
    inline bool
    operator==(const __shared_ptr<_Tp1, _Lp>& __a,
        const __shared_ptr<_Tp2, _Lp>& __b) noexcept
    { return __a.get() == __b.get(); }

  template<typename _Tp, _Lock_policy _Lp>
    inline bool
    operator==(const __shared_ptr<_Tp, _Lp>& __a, nullptr_t) noexcept
    { return !__a; }
# 1463 "/usr/include/c++/10.2.0/bits/shared_ptr_base.h" 3
  template<typename _Tp, _Lock_policy _Lp>
    inline bool
    operator==(nullptr_t, const __shared_ptr<_Tp, _Lp>& __a) noexcept
    { return !__a; }

  template<typename _Tp1, typename _Tp2, _Lock_policy _Lp>
    inline bool
    operator!=(const __shared_ptr<_Tp1, _Lp>& __a,
        const __shared_ptr<_Tp2, _Lp>& __b) noexcept
    { return __a.get() != __b.get(); }

  template<typename _Tp, _Lock_policy _Lp>
    inline bool
    operator!=(const __shared_ptr<_Tp, _Lp>& __a, nullptr_t) noexcept
    { return (bool)__a; }

  template<typename _Tp, _Lock_policy _Lp>
    inline bool
    operator!=(nullptr_t, const __shared_ptr<_Tp, _Lp>& __a) noexcept
    { return (bool)__a; }

  template<typename _Tp, typename _Up, _Lock_policy _Lp>
    inline bool
    operator<(const __shared_ptr<_Tp, _Lp>& __a,
       const __shared_ptr<_Up, _Lp>& __b) noexcept
    {
      using _Tp_elt = typename __shared_ptr<_Tp, _Lp>::element_type;
      using _Up_elt = typename __shared_ptr<_Up, _Lp>::element_type;
      using _Vp = typename common_type<_Tp_elt*, _Up_elt*>::type;
      return less<_Vp>()(__a.get(), __b.get());
    }

  template<typename _Tp, _Lock_policy _Lp>
    inline bool
    operator<(const __shared_ptr<_Tp, _Lp>& __a, nullptr_t) noexcept
    {
      using _Tp_elt = typename __shared_ptr<_Tp, _Lp>::element_type;
      return less<_Tp_elt*>()(__a.get(), nullptr);
    }

  template<typename _Tp, _Lock_policy _Lp>
    inline bool
    operator<(nullptr_t, const __shared_ptr<_Tp, _Lp>& __a) noexcept
    {
      using _Tp_elt = typename __shared_ptr<_Tp, _Lp>::element_type;
      return less<_Tp_elt*>()(nullptr, __a.get());
    }

  template<typename _Tp1, typename _Tp2, _Lock_policy _Lp>
    inline bool
    operator<=(const __shared_ptr<_Tp1, _Lp>& __a,
        const __shared_ptr<_Tp2, _Lp>& __b) noexcept
    { return !(__b < __a); }

  template<typename _Tp, _Lock_policy _Lp>
    inline bool
    operator<=(const __shared_ptr<_Tp, _Lp>& __a, nullptr_t) noexcept
    { return !(nullptr < __a); }

  template<typename _Tp, _Lock_policy _Lp>
    inline bool
    operator<=(nullptr_t, const __shared_ptr<_Tp, _Lp>& __a) noexcept
    { return !(__a < nullptr); }

  template<typename _Tp1, typename _Tp2, _Lock_policy _Lp>
    inline bool
    operator>(const __shared_ptr<_Tp1, _Lp>& __a,
       const __shared_ptr<_Tp2, _Lp>& __b) noexcept
    { return (__b < __a); }

  template<typename _Tp, _Lock_policy _Lp>
    inline bool
    operator>(const __shared_ptr<_Tp, _Lp>& __a, nullptr_t) noexcept
    { return nullptr < __a; }

  template<typename _Tp, _Lock_policy _Lp>
    inline bool
    operator>(nullptr_t, const __shared_ptr<_Tp, _Lp>& __a) noexcept
    { return __a < nullptr; }

  template<typename _Tp1, typename _Tp2, _Lock_policy _Lp>
    inline bool
    operator>=(const __shared_ptr<_Tp1, _Lp>& __a,
        const __shared_ptr<_Tp2, _Lp>& __b) noexcept
    { return !(__a < __b); }

  template<typename _Tp, _Lock_policy _Lp>
    inline bool
    operator>=(const __shared_ptr<_Tp, _Lp>& __a, nullptr_t) noexcept
    { return !(__a < nullptr); }

  template<typename _Tp, _Lock_policy _Lp>
    inline bool
    operator>=(nullptr_t, const __shared_ptr<_Tp, _Lp>& __a) noexcept
    { return !(nullptr < __a); }



  template<typename _Tp, _Lock_policy _Lp>
    inline void
    swap(__shared_ptr<_Tp, _Lp>& __a, __shared_ptr<_Tp, _Lp>& __b) noexcept
    { __a.swap(__b); }
# 1573 "/usr/include/c++/10.2.0/bits/shared_ptr_base.h" 3
  template<typename _Tp, typename _Tp1, _Lock_policy _Lp>
    inline __shared_ptr<_Tp, _Lp>
    static_pointer_cast(const __shared_ptr<_Tp1, _Lp>& __r) noexcept
    {
      using _Sp = __shared_ptr<_Tp, _Lp>;
      return _Sp(__r, static_cast<typename _Sp::element_type*>(__r.get()));
    }






  template<typename _Tp, typename _Tp1, _Lock_policy _Lp>
    inline __shared_ptr<_Tp, _Lp>
    const_pointer_cast(const __shared_ptr<_Tp1, _Lp>& __r) noexcept
    {
      using _Sp = __shared_ptr<_Tp, _Lp>;
      return _Sp(__r, const_cast<typename _Sp::element_type*>(__r.get()));
    }






  template<typename _Tp, typename _Tp1, _Lock_policy _Lp>
    inline __shared_ptr<_Tp, _Lp>
    dynamic_pointer_cast(const __shared_ptr<_Tp1, _Lp>& __r) noexcept
    {
      using _Sp = __shared_ptr<_Tp, _Lp>;
      if (auto* __p = dynamic_cast<typename _Sp::element_type*>(__r.get()))
 return _Sp(__r, __p);
      return _Sp();
    }
# 1619 "/usr/include/c++/10.2.0/bits/shared_ptr_base.h" 3
  template<typename _Tp, _Lock_policy _Lp>
    class __weak_ptr
    {
      template<typename _Yp, typename _Res = void>
 using _Compatible = typename
   enable_if<__sp_compatible_with<_Yp*, _Tp*>::value, _Res>::type;


      template<typename _Yp>
 using _Assignable = _Compatible<_Yp, __weak_ptr&>;

    public:
      using element_type = typename remove_extent<_Tp>::type;

      constexpr __weak_ptr() noexcept
      : _M_ptr(nullptr), _M_refcount()
      { }

      __weak_ptr(const __weak_ptr&) noexcept = default;

      ~__weak_ptr() = default;
# 1655 "/usr/include/c++/10.2.0/bits/shared_ptr_base.h" 3
      template<typename _Yp, typename = _Compatible<_Yp>>
 __weak_ptr(const __weak_ptr<_Yp, _Lp>& __r) noexcept
 : _M_refcount(__r._M_refcount)
        { _M_ptr = __r.lock().get(); }

      template<typename _Yp, typename = _Compatible<_Yp>>
 __weak_ptr(const __shared_ptr<_Yp, _Lp>& __r) noexcept
 : _M_ptr(__r._M_ptr), _M_refcount(__r._M_refcount)
 { }

      __weak_ptr(__weak_ptr&& __r) noexcept
      : _M_ptr(__r._M_ptr), _M_refcount(std::move(__r._M_refcount))
      { __r._M_ptr = nullptr; }

      template<typename _Yp, typename = _Compatible<_Yp>>
 __weak_ptr(__weak_ptr<_Yp, _Lp>&& __r) noexcept
 : _M_ptr(__r.lock().get()), _M_refcount(std::move(__r._M_refcount))
        { __r._M_ptr = nullptr; }

      __weak_ptr&
      operator=(const __weak_ptr& __r) noexcept = default;

      template<typename _Yp>
 _Assignable<_Yp>
 operator=(const __weak_ptr<_Yp, _Lp>& __r) noexcept
 {
   _M_ptr = __r.lock().get();
   _M_refcount = __r._M_refcount;
   return *this;
 }

      template<typename _Yp>
 _Assignable<_Yp>
 operator=(const __shared_ptr<_Yp, _Lp>& __r) noexcept
 {
   _M_ptr = __r._M_ptr;
   _M_refcount = __r._M_refcount;
   return *this;
 }

      __weak_ptr&
      operator=(__weak_ptr&& __r) noexcept
      {
 _M_ptr = __r._M_ptr;
 _M_refcount = std::move(__r._M_refcount);
 __r._M_ptr = nullptr;
 return *this;
      }

      template<typename _Yp>
 _Assignable<_Yp>
 operator=(__weak_ptr<_Yp, _Lp>&& __r) noexcept
 {
   _M_ptr = __r.lock().get();
   _M_refcount = std::move(__r._M_refcount);
   __r._M_ptr = nullptr;
   return *this;
 }

      __shared_ptr<_Tp, _Lp>
      lock() const noexcept
      { return __shared_ptr<element_type, _Lp>(*this, std::nothrow); }

      long
      use_count() const noexcept
      { return _M_refcount._M_get_use_count(); }

      bool
      expired() const noexcept
      { return _M_refcount._M_get_use_count() == 0; }

      template<typename _Tp1>
 bool
 owner_before(const __shared_ptr<_Tp1, _Lp>& __rhs) const noexcept
 { return _M_refcount._M_less(__rhs._M_refcount); }

      template<typename _Tp1>
 bool
 owner_before(const __weak_ptr<_Tp1, _Lp>& __rhs) const noexcept
 { return _M_refcount._M_less(__rhs._M_refcount); }

      void
      reset() noexcept
      { __weak_ptr().swap(*this); }

      void
      swap(__weak_ptr& __s) noexcept
      {
 std::swap(_M_ptr, __s._M_ptr);
 _M_refcount._M_swap(__s._M_refcount);
      }

    private:

      void
      _M_assign(_Tp* __ptr, const __shared_count<_Lp>& __refcount) noexcept
      {
 if (use_count() == 0)
   {
     _M_ptr = __ptr;
     _M_refcount = __refcount;
   }
      }

      template<typename _Tp1, _Lock_policy _Lp1> friend class __shared_ptr;
      template<typename _Tp1, _Lock_policy _Lp1> friend class __weak_ptr;
      friend class __enable_shared_from_this<_Tp, _Lp>;
      friend class enable_shared_from_this<_Tp>;

      element_type* _M_ptr;
      __weak_count<_Lp> _M_refcount;
    };


  template<typename _Tp, _Lock_policy _Lp>
    inline void
    swap(__weak_ptr<_Tp, _Lp>& __a, __weak_ptr<_Tp, _Lp>& __b) noexcept
    { __a.swap(__b); }

  template<typename _Tp, typename _Tp1>
    struct _Sp_owner_less : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __lhs, const _Tp& __rhs) const noexcept
      { return __lhs.owner_before(__rhs); }

      bool
      operator()(const _Tp& __lhs, const _Tp1& __rhs) const noexcept
      { return __lhs.owner_before(__rhs); }

      bool
      operator()(const _Tp1& __lhs, const _Tp& __rhs) const noexcept
      { return __lhs.owner_before(__rhs); }
    };

  template<>
    struct _Sp_owner_less<void, void>
    {
      template<typename _Tp, typename _Up>
 auto
 operator()(const _Tp& __lhs, const _Up& __rhs) const noexcept
 -> decltype(__lhs.owner_before(__rhs))
 { return __lhs.owner_before(__rhs); }

      using is_transparent = void;
    };

  template<typename _Tp, _Lock_policy _Lp>
    struct owner_less<__shared_ptr<_Tp, _Lp>>
    : public _Sp_owner_less<__shared_ptr<_Tp, _Lp>, __weak_ptr<_Tp, _Lp>>
    { };

  template<typename _Tp, _Lock_policy _Lp>
    struct owner_less<__weak_ptr<_Tp, _Lp>>
    : public _Sp_owner_less<__weak_ptr<_Tp, _Lp>, __shared_ptr<_Tp, _Lp>>
    { };


  template<typename _Tp, _Lock_policy _Lp>
    class __enable_shared_from_this
    {
    protected:
      constexpr __enable_shared_from_this() noexcept { }

      __enable_shared_from_this(const __enable_shared_from_this&) noexcept { }

      __enable_shared_from_this&
      operator=(const __enable_shared_from_this&) noexcept
      { return *this; }

      ~__enable_shared_from_this() { }

    public:
      __shared_ptr<_Tp, _Lp>
      shared_from_this()
      { return __shared_ptr<_Tp, _Lp>(this->_M_weak_this); }

      __shared_ptr<const _Tp, _Lp>
      shared_from_this() const
      { return __shared_ptr<const _Tp, _Lp>(this->_M_weak_this); }
# 1846 "/usr/include/c++/10.2.0/bits/shared_ptr_base.h" 3
    private:
      template<typename _Tp1>
 void
 _M_weak_assign(_Tp1* __p, const __shared_count<_Lp>& __n) const noexcept
 { _M_weak_this._M_assign(__p, __n); }

      friend const __enable_shared_from_this*
      __enable_shared_from_this_base(const __shared_count<_Lp>&,
         const __enable_shared_from_this* __p)
      { return __p; }

      template<typename, _Lock_policy>
 friend class __shared_ptr;

      mutable __weak_ptr<_Tp, _Lp> _M_weak_this;
    };

  template<typename _Tp, _Lock_policy _Lp = __default_lock_policy,
    typename _Alloc, typename... _Args>
    inline __shared_ptr<_Tp, _Lp>
    __allocate_shared(const _Alloc& __a, _Args&&... __args)
    {
      return __shared_ptr<_Tp, _Lp>(_Sp_alloc_shared_tag<_Alloc>{__a},
        std::forward<_Args>(__args)...);
    }

  template<typename _Tp, _Lock_policy _Lp = __default_lock_policy,
    typename... _Args>
    inline __shared_ptr<_Tp, _Lp>
    __make_shared(_Args&&... __args)
    {
      typedef typename std::remove_const<_Tp>::type _Tp_nc;
      return std::__allocate_shared<_Tp, _Lp>(std::allocator<_Tp_nc>(),
           std::forward<_Args>(__args)...);
    }


  template<typename _Tp, _Lock_policy _Lp>
    struct hash<__shared_ptr<_Tp, _Lp>>
    : public __hash_base<size_t, __shared_ptr<_Tp, _Lp>>
    {
      size_t
      operator()(const __shared_ptr<_Tp, _Lp>& __s) const noexcept
      {
 return hash<typename __shared_ptr<_Tp, _Lp>::element_type*>()(
     __s.get());
      }
    };


}
# 53 "/usr/include/c++/10.2.0/bits/shared_ptr.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{

# 67 "/usr/include/c++/10.2.0/bits/shared_ptr.h" 3
  template<typename _Ch, typename _Tr, typename _Tp, _Lock_policy _Lp>
    inline std::basic_ostream<_Ch, _Tr>&
    operator<<(std::basic_ostream<_Ch, _Tr>& __os,
        const __shared_ptr<_Tp, _Lp>& __p)
    {
      __os << __p.get();
      return __os;
    }

  template<typename _Del, typename _Tp, _Lock_policy _Lp>
    inline _Del*
    get_deleter(const __shared_ptr<_Tp, _Lp>& __p) noexcept
    {

      return static_cast<_Del*>(__p._M_get_deleter(typeid(_Del)));



    }





  template<typename _Del, typename _Tp>
    inline _Del*
    get_deleter(const shared_ptr<_Tp>& __p) noexcept
    {

      return static_cast<_Del*>(__p._M_get_deleter(typeid(_Del)));



    }
# 120 "/usr/include/c++/10.2.0/bits/shared_ptr.h" 3
  template<typename _Tp>
    class shared_ptr : public __shared_ptr<_Tp>
    {
      template<typename... _Args>
 using _Constructible = typename enable_if<
   is_constructible<__shared_ptr<_Tp>, _Args...>::value
 >::type;

      template<typename _Arg>
 using _Assignable = typename enable_if<
   is_assignable<__shared_ptr<_Tp>&, _Arg>::value, shared_ptr&
 >::type;

    public:


      using element_type = typename __shared_ptr<_Tp>::element_type;
# 147 "/usr/include/c++/10.2.0/bits/shared_ptr.h" 3
      constexpr shared_ptr() noexcept : __shared_ptr<_Tp>() { }

      shared_ptr(const shared_ptr&) noexcept = default;







      template<typename _Yp, typename = _Constructible<_Yp*>>
 explicit
 shared_ptr(_Yp* __p) : __shared_ptr<_Tp>(__p) { }
# 174 "/usr/include/c++/10.2.0/bits/shared_ptr.h" 3
      template<typename _Yp, typename _Deleter,
        typename = _Constructible<_Yp*, _Deleter>>
 shared_ptr(_Yp* __p, _Deleter __d)
        : __shared_ptr<_Tp>(__p, std::move(__d)) { }
# 192 "/usr/include/c++/10.2.0/bits/shared_ptr.h" 3
      template<typename _Deleter>
 shared_ptr(nullptr_t __p, _Deleter __d)
        : __shared_ptr<_Tp>(__p, std::move(__d)) { }
# 211 "/usr/include/c++/10.2.0/bits/shared_ptr.h" 3
      template<typename _Yp, typename _Deleter, typename _Alloc,
        typename = _Constructible<_Yp*, _Deleter, _Alloc>>
 shared_ptr(_Yp* __p, _Deleter __d, _Alloc __a)
 : __shared_ptr<_Tp>(__p, std::move(__d), std::move(__a)) { }
# 231 "/usr/include/c++/10.2.0/bits/shared_ptr.h" 3
      template<typename _Deleter, typename _Alloc>
 shared_ptr(nullptr_t __p, _Deleter __d, _Alloc __a)
 : __shared_ptr<_Tp>(__p, std::move(__d), std::move(__a)) { }
# 255 "/usr/include/c++/10.2.0/bits/shared_ptr.h" 3
      template<typename _Yp>
 shared_ptr(const shared_ptr<_Yp>& __r, element_type* __p) noexcept
 : __shared_ptr<_Tp>(__r, __p) { }
# 293 "/usr/include/c++/10.2.0/bits/shared_ptr.h" 3
      template<typename _Yp,
        typename = _Constructible<const shared_ptr<_Yp>&>>
 shared_ptr(const shared_ptr<_Yp>& __r) noexcept
        : __shared_ptr<_Tp>(__r) { }






      shared_ptr(shared_ptr&& __r) noexcept
      : __shared_ptr<_Tp>(std::move(__r)) { }






      template<typename _Yp, typename = _Constructible<shared_ptr<_Yp>>>
 shared_ptr(shared_ptr<_Yp>&& __r) noexcept
 : __shared_ptr<_Tp>(std::move(__r)) { }
# 323 "/usr/include/c++/10.2.0/bits/shared_ptr.h" 3
      template<typename _Yp, typename = _Constructible<const weak_ptr<_Yp>&>>
 explicit shared_ptr(const weak_ptr<_Yp>& __r)
 : __shared_ptr<_Tp>(__r) { }


#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
      template<typename _Yp, typename = _Constructible<auto_ptr<_Yp>>>
 shared_ptr(auto_ptr<_Yp>&& __r);
#pragma GCC diagnostic pop




      template<typename _Yp, typename _Del,
        typename = _Constructible<unique_ptr<_Yp, _Del>>>
 shared_ptr(unique_ptr<_Yp, _Del>&& __r)
 : __shared_ptr<_Tp>(std::move(__r)) { }





      template<typename _Yp, typename _Del,
  _Constructible<unique_ptr<_Yp, _Del>, __sp_array_delete>* = 0>
 shared_ptr(unique_ptr<_Yp, _Del>&& __r)
 : __shared_ptr<_Tp>(std::move(__r), __sp_array_delete()) { }






      constexpr shared_ptr(nullptr_t) noexcept : shared_ptr() { }

      shared_ptr& operator=(const shared_ptr&) noexcept = default;

      template<typename _Yp>
 _Assignable<const shared_ptr<_Yp>&>
 operator=(const shared_ptr<_Yp>& __r) noexcept
 {
   this->__shared_ptr<_Tp>::operator=(__r);
   return *this;
 }


#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
      template<typename _Yp>
 _Assignable<auto_ptr<_Yp>>
 operator=(auto_ptr<_Yp>&& __r)
 {
   this->__shared_ptr<_Tp>::operator=(std::move(__r));
   return *this;
 }
#pragma GCC diagnostic pop


      shared_ptr&
      operator=(shared_ptr&& __r) noexcept
      {
 this->__shared_ptr<_Tp>::operator=(std::move(__r));
 return *this;
      }

      template<class _Yp>
 _Assignable<shared_ptr<_Yp>>
 operator=(shared_ptr<_Yp>&& __r) noexcept
 {
   this->__shared_ptr<_Tp>::operator=(std::move(__r));
   return *this;
 }

      template<typename _Yp, typename _Del>
 _Assignable<unique_ptr<_Yp, _Del>>
 operator=(unique_ptr<_Yp, _Del>&& __r)
 {
   this->__shared_ptr<_Tp>::operator=(std::move(__r));
   return *this;
 }

    private:

      template<typename _Alloc, typename... _Args>
 shared_ptr(_Sp_alloc_shared_tag<_Alloc> __tag, _Args&&... __args)
 : __shared_ptr<_Tp>(__tag, std::forward<_Args>(__args)...)
 { }

      template<typename _Yp, typename _Alloc, typename... _Args>
 friend shared_ptr<_Yp>
 allocate_shared(const _Alloc& __a, _Args&&... __args);


      shared_ptr(const weak_ptr<_Tp>& __r, std::nothrow_t)
      : __shared_ptr<_Tp>(__r, std::nothrow) { }

      friend class weak_ptr<_Tp>;
    };
# 434 "/usr/include/c++/10.2.0/bits/shared_ptr.h" 3
  template<typename _Tp, typename _Up>
    inline bool
    operator==(const shared_ptr<_Tp>& __a, const shared_ptr<_Up>& __b) noexcept
    { return __a.get() == __b.get(); }


  template<typename _Tp>
    inline bool
    operator==(const shared_ptr<_Tp>& __a, nullptr_t) noexcept
    { return !__a; }
# 461 "/usr/include/c++/10.2.0/bits/shared_ptr.h" 3
  template<typename _Tp>
    inline bool
    operator==(nullptr_t, const shared_ptr<_Tp>& __a) noexcept
    { return !__a; }


  template<typename _Tp, typename _Up>
    inline bool
    operator!=(const shared_ptr<_Tp>& __a, const shared_ptr<_Up>& __b) noexcept
    { return __a.get() != __b.get(); }


  template<typename _Tp>
    inline bool
    operator!=(const shared_ptr<_Tp>& __a, nullptr_t) noexcept
    { return (bool)__a; }


  template<typename _Tp>
    inline bool
    operator!=(nullptr_t, const shared_ptr<_Tp>& __a) noexcept
    { return (bool)__a; }


  template<typename _Tp, typename _Up>
    inline bool
    operator<(const shared_ptr<_Tp>& __a, const shared_ptr<_Up>& __b) noexcept
    {
      using _Tp_elt = typename shared_ptr<_Tp>::element_type;
      using _Up_elt = typename shared_ptr<_Up>::element_type;
      using _Vp = typename common_type<_Tp_elt*, _Up_elt*>::type;
      return less<_Vp>()(__a.get(), __b.get());
    }


  template<typename _Tp>
    inline bool
    operator<(const shared_ptr<_Tp>& __a, nullptr_t) noexcept
    {
      using _Tp_elt = typename shared_ptr<_Tp>::element_type;
      return less<_Tp_elt*>()(__a.get(), nullptr);
    }


  template<typename _Tp>
    inline bool
    operator<(nullptr_t, const shared_ptr<_Tp>& __a) noexcept
    {
      using _Tp_elt = typename shared_ptr<_Tp>::element_type;
      return less<_Tp_elt*>()(nullptr, __a.get());
    }


  template<typename _Tp, typename _Up>
    inline bool
    operator<=(const shared_ptr<_Tp>& __a, const shared_ptr<_Up>& __b) noexcept
    { return !(__b < __a); }


  template<typename _Tp>
    inline bool
    operator<=(const shared_ptr<_Tp>& __a, nullptr_t) noexcept
    { return !(nullptr < __a); }


  template<typename _Tp>
    inline bool
    operator<=(nullptr_t, const shared_ptr<_Tp>& __a) noexcept
    { return !(__a < nullptr); }


  template<typename _Tp, typename _Up>
    inline bool
    operator>(const shared_ptr<_Tp>& __a, const shared_ptr<_Up>& __b) noexcept
    { return (__b < __a); }


  template<typename _Tp>
    inline bool
    operator>(const shared_ptr<_Tp>& __a, nullptr_t) noexcept
    { return nullptr < __a; }


  template<typename _Tp>
    inline bool
    operator>(nullptr_t, const shared_ptr<_Tp>& __a) noexcept
    { return __a < nullptr; }


  template<typename _Tp, typename _Up>
    inline bool
    operator>=(const shared_ptr<_Tp>& __a, const shared_ptr<_Up>& __b) noexcept
    { return !(__a < __b); }


  template<typename _Tp>
    inline bool
    operator>=(const shared_ptr<_Tp>& __a, nullptr_t) noexcept
    { return !(__a < nullptr); }


  template<typename _Tp>
    inline bool
    operator>=(nullptr_t, const shared_ptr<_Tp>& __a) noexcept
    { return !(nullptr < __a); }





  template<typename _Tp>
    inline void
    swap(shared_ptr<_Tp>& __a, shared_ptr<_Tp>& __b) noexcept
    { __a.swap(__b); }




  template<typename _Tp, typename _Up>
    inline shared_ptr<_Tp>
    static_pointer_cast(const shared_ptr<_Up>& __r) noexcept
    {
      using _Sp = shared_ptr<_Tp>;
      return _Sp(__r, static_cast<typename _Sp::element_type*>(__r.get()));
    }


  template<typename _Tp, typename _Up>
    inline shared_ptr<_Tp>
    const_pointer_cast(const shared_ptr<_Up>& __r) noexcept
    {
      using _Sp = shared_ptr<_Tp>;
      return _Sp(__r, const_cast<typename _Sp::element_type*>(__r.get()));
    }


  template<typename _Tp, typename _Up>
    inline shared_ptr<_Tp>
    dynamic_pointer_cast(const shared_ptr<_Up>& __r) noexcept
    {
      using _Sp = shared_ptr<_Tp>;
      if (auto* __p = dynamic_cast<typename _Sp::element_type*>(__r.get()))
 return _Sp(__r, __p);
      return _Sp();
    }
# 684 "/usr/include/c++/10.2.0/bits/shared_ptr.h" 3
  template<typename _Tp>
    class weak_ptr : public __weak_ptr<_Tp>
    {
      template<typename _Arg>
 using _Constructible = typename enable_if<
   is_constructible<__weak_ptr<_Tp>, _Arg>::value
 >::type;

      template<typename _Arg>
 using _Assignable = typename enable_if<
   is_assignable<__weak_ptr<_Tp>&, _Arg>::value, weak_ptr&
 >::type;

    public:
      constexpr weak_ptr() noexcept = default;

      template<typename _Yp,
        typename = _Constructible<const shared_ptr<_Yp>&>>
 weak_ptr(const shared_ptr<_Yp>& __r) noexcept
 : __weak_ptr<_Tp>(__r) { }

      weak_ptr(const weak_ptr&) noexcept = default;

      template<typename _Yp, typename = _Constructible<const weak_ptr<_Yp>&>>
 weak_ptr(const weak_ptr<_Yp>& __r) noexcept
 : __weak_ptr<_Tp>(__r) { }

      weak_ptr(weak_ptr&&) noexcept = default;

      template<typename _Yp, typename = _Constructible<weak_ptr<_Yp>>>
 weak_ptr(weak_ptr<_Yp>&& __r) noexcept
 : __weak_ptr<_Tp>(std::move(__r)) { }

      weak_ptr&
      operator=(const weak_ptr& __r) noexcept = default;

      template<typename _Yp>
 _Assignable<const weak_ptr<_Yp>&>
 operator=(const weak_ptr<_Yp>& __r) noexcept
 {
   this->__weak_ptr<_Tp>::operator=(__r);
   return *this;
 }

      template<typename _Yp>
 _Assignable<const shared_ptr<_Yp>&>
 operator=(const shared_ptr<_Yp>& __r) noexcept
 {
   this->__weak_ptr<_Tp>::operator=(__r);
   return *this;
 }

      weak_ptr&
      operator=(weak_ptr&& __r) noexcept = default;

      template<typename _Yp>
 _Assignable<weak_ptr<_Yp>>
 operator=(weak_ptr<_Yp>&& __r) noexcept
 {
   this->__weak_ptr<_Tp>::operator=(std::move(__r));
   return *this;
 }

      shared_ptr<_Tp>
      lock() const noexcept
      { return shared_ptr<_Tp>(*this, std::nothrow); }
    };
# 760 "/usr/include/c++/10.2.0/bits/shared_ptr.h" 3
  template<typename _Tp>
    inline void
    swap(weak_ptr<_Tp>& __a, weak_ptr<_Tp>& __b) noexcept
    { __a.swap(__b); }



  template<typename _Tp = void>
    struct owner_less;


  template<>
    struct owner_less<void> : _Sp_owner_less<void, void>
    { };


  template<typename _Tp>
    struct owner_less<shared_ptr<_Tp>>
    : public _Sp_owner_less<shared_ptr<_Tp>, weak_ptr<_Tp>>
    { };


  template<typename _Tp>
    struct owner_less<weak_ptr<_Tp>>
    : public _Sp_owner_less<weak_ptr<_Tp>, shared_ptr<_Tp>>
    { };




  template<typename _Tp>
    class enable_shared_from_this
    {
    protected:
      constexpr enable_shared_from_this() noexcept { }

      enable_shared_from_this(const enable_shared_from_this&) noexcept { }

      enable_shared_from_this&
      operator=(const enable_shared_from_this&) noexcept
      { return *this; }

      ~enable_shared_from_this() { }

    public:
      shared_ptr<_Tp>
      shared_from_this()
      { return shared_ptr<_Tp>(this->_M_weak_this); }

      shared_ptr<const _Tp>
      shared_from_this() const
      { return shared_ptr<const _Tp>(this->_M_weak_this); }
# 824 "/usr/include/c++/10.2.0/bits/shared_ptr.h" 3
    private:
      template<typename _Tp1>
 void
 _M_weak_assign(_Tp1* __p, const __shared_count<>& __n) const noexcept
 { _M_weak_this._M_assign(__p, __n); }


      friend const enable_shared_from_this*
      __enable_shared_from_this_base(const __shared_count<>&,
         const enable_shared_from_this* __p)
      { return __p; }

      template<typename, _Lock_policy>
 friend class __shared_ptr;

      mutable weak_ptr<_Tp> _M_weak_this;
    };
# 855 "/usr/include/c++/10.2.0/bits/shared_ptr.h" 3
  template<typename _Tp, typename _Alloc, typename... _Args>
    inline shared_ptr<_Tp>
    allocate_shared(const _Alloc& __a, _Args&&... __args)
    {
      return shared_ptr<_Tp>(_Sp_alloc_shared_tag<_Alloc>{__a},
        std::forward<_Args>(__args)...);
    }
# 870 "/usr/include/c++/10.2.0/bits/shared_ptr.h" 3
  template<typename _Tp, typename... _Args>
    inline shared_ptr<_Tp>
    make_shared(_Args&&... __args)
    {
      typedef typename std::remove_cv<_Tp>::type _Tp_nc;
      return std::allocate_shared<_Tp>(std::allocator<_Tp_nc>(),
           std::forward<_Args>(__args)...);
    }


  template<typename _Tp>
    struct hash<shared_ptr<_Tp>>
    : public __hash_base<size_t, shared_ptr<_Tp>>
    {
      size_t
      operator()(const shared_ptr<_Tp>& __s) const noexcept
      {
 return std::hash<typename shared_ptr<_Tp>::element_type*>()(__s.get());
      }
    };
# 915 "/usr/include/c++/10.2.0/bits/shared_ptr.h" 3

}
# 85 "/usr/include/c++/10.2.0/memory" 2 3
# 1 "/usr/include/c++/10.2.0/bits/shared_ptr_atomic.h" 1 3
# 33 "/usr/include/c++/10.2.0/bits/shared_ptr_atomic.h" 3
# 1 "/usr/include/c++/10.2.0/bits/atomic_base.h" 1 3
# 33 "/usr/include/c++/10.2.0/bits/atomic_base.h" 3
       
# 34 "/usr/include/c++/10.2.0/bits/atomic_base.h" 3



# 1 "/usr/include/c++/10.2.0/bits/atomic_lockfree_defines.h" 1 3
# 33 "/usr/include/c++/10.2.0/bits/atomic_lockfree_defines.h" 3
       
# 34 "/usr/include/c++/10.2.0/bits/atomic_lockfree_defines.h" 3
# 38 "/usr/include/c++/10.2.0/bits/atomic_base.h" 2 3






namespace std __attribute__ ((__visibility__ ("default")))
{

# 74 "/usr/include/c++/10.2.0/bits/atomic_base.h" 3
  typedef enum memory_order
    {
      memory_order_relaxed,
      memory_order_consume,
      memory_order_acquire,
      memory_order_release,
      memory_order_acq_rel,
      memory_order_seq_cst
    } memory_order;


  enum __memory_order_modifier
    {
      __memory_order_mask = 0x0ffff,
      __memory_order_modifier_mask = 0xffff0000,
      __memory_order_hle_acquire = 0x10000,
      __memory_order_hle_release = 0x20000
    };

  constexpr memory_order
  operator|(memory_order __m, __memory_order_modifier __mod)
  {
    return memory_order(int(__m) | int(__mod));
  }

  constexpr memory_order
  operator&(memory_order __m, __memory_order_modifier __mod)
  {
    return memory_order(int(__m) & int(__mod));
  }


  constexpr memory_order
  __cmpexch_failure_order2(memory_order __m) noexcept
  {
    return __m == memory_order_acq_rel ? memory_order_acquire
      : __m == memory_order_release ? memory_order_relaxed : __m;
  }

  constexpr memory_order
  __cmpexch_failure_order(memory_order __m) noexcept
  {
    return memory_order(__cmpexch_failure_order2(__m & __memory_order_mask)
      | __memory_order_modifier(__m & __memory_order_modifier_mask));
  }

  inline __attribute__((__always_inline__)) void
  atomic_thread_fence(memory_order __m) noexcept
  { __atomic_thread_fence(int(__m)); }

  inline __attribute__((__always_inline__)) void
  atomic_signal_fence(memory_order __m) noexcept
  { __atomic_signal_fence(int(__m)); }


  template<typename _Tp>
    inline _Tp
    kill_dependency(_Tp __y) noexcept
    {
      _Tp __ret(__y);
      return __ret;
    }



  template<typename _IntTp>
    struct __atomic_base;
# 151 "/usr/include/c++/10.2.0/bits/atomic_base.h" 3
  template<typename _Tp>
    struct atomic;

  template<typename _Tp>
    struct atomic<_Tp*>;



    typedef bool __atomic_flag_data_type;
# 174 "/usr/include/c++/10.2.0/bits/atomic_base.h" 3
  extern "C" {

  struct __atomic_flag_base
  {
    __atomic_flag_data_type _M_i ;
  };

  }




  struct atomic_flag : public __atomic_flag_base
  {
    atomic_flag() noexcept = default;
    ~atomic_flag() noexcept = default;
    atomic_flag(const atomic_flag&) = delete;
    atomic_flag& operator=(const atomic_flag&) = delete;
    atomic_flag& operator=(const atomic_flag&) volatile = delete;


    constexpr atomic_flag(bool __i) noexcept
      : __atomic_flag_base{ _S_init(__i) }
    { }

    inline __attribute__((__always_inline__)) bool
    test_and_set(memory_order __m = memory_order_seq_cst) noexcept
    {
      return __atomic_test_and_set (&_M_i, int(__m));
    }

    inline __attribute__((__always_inline__)) bool
    test_and_set(memory_order __m = memory_order_seq_cst) volatile noexcept
    {
      return __atomic_test_and_set (&_M_i, int(__m));
    }

    inline __attribute__((__always_inline__)) void
    clear(memory_order __m = memory_order_seq_cst) noexcept
    {
      memory_order __b = __m & __memory_order_mask;
      ;
      ;
      ;

      __atomic_clear (&_M_i, int(__m));
    }

    inline __attribute__((__always_inline__)) void
    clear(memory_order __m = memory_order_seq_cst) volatile noexcept
    {
      memory_order __b = __m & __memory_order_mask;
      ;
      ;
      ;

      __atomic_clear (&_M_i, int(__m));
    }

  private:
    static constexpr __atomic_flag_data_type
    _S_init(bool __i)
    { return __i ? 1 : 0; }
  };
# 264 "/usr/include/c++/10.2.0/bits/atomic_base.h" 3
  template<typename _ITp>
    struct __atomic_base
    {
      using value_type = _ITp;
      using difference_type = value_type;

    private:
      typedef _ITp __int_type;

      static constexpr int _S_alignment =
 sizeof(_ITp) > alignof(_ITp) ? sizeof(_ITp) : alignof(_ITp);

      alignas(_S_alignment) __int_type _M_i ;

    public:
      __atomic_base() noexcept = default;
      ~__atomic_base() noexcept = default;
      __atomic_base(const __atomic_base&) = delete;
      __atomic_base& operator=(const __atomic_base&) = delete;
      __atomic_base& operator=(const __atomic_base&) volatile = delete;


      constexpr __atomic_base(__int_type __i) noexcept : _M_i (__i) { }

      operator __int_type() const noexcept
      { return load(); }

      operator __int_type() const volatile noexcept
      { return load(); }

      __int_type
      operator=(__int_type __i) noexcept
      {
 store(__i);
 return __i;
      }

      __int_type
      operator=(__int_type __i) volatile noexcept
      {
 store(__i);
 return __i;
      }

      __int_type
      operator++(int) noexcept
      { return fetch_add(1); }

      __int_type
      operator++(int) volatile noexcept
      { return fetch_add(1); }

      __int_type
      operator--(int) noexcept
      { return fetch_sub(1); }

      __int_type
      operator--(int) volatile noexcept
      { return fetch_sub(1); }

      __int_type
      operator++() noexcept
      { return __atomic_add_fetch(&_M_i, 1, int(memory_order_seq_cst)); }

      __int_type
      operator++() volatile noexcept
      { return __atomic_add_fetch(&_M_i, 1, int(memory_order_seq_cst)); }

      __int_type
      operator--() noexcept
      { return __atomic_sub_fetch(&_M_i, 1, int(memory_order_seq_cst)); }

      __int_type
      operator--() volatile noexcept
      { return __atomic_sub_fetch(&_M_i, 1, int(memory_order_seq_cst)); }

      __int_type
      operator+=(__int_type __i) noexcept
      { return __atomic_add_fetch(&_M_i, __i, int(memory_order_seq_cst)); }

      __int_type
      operator+=(__int_type __i) volatile noexcept
      { return __atomic_add_fetch(&_M_i, __i, int(memory_order_seq_cst)); }

      __int_type
      operator-=(__int_type __i) noexcept
      { return __atomic_sub_fetch(&_M_i, __i, int(memory_order_seq_cst)); }

      __int_type
      operator-=(__int_type __i) volatile noexcept
      { return __atomic_sub_fetch(&_M_i, __i, int(memory_order_seq_cst)); }

      __int_type
      operator&=(__int_type __i) noexcept
      { return __atomic_and_fetch(&_M_i, __i, int(memory_order_seq_cst)); }

      __int_type
      operator&=(__int_type __i) volatile noexcept
      { return __atomic_and_fetch(&_M_i, __i, int(memory_order_seq_cst)); }

      __int_type
      operator|=(__int_type __i) noexcept
      { return __atomic_or_fetch(&_M_i, __i, int(memory_order_seq_cst)); }

      __int_type
      operator|=(__int_type __i) volatile noexcept
      { return __atomic_or_fetch(&_M_i, __i, int(memory_order_seq_cst)); }

      __int_type
      operator^=(__int_type __i) noexcept
      { return __atomic_xor_fetch(&_M_i, __i, int(memory_order_seq_cst)); }

      __int_type
      operator^=(__int_type __i) volatile noexcept
      { return __atomic_xor_fetch(&_M_i, __i, int(memory_order_seq_cst)); }

      bool
      is_lock_free() const noexcept
      {

 return __atomic_is_lock_free(sizeof(_M_i),
     reinterpret_cast<void *>(-_S_alignment));
      }

      bool
      is_lock_free() const volatile noexcept
      {

 return __atomic_is_lock_free(sizeof(_M_i),
     reinterpret_cast<void *>(-_S_alignment));
      }

      inline __attribute__((__always_inline__)) void
      store(__int_type __i, memory_order __m = memory_order_seq_cst) noexcept
      {
 memory_order __b = __m & __memory_order_mask;
 ;
 ;
 ;

 __atomic_store_n(&_M_i, __i, int(__m));
      }

      inline __attribute__((__always_inline__)) void
      store(__int_type __i,
     memory_order __m = memory_order_seq_cst) volatile noexcept
      {
 memory_order __b = __m & __memory_order_mask;
 ;
 ;
 ;

 __atomic_store_n(&_M_i, __i, int(__m));
      }

      inline __attribute__((__always_inline__)) __int_type
      load(memory_order __m = memory_order_seq_cst) const noexcept
      {
 memory_order __b = __m & __memory_order_mask;
 ;
 ;

 return __atomic_load_n(&_M_i, int(__m));
      }

      inline __attribute__((__always_inline__)) __int_type
      load(memory_order __m = memory_order_seq_cst) const volatile noexcept
      {
 memory_order __b = __m & __memory_order_mask;
 ;
 ;

 return __atomic_load_n(&_M_i, int(__m));
      }

      inline __attribute__((__always_inline__)) __int_type
      exchange(__int_type __i,
        memory_order __m = memory_order_seq_cst) noexcept
      {
 return __atomic_exchange_n(&_M_i, __i, int(__m));
      }


      inline __attribute__((__always_inline__)) __int_type
      exchange(__int_type __i,
        memory_order __m = memory_order_seq_cst) volatile noexcept
      {
 return __atomic_exchange_n(&_M_i, __i, int(__m));
      }

      inline __attribute__((__always_inline__)) bool
      compare_exchange_weak(__int_type& __i1, __int_type __i2,
       memory_order __m1, memory_order __m2) noexcept
      {
 memory_order __b2 = __m2 & __memory_order_mask;
 memory_order __b1 = __m1 & __memory_order_mask;
 ;
 ;
 ;

 return __atomic_compare_exchange_n(&_M_i, &__i1, __i2, 1,
        int(__m1), int(__m2));
      }

      inline __attribute__((__always_inline__)) bool
      compare_exchange_weak(__int_type& __i1, __int_type __i2,
       memory_order __m1,
       memory_order __m2) volatile noexcept
      {
 memory_order __b2 = __m2 & __memory_order_mask;
 memory_order __b1 = __m1 & __memory_order_mask;
 ;
 ;
 ;

 return __atomic_compare_exchange_n(&_M_i, &__i1, __i2, 1,
        int(__m1), int(__m2));
      }

      inline __attribute__((__always_inline__)) bool
      compare_exchange_weak(__int_type& __i1, __int_type __i2,
       memory_order __m = memory_order_seq_cst) noexcept
      {
 return compare_exchange_weak(__i1, __i2, __m,
         __cmpexch_failure_order(__m));
      }

      inline __attribute__((__always_inline__)) bool
      compare_exchange_weak(__int_type& __i1, __int_type __i2,
     memory_order __m = memory_order_seq_cst) volatile noexcept
      {
 return compare_exchange_weak(__i1, __i2, __m,
         __cmpexch_failure_order(__m));
      }

      inline __attribute__((__always_inline__)) bool
      compare_exchange_strong(__int_type& __i1, __int_type __i2,
         memory_order __m1, memory_order __m2) noexcept
      {
 memory_order __b2 = __m2 & __memory_order_mask;
 memory_order __b1 = __m1 & __memory_order_mask;
 ;
 ;
 ;

 return __atomic_compare_exchange_n(&_M_i, &__i1, __i2, 0,
        int(__m1), int(__m2));
      }

      inline __attribute__((__always_inline__)) bool
      compare_exchange_strong(__int_type& __i1, __int_type __i2,
         memory_order __m1,
         memory_order __m2) volatile noexcept
      {
 memory_order __b2 = __m2 & __memory_order_mask;
 memory_order __b1 = __m1 & __memory_order_mask;

 ;
 ;
 ;

 return __atomic_compare_exchange_n(&_M_i, &__i1, __i2, 0,
        int(__m1), int(__m2));
      }

      inline __attribute__((__always_inline__)) bool
      compare_exchange_strong(__int_type& __i1, __int_type __i2,
         memory_order __m = memory_order_seq_cst) noexcept
      {
 return compare_exchange_strong(__i1, __i2, __m,
           __cmpexch_failure_order(__m));
      }

      inline __attribute__((__always_inline__)) bool
      compare_exchange_strong(__int_type& __i1, __int_type __i2,
   memory_order __m = memory_order_seq_cst) volatile noexcept
      {
 return compare_exchange_strong(__i1, __i2, __m,
           __cmpexch_failure_order(__m));
      }

      inline __attribute__((__always_inline__)) __int_type
      fetch_add(__int_type __i,
  memory_order __m = memory_order_seq_cst) noexcept
      { return __atomic_fetch_add(&_M_i, __i, int(__m)); }

      inline __attribute__((__always_inline__)) __int_type
      fetch_add(__int_type __i,
  memory_order __m = memory_order_seq_cst) volatile noexcept
      { return __atomic_fetch_add(&_M_i, __i, int(__m)); }

      inline __attribute__((__always_inline__)) __int_type
      fetch_sub(__int_type __i,
  memory_order __m = memory_order_seq_cst) noexcept
      { return __atomic_fetch_sub(&_M_i, __i, int(__m)); }

      inline __attribute__((__always_inline__)) __int_type
      fetch_sub(__int_type __i,
  memory_order __m = memory_order_seq_cst) volatile noexcept
      { return __atomic_fetch_sub(&_M_i, __i, int(__m)); }

      inline __attribute__((__always_inline__)) __int_type
      fetch_and(__int_type __i,
  memory_order __m = memory_order_seq_cst) noexcept
      { return __atomic_fetch_and(&_M_i, __i, int(__m)); }

      inline __attribute__((__always_inline__)) __int_type
      fetch_and(__int_type __i,
  memory_order __m = memory_order_seq_cst) volatile noexcept
      { return __atomic_fetch_and(&_M_i, __i, int(__m)); }

      inline __attribute__((__always_inline__)) __int_type
      fetch_or(__int_type __i,
        memory_order __m = memory_order_seq_cst) noexcept
      { return __atomic_fetch_or(&_M_i, __i, int(__m)); }

      inline __attribute__((__always_inline__)) __int_type
      fetch_or(__int_type __i,
        memory_order __m = memory_order_seq_cst) volatile noexcept
      { return __atomic_fetch_or(&_M_i, __i, int(__m)); }

      inline __attribute__((__always_inline__)) __int_type
      fetch_xor(__int_type __i,
  memory_order __m = memory_order_seq_cst) noexcept
      { return __atomic_fetch_xor(&_M_i, __i, int(__m)); }

      inline __attribute__((__always_inline__)) __int_type
      fetch_xor(__int_type __i,
  memory_order __m = memory_order_seq_cst) volatile noexcept
      { return __atomic_fetch_xor(&_M_i, __i, int(__m)); }
    };



  template<typename _PTp>
    struct __atomic_base<_PTp*>
    {
    private:
      typedef _PTp* __pointer_type;

      __pointer_type _M_p ;


      constexpr ptrdiff_t
      _M_type_size(ptrdiff_t __d) const { return __d * sizeof(_PTp); }

      constexpr ptrdiff_t
      _M_type_size(ptrdiff_t __d) const volatile { return __d * sizeof(_PTp); }

    public:
      __atomic_base() noexcept = default;
      ~__atomic_base() noexcept = default;
      __atomic_base(const __atomic_base&) = delete;
      __atomic_base& operator=(const __atomic_base&) = delete;
      __atomic_base& operator=(const __atomic_base&) volatile = delete;


      constexpr __atomic_base(__pointer_type __p) noexcept : _M_p (__p) { }

      operator __pointer_type() const noexcept
      { return load(); }

      operator __pointer_type() const volatile noexcept
      { return load(); }

      __pointer_type
      operator=(__pointer_type __p) noexcept
      {
 store(__p);
 return __p;
      }

      __pointer_type
      operator=(__pointer_type __p) volatile noexcept
      {
 store(__p);
 return __p;
      }

      __pointer_type
      operator++(int) noexcept
      { return fetch_add(1); }

      __pointer_type
      operator++(int) volatile noexcept
      { return fetch_add(1); }

      __pointer_type
      operator--(int) noexcept
      { return fetch_sub(1); }

      __pointer_type
      operator--(int) volatile noexcept
      { return fetch_sub(1); }

      __pointer_type
      operator++() noexcept
      { return __atomic_add_fetch(&_M_p, _M_type_size(1),
      int(memory_order_seq_cst)); }

      __pointer_type
      operator++() volatile noexcept
      { return __atomic_add_fetch(&_M_p, _M_type_size(1),
      int(memory_order_seq_cst)); }

      __pointer_type
      operator--() noexcept
      { return __atomic_sub_fetch(&_M_p, _M_type_size(1),
      int(memory_order_seq_cst)); }

      __pointer_type
      operator--() volatile noexcept
      { return __atomic_sub_fetch(&_M_p, _M_type_size(1),
      int(memory_order_seq_cst)); }

      __pointer_type
      operator+=(ptrdiff_t __d) noexcept
      { return __atomic_add_fetch(&_M_p, _M_type_size(__d),
      int(memory_order_seq_cst)); }

      __pointer_type
      operator+=(ptrdiff_t __d) volatile noexcept
      { return __atomic_add_fetch(&_M_p, _M_type_size(__d),
      int(memory_order_seq_cst)); }

      __pointer_type
      operator-=(ptrdiff_t __d) noexcept
      { return __atomic_sub_fetch(&_M_p, _M_type_size(__d),
      int(memory_order_seq_cst)); }

      __pointer_type
      operator-=(ptrdiff_t __d) volatile noexcept
      { return __atomic_sub_fetch(&_M_p, _M_type_size(__d),
      int(memory_order_seq_cst)); }

      bool
      is_lock_free() const noexcept
      {

 return __atomic_is_lock_free(sizeof(_M_p),
     reinterpret_cast<void *>(-__alignof(_M_p)));
      }

      bool
      is_lock_free() const volatile noexcept
      {

 return __atomic_is_lock_free(sizeof(_M_p),
     reinterpret_cast<void *>(-__alignof(_M_p)));
      }

      inline __attribute__((__always_inline__)) void
      store(__pointer_type __p,
     memory_order __m = memory_order_seq_cst) noexcept
      {
        memory_order __b = __m & __memory_order_mask;

 ;
 ;
 ;

 __atomic_store_n(&_M_p, __p, int(__m));
      }

      inline __attribute__((__always_inline__)) void
      store(__pointer_type __p,
     memory_order __m = memory_order_seq_cst) volatile noexcept
      {
 memory_order __b = __m & __memory_order_mask;
 ;
 ;
 ;

 __atomic_store_n(&_M_p, __p, int(__m));
      }

      inline __attribute__((__always_inline__)) __pointer_type
      load(memory_order __m = memory_order_seq_cst) const noexcept
      {
 memory_order __b = __m & __memory_order_mask;
 ;
 ;

 return __atomic_load_n(&_M_p, int(__m));
      }

      inline __attribute__((__always_inline__)) __pointer_type
      load(memory_order __m = memory_order_seq_cst) const volatile noexcept
      {
 memory_order __b = __m & __memory_order_mask;
 ;
 ;

 return __atomic_load_n(&_M_p, int(__m));
      }

      inline __attribute__((__always_inline__)) __pointer_type
      exchange(__pointer_type __p,
        memory_order __m = memory_order_seq_cst) noexcept
      {
 return __atomic_exchange_n(&_M_p, __p, int(__m));
      }


      inline __attribute__((__always_inline__)) __pointer_type
      exchange(__pointer_type __p,
        memory_order __m = memory_order_seq_cst) volatile noexcept
      {
 return __atomic_exchange_n(&_M_p, __p, int(__m));
      }

      inline __attribute__((__always_inline__)) bool
      compare_exchange_strong(__pointer_type& __p1, __pointer_type __p2,
         memory_order __m1,
         memory_order __m2) noexcept
      {
 memory_order __b2 = __m2 & __memory_order_mask;
 memory_order __b1 = __m1 & __memory_order_mask;
 ;
 ;
 ;

 return __atomic_compare_exchange_n(&_M_p, &__p1, __p2, 0,
        int(__m1), int(__m2));
      }

      inline __attribute__((__always_inline__)) bool
      compare_exchange_strong(__pointer_type& __p1, __pointer_type __p2,
         memory_order __m1,
         memory_order __m2) volatile noexcept
      {
 memory_order __b2 = __m2 & __memory_order_mask;
 memory_order __b1 = __m1 & __memory_order_mask;

 ;
 ;
 ;

 return __atomic_compare_exchange_n(&_M_p, &__p1, __p2, 0,
        int(__m1), int(__m2));
      }

      inline __attribute__((__always_inline__)) __pointer_type
      fetch_add(ptrdiff_t __d,
  memory_order __m = memory_order_seq_cst) noexcept
      { return __atomic_fetch_add(&_M_p, _M_type_size(__d), int(__m)); }

      inline __attribute__((__always_inline__)) __pointer_type
      fetch_add(ptrdiff_t __d,
  memory_order __m = memory_order_seq_cst) volatile noexcept
      { return __atomic_fetch_add(&_M_p, _M_type_size(__d), int(__m)); }

      inline __attribute__((__always_inline__)) __pointer_type
      fetch_sub(ptrdiff_t __d,
  memory_order __m = memory_order_seq_cst) noexcept
      { return __atomic_fetch_sub(&_M_p, _M_type_size(__d), int(__m)); }

      inline __attribute__((__always_inline__)) __pointer_type
      fetch_sub(ptrdiff_t __d,
  memory_order __m = memory_order_seq_cst) volatile noexcept
      { return __atomic_fetch_sub(&_M_p, _M_type_size(__d), int(__m)); }
    };
# 1700 "/usr/include/c++/10.2.0/bits/atomic_base.h" 3

}
# 34 "/usr/include/c++/10.2.0/bits/shared_ptr_atomic.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{

# 47 "/usr/include/c++/10.2.0/bits/shared_ptr_atomic.h" 3
  struct _Sp_locker
  {
    _Sp_locker(const _Sp_locker&) = delete;
    _Sp_locker& operator=(const _Sp_locker&) = delete;


    explicit
    _Sp_locker(const void*) noexcept;
    _Sp_locker(const void*, const void*) noexcept;
    ~_Sp_locker();

  private:
    unsigned char _M_key1;
    unsigned char _M_key2;



  };
# 74 "/usr/include/c++/10.2.0/bits/shared_ptr_atomic.h" 3
  template<typename _Tp, _Lock_policy _Lp>
    inline bool
    atomic_is_lock_free(const __shared_ptr<_Tp, _Lp>* __p)
    {

      return __gthread_active_p() == 0;



    }

  template<typename _Tp>
    inline bool
    atomic_is_lock_free(const shared_ptr<_Tp>* __p)
    { return std::atomic_is_lock_free<_Tp, __default_lock_policy>(__p); }
# 101 "/usr/include/c++/10.2.0/bits/shared_ptr_atomic.h" 3
  template<typename _Tp>
    inline shared_ptr<_Tp>
    atomic_load_explicit(const shared_ptr<_Tp>* __p, memory_order)
    {
      _Sp_locker __lock{__p};
      return *__p;
    }

  template<typename _Tp>
    inline shared_ptr<_Tp>
    atomic_load(const shared_ptr<_Tp>* __p)
    { return std::atomic_load_explicit(__p, memory_order_seq_cst); }

  template<typename _Tp, _Lock_policy _Lp>
    inline __shared_ptr<_Tp, _Lp>
    atomic_load_explicit(const __shared_ptr<_Tp, _Lp>* __p, memory_order)
    {
      _Sp_locker __lock{__p};
      return *__p;
    }

  template<typename _Tp, _Lock_policy _Lp>
    inline __shared_ptr<_Tp, _Lp>
    atomic_load(const __shared_ptr<_Tp, _Lp>* __p)
    { return std::atomic_load_explicit(__p, memory_order_seq_cst); }
# 137 "/usr/include/c++/10.2.0/bits/shared_ptr_atomic.h" 3
  template<typename _Tp>
    inline void
    atomic_store_explicit(shared_ptr<_Tp>* __p, shared_ptr<_Tp> __r,
     memory_order)
    {
      _Sp_locker __lock{__p};
      __p->swap(__r);
    }

  template<typename _Tp>
    inline void
    atomic_store(shared_ptr<_Tp>* __p, shared_ptr<_Tp> __r)
    { std::atomic_store_explicit(__p, std::move(__r), memory_order_seq_cst); }

  template<typename _Tp, _Lock_policy _Lp>
    inline void
    atomic_store_explicit(__shared_ptr<_Tp, _Lp>* __p,
     __shared_ptr<_Tp, _Lp> __r,
     memory_order)
    {
      _Sp_locker __lock{__p};
      __p->swap(__r);
    }

  template<typename _Tp, _Lock_policy _Lp>
    inline void
    atomic_store(__shared_ptr<_Tp, _Lp>* __p, __shared_ptr<_Tp, _Lp> __r)
    { std::atomic_store_explicit(__p, std::move(__r), memory_order_seq_cst); }
# 174 "/usr/include/c++/10.2.0/bits/shared_ptr_atomic.h" 3
  template<typename _Tp>
    inline shared_ptr<_Tp>
    atomic_exchange_explicit(shared_ptr<_Tp>* __p, shared_ptr<_Tp> __r,
        memory_order)
    {
      _Sp_locker __lock{__p};
      __p->swap(__r);
      return __r;
    }

  template<typename _Tp>
    inline shared_ptr<_Tp>
    atomic_exchange(shared_ptr<_Tp>* __p, shared_ptr<_Tp> __r)
    {
      return std::atomic_exchange_explicit(__p, std::move(__r),
        memory_order_seq_cst);
    }

  template<typename _Tp, _Lock_policy _Lp>
    inline __shared_ptr<_Tp, _Lp>
    atomic_exchange_explicit(__shared_ptr<_Tp, _Lp>* __p,
        __shared_ptr<_Tp, _Lp> __r,
        memory_order)
    {
      _Sp_locker __lock{__p};
      __p->swap(__r);
      return __r;
    }

  template<typename _Tp, _Lock_policy _Lp>
    inline __shared_ptr<_Tp, _Lp>
    atomic_exchange(__shared_ptr<_Tp, _Lp>* __p, __shared_ptr<_Tp, _Lp> __r)
    {
      return std::atomic_exchange_explicit(__p, std::move(__r),
        memory_order_seq_cst);
    }
# 223 "/usr/include/c++/10.2.0/bits/shared_ptr_atomic.h" 3
  template<typename _Tp>
    bool
    atomic_compare_exchange_strong_explicit(shared_ptr<_Tp>* __p,
         shared_ptr<_Tp>* __v,
         shared_ptr<_Tp> __w,
         memory_order,
         memory_order)
    {
      shared_ptr<_Tp> __x;
      _Sp_locker __lock{__p, __v};
      owner_less<shared_ptr<_Tp>> __less;
      if (*__p == *__v && !__less(*__p, *__v) && !__less(*__v, *__p))
 {
   __x = std::move(*__p);
   *__p = std::move(__w);
   return true;
 }
      __x = std::move(*__v);
      *__v = *__p;
      return false;
    }

  template<typename _Tp>
    inline bool
    atomic_compare_exchange_strong(shared_ptr<_Tp>* __p, shared_ptr<_Tp>* __v,
     shared_ptr<_Tp> __w)
    {
      return std::atomic_compare_exchange_strong_explicit(__p, __v,
   std::move(__w), memory_order_seq_cst, memory_order_seq_cst);
    }

  template<typename _Tp>
    inline bool
    atomic_compare_exchange_weak_explicit(shared_ptr<_Tp>* __p,
       shared_ptr<_Tp>* __v,
       shared_ptr<_Tp> __w,
       memory_order __success,
       memory_order __failure)
    {
      return std::atomic_compare_exchange_strong_explicit(__p, __v,
   std::move(__w), __success, __failure);
    }

  template<typename _Tp>
    inline bool
    atomic_compare_exchange_weak(shared_ptr<_Tp>* __p, shared_ptr<_Tp>* __v,
     shared_ptr<_Tp> __w)
    {
      return std::atomic_compare_exchange_weak_explicit(__p, __v,
   std::move(__w), memory_order_seq_cst, memory_order_seq_cst);
    }

  template<typename _Tp, _Lock_policy _Lp>
    bool
    atomic_compare_exchange_strong_explicit(__shared_ptr<_Tp, _Lp>* __p,
         __shared_ptr<_Tp, _Lp>* __v,
         __shared_ptr<_Tp, _Lp> __w,
         memory_order,
         memory_order)
    {
      __shared_ptr<_Tp, _Lp> __x;
      _Sp_locker __lock{__p, __v};
      owner_less<__shared_ptr<_Tp, _Lp>> __less;
      if (*__p == *__v && !__less(*__p, *__v) && !__less(*__v, *__p))
 {
   __x = std::move(*__p);
   *__p = std::move(__w);
   return true;
 }
      __x = std::move(*__v);
      *__v = *__p;
      return false;
    }

  template<typename _Tp, _Lock_policy _Lp>
    inline bool
    atomic_compare_exchange_strong(__shared_ptr<_Tp, _Lp>* __p,
       __shared_ptr<_Tp, _Lp>* __v,
       __shared_ptr<_Tp, _Lp> __w)
    {
      return std::atomic_compare_exchange_strong_explicit(__p, __v,
   std::move(__w), memory_order_seq_cst, memory_order_seq_cst);
    }

  template<typename _Tp, _Lock_policy _Lp>
    inline bool
    atomic_compare_exchange_weak_explicit(__shared_ptr<_Tp, _Lp>* __p,
       __shared_ptr<_Tp, _Lp>* __v,
       __shared_ptr<_Tp, _Lp> __w,
       memory_order __success,
       memory_order __failure)
    {
      return std::atomic_compare_exchange_strong_explicit(__p, __v,
   std::move(__w), __success, __failure);
    }

  template<typename _Tp, _Lock_policy _Lp>
    inline bool
    atomic_compare_exchange_weak(__shared_ptr<_Tp, _Lp>* __p,
     __shared_ptr<_Tp, _Lp>* __v,
     __shared_ptr<_Tp, _Lp> __w)
    {
      return std::atomic_compare_exchange_weak_explicit(__p, __v,
   std::move(__w), memory_order_seq_cst, memory_order_seq_cst);
    }






}
# 86 "/usr/include/c++/10.2.0/memory" 2 3

# 1 "/usr/include/c++/10.2.0/backward/auto_ptr.h" 1 3
# 36 "/usr/include/c++/10.2.0/backward/auto_ptr.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{

# 47 "/usr/include/c++/10.2.0/backward/auto_ptr.h" 3
  template<typename _Tp1>
    struct auto_ptr_ref
    {
      _Tp1* _M_ptr;

      explicit
      auto_ptr_ref(_Tp1* __p): _M_ptr(__p) { }
    } __attribute__ ((__deprecated__));

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
# 88 "/usr/include/c++/10.2.0/backward/auto_ptr.h" 3
  template<typename _Tp>
    class auto_ptr
    {
    private:
      _Tp* _M_ptr;

    public:

      typedef _Tp element_type;







      explicit
      auto_ptr(element_type* __p = 0) throw() : _M_ptr(__p) { }
# 114 "/usr/include/c++/10.2.0/backward/auto_ptr.h" 3
      auto_ptr(auto_ptr& __a) throw() : _M_ptr(__a.release()) { }
# 126 "/usr/include/c++/10.2.0/backward/auto_ptr.h" 3
      template<typename _Tp1>
        auto_ptr(auto_ptr<_Tp1>& __a) throw() : _M_ptr(__a.release()) { }
# 137 "/usr/include/c++/10.2.0/backward/auto_ptr.h" 3
      auto_ptr&
      operator=(auto_ptr& __a) throw()
      {
 reset(__a.release());
 return *this;
      }
# 154 "/usr/include/c++/10.2.0/backward/auto_ptr.h" 3
      template<typename _Tp1>
        auto_ptr&
        operator=(auto_ptr<_Tp1>& __a) throw()
        {
   reset(__a.release());
   return *this;
 }
# 172 "/usr/include/c++/10.2.0/backward/auto_ptr.h" 3
      ~auto_ptr() { delete _M_ptr; }
# 182 "/usr/include/c++/10.2.0/backward/auto_ptr.h" 3
      element_type&
      operator*() const throw()
      {
 ;
 return *_M_ptr;
      }







      element_type*
      operator->() const throw()
      {
 ;
 return _M_ptr;
      }
# 212 "/usr/include/c++/10.2.0/backward/auto_ptr.h" 3
      element_type*
      get() const throw() { return _M_ptr; }
# 226 "/usr/include/c++/10.2.0/backward/auto_ptr.h" 3
      element_type*
      release() throw()
      {
 element_type* __tmp = _M_ptr;
 _M_ptr = 0;
 return __tmp;
      }
# 241 "/usr/include/c++/10.2.0/backward/auto_ptr.h" 3
      void
      reset(element_type* __p = 0) throw()
      {
 if (__p != _M_ptr)
   {
     delete _M_ptr;
     _M_ptr = __p;
   }
      }
# 266 "/usr/include/c++/10.2.0/backward/auto_ptr.h" 3
      auto_ptr(auto_ptr_ref<element_type> __ref) throw()
      : _M_ptr(__ref._M_ptr) { }

      auto_ptr&
      operator=(auto_ptr_ref<element_type> __ref) throw()
      {
 if (__ref._M_ptr != this->get())
   {
     delete _M_ptr;
     _M_ptr = __ref._M_ptr;
   }
 return *this;
      }

      template<typename _Tp1>
        operator auto_ptr_ref<_Tp1>() throw()
        { return auto_ptr_ref<_Tp1>(this->release()); }

      template<typename _Tp1>
        operator auto_ptr<_Tp1>() throw()
        { return auto_ptr<_Tp1>(this->release()); }
    } __attribute__ ((__deprecated__));



  template<>
    class auto_ptr<void>
    {
    public:
      typedef void element_type;
    } __attribute__ ((__deprecated__));


  template<_Lock_policy _Lp>
  template<typename _Tp>
    inline
    __shared_count<_Lp>::__shared_count(std::auto_ptr<_Tp>&& __r)
    : _M_pi(new _Sp_counted_ptr<_Tp*, _Lp>(__r.get()))
    { __r.release(); }

  template<typename _Tp, _Lock_policy _Lp>
  template<typename _Tp1, typename>
    inline
    __shared_ptr<_Tp, _Lp>::__shared_ptr(std::auto_ptr<_Tp1>&& __r)
    : _M_ptr(__r.get()), _M_refcount()
    {
     
      static_assert( sizeof(_Tp1) > 0, "incomplete type" );
      _Tp1* __tmp = __r.get();
      _M_refcount = __shared_count<_Lp>(std::move(__r));
      _M_enable_shared_from_this_with(__tmp);
    }

  template<typename _Tp>
  template<typename _Tp1, typename>
    inline
    shared_ptr<_Tp>::shared_ptr(std::auto_ptr<_Tp1>&& __r)
    : __shared_ptr<_Tp>(std::move(__r)) { }

  template<typename _Tp, typename _Dp>
  template<typename _Up, typename>
    inline
    unique_ptr<_Tp, _Dp>::unique_ptr(auto_ptr<_Up>&& __u) noexcept
    : _M_t(__u.release(), deleter_type()) { }


#pragma GCC diagnostic pop


}
# 88 "/usr/include/c++/10.2.0/memory" 2 3
# 100 "/usr/include/c++/10.2.0/memory" 3
namespace std __attribute__ ((__visibility__ ("default")))
{

# 122 "/usr/include/c++/10.2.0/memory" 3
inline void*
align(size_t __align, size_t __size, void*& __ptr, size_t& __space) noexcept
{

  const auto __intptr = reinterpret_cast<uintptr_t>(__ptr);






  const auto __aligned = (__intptr - 1u + __align) & -__align;
  const auto __diff = __aligned - __intptr;
  if ((__size + __diff) > __space)
    return nullptr;
  else
    {
      __space -= __diff;
      return __ptr = reinterpret_cast<void*>(__aligned);
    }
}
# 158 "/usr/include/c++/10.2.0/memory" 3
enum class pointer_safety { relaxed, preferred, strict };


inline void
declare_reachable(void*) { }


template <typename _Tp>
  inline _Tp*
  undeclare_reachable(_Tp* __p) { return __p; }


inline void
declare_no_pointers(char*, size_t) { }


inline void
undeclare_no_pointers(char*, size_t) { }


inline pointer_safety
get_pointer_safety() noexcept { return pointer_safety::relaxed; }
# 400 "/usr/include/c++/10.2.0/memory" 3

}
# 12 "/usr/include/json/config.h" 2 3 4

# 1 "/usr/include/c++/10.2.0/sstream" 1 3 4
# 36 "/usr/include/c++/10.2.0/sstream" 3 4
       
# 37 "/usr/include/c++/10.2.0/sstream" 3




namespace std __attribute__ ((__visibility__ ("default")))
{

namespace __cxx11 {
# 64 "/usr/include/c++/10.2.0/sstream" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    class basic_stringbuf : public basic_streambuf<_CharT, _Traits>
    {
      struct __xfer_bufptrs;
    public:

      typedef _CharT char_type;
      typedef _Traits traits_type;


      typedef _Alloc allocator_type;
      typedef typename traits_type::int_type int_type;
      typedef typename traits_type::pos_type pos_type;
      typedef typename traits_type::off_type off_type;

      typedef basic_streambuf<char_type, traits_type> __streambuf_type;
      typedef basic_string<char_type, _Traits, _Alloc> __string_type;
      typedef typename __string_type::size_type __size_type;

    protected:

      ios_base::openmode _M_mode;


      __string_type _M_string;

    public:
# 99 "/usr/include/c++/10.2.0/sstream" 3
      basic_stringbuf()
      : __streambuf_type(), _M_mode(ios_base::in | ios_base::out), _M_string()
      { }
# 110 "/usr/include/c++/10.2.0/sstream" 3
      explicit
      basic_stringbuf(ios_base::openmode __mode)
      : __streambuf_type(), _M_mode(__mode), _M_string()
      { }
# 123 "/usr/include/c++/10.2.0/sstream" 3
      explicit
      basic_stringbuf(const __string_type& __str,
        ios_base::openmode __mode = ios_base::in | ios_base::out)
      : __streambuf_type(), _M_mode(),
 _M_string(__str.data(), __str.size(), __str.get_allocator())
      { _M_stringbuf_init(__mode); }


      basic_stringbuf(const basic_stringbuf&) = delete;

      basic_stringbuf(basic_stringbuf&& __rhs)
      : basic_stringbuf(std::move(__rhs), __xfer_bufptrs(__rhs, this))
      { __rhs._M_sync(const_cast<char_type*>(__rhs._M_string.data()), 0, 0); }



      basic_stringbuf&
      operator=(const basic_stringbuf&) = delete;

      basic_stringbuf&
      operator=(basic_stringbuf&& __rhs)
      {
 __xfer_bufptrs __st{__rhs, this};
 const __streambuf_type& __base = __rhs;
 __streambuf_type::operator=(__base);
 this->pubimbue(__rhs.getloc());
 _M_mode = __rhs._M_mode;
 _M_string = std::move(__rhs._M_string);
 __rhs._M_sync(const_cast<char_type*>(__rhs._M_string.data()), 0, 0);
 return *this;
      }

      void
      swap(basic_stringbuf& __rhs)
      {
 __xfer_bufptrs __l_st{*this, std::__addressof(__rhs)};
 __xfer_bufptrs __r_st{__rhs, this};
 __streambuf_type& __base = __rhs;
 __streambuf_type::swap(__base);
 __rhs.pubimbue(this->pubimbue(__rhs.getloc()));
 std::swap(_M_mode, __rhs._M_mode);
 std::swap(_M_string, __rhs._M_string);
      }
# 177 "/usr/include/c++/10.2.0/sstream" 3
      __string_type
      str() const
      {
 __string_type __ret(_M_string.get_allocator());
 if (this->pptr())
   {

     if (this->pptr() > this->egptr())
       __ret.assign(this->pbase(), this->pptr());
     else
       __ret.assign(this->pbase(), this->egptr());
   }
 else
   __ret = _M_string;
 return __ret;
      }
# 201 "/usr/include/c++/10.2.0/sstream" 3
      void
      str(const __string_type& __s)
      {


 _M_string.assign(__s.data(), __s.size());
 _M_stringbuf_init(_M_mode);
      }

    protected:

      void
      _M_stringbuf_init(ios_base::openmode __mode)
      {
 _M_mode = __mode;
 __size_type __len = 0;
 if (_M_mode & (ios_base::ate | ios_base::app))
   __len = _M_string.size();
 _M_sync(const_cast<char_type*>(_M_string.data()), 0, __len);
      }

      virtual streamsize
      showmanyc()
      {
 streamsize __ret = -1;
 if (_M_mode & ios_base::in)
   {
     _M_update_egptr();
     __ret = this->egptr() - this->gptr();
   }
 return __ret;
      }

      virtual int_type
      underflow();

      virtual int_type
      pbackfail(int_type __c = traits_type::eof());

      virtual int_type
      overflow(int_type __c = traits_type::eof());
# 254 "/usr/include/c++/10.2.0/sstream" 3
      virtual __streambuf_type*
      setbuf(char_type* __s, streamsize __n)
      {
 if (__s && __n >= 0)
   {






     _M_string.clear();


     _M_sync(__s, __n, 0);
   }
 return this;
      }

      virtual pos_type
      seekoff(off_type __off, ios_base::seekdir __way,
       ios_base::openmode __mode = ios_base::in | ios_base::out);

      virtual pos_type
      seekpos(pos_type __sp,
       ios_base::openmode __mode = ios_base::in | ios_base::out);




      void
      _M_sync(char_type* __base, __size_type __i, __size_type __o);



      void
      _M_update_egptr()
      {
 const bool __testin = _M_mode & ios_base::in;
 if (this->pptr() && this->pptr() > this->egptr())
   {
     if (__testin)
       this->setg(this->eback(), this->gptr(), this->pptr());
     else
       this->setg(this->pptr(), this->pptr(), this->pptr());
   }
      }



      void
      _M_pbump(char_type* __pbeg, char_type* __pend, off_type __off);

    private:




      struct __xfer_bufptrs
      {
 __xfer_bufptrs(const basic_stringbuf& __from, basic_stringbuf* __to)
 : _M_to{__to}, _M_goff{-1, -1, -1}, _M_poff{-1, -1, -1}
 {
   const _CharT* const __str = __from._M_string.data();
   const _CharT* __end = nullptr;
   if (__from.eback())
     {
       _M_goff[0] = __from.eback() - __str;
       _M_goff[1] = __from.gptr() - __str;
       _M_goff[2] = __from.egptr() - __str;
       __end = __from.egptr();
     }
   if (__from.pbase())
     {
       _M_poff[0] = __from.pbase() - __str;
       _M_poff[1] = __from.pptr() - __from.pbase();
       _M_poff[2] = __from.epptr() - __str;
       if (__from.pptr() > __end)
  __end = __from.pptr();
     }


   if (__end)
     {


       auto& __mut_from = const_cast<basic_stringbuf&>(__from);
       __mut_from._M_string._M_length(__end - __str);
     }
 }

 ~__xfer_bufptrs()
 {
   char_type* __str = const_cast<char_type*>(_M_to->_M_string.data());
   if (_M_goff[0] != -1)
     _M_to->setg(__str+_M_goff[0], __str+_M_goff[1], __str+_M_goff[2]);
   if (_M_poff[0] != -1)
     _M_to->_M_pbump(__str+_M_poff[0], __str+_M_poff[2], _M_poff[1]);
 }

 basic_stringbuf* _M_to;
 off_type _M_goff[3];
 off_type _M_poff[3];
      };
# 368 "/usr/include/c++/10.2.0/sstream" 3
      basic_stringbuf(basic_stringbuf&& __rhs, __xfer_bufptrs&&)
      : __streambuf_type(static_cast<const __streambuf_type&>(__rhs)),
      _M_mode(__rhs._M_mode), _M_string(std::move(__rhs._M_string))
      { }

    };
# 391 "/usr/include/c++/10.2.0/sstream" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    class basic_istringstream : public basic_istream<_CharT, _Traits>
    {
    public:

      typedef _CharT char_type;
      typedef _Traits traits_type;


      typedef _Alloc allocator_type;
      typedef typename traits_type::int_type int_type;
      typedef typename traits_type::pos_type pos_type;
      typedef typename traits_type::off_type off_type;


      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef basic_stringbuf<_CharT, _Traits, _Alloc> __stringbuf_type;
      typedef basic_istream<char_type, traits_type> __istream_type;

    private:
      __stringbuf_type _M_stringbuf;

    public:
# 425 "/usr/include/c++/10.2.0/sstream" 3
      basic_istringstream()
      : __istream_type(), _M_stringbuf(ios_base::in)
      { this->init(&_M_stringbuf); }
# 441 "/usr/include/c++/10.2.0/sstream" 3
      explicit
      basic_istringstream(ios_base::openmode __mode)
      : __istream_type(), _M_stringbuf(__mode | ios_base::in)
      { this->init(&_M_stringbuf); }
# 459 "/usr/include/c++/10.2.0/sstream" 3
      explicit
      basic_istringstream(const __string_type& __str,
     ios_base::openmode __mode = ios_base::in)
      : __istream_type(), _M_stringbuf(__str, __mode | ios_base::in)
      { this->init(&_M_stringbuf); }







      ~basic_istringstream()
      { }


      basic_istringstream(const basic_istringstream&) = delete;

      basic_istringstream(basic_istringstream&& __rhs)
      : __istream_type(std::move(__rhs)),
      _M_stringbuf(std::move(__rhs._M_stringbuf))
      { __istream_type::set_rdbuf(&_M_stringbuf); }



      basic_istringstream&
      operator=(const basic_istringstream&) = delete;

      basic_istringstream&
      operator=(basic_istringstream&& __rhs)
      {
 __istream_type::operator=(std::move(__rhs));
 _M_stringbuf = std::move(__rhs._M_stringbuf);
 return *this;
      }

      void
      swap(basic_istringstream& __rhs)
      {
 __istream_type::swap(__rhs);
 _M_stringbuf.swap(__rhs._M_stringbuf);
      }
# 510 "/usr/include/c++/10.2.0/sstream" 3
      __stringbuf_type*
      rdbuf() const
      { return const_cast<__stringbuf_type*>(&_M_stringbuf); }





      __string_type
      str() const
      { return _M_stringbuf.str(); }







      void
      str(const __string_type& __s)
      { _M_stringbuf.str(__s); }
    };
# 549 "/usr/include/c++/10.2.0/sstream" 3
  template <typename _CharT, typename _Traits, typename _Alloc>
    class basic_ostringstream : public basic_ostream<_CharT, _Traits>
    {
    public:

      typedef _CharT char_type;
      typedef _Traits traits_type;


      typedef _Alloc allocator_type;
      typedef typename traits_type::int_type int_type;
      typedef typename traits_type::pos_type pos_type;
      typedef typename traits_type::off_type off_type;


      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef basic_stringbuf<_CharT, _Traits, _Alloc> __stringbuf_type;
      typedef basic_ostream<char_type, traits_type> __ostream_type;

    private:
      __stringbuf_type _M_stringbuf;

    public:
# 583 "/usr/include/c++/10.2.0/sstream" 3
      basic_ostringstream()
      : __ostream_type(), _M_stringbuf(ios_base::out)
      { this->init(&_M_stringbuf); }
# 599 "/usr/include/c++/10.2.0/sstream" 3
      explicit
      basic_ostringstream(ios_base::openmode __mode)
      : __ostream_type(), _M_stringbuf(__mode | ios_base::out)
      { this->init(&_M_stringbuf); }
# 617 "/usr/include/c++/10.2.0/sstream" 3
      explicit
      basic_ostringstream(const __string_type& __str,
     ios_base::openmode __mode = ios_base::out)
      : __ostream_type(), _M_stringbuf(__str, __mode | ios_base::out)
      { this->init(&_M_stringbuf); }







      ~basic_ostringstream()
      { }


      basic_ostringstream(const basic_ostringstream&) = delete;

      basic_ostringstream(basic_ostringstream&& __rhs)
      : __ostream_type(std::move(__rhs)),
      _M_stringbuf(std::move(__rhs._M_stringbuf))
      { __ostream_type::set_rdbuf(&_M_stringbuf); }



      basic_ostringstream&
      operator=(const basic_ostringstream&) = delete;

      basic_ostringstream&
      operator=(basic_ostringstream&& __rhs)
      {
 __ostream_type::operator=(std::move(__rhs));
 _M_stringbuf = std::move(__rhs._M_stringbuf);
 return *this;
      }

      void
      swap(basic_ostringstream& __rhs)
      {
 __ostream_type::swap(__rhs);
 _M_stringbuf.swap(__rhs._M_stringbuf);
      }
# 668 "/usr/include/c++/10.2.0/sstream" 3
      __stringbuf_type*
      rdbuf() const
      { return const_cast<__stringbuf_type*>(&_M_stringbuf); }





      __string_type
      str() const
      { return _M_stringbuf.str(); }







      void
      str(const __string_type& __s)
      { _M_stringbuf.str(__s); }
    };
# 707 "/usr/include/c++/10.2.0/sstream" 3
  template <typename _CharT, typename _Traits, typename _Alloc>
    class basic_stringstream : public basic_iostream<_CharT, _Traits>
    {
    public:

      typedef _CharT char_type;
      typedef _Traits traits_type;


      typedef _Alloc allocator_type;
      typedef typename traits_type::int_type int_type;
      typedef typename traits_type::pos_type pos_type;
      typedef typename traits_type::off_type off_type;


      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef basic_stringbuf<_CharT, _Traits, _Alloc> __stringbuf_type;
      typedef basic_iostream<char_type, traits_type> __iostream_type;

    private:
      __stringbuf_type _M_stringbuf;

    public:
# 741 "/usr/include/c++/10.2.0/sstream" 3
      basic_stringstream()
      : __iostream_type(), _M_stringbuf(ios_base::out | ios_base::in)
      { this->init(&_M_stringbuf); }
# 755 "/usr/include/c++/10.2.0/sstream" 3
      explicit
      basic_stringstream(ios_base::openmode __m)
      : __iostream_type(), _M_stringbuf(__m)
      { this->init(&_M_stringbuf); }
# 771 "/usr/include/c++/10.2.0/sstream" 3
      explicit
      basic_stringstream(const __string_type& __str,
    ios_base::openmode __m = ios_base::out | ios_base::in)
      : __iostream_type(), _M_stringbuf(__str, __m)
      { this->init(&_M_stringbuf); }







      ~basic_stringstream()
      { }


      basic_stringstream(const basic_stringstream&) = delete;

      basic_stringstream(basic_stringstream&& __rhs)
      : __iostream_type(std::move(__rhs)),
      _M_stringbuf(std::move(__rhs._M_stringbuf))
      { __iostream_type::set_rdbuf(&_M_stringbuf); }



      basic_stringstream&
      operator=(const basic_stringstream&) = delete;

      basic_stringstream&
      operator=(basic_stringstream&& __rhs)
      {
 __iostream_type::operator=(std::move(__rhs));
 _M_stringbuf = std::move(__rhs._M_stringbuf);
 return *this;
      }

      void
      swap(basic_stringstream& __rhs)
      {
 __iostream_type::swap(__rhs);
 _M_stringbuf.swap(__rhs._M_stringbuf);
      }
# 822 "/usr/include/c++/10.2.0/sstream" 3
      __stringbuf_type*
      rdbuf() const
      { return const_cast<__stringbuf_type*>(&_M_stringbuf); }





      __string_type
      str() const
      { return _M_stringbuf.str(); }







      void
      str(const __string_type& __s)
      { _M_stringbuf.str(__s); }
    };



  template <class _CharT, class _Traits, class _Allocator>
    inline void
    swap(basic_stringbuf<_CharT, _Traits, _Allocator>& __x,
  basic_stringbuf<_CharT, _Traits, _Allocator>& __y)
    { __x.swap(__y); }


  template <class _CharT, class _Traits, class _Allocator>
    inline void
    swap(basic_istringstream<_CharT, _Traits, _Allocator>& __x,
  basic_istringstream<_CharT, _Traits, _Allocator>& __y)
    { __x.swap(__y); }


  template <class _CharT, class _Traits, class _Allocator>
    inline void
    swap(basic_ostringstream<_CharT, _Traits, _Allocator>& __x,
  basic_ostringstream<_CharT, _Traits, _Allocator>& __y)
    { __x.swap(__y); }


  template <class _CharT, class _Traits, class _Allocator>
    inline void
    swap(basic_stringstream<_CharT, _Traits, _Allocator>& __x,
  basic_stringstream<_CharT, _Traits, _Allocator>& __y)
    { __x.swap(__y); }


}

}

# 1 "/usr/include/c++/10.2.0/bits/sstream.tcc" 1 3
# 37 "/usr/include/c++/10.2.0/bits/sstream.tcc" 3
       
# 38 "/usr/include/c++/10.2.0/bits/sstream.tcc" 3

namespace std __attribute__ ((__visibility__ ("default")))
{


  template <class _CharT, class _Traits, class _Alloc>
    typename basic_stringbuf<_CharT, _Traits, _Alloc>::int_type
    basic_stringbuf<_CharT, _Traits, _Alloc>::
    pbackfail(int_type __c)
    {
      int_type __ret = traits_type::eof();
      if (this->eback() < this->gptr())
 {


   const bool __testeof = traits_type::eq_int_type(__c, __ret);
   if (!__testeof)
     {
       const bool __testeq = traits_type::eq(traits_type::
          to_char_type(__c),
          this->gptr()[-1]);
       const bool __testout = this->_M_mode & ios_base::out;
       if (__testeq || __testout)
  {
    this->gbump(-1);
    if (!__testeq)
      *this->gptr() = traits_type::to_char_type(__c);
    __ret = __c;
  }
     }
   else
     {
       this->gbump(-1);
       __ret = traits_type::not_eof(__c);
     }
 }
      return __ret;
    }

  template <class _CharT, class _Traits, class _Alloc>
    typename basic_stringbuf<_CharT, _Traits, _Alloc>::int_type
    basic_stringbuf<_CharT, _Traits, _Alloc>::
    overflow(int_type __c)
    {
      const bool __testout = this->_M_mode & ios_base::out;
      if (__builtin_expect(!__testout, false))
 return traits_type::eof();

      const bool __testeof = traits_type::eq_int_type(__c, traits_type::eof());
      if (__builtin_expect(__testeof, false))
 return traits_type::not_eof(__c);

      const __size_type __capacity = _M_string.capacity();


      if ((this->epptr() - this->pbase()) < __capacity)
 {

   char_type* __base = const_cast<char_type*>(_M_string.data());
   _M_pbump(__base, __base + __capacity, this->pptr() - this->pbase());
   if (_M_mode & ios_base::in)
     {
       const __size_type __nget = this->gptr() - this->eback();
       const __size_type __eget = this->egptr() - this->eback();
       this->setg(__base, __base + __nget, __base + __eget + 1);
     }
   *this->pptr() = traits_type::to_char_type(__c);
   this->pbump(1);
   return __c;
 }


      const __size_type __max_size = _M_string.max_size();
      const bool __testput = this->pptr() < this->epptr();
      if (__builtin_expect(!__testput && __capacity == __max_size, false))
 return traits_type::eof();



      const char_type __conv = traits_type::to_char_type(__c);
      if (!__testput)
 {
# 129 "/usr/include/c++/10.2.0/bits/sstream.tcc" 3
   const __size_type __opt_len = std::max(__size_type(2 * __capacity),
       __size_type(512));
   const __size_type __len = std::min(__opt_len, __max_size);
   __string_type __tmp(_M_string.get_allocator());
   __tmp.reserve(__len);
   if (this->pbase())
     __tmp.assign(this->pbase(), this->epptr() - this->pbase());
   __tmp.push_back(__conv);
   _M_string.swap(__tmp);
   _M_sync(const_cast<char_type*>(_M_string.data()),
    this->gptr() - this->eback(), this->pptr() - this->pbase());
 }
      else
 *this->pptr() = __conv;
      this->pbump(1);
      return __c;
    }

  template <class _CharT, class _Traits, class _Alloc>
    typename basic_stringbuf<_CharT, _Traits, _Alloc>::int_type
    basic_stringbuf<_CharT, _Traits, _Alloc>::
    underflow()
    {
      int_type __ret = traits_type::eof();
      const bool __testin = this->_M_mode & ios_base::in;
      if (__testin)
 {

   _M_update_egptr();

   if (this->gptr() < this->egptr())
     __ret = traits_type::to_int_type(*this->gptr());
 }
      return __ret;
    }

  template <class _CharT, class _Traits, class _Alloc>
    typename basic_stringbuf<_CharT, _Traits, _Alloc>::pos_type
    basic_stringbuf<_CharT, _Traits, _Alloc>::
    seekoff(off_type __off, ios_base::seekdir __way, ios_base::openmode __mode)
    {
      pos_type __ret = pos_type(off_type(-1));
      bool __testin = (ios_base::in & this->_M_mode & __mode) != 0;
      bool __testout = (ios_base::out & this->_M_mode & __mode) != 0;
      const bool __testboth = __testin && __testout && __way != ios_base::cur;
      __testin &= !(__mode & ios_base::out);
      __testout &= !(__mode & ios_base::in);



      const char_type* __beg = __testin ? this->eback() : this->pbase();
      if ((__beg || !__off) && (__testin || __testout || __testboth))
 {
   _M_update_egptr();

   off_type __newoffi = __off;
   off_type __newoffo = __newoffi;
   if (__way == ios_base::cur)
     {
       __newoffi += this->gptr() - __beg;
       __newoffo += this->pptr() - __beg;
     }
   else if (__way == ios_base::end)
     __newoffo = __newoffi += this->egptr() - __beg;

   if ((__testin || __testboth)
       && __newoffi >= 0
       && this->egptr() - __beg >= __newoffi)
     {
       this->setg(this->eback(), this->eback() + __newoffi,
    this->egptr());
       __ret = pos_type(__newoffi);
     }
   if ((__testout || __testboth)
       && __newoffo >= 0
       && this->egptr() - __beg >= __newoffo)
     {
       _M_pbump(this->pbase(), this->epptr(), __newoffo);
       __ret = pos_type(__newoffo);
     }
 }
      return __ret;
    }

  template <class _CharT, class _Traits, class _Alloc>
    typename basic_stringbuf<_CharT, _Traits, _Alloc>::pos_type
    basic_stringbuf<_CharT, _Traits, _Alloc>::
    seekpos(pos_type __sp, ios_base::openmode __mode)
    {
      pos_type __ret = pos_type(off_type(-1));
      const bool __testin = (ios_base::in & this->_M_mode & __mode) != 0;
      const bool __testout = (ios_base::out & this->_M_mode & __mode) != 0;

      const char_type* __beg = __testin ? this->eback() : this->pbase();
      if ((__beg || !off_type(__sp)) && (__testin || __testout))
 {
   _M_update_egptr();

   const off_type __pos(__sp);
   const bool __testpos = (0 <= __pos
      && __pos <= this->egptr() - __beg);
   if (__testpos)
     {
       if (__testin)
  this->setg(this->eback(), this->eback() + __pos,
      this->egptr());
       if (__testout)
  _M_pbump(this->pbase(), this->epptr(), __pos);
       __ret = __sp;
     }
 }
      return __ret;
    }

  template <class _CharT, class _Traits, class _Alloc>
    void
    basic_stringbuf<_CharT, _Traits, _Alloc>::
    _M_sync(char_type* __base, __size_type __i, __size_type __o)
    {
      const bool __testin = _M_mode & ios_base::in;
      const bool __testout = _M_mode & ios_base::out;
      char_type* __endg = __base + _M_string.size();
      char_type* __endp = __base + _M_string.capacity();

      if (__base != _M_string.data())
 {

   __endg += __i;
   __i = 0;
   __endp = __endg;
 }

      if (__testin)
 this->setg(__base, __base + __i, __endg);
      if (__testout)
 {
   _M_pbump(__base, __endp, __o);



   if (!__testin)
     this->setg(__endg, __endg, __endg);
 }
    }

  template <class _CharT, class _Traits, class _Alloc>
    void
    basic_stringbuf<_CharT, _Traits, _Alloc>::
    _M_pbump(char_type* __pbeg, char_type* __pend, off_type __off)
    {
      this->setp(__pbeg, __pend);
      while (__off > __gnu_cxx::__numeric_traits<int>::__max)
 {
   this->pbump(__gnu_cxx::__numeric_traits<int>::__max);
   __off -= __gnu_cxx::__numeric_traits<int>::__max;
 }
      this->pbump(__off);
    }




  extern template class basic_stringbuf<char>;
  extern template class basic_istringstream<char>;
  extern template class basic_ostringstream<char>;
  extern template class basic_stringstream<char>;


  extern template class basic_stringbuf<wchar_t>;
  extern template class basic_istringstream<wchar_t>;
  extern template class basic_ostringstream<wchar_t>;
  extern template class basic_stringstream<wchar_t>;




}
# 880 "/usr/include/c++/10.2.0/sstream" 2 3
# 14 "/usr/include/json/config.h" 2 3 4
# 102 "/usr/include/json/config.h" 3 4
# 1 "/usr/include/json/allocator.h" 1 3 4
# 9 "/usr/include/json/allocator.h" 3 4
# 1 "/usr/include/c++/10.2.0/cstring" 1 3 4
# 39 "/usr/include/c++/10.2.0/cstring" 3 4
       
# 40 "/usr/include/c++/10.2.0/cstring" 3
# 71 "/usr/include/c++/10.2.0/cstring" 3
extern "C++"
{
namespace std __attribute__ ((__visibility__ ("default")))
{


  using ::memchr;
  using ::memcmp;
  using ::memcpy;
  using ::memmove;
  using ::memset;
  using ::strcat;
  using ::strcmp;
  using ::strcoll;
  using ::strcpy;
  using ::strcspn;
  using ::strerror;
  using ::strlen;
  using ::strncat;
  using ::strncmp;
  using ::strncpy;
  using ::strspn;
  using ::strtok;
  using ::strxfrm;
  using ::strchr;
  using ::strpbrk;
  using ::strrchr;
  using ::strstr;
# 122 "/usr/include/c++/10.2.0/cstring" 3

}
}
# 10 "/usr/include/json/allocator.h" 2 3 4


#pragma pack(push, 8)

namespace Json {
template <typename T> class SecureAllocator {
public:

  using value_type = T;
  using pointer = T*;
  using const_pointer = const T*;
  using reference = T&;
  using const_reference = const T&;
  using size_type = std::size_t;
  using difference_type = std::ptrdiff_t;




  pointer allocate(size_type n) {

    return static_cast<pointer>(::operator new(n * sizeof(T)));
  }
# 41 "/usr/include/json/allocator.h" 3 4
  void deallocate(volatile pointer p, size_type n) {
    std::memset(p, 0, n * sizeof(T));

    ::operator delete(p);
  }




  template <typename... Args> void construct(pointer p, Args&&... args) {

    ::new (static_cast<void*>(p)) T(std::forward<Args>(args)...);
  }

  size_type max_size() const { return size_t(-1) / sizeof(T); }

  pointer address(reference x) const { return std::addressof(x); }

  const_pointer address(const_reference x) const { return std::addressof(x); }




  void destroy(pointer p) {

    p->~T();
  }


  SecureAllocator() {}
  template <typename U> SecureAllocator(const SecureAllocator<U>&) {}
  template <typename U> struct rebind { using other = SecureAllocator<U>; };
};

template <typename T, typename U>
bool operator==(const SecureAllocator<T>&, const SecureAllocator<U>&) {
  return true;
}

template <typename T, typename U>
bool operator!=(const SecureAllocator<T>&, const SecureAllocator<U>&) {
  return false;
}

}

#pragma pack(pop)
# 103 "/usr/include/json/config.h" 2 3 4
# 1 "/usr/include/json/version.h" 1 3 4
# 104 "/usr/include/json/config.h" 2 3 4



namespace Json {
using Int = int;
using UInt = unsigned int;
# 120 "/usr/include/json/config.h" 3 4
using Int64 = int64_t;
using UInt64 = uint64_t;

using LargestInt = Int64;
using LargestUInt = UInt64;



template <typename T>
using Allocator =
    typename std::conditional<0, SecureAllocator<T>,
                              std::allocator<T>>::type;
using String = std::basic_string<char, std::char_traits<char>, Allocator<char>>;
using IStringStream =
    std::basic_istringstream<String::value_type, String::traits_type,
                             String::allocator_type>;
using OStringStream =
    std::basic_ostringstream<String::value_type, String::traits_type,
                             String::allocator_type>;
using IStream = std::istream;
using OStream = std::ostream;
}


using JSONCPP_STRING = Json::String;
using JSONCPP_ISTRINGSTREAM = Json::IStringStream;
using JSONCPP_OSTRINGSTREAM = Json::OStringStream;
using JSONCPP_ISTREAM = Json::IStream;
using JSONCPP_OSTREAM = Json::OStream;
# 10 "/usr/include/json/json.h" 2 3 4
# 1 "/usr/include/json/json_features.h" 1 3 4
# 10 "/usr/include/json/json_features.h" 3 4
# 1 "/usr/include/json/forwards.h" 1 3 4
# 13 "/usr/include/json/forwards.h" 3 4
namespace Json {


class StreamWriter;
class StreamWriterBuilder;
class Writer;
class FastWriter;
class StyledWriter;
class StyledStreamWriter;


class Reader;
class CharReader;
class CharReaderBuilder;


class Features;


using ArrayIndex = unsigned int;
class StaticString;
class Path;
class PathArgument;
class Value;
class ValueIteratorBase;
class ValueIterator;
class ValueConstIterator;

}
# 11 "/usr/include/json/json_features.h" 2 3 4


#pragma pack(push, 8)

namespace Json {





class Features {
public:






  static Features all();







  static Features strictMode();



  Features();


  bool allowComments_{true};



  bool strictRoot_{false};


  bool allowDroppedNullPlaceholders_{false};


  bool allowNumericKeys_{false};
};

}

#pragma pack(pop)
# 11 "/usr/include/json/json.h" 2 3 4
# 1 "/usr/include/json/reader.h" 1 3 4
# 11 "/usr/include/json/reader.h" 3 4
# 1 "/usr/include/json/value.h" 1 3 4
# 44 "/usr/include/json/value.h" 3 4
# 1 "/usr/include/c++/10.2.0/map" 1 3 4
# 58 "/usr/include/c++/10.2.0/map" 3 4
       
# 59 "/usr/include/c++/10.2.0/map" 3

# 1 "/usr/include/c++/10.2.0/bits/stl_tree.h" 1 3
# 61 "/usr/include/c++/10.2.0/bits/stl_tree.h" 3
       
# 62 "/usr/include/c++/10.2.0/bits/stl_tree.h" 3
# 75 "/usr/include/c++/10.2.0/bits/stl_tree.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{

# 99 "/usr/include/c++/10.2.0/bits/stl_tree.h" 3
  enum _Rb_tree_color { _S_red = false, _S_black = true };

  struct _Rb_tree_node_base
  {
    typedef _Rb_tree_node_base* _Base_ptr;
    typedef const _Rb_tree_node_base* _Const_Base_ptr;

    _Rb_tree_color _M_color;
    _Base_ptr _M_parent;
    _Base_ptr _M_left;
    _Base_ptr _M_right;

    static _Base_ptr
    _S_minimum(_Base_ptr __x) noexcept
    {
      while (__x->_M_left != 0) __x = __x->_M_left;
      return __x;
    }

    static _Const_Base_ptr
    _S_minimum(_Const_Base_ptr __x) noexcept
    {
      while (__x->_M_left != 0) __x = __x->_M_left;
      return __x;
    }

    static _Base_ptr
    _S_maximum(_Base_ptr __x) noexcept
    {
      while (__x->_M_right != 0) __x = __x->_M_right;
      return __x;
    }

    static _Const_Base_ptr
    _S_maximum(_Const_Base_ptr __x) noexcept
    {
      while (__x->_M_right != 0) __x = __x->_M_right;
      return __x;
    }
  };


  template<typename _Key_compare>
    struct _Rb_tree_key_compare
    {
      _Key_compare _M_key_compare;

      _Rb_tree_key_compare()
      noexcept(is_nothrow_default_constructible<_Key_compare>::value)

      : _M_key_compare()
      { }

      _Rb_tree_key_compare(const _Key_compare& __comp)
      : _M_key_compare(__comp)
      { }



      _Rb_tree_key_compare(const _Rb_tree_key_compare&) = default;

      _Rb_tree_key_compare(_Rb_tree_key_compare&& __x)
 noexcept(is_nothrow_copy_constructible<_Key_compare>::value)
      : _M_key_compare(__x._M_key_compare)
      { }

    };


  struct _Rb_tree_header
  {
    _Rb_tree_node_base _M_header;
    size_t _M_node_count;

    _Rb_tree_header() noexcept
    {
      _M_header._M_color = _S_red;
      _M_reset();
    }


    _Rb_tree_header(_Rb_tree_header&& __x) noexcept
    {
      if (__x._M_header._M_parent != nullptr)
 _M_move_data(__x);
      else
 {
   _M_header._M_color = _S_red;
   _M_reset();
 }
    }


    void
    _M_move_data(_Rb_tree_header& __from)
    {
      _M_header._M_color = __from._M_header._M_color;
      _M_header._M_parent = __from._M_header._M_parent;
      _M_header._M_left = __from._M_header._M_left;
      _M_header._M_right = __from._M_header._M_right;
      _M_header._M_parent->_M_parent = &_M_header;
      _M_node_count = __from._M_node_count;

      __from._M_reset();
    }

    void
    _M_reset()
    {
      _M_header._M_parent = 0;
      _M_header._M_left = &_M_header;
      _M_header._M_right = &_M_header;
      _M_node_count = 0;
    }
  };

  template<typename _Val>
    struct _Rb_tree_node : public _Rb_tree_node_base
    {
      typedef _Rb_tree_node<_Val>* _Link_type;
# 231 "/usr/include/c++/10.2.0/bits/stl_tree.h" 3
      __gnu_cxx::__aligned_membuf<_Val> _M_storage;

      _Val*
      _M_valptr()
      { return _M_storage._M_ptr(); }

      const _Val*
      _M_valptr() const
      { return _M_storage._M_ptr(); }

    };

  __attribute__ ((__pure__)) _Rb_tree_node_base*
  _Rb_tree_increment(_Rb_tree_node_base* __x) throw ();

  __attribute__ ((__pure__)) const _Rb_tree_node_base*
  _Rb_tree_increment(const _Rb_tree_node_base* __x) throw ();

  __attribute__ ((__pure__)) _Rb_tree_node_base*
  _Rb_tree_decrement(_Rb_tree_node_base* __x) throw ();

  __attribute__ ((__pure__)) const _Rb_tree_node_base*
  _Rb_tree_decrement(const _Rb_tree_node_base* __x) throw ();

  template<typename _Tp>
    struct _Rb_tree_iterator
    {
      typedef _Tp value_type;
      typedef _Tp& reference;
      typedef _Tp* pointer;

      typedef bidirectional_iterator_tag iterator_category;
      typedef ptrdiff_t difference_type;

      typedef _Rb_tree_iterator<_Tp> _Self;
      typedef _Rb_tree_node_base::_Base_ptr _Base_ptr;
      typedef _Rb_tree_node<_Tp>* _Link_type;

      _Rb_tree_iterator() noexcept
      : _M_node() { }

      explicit
      _Rb_tree_iterator(_Base_ptr __x) noexcept
      : _M_node(__x) { }

      reference
      operator*() const noexcept
      { return *static_cast<_Link_type>(_M_node)->_M_valptr(); }

      pointer
      operator->() const noexcept
      { return static_cast<_Link_type> (_M_node)->_M_valptr(); }

      _Self&
      operator++() noexcept
      {
 _M_node = _Rb_tree_increment(_M_node);
 return *this;
      }

      _Self
      operator++(int) noexcept
      {
 _Self __tmp = *this;
 _M_node = _Rb_tree_increment(_M_node);
 return __tmp;
      }

      _Self&
      operator--() noexcept
      {
 _M_node = _Rb_tree_decrement(_M_node);
 return *this;
      }

      _Self
      operator--(int) noexcept
      {
 _Self __tmp = *this;
 _M_node = _Rb_tree_decrement(_M_node);
 return __tmp;
      }

      friend bool
      operator==(const _Self& __x, const _Self& __y) noexcept
      { return __x._M_node == __y._M_node; }


      friend bool
      operator!=(const _Self& __x, const _Self& __y) noexcept
      { return __x._M_node != __y._M_node; }


      _Base_ptr _M_node;
  };

  template<typename _Tp>
    struct _Rb_tree_const_iterator
    {
      typedef _Tp value_type;
      typedef const _Tp& reference;
      typedef const _Tp* pointer;

      typedef _Rb_tree_iterator<_Tp> iterator;

      typedef bidirectional_iterator_tag iterator_category;
      typedef ptrdiff_t difference_type;

      typedef _Rb_tree_const_iterator<_Tp> _Self;
      typedef _Rb_tree_node_base::_Const_Base_ptr _Base_ptr;
      typedef const _Rb_tree_node<_Tp>* _Link_type;

      _Rb_tree_const_iterator() noexcept
      : _M_node() { }

      explicit
      _Rb_tree_const_iterator(_Base_ptr __x) noexcept
      : _M_node(__x) { }

      _Rb_tree_const_iterator(const iterator& __it) noexcept
      : _M_node(__it._M_node) { }

      iterator
      _M_const_cast() const noexcept
      { return iterator(const_cast<typename iterator::_Base_ptr>(_M_node)); }

      reference
      operator*() const noexcept
      { return *static_cast<_Link_type>(_M_node)->_M_valptr(); }

      pointer
      operator->() const noexcept
      { return static_cast<_Link_type>(_M_node)->_M_valptr(); }

      _Self&
      operator++() noexcept
      {
 _M_node = _Rb_tree_increment(_M_node);
 return *this;
      }

      _Self
      operator++(int) noexcept
      {
 _Self __tmp = *this;
 _M_node = _Rb_tree_increment(_M_node);
 return __tmp;
      }

      _Self&
      operator--() noexcept
      {
 _M_node = _Rb_tree_decrement(_M_node);
 return *this;
      }

      _Self
      operator--(int) noexcept
      {
 _Self __tmp = *this;
 _M_node = _Rb_tree_decrement(_M_node);
 return __tmp;
      }

      friend bool
      operator==(const _Self& __x, const _Self& __y) noexcept
      { return __x._M_node == __y._M_node; }


      friend bool
      operator!=(const _Self& __x, const _Self& __y) noexcept
      { return __x._M_node != __y._M_node; }


      _Base_ptr _M_node;
    };

  void
  _Rb_tree_insert_and_rebalance(const bool __insert_left,
    _Rb_tree_node_base* __x,
    _Rb_tree_node_base* __p,
    _Rb_tree_node_base& __header) throw ();

  _Rb_tree_node_base*
  _Rb_tree_rebalance_for_erase(_Rb_tree_node_base* const __z,
          _Rb_tree_node_base& __header) throw ();
# 438 "/usr/include/c++/10.2.0/bits/stl_tree.h" 3
  template<typename _Key, typename _Val, typename _KeyOfValue,
    typename _Compare, typename _Alloc = allocator<_Val> >
    class _Rb_tree
    {
      typedef typename __gnu_cxx::__alloc_traits<_Alloc>::template
 rebind<_Rb_tree_node<_Val> >::other _Node_allocator;

      typedef __gnu_cxx::__alloc_traits<_Node_allocator> _Alloc_traits;

    protected:
      typedef _Rb_tree_node_base* _Base_ptr;
      typedef const _Rb_tree_node_base* _Const_Base_ptr;
      typedef _Rb_tree_node<_Val>* _Link_type;
      typedef const _Rb_tree_node<_Val>* _Const_Link_type;

    private:


      struct _Reuse_or_alloc_node
      {
 _Reuse_or_alloc_node(_Rb_tree& __t)
 : _M_root(__t._M_root()), _M_nodes(__t._M_rightmost()), _M_t(__t)
 {
   if (_M_root)
     {
       _M_root->_M_parent = 0;

       if (_M_nodes->_M_left)
  _M_nodes = _M_nodes->_M_left;
     }
   else
     _M_nodes = 0;
 }


 _Reuse_or_alloc_node(const _Reuse_or_alloc_node&) = delete;


 ~_Reuse_or_alloc_node()
 { _M_t._M_erase(static_cast<_Link_type>(_M_root)); }

 template<typename _Arg>
   _Link_type



   operator()(_Arg&& __arg)

   {
     _Link_type __node = static_cast<_Link_type>(_M_extract());
     if (__node)
       {
  _M_t._M_destroy_node(__node);
  _M_t._M_construct_node(__node, std::forward<_Arg>(__arg));
  return __node;
       }

     return _M_t._M_create_node(std::forward<_Arg>(__arg));
   }

      private:
 _Base_ptr
 _M_extract()
 {
   if (!_M_nodes)
     return _M_nodes;

   _Base_ptr __node = _M_nodes;
   _M_nodes = _M_nodes->_M_parent;
   if (_M_nodes)
     {
       if (_M_nodes->_M_right == __node)
  {
    _M_nodes->_M_right = 0;

    if (_M_nodes->_M_left)
      {
        _M_nodes = _M_nodes->_M_left;

        while (_M_nodes->_M_right)
   _M_nodes = _M_nodes->_M_right;

        if (_M_nodes->_M_left)
   _M_nodes = _M_nodes->_M_left;
      }
  }
       else
  _M_nodes->_M_left = 0;
     }
   else
     _M_root = 0;

   return __node;
 }

 _Base_ptr _M_root;
 _Base_ptr _M_nodes;
 _Rb_tree& _M_t;
      };



      struct _Alloc_node
      {
 _Alloc_node(_Rb_tree& __t)
 : _M_t(__t) { }

 template<typename _Arg>
   _Link_type



   operator()(_Arg&& __arg) const

   { return _M_t._M_create_node(std::forward<_Arg>(__arg)); }

      private:
 _Rb_tree& _M_t;
      };

    public:
      typedef _Key key_type;
      typedef _Val value_type;
      typedef value_type* pointer;
      typedef const value_type* const_pointer;
      typedef value_type& reference;
      typedef const value_type& const_reference;
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef _Alloc allocator_type;

      _Node_allocator&
      _M_get_Node_allocator() noexcept
      { return this->_M_impl; }

      const _Node_allocator&
      _M_get_Node_allocator() const noexcept
      { return this->_M_impl; }

      allocator_type
      get_allocator() const noexcept
      { return allocator_type(_M_get_Node_allocator()); }

    protected:
      _Link_type
      _M_get_node()
      { return _Alloc_traits::allocate(_M_get_Node_allocator(), 1); }

      void
      _M_put_node(_Link_type __p) noexcept
      { _Alloc_traits::deallocate(_M_get_Node_allocator(), __p, 1); }
# 611 "/usr/include/c++/10.2.0/bits/stl_tree.h" 3
      template<typename... _Args>
 void
 _M_construct_node(_Link_type __node, _Args&&... __args)
 {
   try
     {
       ::new(__node) _Rb_tree_node<_Val>;
       _Alloc_traits::construct(_M_get_Node_allocator(),
           __node->_M_valptr(),
           std::forward<_Args>(__args)...);
     }
   catch(...)
     {
       __node->~_Rb_tree_node<_Val>();
       _M_put_node(__node);
       throw;
     }
 }

      template<typename... _Args>
 _Link_type
 _M_create_node(_Args&&... __args)
 {
   _Link_type __tmp = _M_get_node();
   _M_construct_node(__tmp, std::forward<_Args>(__args)...);
   return __tmp;
 }


      void
      _M_destroy_node(_Link_type __p) noexcept
      {



 _Alloc_traits::destroy(_M_get_Node_allocator(), __p->_M_valptr());
 __p->~_Rb_tree_node<_Val>();

      }

      void
      _M_drop_node(_Link_type __p) noexcept
      {
 _M_destroy_node(__p);
 _M_put_node(__p);
      }

      template<typename _NodeGen>
 _Link_type
 _M_clone_node(_Const_Link_type __x, _NodeGen& __node_gen)
 {
   _Link_type __tmp = __node_gen(*__x->_M_valptr());
   __tmp->_M_color = __x->_M_color;
   __tmp->_M_left = 0;
   __tmp->_M_right = 0;
   return __tmp;
 }

    protected:




      template<typename _Key_compare,
        bool = __is_pod(_Key_compare)>

 struct _Rb_tree_impl
 : public _Node_allocator
 , public _Rb_tree_key_compare<_Key_compare>
 , public _Rb_tree_header
 {
   typedef _Rb_tree_key_compare<_Key_compare> _Base_key_compare;

   _Rb_tree_impl()
     noexcept(is_nothrow_default_constructible<_Node_allocator>::value && is_nothrow_default_constructible<_Base_key_compare>::value)


   : _Node_allocator()
   { }

   _Rb_tree_impl(const _Rb_tree_impl& __x)
   : _Node_allocator(_Alloc_traits::_S_select_on_copy(__x))
   , _Base_key_compare(__x._M_key_compare)
   { }






   _Rb_tree_impl(_Rb_tree_impl&&) = default;

   explicit
   _Rb_tree_impl(_Node_allocator&& __a)
   : _Node_allocator(std::move(__a))
   { }

   _Rb_tree_impl(_Rb_tree_impl&& __x, _Node_allocator&& __a)
   : _Node_allocator(std::move(__a)),
     _Base_key_compare(std::move(__x)),
     _Rb_tree_header(std::move(__x))
   { }

   _Rb_tree_impl(const _Key_compare& __comp, _Node_allocator&& __a)
   : _Node_allocator(std::move(__a)), _Base_key_compare(__comp)
   { }

 };

      _Rb_tree_impl<_Compare> _M_impl;

    protected:
      _Base_ptr&
      _M_root() noexcept
      { return this->_M_impl._M_header._M_parent; }

      _Const_Base_ptr
      _M_root() const noexcept
      { return this->_M_impl._M_header._M_parent; }

      _Base_ptr&
      _M_leftmost() noexcept
      { return this->_M_impl._M_header._M_left; }

      _Const_Base_ptr
      _M_leftmost() const noexcept
      { return this->_M_impl._M_header._M_left; }

      _Base_ptr&
      _M_rightmost() noexcept
      { return this->_M_impl._M_header._M_right; }

      _Const_Base_ptr
      _M_rightmost() const noexcept
      { return this->_M_impl._M_header._M_right; }

      _Link_type
      _M_begin() noexcept
      { return static_cast<_Link_type>(this->_M_impl._M_header._M_parent); }

      _Const_Link_type
      _M_begin() const noexcept
      {
 return static_cast<_Const_Link_type>
   (this->_M_impl._M_header._M_parent);
      }

      _Base_ptr
      _M_end() noexcept
      { return &this->_M_impl._M_header; }

      _Const_Base_ptr
      _M_end() const noexcept
      { return &this->_M_impl._M_header; }

      static const _Key&
      _S_key(_Const_Link_type __x)
      {



 static_assert(__is_invocable<_Compare&, const _Key&, const _Key&>{},
        "comparison object must be invocable "
        "with two arguments of key type");
# 785 "/usr/include/c++/10.2.0/bits/stl_tree.h" 3
 return _KeyOfValue()(*__x->_M_valptr());
      }

      static _Link_type
      _S_left(_Base_ptr __x) noexcept
      { return static_cast<_Link_type>(__x->_M_left); }

      static _Const_Link_type
      _S_left(_Const_Base_ptr __x) noexcept
      { return static_cast<_Const_Link_type>(__x->_M_left); }

      static _Link_type
      _S_right(_Base_ptr __x) noexcept
      { return static_cast<_Link_type>(__x->_M_right); }

      static _Const_Link_type
      _S_right(_Const_Base_ptr __x) noexcept
      { return static_cast<_Const_Link_type>(__x->_M_right); }

      static const _Key&
      _S_key(_Const_Base_ptr __x)
      { return _S_key(static_cast<_Const_Link_type>(__x)); }

      static _Base_ptr
      _S_minimum(_Base_ptr __x) noexcept
      { return _Rb_tree_node_base::_S_minimum(__x); }

      static _Const_Base_ptr
      _S_minimum(_Const_Base_ptr __x) noexcept
      { return _Rb_tree_node_base::_S_minimum(__x); }

      static _Base_ptr
      _S_maximum(_Base_ptr __x) noexcept
      { return _Rb_tree_node_base::_S_maximum(__x); }

      static _Const_Base_ptr
      _S_maximum(_Const_Base_ptr __x) noexcept
      { return _Rb_tree_node_base::_S_maximum(__x); }

    public:
      typedef _Rb_tree_iterator<value_type> iterator;
      typedef _Rb_tree_const_iterator<value_type> const_iterator;

      typedef std::reverse_iterator<iterator> reverse_iterator;
      typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
# 838 "/usr/include/c++/10.2.0/bits/stl_tree.h" 3
      pair<_Base_ptr, _Base_ptr>
      _M_get_insert_unique_pos(const key_type& __k);

      pair<_Base_ptr, _Base_ptr>
      _M_get_insert_equal_pos(const key_type& __k);

      pair<_Base_ptr, _Base_ptr>
      _M_get_insert_hint_unique_pos(const_iterator __pos,
        const key_type& __k);

      pair<_Base_ptr, _Base_ptr>
      _M_get_insert_hint_equal_pos(const_iterator __pos,
       const key_type& __k);

    private:

      template<typename _Arg, typename _NodeGen>
 iterator
 _M_insert_(_Base_ptr __x, _Base_ptr __y, _Arg&& __v, _NodeGen&);

      iterator
      _M_insert_node(_Base_ptr __x, _Base_ptr __y, _Link_type __z);

      template<typename _Arg>
 iterator
 _M_insert_lower(_Base_ptr __y, _Arg&& __v);

      template<typename _Arg>
 iterator
 _M_insert_equal_lower(_Arg&& __x);

      iterator
      _M_insert_lower_node(_Base_ptr __p, _Link_type __z);

      iterator
      _M_insert_equal_lower_node(_Link_type __z);
# 889 "/usr/include/c++/10.2.0/bits/stl_tree.h" 3
      template<typename _NodeGen>
 _Link_type
 _M_copy(_Const_Link_type __x, _Base_ptr __p, _NodeGen&);

      template<typename _NodeGen>
 _Link_type
 _M_copy(const _Rb_tree& __x, _NodeGen& __gen)
 {
   _Link_type __root = _M_copy(__x._M_begin(), _M_end(), __gen);
   _M_leftmost() = _S_minimum(__root);
   _M_rightmost() = _S_maximum(__root);
   _M_impl._M_node_count = __x._M_impl._M_node_count;
   return __root;
 }

      _Link_type
      _M_copy(const _Rb_tree& __x)
      {
 _Alloc_node __an(*this);
 return _M_copy(__x, __an);
      }

      void
      _M_erase(_Link_type __x);

      iterator
      _M_lower_bound(_Link_type __x, _Base_ptr __y,
       const _Key& __k);

      const_iterator
      _M_lower_bound(_Const_Link_type __x, _Const_Base_ptr __y,
       const _Key& __k) const;

      iterator
      _M_upper_bound(_Link_type __x, _Base_ptr __y,
       const _Key& __k);

      const_iterator
      _M_upper_bound(_Const_Link_type __x, _Const_Base_ptr __y,
       const _Key& __k) const;

    public:




      _Rb_tree() = default;


      _Rb_tree(const _Compare& __comp,
        const allocator_type& __a = allocator_type())
      : _M_impl(__comp, _Node_allocator(__a)) { }

      _Rb_tree(const _Rb_tree& __x)
      : _M_impl(__x._M_impl)
      {
 if (__x._M_root() != 0)
   _M_root() = _M_copy(__x);
      }


      _Rb_tree(const allocator_type& __a)
      : _M_impl(_Node_allocator(__a))
      { }

      _Rb_tree(const _Rb_tree& __x, const allocator_type& __a)
      : _M_impl(__x._M_impl._M_key_compare, _Node_allocator(__a))
      {
 if (__x._M_root() != nullptr)
   _M_root() = _M_copy(__x);
      }

      _Rb_tree(_Rb_tree&&) = default;

      _Rb_tree(_Rb_tree&& __x, const allocator_type& __a)
      : _Rb_tree(std::move(__x), _Node_allocator(__a))
      { }

    private:
      _Rb_tree(_Rb_tree&& __x, _Node_allocator&& __a, true_type)
      noexcept(is_nothrow_default_constructible<_Compare>::value)
      : _M_impl(std::move(__x._M_impl), std::move(__a))
      { }

      _Rb_tree(_Rb_tree&& __x, _Node_allocator&& __a, false_type)
      : _M_impl(__x._M_impl._M_key_compare, std::move(__a))
      {
 if (__x._M_root() != nullptr)
   _M_move_data(__x, false_type{});
      }

    public:
      _Rb_tree(_Rb_tree&& __x, _Node_allocator&& __a)
      noexcept( noexcept(
 _Rb_tree(std::declval<_Rb_tree&&>(), std::declval<_Node_allocator&&>(),
   std::declval<typename _Alloc_traits::is_always_equal>())) )
      : _Rb_tree(std::move(__x), std::move(__a),
   typename _Alloc_traits::is_always_equal{})
      { }


      ~_Rb_tree() noexcept
      { _M_erase(_M_begin()); }

      _Rb_tree&
      operator=(const _Rb_tree& __x);


      _Compare
      key_comp() const
      { return _M_impl._M_key_compare; }

      iterator
      begin() noexcept
      { return iterator(this->_M_impl._M_header._M_left); }

      const_iterator
      begin() const noexcept
      { return const_iterator(this->_M_impl._M_header._M_left); }

      iterator
      end() noexcept
      { return iterator(&this->_M_impl._M_header); }

      const_iterator
      end() const noexcept
      { return const_iterator(&this->_M_impl._M_header); }

      reverse_iterator
      rbegin() noexcept
      { return reverse_iterator(end()); }

      const_reverse_iterator
      rbegin() const noexcept
      { return const_reverse_iterator(end()); }

      reverse_iterator
      rend() noexcept
      { return reverse_iterator(begin()); }

      const_reverse_iterator
      rend() const noexcept
      { return const_reverse_iterator(begin()); }

      bool
      empty() const noexcept
      { return _M_impl._M_node_count == 0; }

      size_type
      size() const noexcept
      { return _M_impl._M_node_count; }

      size_type
      max_size() const noexcept
      { return _Alloc_traits::max_size(_M_get_Node_allocator()); }

      void
      swap(_Rb_tree& __t)
      noexcept(__is_nothrow_swappable<_Compare>::value);



      template<typename _Arg>
 pair<iterator, bool>
 _M_insert_unique(_Arg&& __x);

      template<typename _Arg>
 iterator
 _M_insert_equal(_Arg&& __x);

      template<typename _Arg, typename _NodeGen>
 iterator
 _M_insert_unique_(const_iterator __pos, _Arg&& __x, _NodeGen&);

      template<typename _Arg>
 iterator
 _M_insert_unique_(const_iterator __pos, _Arg&& __x)
 {
   _Alloc_node __an(*this);
   return _M_insert_unique_(__pos, std::forward<_Arg>(__x), __an);
 }

      template<typename _Arg, typename _NodeGen>
 iterator
 _M_insert_equal_(const_iterator __pos, _Arg&& __x, _NodeGen&);

      template<typename _Arg>
 iterator
 _M_insert_equal_(const_iterator __pos, _Arg&& __x)
 {
   _Alloc_node __an(*this);
   return _M_insert_equal_(__pos, std::forward<_Arg>(__x), __an);
 }

      template<typename... _Args>
 pair<iterator, bool>
 _M_emplace_unique(_Args&&... __args);

      template<typename... _Args>
 iterator
 _M_emplace_equal(_Args&&... __args);

      template<typename... _Args>
 iterator
 _M_emplace_hint_unique(const_iterator __pos, _Args&&... __args);

      template<typename... _Args>
 iterator
 _M_emplace_hint_equal(const_iterator __pos, _Args&&... __args);

      template<typename _Iter>
 using __same_value_type
   = is_same<value_type, typename iterator_traits<_Iter>::value_type>;

      template<typename _InputIterator>
 __enable_if_t<__same_value_type<_InputIterator>::value>
 _M_insert_range_unique(_InputIterator __first, _InputIterator __last)
 {
   _Alloc_node __an(*this);
   for (; __first != __last; ++__first)
     _M_insert_unique_(end(), *__first, __an);
 }

      template<typename _InputIterator>
 __enable_if_t<!__same_value_type<_InputIterator>::value>
 _M_insert_range_unique(_InputIterator __first, _InputIterator __last)
 {
   for (; __first != __last; ++__first)
     _M_emplace_unique(*__first);
 }

      template<typename _InputIterator>
 __enable_if_t<__same_value_type<_InputIterator>::value>
 _M_insert_range_equal(_InputIterator __first, _InputIterator __last)
 {
   _Alloc_node __an(*this);
   for (; __first != __last; ++__first)
     _M_insert_equal_(end(), *__first, __an);
 }

      template<typename _InputIterator>
 __enable_if_t<!__same_value_type<_InputIterator>::value>
 _M_insert_range_equal(_InputIterator __first, _InputIterator __last)
 {
   _Alloc_node __an(*this);
   for (; __first != __last; ++__first)
     _M_emplace_equal(*__first);
 }
# 1186 "/usr/include/c++/10.2.0/bits/stl_tree.h" 3
    private:
      void
      _M_erase_aux(const_iterator __position);

      void
      _M_erase_aux(const_iterator __first, const_iterator __last);

    public:



      __attribute ((__abi_tag__ ("cxx11")))
      iterator
      erase(const_iterator __position)
      {
 ;
 const_iterator __result = __position;
 ++__result;
 _M_erase_aux(__position);
 return __result._M_const_cast();
      }


      __attribute ((__abi_tag__ ("cxx11")))
      iterator
      erase(iterator __position)
      {
 ;
 iterator __result = __position;
 ++__result;
 _M_erase_aux(__position);
 return __result;
      }
# 1235 "/usr/include/c++/10.2.0/bits/stl_tree.h" 3
      size_type
      erase(const key_type& __x);




      __attribute ((__abi_tag__ ("cxx11")))
      iterator
      erase(const_iterator __first, const_iterator __last)
      {
 _M_erase_aux(__first, __last);
 return __last._M_const_cast();
      }
# 1258 "/usr/include/c++/10.2.0/bits/stl_tree.h" 3
      void
      clear() noexcept
      {
 _M_erase(_M_begin());
 _M_impl._M_reset();
      }


      iterator
      find(const key_type& __k);

      const_iterator
      find(const key_type& __k) const;

      size_type
      count(const key_type& __k) const;

      iterator
      lower_bound(const key_type& __k)
      { return _M_lower_bound(_M_begin(), _M_end(), __k); }

      const_iterator
      lower_bound(const key_type& __k) const
      { return _M_lower_bound(_M_begin(), _M_end(), __k); }

      iterator
      upper_bound(const key_type& __k)
      { return _M_upper_bound(_M_begin(), _M_end(), __k); }

      const_iterator
      upper_bound(const key_type& __k) const
      { return _M_upper_bound(_M_begin(), _M_end(), __k); }

      pair<iterator, iterator>
      equal_range(const key_type& __k);

      pair<const_iterator, const_iterator>
      equal_range(const key_type& __k) const;
# 1406 "/usr/include/c++/10.2.0/bits/stl_tree.h" 3
      bool
      __rb_verify() const;


      _Rb_tree&
      operator=(_Rb_tree&&)
      noexcept(_Alloc_traits::_S_nothrow_move()
        && is_nothrow_move_assignable<_Compare>::value);

      template<typename _Iterator>
 void
 _M_assign_unique(_Iterator, _Iterator);

      template<typename _Iterator>
 void
 _M_assign_equal(_Iterator, _Iterator);

    private:

      void
      _M_move_data(_Rb_tree& __x, true_type)
      { _M_impl._M_move_data(__x._M_impl); }



      void
      _M_move_data(_Rb_tree&, false_type);


      void
      _M_move_assign(_Rb_tree&, true_type);



      void
      _M_move_assign(_Rb_tree&, false_type);
# 1610 "/usr/include/c++/10.2.0/bits/stl_tree.h" 3
      friend bool
      operator==(const _Rb_tree& __x, const _Rb_tree& __y)
      {
 return __x.size() == __y.size()
   && std::equal(__x.begin(), __x.end(), __y.begin());
      }
# 1627 "/usr/include/c++/10.2.0/bits/stl_tree.h" 3
      friend bool
      operator<(const _Rb_tree& __x, const _Rb_tree& __y)
      {
 return std::lexicographical_compare(__x.begin(), __x.end(),
         __y.begin(), __y.end());
      }

      friend bool __attribute__ ((__deprecated__))
      operator!=(const _Rb_tree& __x, const _Rb_tree& __y)
      { return !(__x == __y); }

      friend bool __attribute__ ((__deprecated__))
      operator>(const _Rb_tree& __x, const _Rb_tree& __y)
      { return __y < __x; }

      friend bool __attribute__ ((__deprecated__))
      operator<=(const _Rb_tree& __x, const _Rb_tree& __y)
      { return !(__y < __x); }

      friend bool __attribute__ ((__deprecated__))
      operator>=(const _Rb_tree& __x, const _Rb_tree& __y)
      { return !(__x < __y); }

    };

  template<typename _Key, typename _Val, typename _KeyOfValue,
    typename _Compare, typename _Alloc>
    inline void
    swap(_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __x,
  _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __y)
    { __x.swap(__y); }


  template<typename _Key, typename _Val, typename _KeyOfValue,
    typename _Compare, typename _Alloc>
    void
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_move_data(_Rb_tree& __x, false_type)
    {
      if (_M_get_Node_allocator() == __x._M_get_Node_allocator())
 _M_move_data(__x, true_type());
      else
 {
   _Alloc_node __an(*this);
   auto __lbd =
     [&__an](const value_type& __cval)
     {
       auto& __val = const_cast<value_type&>(__cval);
       return __an(std::move_if_noexcept(__val));
     };
   _M_root() = _M_copy(__x, __lbd);
 }
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
    typename _Compare, typename _Alloc>
    inline void
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_move_assign(_Rb_tree& __x, true_type)
    {
      clear();
      if (__x._M_root() != nullptr)
 _M_move_data(__x, true_type());
      std::__alloc_on_move(_M_get_Node_allocator(),
      __x._M_get_Node_allocator());
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
    typename _Compare, typename _Alloc>
    void
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_move_assign(_Rb_tree& __x, false_type)
    {
      if (_M_get_Node_allocator() == __x._M_get_Node_allocator())
 return _M_move_assign(__x, true_type{});



      _Reuse_or_alloc_node __roan(*this);
      _M_impl._M_reset();
      if (__x._M_root() != nullptr)
 {
   auto __lbd =
     [&__roan](const value_type& __cval)
     {
       auto& __val = const_cast<value_type&>(__cval);
       return __roan(std::move(__val));
     };
   _M_root() = _M_copy(__x, __lbd);
   __x.clear();
 }
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
    typename _Compare, typename _Alloc>
    inline _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>&
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    operator=(_Rb_tree&& __x)
    noexcept(_Alloc_traits::_S_nothrow_move()
      && is_nothrow_move_assignable<_Compare>::value)
    {
      _M_impl._M_key_compare = std::move(__x._M_impl._M_key_compare);
      _M_move_assign(__x, __bool_constant<_Alloc_traits::_S_nothrow_move()>());
      return *this;
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
    typename _Compare, typename _Alloc>
    template<typename _Iterator>
      void
      _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
      _M_assign_unique(_Iterator __first, _Iterator __last)
      {
 _Reuse_or_alloc_node __roan(*this);
 _M_impl._M_reset();
 for (; __first != __last; ++__first)
   _M_insert_unique_(end(), *__first, __roan);
      }

  template<typename _Key, typename _Val, typename _KeyOfValue,
    typename _Compare, typename _Alloc>
    template<typename _Iterator>
      void
      _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
      _M_assign_equal(_Iterator __first, _Iterator __last)
      {
 _Reuse_or_alloc_node __roan(*this);
 _M_impl._M_reset();
 for (; __first != __last; ++__first)
   _M_insert_equal_(end(), *__first, __roan);
      }


  template<typename _Key, typename _Val, typename _KeyOfValue,
    typename _Compare, typename _Alloc>
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>&
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    operator=(const _Rb_tree& __x)
    {
      if (this != &__x)
 {


   if (_Alloc_traits::_S_propagate_on_copy_assign())
     {
       auto& __this_alloc = this->_M_get_Node_allocator();
       auto& __that_alloc = __x._M_get_Node_allocator();
       if (!_Alloc_traits::_S_always_equal()
    && __this_alloc != __that_alloc)
  {


    clear();
    std::__alloc_on_copy(__this_alloc, __that_alloc);
  }
     }


   _Reuse_or_alloc_node __roan(*this);
   _M_impl._M_reset();
   _M_impl._M_key_compare = __x._M_impl._M_key_compare;
   if (__x._M_root() != 0)
     _M_root() = _M_copy(__x, __roan);
 }

      return *this;
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
    typename _Compare, typename _Alloc>

    template<typename _Arg, typename _NodeGen>



      typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
      _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
      _M_insert_(_Base_ptr __x, _Base_ptr __p,

   _Arg&& __v,



   _NodeGen& __node_gen)
      {
 bool __insert_left = (__x != 0 || __p == _M_end()
         || _M_impl._M_key_compare(_KeyOfValue()(__v),
       _S_key(__p)));

 _Link_type __z = __node_gen(std::forward<_Arg>(__v));

 _Rb_tree_insert_and_rebalance(__insert_left, __z, __p,
          this->_M_impl._M_header);
 ++_M_impl._M_node_count;
 return iterator(__z);
      }

  template<typename _Key, typename _Val, typename _KeyOfValue,
    typename _Compare, typename _Alloc>

    template<typename _Arg>

    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::

    _M_insert_lower(_Base_ptr __p, _Arg&& __v)



    {
      bool __insert_left = (__p == _M_end()
       || !_M_impl._M_key_compare(_S_key(__p),
             _KeyOfValue()(__v)));

      _Link_type __z = _M_create_node(std::forward<_Arg>(__v));

      _Rb_tree_insert_and_rebalance(__insert_left, __z, __p,
        this->_M_impl._M_header);
      ++_M_impl._M_node_count;
      return iterator(__z);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
    typename _Compare, typename _Alloc>

    template<typename _Arg>

    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::

    _M_insert_equal_lower(_Arg&& __v)



    {
      _Link_type __x = _M_begin();
      _Base_ptr __y = _M_end();
      while (__x != 0)
 {
   __y = __x;
   __x = !_M_impl._M_key_compare(_S_key(__x), _KeyOfValue()(__v)) ?
  _S_left(__x) : _S_right(__x);
 }
      return _M_insert_lower(__y, std::forward<_Arg>(__v));
    }

  template<typename _Key, typename _Val, typename _KoV,
    typename _Compare, typename _Alloc>
    template<typename _NodeGen>
      typename _Rb_tree<_Key, _Val, _KoV, _Compare, _Alloc>::_Link_type
      _Rb_tree<_Key, _Val, _KoV, _Compare, _Alloc>::
      _M_copy(_Const_Link_type __x, _Base_ptr __p, _NodeGen& __node_gen)
      {

 _Link_type __top = _M_clone_node(__x, __node_gen);
 __top->_M_parent = __p;

 try
   {
     if (__x->_M_right)
       __top->_M_right = _M_copy(_S_right(__x), __top, __node_gen);
     __p = __top;
     __x = _S_left(__x);

     while (__x != 0)
       {
  _Link_type __y = _M_clone_node(__x, __node_gen);
  __p->_M_left = __y;
  __y->_M_parent = __p;
  if (__x->_M_right)
    __y->_M_right = _M_copy(_S_right(__x), __y, __node_gen);
  __p = __y;
  __x = _S_left(__x);
       }
   }
 catch(...)
   {
     _M_erase(__top);
     throw;
   }
 return __top;
      }

  template<typename _Key, typename _Val, typename _KeyOfValue,
    typename _Compare, typename _Alloc>
    void
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_erase(_Link_type __x)
    {

      while (__x != 0)
 {
   _M_erase(_S_right(__x));
   _Link_type __y = _S_left(__x);
   _M_drop_node(__x);
   __x = __y;
 }
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
    typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue,
        _Compare, _Alloc>::iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_lower_bound(_Link_type __x, _Base_ptr __y,
     const _Key& __k)
    {
      while (__x != 0)
 if (!_M_impl._M_key_compare(_S_key(__x), __k))
   __y = __x, __x = _S_left(__x);
 else
   __x = _S_right(__x);
      return iterator(__y);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
    typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue,
        _Compare, _Alloc>::const_iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_lower_bound(_Const_Link_type __x, _Const_Base_ptr __y,
     const _Key& __k) const
    {
      while (__x != 0)
 if (!_M_impl._M_key_compare(_S_key(__x), __k))
   __y = __x, __x = _S_left(__x);
 else
   __x = _S_right(__x);
      return const_iterator(__y);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
    typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue,
        _Compare, _Alloc>::iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_upper_bound(_Link_type __x, _Base_ptr __y,
     const _Key& __k)
    {
      while (__x != 0)
 if (_M_impl._M_key_compare(__k, _S_key(__x)))
   __y = __x, __x = _S_left(__x);
 else
   __x = _S_right(__x);
      return iterator(__y);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
    typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue,
        _Compare, _Alloc>::const_iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_upper_bound(_Const_Link_type __x, _Const_Base_ptr __y,
     const _Key& __k) const
    {
      while (__x != 0)
 if (_M_impl._M_key_compare(__k, _S_key(__x)))
   __y = __x, __x = _S_left(__x);
 else
   __x = _S_right(__x);
      return const_iterator(__y);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
    typename _Compare, typename _Alloc>
    pair<typename _Rb_tree<_Key, _Val, _KeyOfValue,
      _Compare, _Alloc>::iterator,
  typename _Rb_tree<_Key, _Val, _KeyOfValue,
      _Compare, _Alloc>::iterator>
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    equal_range(const _Key& __k)
    {
      _Link_type __x = _M_begin();
      _Base_ptr __y = _M_end();
      while (__x != 0)
 {
   if (_M_impl._M_key_compare(_S_key(__x), __k))
     __x = _S_right(__x);
   else if (_M_impl._M_key_compare(__k, _S_key(__x)))
     __y = __x, __x = _S_left(__x);
   else
     {
       _Link_type __xu(__x);
       _Base_ptr __yu(__y);
       __y = __x, __x = _S_left(__x);
       __xu = _S_right(__xu);
       return pair<iterator,
     iterator>(_M_lower_bound(__x, __y, __k),
        _M_upper_bound(__xu, __yu, __k));
     }
 }
      return pair<iterator, iterator>(iterator(__y),
          iterator(__y));
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
    typename _Compare, typename _Alloc>
    pair<typename _Rb_tree<_Key, _Val, _KeyOfValue,
      _Compare, _Alloc>::const_iterator,
  typename _Rb_tree<_Key, _Val, _KeyOfValue,
      _Compare, _Alloc>::const_iterator>
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    equal_range(const _Key& __k) const
    {
      _Const_Link_type __x = _M_begin();
      _Const_Base_ptr __y = _M_end();
      while (__x != 0)
 {
   if (_M_impl._M_key_compare(_S_key(__x), __k))
     __x = _S_right(__x);
   else if (_M_impl._M_key_compare(__k, _S_key(__x)))
     __y = __x, __x = _S_left(__x);
   else
     {
       _Const_Link_type __xu(__x);
       _Const_Base_ptr __yu(__y);
       __y = __x, __x = _S_left(__x);
       __xu = _S_right(__xu);
       return pair<const_iterator,
     const_iterator>(_M_lower_bound(__x, __y, __k),
       _M_upper_bound(__xu, __yu, __k));
     }
 }
      return pair<const_iterator, const_iterator>(const_iterator(__y),
        const_iterator(__y));
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
    typename _Compare, typename _Alloc>
    void
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    swap(_Rb_tree& __t)
    noexcept(__is_nothrow_swappable<_Compare>::value)
    {
      if (_M_root() == 0)
 {
   if (__t._M_root() != 0)
     _M_impl._M_move_data(__t._M_impl);
 }
      else if (__t._M_root() == 0)
 __t._M_impl._M_move_data(_M_impl);
      else
 {
   std::swap(_M_root(),__t._M_root());
   std::swap(_M_leftmost(),__t._M_leftmost());
   std::swap(_M_rightmost(),__t._M_rightmost());

   _M_root()->_M_parent = _M_end();
   __t._M_root()->_M_parent = __t._M_end();
   std::swap(this->_M_impl._M_node_count, __t._M_impl._M_node_count);
 }

      std::swap(this->_M_impl._M_key_compare, __t._M_impl._M_key_compare);

      _Alloc_traits::_S_on_swap(_M_get_Node_allocator(),
    __t._M_get_Node_allocator());
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
    typename _Compare, typename _Alloc>
    pair<typename _Rb_tree<_Key, _Val, _KeyOfValue,
      _Compare, _Alloc>::_Base_ptr,
  typename _Rb_tree<_Key, _Val, _KeyOfValue,
      _Compare, _Alloc>::_Base_ptr>
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_get_insert_unique_pos(const key_type& __k)
    {
      typedef pair<_Base_ptr, _Base_ptr> _Res;
      _Link_type __x = _M_begin();
      _Base_ptr __y = _M_end();
      bool __comp = true;
      while (__x != 0)
 {
   __y = __x;
   __comp = _M_impl._M_key_compare(__k, _S_key(__x));
   __x = __comp ? _S_left(__x) : _S_right(__x);
 }
      iterator __j = iterator(__y);
      if (__comp)
 {
   if (__j == begin())
     return _Res(__x, __y);
   else
     --__j;
 }
      if (_M_impl._M_key_compare(_S_key(__j._M_node), __k))
 return _Res(__x, __y);
      return _Res(__j._M_node, 0);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
    typename _Compare, typename _Alloc>
    pair<typename _Rb_tree<_Key, _Val, _KeyOfValue,
      _Compare, _Alloc>::_Base_ptr,
  typename _Rb_tree<_Key, _Val, _KeyOfValue,
      _Compare, _Alloc>::_Base_ptr>
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_get_insert_equal_pos(const key_type& __k)
    {
      typedef pair<_Base_ptr, _Base_ptr> _Res;
      _Link_type __x = _M_begin();
      _Base_ptr __y = _M_end();
      while (__x != 0)
 {
   __y = __x;
   __x = _M_impl._M_key_compare(__k, _S_key(__x)) ?
  _S_left(__x) : _S_right(__x);
 }
      return _Res(__x, __y);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
    typename _Compare, typename _Alloc>

    template<typename _Arg>

    pair<typename _Rb_tree<_Key, _Val, _KeyOfValue,
      _Compare, _Alloc>::iterator, bool>
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::

    _M_insert_unique(_Arg&& __v)



    {
      typedef pair<iterator, bool> _Res;
      pair<_Base_ptr, _Base_ptr> __res
 = _M_get_insert_unique_pos(_KeyOfValue()(__v));

      if (__res.second)
 {
   _Alloc_node __an(*this);
   return _Res(_M_insert_(__res.first, __res.second,
     std::forward<_Arg>(__v), __an),
        true);
 }

      return _Res(iterator(__res.first), false);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
    typename _Compare, typename _Alloc>

    template<typename _Arg>

    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::

    _M_insert_equal(_Arg&& __v)



    {
      pair<_Base_ptr, _Base_ptr> __res
 = _M_get_insert_equal_pos(_KeyOfValue()(__v));
      _Alloc_node __an(*this);
      return _M_insert_(__res.first, __res.second,
   std::forward<_Arg>(__v), __an);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
    typename _Compare, typename _Alloc>
    pair<typename _Rb_tree<_Key, _Val, _KeyOfValue,
      _Compare, _Alloc>::_Base_ptr,
  typename _Rb_tree<_Key, _Val, _KeyOfValue,
      _Compare, _Alloc>::_Base_ptr>
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_get_insert_hint_unique_pos(const_iterator __position,
      const key_type& __k)
    {
      iterator __pos = __position._M_const_cast();
      typedef pair<_Base_ptr, _Base_ptr> _Res;


      if (__pos._M_node == _M_end())
 {
   if (size() > 0
       && _M_impl._M_key_compare(_S_key(_M_rightmost()), __k))
     return _Res(0, _M_rightmost());
   else
     return _M_get_insert_unique_pos(__k);
 }
      else if (_M_impl._M_key_compare(__k, _S_key(__pos._M_node)))
 {

   iterator __before = __pos;
   if (__pos._M_node == _M_leftmost())
     return _Res(_M_leftmost(), _M_leftmost());
   else if (_M_impl._M_key_compare(_S_key((--__before)._M_node), __k))
     {
       if (_S_right(__before._M_node) == 0)
  return _Res(0, __before._M_node);
       else
  return _Res(__pos._M_node, __pos._M_node);
     }
   else
     return _M_get_insert_unique_pos(__k);
 }
      else if (_M_impl._M_key_compare(_S_key(__pos._M_node), __k))
 {

   iterator __after = __pos;
   if (__pos._M_node == _M_rightmost())
     return _Res(0, _M_rightmost());
   else if (_M_impl._M_key_compare(__k, _S_key((++__after)._M_node)))
     {
       if (_S_right(__pos._M_node) == 0)
  return _Res(0, __pos._M_node);
       else
  return _Res(__after._M_node, __after._M_node);
     }
   else
     return _M_get_insert_unique_pos(__k);
 }
      else

 return _Res(__pos._M_node, 0);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
    typename _Compare, typename _Alloc>

    template<typename _Arg, typename _NodeGen>



      typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
      _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
      _M_insert_unique_(const_iterator __position,

   _Arg&& __v,



   _NodeGen& __node_gen)
    {
      pair<_Base_ptr, _Base_ptr> __res
 = _M_get_insert_hint_unique_pos(__position, _KeyOfValue()(__v));

      if (__res.second)
 return _M_insert_(__res.first, __res.second,
     std::forward<_Arg>(__v),
     __node_gen);
      return iterator(__res.first);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
    typename _Compare, typename _Alloc>
    pair<typename _Rb_tree<_Key, _Val, _KeyOfValue,
      _Compare, _Alloc>::_Base_ptr,
  typename _Rb_tree<_Key, _Val, _KeyOfValue,
      _Compare, _Alloc>::_Base_ptr>
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_get_insert_hint_equal_pos(const_iterator __position, const key_type& __k)
    {
      iterator __pos = __position._M_const_cast();
      typedef pair<_Base_ptr, _Base_ptr> _Res;


      if (__pos._M_node == _M_end())
 {
   if (size() > 0
       && !_M_impl._M_key_compare(__k, _S_key(_M_rightmost())))
     return _Res(0, _M_rightmost());
   else
     return _M_get_insert_equal_pos(__k);
 }
      else if (!_M_impl._M_key_compare(_S_key(__pos._M_node), __k))
 {

   iterator __before = __pos;
   if (__pos._M_node == _M_leftmost())
     return _Res(_M_leftmost(), _M_leftmost());
   else if (!_M_impl._M_key_compare(__k, _S_key((--__before)._M_node)))
     {
       if (_S_right(__before._M_node) == 0)
  return _Res(0, __before._M_node);
       else
  return _Res(__pos._M_node, __pos._M_node);
     }
   else
     return _M_get_insert_equal_pos(__k);
 }
      else
 {

   iterator __after = __pos;
   if (__pos._M_node == _M_rightmost())
     return _Res(0, _M_rightmost());
   else if (!_M_impl._M_key_compare(_S_key((++__after)._M_node), __k))
     {
       if (_S_right(__pos._M_node) == 0)
  return _Res(0, __pos._M_node);
       else
  return _Res(__after._M_node, __after._M_node);
     }
   else
     return _Res(0, 0);
 }
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
    typename _Compare, typename _Alloc>

    template<typename _Arg, typename _NodeGen>



      typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
      _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
      _M_insert_equal_(const_iterator __position,

         _Arg&& __v,



         _NodeGen& __node_gen)
      {
 pair<_Base_ptr, _Base_ptr> __res
   = _M_get_insert_hint_equal_pos(__position, _KeyOfValue()(__v));

 if (__res.second)
   return _M_insert_(__res.first, __res.second,
       std::forward<_Arg>(__v),
       __node_gen);

 return _M_insert_equal_lower(std::forward<_Arg>(__v));
      }


  template<typename _Key, typename _Val, typename _KeyOfValue,
    typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_insert_node(_Base_ptr __x, _Base_ptr __p, _Link_type __z)
    {
      bool __insert_left = (__x != 0 || __p == _M_end()
       || _M_impl._M_key_compare(_S_key(__z),
            _S_key(__p)));

      _Rb_tree_insert_and_rebalance(__insert_left, __z, __p,
        this->_M_impl._M_header);
      ++_M_impl._M_node_count;
      return iterator(__z);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
    typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_insert_lower_node(_Base_ptr __p, _Link_type __z)
    {
      bool __insert_left = (__p == _M_end()
       || !_M_impl._M_key_compare(_S_key(__p),
             _S_key(__z)));

      _Rb_tree_insert_and_rebalance(__insert_left, __z, __p,
        this->_M_impl._M_header);
      ++_M_impl._M_node_count;
      return iterator(__z);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
    typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_insert_equal_lower_node(_Link_type __z)
    {
      _Link_type __x = _M_begin();
      _Base_ptr __y = _M_end();
      while (__x != 0)
 {
   __y = __x;
   __x = !_M_impl._M_key_compare(_S_key(__x), _S_key(__z)) ?
  _S_left(__x) : _S_right(__x);
 }
      return _M_insert_lower_node(__y, __z);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
    typename _Compare, typename _Alloc>
    template<typename... _Args>
      pair<typename _Rb_tree<_Key, _Val, _KeyOfValue,
        _Compare, _Alloc>::iterator, bool>
      _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
      _M_emplace_unique(_Args&&... __args)
      {
 _Link_type __z = _M_create_node(std::forward<_Args>(__args)...);

 try
   {
     typedef pair<iterator, bool> _Res;
     auto __res = _M_get_insert_unique_pos(_S_key(__z));
     if (__res.second)
       return _Res(_M_insert_node(__res.first, __res.second, __z), true);

     _M_drop_node(__z);
     return _Res(iterator(__res.first), false);
   }
 catch(...)
   {
     _M_drop_node(__z);
     throw;
   }
      }

  template<typename _Key, typename _Val, typename _KeyOfValue,
    typename _Compare, typename _Alloc>
    template<typename... _Args>
      typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
      _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
      _M_emplace_equal(_Args&&... __args)
      {
 _Link_type __z = _M_create_node(std::forward<_Args>(__args)...);

 try
   {
     auto __res = _M_get_insert_equal_pos(_S_key(__z));
     return _M_insert_node(__res.first, __res.second, __z);
   }
 catch(...)
   {
     _M_drop_node(__z);
     throw;
   }
      }

  template<typename _Key, typename _Val, typename _KeyOfValue,
    typename _Compare, typename _Alloc>
    template<typename... _Args>
      typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
      _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
      _M_emplace_hint_unique(const_iterator __pos, _Args&&... __args)
      {
 _Link_type __z = _M_create_node(std::forward<_Args>(__args)...);

 try
   {
     auto __res = _M_get_insert_hint_unique_pos(__pos, _S_key(__z));

     if (__res.second)
       return _M_insert_node(__res.first, __res.second, __z);

     _M_drop_node(__z);
     return iterator(__res.first);
   }
 catch(...)
   {
     _M_drop_node(__z);
     throw;
   }
      }

  template<typename _Key, typename _Val, typename _KeyOfValue,
    typename _Compare, typename _Alloc>
    template<typename... _Args>
      typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
      _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
      _M_emplace_hint_equal(const_iterator __pos, _Args&&... __args)
      {
 _Link_type __z = _M_create_node(std::forward<_Args>(__args)...);

 try
   {
     auto __res = _M_get_insert_hint_equal_pos(__pos, _S_key(__z));

     if (__res.second)
       return _M_insert_node(__res.first, __res.second, __z);

     return _M_insert_equal_lower_node(__z);
   }
 catch(...)
   {
     _M_drop_node(__z);
     throw;
   }
      }



  template<typename _Key, typename _Val, typename _KeyOfValue,
    typename _Compare, typename _Alloc>
    void
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_erase_aux(const_iterator __position)
    {
      _Link_type __y =
 static_cast<_Link_type>(_Rb_tree_rebalance_for_erase
    (const_cast<_Base_ptr>(__position._M_node),
     this->_M_impl._M_header));
      _M_drop_node(__y);
      --_M_impl._M_node_count;
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
    typename _Compare, typename _Alloc>
    void
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_erase_aux(const_iterator __first, const_iterator __last)
    {
      if (__first == begin() && __last == end())
 clear();
      else
 while (__first != __last)
   _M_erase_aux(__first++);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
    typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::size_type
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    erase(const _Key& __x)
    {
      pair<iterator, iterator> __p = equal_range(__x);
      const size_type __old_size = size();
      _M_erase_aux(__p.first, __p.second);
      return __old_size - size();
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
    typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue,
        _Compare, _Alloc>::iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    find(const _Key& __k)
    {
      iterator __j = _M_lower_bound(_M_begin(), _M_end(), __k);
      return (__j == end()
       || _M_impl._M_key_compare(__k,
     _S_key(__j._M_node))) ? end() : __j;
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
    typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue,
        _Compare, _Alloc>::const_iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    find(const _Key& __k) const
    {
      const_iterator __j = _M_lower_bound(_M_begin(), _M_end(), __k);
      return (__j == end()
       || _M_impl._M_key_compare(__k,
     _S_key(__j._M_node))) ? end() : __j;
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
    typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::size_type
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    count(const _Key& __k) const
    {
      pair<const_iterator, const_iterator> __p = equal_range(__k);
      const size_type __n = std::distance(__p.first, __p.second);
      return __n;
    }

  __attribute__ ((__pure__)) unsigned int
  _Rb_tree_black_count(const _Rb_tree_node_base* __node,
         const _Rb_tree_node_base* __root) throw ();

  template<typename _Key, typename _Val, typename _KeyOfValue,
    typename _Compare, typename _Alloc>
    bool
    _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::__rb_verify() const
    {
      if (_M_impl._M_node_count == 0 || begin() == end())
 return _M_impl._M_node_count == 0 && begin() == end()
        && this->_M_impl._M_header._M_left == _M_end()
        && this->_M_impl._M_header._M_right == _M_end();

      unsigned int __len = _Rb_tree_black_count(_M_leftmost(), _M_root());
      for (const_iterator __it = begin(); __it != end(); ++__it)
 {
   _Const_Link_type __x = static_cast<_Const_Link_type>(__it._M_node);
   _Const_Link_type __L = _S_left(__x);
   _Const_Link_type __R = _S_right(__x);

   if (__x->_M_color == _S_red)
     if ((__L && __L->_M_color == _S_red)
  || (__R && __R->_M_color == _S_red))
       return false;

   if (__L && _M_impl._M_key_compare(_S_key(__x), _S_key(__L)))
     return false;
   if (__R && _M_impl._M_key_compare(_S_key(__R), _S_key(__x)))
     return false;

   if (!__L && !__R && _Rb_tree_black_count(__x, _M_root()) != __len)
     return false;
 }

      if (_M_leftmost() != _Rb_tree_node_base::_S_minimum(_M_root()))
 return false;
      if (_M_rightmost() != _Rb_tree_node_base::_S_maximum(_M_root()))
 return false;
      return true;
    }
# 2641 "/usr/include/c++/10.2.0/bits/stl_tree.h" 3

}
# 61 "/usr/include/c++/10.2.0/map" 2 3
# 1 "/usr/include/c++/10.2.0/bits/stl_map.h" 1 3
# 66 "/usr/include/c++/10.2.0/bits/stl_map.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{



  template <typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    class multimap;
# 98 "/usr/include/c++/10.2.0/bits/stl_map.h" 3
  template <typename _Key, typename _Tp, typename _Compare = std::less<_Key>,
     typename _Alloc = std::allocator<std::pair<const _Key, _Tp> > >
    class map
    {
    public:
      typedef _Key key_type;
      typedef _Tp mapped_type;
      typedef std::pair<const _Key, _Tp> value_type;
      typedef _Compare key_compare;
      typedef _Alloc allocator_type;

    private:
# 123 "/usr/include/c++/10.2.0/bits/stl_map.h" 3
      static_assert(is_same<typename _Alloc::value_type, value_type>::value,
   "std::map must have the same value_type as its allocator");



    public:
      class value_compare
      : public std::binary_function<value_type, value_type, bool>
      {
 friend class map<_Key, _Tp, _Compare, _Alloc>;
      protected:
 _Compare comp;

 value_compare(_Compare __c)
 : comp(__c) { }

      public:
 bool operator()(const value_type& __x, const value_type& __y) const
 { return comp(__x.first, __y.first); }
      };

    private:

      typedef typename __gnu_cxx::__alloc_traits<_Alloc>::template
 rebind<value_type>::other _Pair_alloc_type;

      typedef _Rb_tree<key_type, value_type, _Select1st<value_type>,
         key_compare, _Pair_alloc_type> _Rep_type;


      _Rep_type _M_t;

      typedef __gnu_cxx::__alloc_traits<_Pair_alloc_type> _Alloc_traits;

    public:


      typedef typename _Alloc_traits::pointer pointer;
      typedef typename _Alloc_traits::const_pointer const_pointer;
      typedef typename _Alloc_traits::reference reference;
      typedef typename _Alloc_traits::const_reference const_reference;
      typedef typename _Rep_type::iterator iterator;
      typedef typename _Rep_type::const_iterator const_iterator;
      typedef typename _Rep_type::size_type size_type;
      typedef typename _Rep_type::difference_type difference_type;
      typedef typename _Rep_type::reverse_iterator reverse_iterator;
      typedef typename _Rep_type::const_reverse_iterator const_reverse_iterator;
# 185 "/usr/include/c++/10.2.0/bits/stl_map.h" 3
      map() = default;







      explicit
      map(const _Compare& __comp,
   const allocator_type& __a = allocator_type())
      : _M_t(__comp, _Pair_alloc_type(__a)) { }
# 207 "/usr/include/c++/10.2.0/bits/stl_map.h" 3
      map(const map&) = default;







      map(map&&) = default;
# 228 "/usr/include/c++/10.2.0/bits/stl_map.h" 3
      map(initializer_list<value_type> __l,
   const _Compare& __comp = _Compare(),
   const allocator_type& __a = allocator_type())
      : _M_t(__comp, _Pair_alloc_type(__a))
      { _M_t._M_insert_range_unique(__l.begin(), __l.end()); }


      explicit
      map(const allocator_type& __a)
      : _M_t(_Pair_alloc_type(__a)) { }


      map(const map& __m, const allocator_type& __a)
      : _M_t(__m._M_t, _Pair_alloc_type(__a)) { }


      map(map&& __m, const allocator_type& __a)
      noexcept(is_nothrow_copy_constructible<_Compare>::value
        && _Alloc_traits::_S_always_equal())
      : _M_t(std::move(__m._M_t), _Pair_alloc_type(__a)) { }


      map(initializer_list<value_type> __l, const allocator_type& __a)
      : _M_t(_Pair_alloc_type(__a))
      { _M_t._M_insert_range_unique(__l.begin(), __l.end()); }


      template<typename _InputIterator>
 map(_InputIterator __first, _InputIterator __last,
     const allocator_type& __a)
 : _M_t(_Pair_alloc_type(__a))
 { _M_t._M_insert_range_unique(__first, __last); }
# 272 "/usr/include/c++/10.2.0/bits/stl_map.h" 3
      template<typename _InputIterator>
 map(_InputIterator __first, _InputIterator __last)
 : _M_t()
 { _M_t._M_insert_range_unique(__first, __last); }
# 289 "/usr/include/c++/10.2.0/bits/stl_map.h" 3
      template<typename _InputIterator>
 map(_InputIterator __first, _InputIterator __last,
     const _Compare& __comp,
     const allocator_type& __a = allocator_type())
 : _M_t(__comp, _Pair_alloc_type(__a))
 { _M_t._M_insert_range_unique(__first, __last); }







      ~map() = default;
# 318 "/usr/include/c++/10.2.0/bits/stl_map.h" 3
      map&
      operator=(const map&) = default;


      map&
      operator=(map&&) = default;
# 336 "/usr/include/c++/10.2.0/bits/stl_map.h" 3
      map&
      operator=(initializer_list<value_type> __l)
      {
 _M_t._M_assign_unique(__l.begin(), __l.end());
 return *this;
      }



      allocator_type
      get_allocator() const noexcept
      { return allocator_type(_M_t.get_allocator()); }







      iterator
      begin() noexcept
      { return _M_t.begin(); }






      const_iterator
      begin() const noexcept
      { return _M_t.begin(); }






      iterator
      end() noexcept
      { return _M_t.end(); }






      const_iterator
      end() const noexcept
      { return _M_t.end(); }






      reverse_iterator
      rbegin() noexcept
      { return _M_t.rbegin(); }






      const_reverse_iterator
      rbegin() const noexcept
      { return _M_t.rbegin(); }






      reverse_iterator
      rend() noexcept
      { return _M_t.rend(); }






      const_reverse_iterator
      rend() const noexcept
      { return _M_t.rend(); }







      const_iterator
      cbegin() const noexcept
      { return _M_t.begin(); }






      const_iterator
      cend() const noexcept
      { return _M_t.end(); }






      const_reverse_iterator
      crbegin() const noexcept
      { return _M_t.rbegin(); }






      const_reverse_iterator
      crend() const noexcept
      { return _M_t.rend(); }






      bool
      empty() const noexcept
      { return _M_t.empty(); }


      size_type
      size() const noexcept
      { return _M_t.size(); }


      size_type
      max_size() const noexcept
      { return _M_t.max_size(); }
# 491 "/usr/include/c++/10.2.0/bits/stl_map.h" 3
      mapped_type&
      operator[](const key_type& __k)
      {



 iterator __i = lower_bound(__k);

 if (__i == end() || key_comp()(__k, (*__i).first))

   __i = _M_t._M_emplace_hint_unique(__i, std::piecewise_construct,
         std::tuple<const key_type&>(__k),
         std::tuple<>());



 return (*__i).second;
      }


      mapped_type&
      operator[](key_type&& __k)
      {



 iterator __i = lower_bound(__k);

 if (__i == end() || key_comp()(__k, (*__i).first))
   __i = _M_t._M_emplace_hint_unique(__i, std::piecewise_construct,
     std::forward_as_tuple(std::move(__k)),
     std::tuple<>());
 return (*__i).second;
      }
# 536 "/usr/include/c++/10.2.0/bits/stl_map.h" 3
      mapped_type&
      at(const key_type& __k)
      {
 iterator __i = lower_bound(__k);
 if (__i == end() || key_comp()(__k, (*__i).first))
   __throw_out_of_range(("map::at"));
 return (*__i).second;
      }

      const mapped_type&
      at(const key_type& __k) const
      {
 const_iterator __i = lower_bound(__k);
 if (__i == end() || key_comp()(__k, (*__i).first))
   __throw_out_of_range(("map::at"));
 return (*__i).second;
      }
# 574 "/usr/include/c++/10.2.0/bits/stl_map.h" 3
      template<typename... _Args>
 std::pair<iterator, bool>
 emplace(_Args&&... __args)
 { return _M_t._M_emplace_unique(std::forward<_Args>(__args)...); }
# 604 "/usr/include/c++/10.2.0/bits/stl_map.h" 3
      template<typename... _Args>
 iterator
 emplace_hint(const_iterator __pos, _Args&&... __args)
 {
   return _M_t._M_emplace_hint_unique(__pos,
          std::forward<_Args>(__args)...);
 }
# 802 "/usr/include/c++/10.2.0/bits/stl_map.h" 3
      std::pair<iterator, bool>
      insert(const value_type& __x)
      { return _M_t._M_insert_unique(__x); }




      std::pair<iterator, bool>
      insert(value_type&& __x)
      { return _M_t._M_insert_unique(std::move(__x)); }

      template<typename _Pair>
 __enable_if_t<is_constructible<value_type, _Pair>::value,
        pair<iterator, bool>>
 insert(_Pair&& __x)
 { return _M_t._M_emplace_unique(std::forward<_Pair>(__x)); }
# 829 "/usr/include/c++/10.2.0/bits/stl_map.h" 3
      void
      insert(std::initializer_list<value_type> __list)
      { insert(__list.begin(), __list.end()); }
# 858 "/usr/include/c++/10.2.0/bits/stl_map.h" 3
      iterator

      insert(const_iterator __position, const value_type& __x)



      { return _M_t._M_insert_unique_(__position, __x); }




      iterator
      insert(const_iterator __position, value_type&& __x)
      { return _M_t._M_insert_unique_(__position, std::move(__x)); }

      template<typename _Pair>
 __enable_if_t<is_constructible<value_type, _Pair>::value, iterator>
 insert(const_iterator __position, _Pair&& __x)
 {
   return _M_t._M_emplace_hint_unique(__position,
          std::forward<_Pair>(__x));
 }
# 891 "/usr/include/c++/10.2.0/bits/stl_map.h" 3
      template<typename _InputIterator>
 void
 insert(_InputIterator __first, _InputIterator __last)
 { _M_t._M_insert_range_unique(__first, __last); }
# 1030 "/usr/include/c++/10.2.0/bits/stl_map.h" 3
      iterator
      erase(const_iterator __position)
      { return _M_t.erase(__position); }


      __attribute ((__abi_tag__ ("cxx11")))
      iterator
      erase(iterator __position)
      { return _M_t.erase(__position); }
# 1067 "/usr/include/c++/10.2.0/bits/stl_map.h" 3
      size_type
      erase(const key_type& __x)
      { return _M_t.erase(__x); }
# 1087 "/usr/include/c++/10.2.0/bits/stl_map.h" 3
      iterator
      erase(const_iterator __first, const_iterator __last)
      { return _M_t.erase(__first, __last); }
# 1121 "/usr/include/c++/10.2.0/bits/stl_map.h" 3
      void
      swap(map& __x)
      noexcept(__is_nothrow_swappable<_Compare>::value)
      { _M_t.swap(__x._M_t); }







      void
      clear() noexcept
      { _M_t.clear(); }






      key_compare
      key_comp() const
      { return _M_t.key_comp(); }





      value_compare
      value_comp() const
      { return value_compare(_M_t.key_comp()); }
# 1168 "/usr/include/c++/10.2.0/bits/stl_map.h" 3
      iterator
      find(const key_type& __x)
      { return _M_t.find(__x); }
# 1193 "/usr/include/c++/10.2.0/bits/stl_map.h" 3
      const_iterator
      find(const key_type& __x) const
      { return _M_t.find(__x); }
# 1214 "/usr/include/c++/10.2.0/bits/stl_map.h" 3
      size_type
      count(const key_type& __x) const
      { return _M_t.find(__x) == _M_t.end() ? 0 : 1; }
# 1257 "/usr/include/c++/10.2.0/bits/stl_map.h" 3
      iterator
      lower_bound(const key_type& __x)
      { return _M_t.lower_bound(__x); }
# 1282 "/usr/include/c++/10.2.0/bits/stl_map.h" 3
      const_iterator
      lower_bound(const key_type& __x) const
      { return _M_t.lower_bound(__x); }
# 1302 "/usr/include/c++/10.2.0/bits/stl_map.h" 3
      iterator
      upper_bound(const key_type& __x)
      { return _M_t.upper_bound(__x); }
# 1322 "/usr/include/c++/10.2.0/bits/stl_map.h" 3
      const_iterator
      upper_bound(const key_type& __x) const
      { return _M_t.upper_bound(__x); }
# 1351 "/usr/include/c++/10.2.0/bits/stl_map.h" 3
      std::pair<iterator, iterator>
      equal_range(const key_type& __x)
      { return _M_t.equal_range(__x); }
# 1380 "/usr/include/c++/10.2.0/bits/stl_map.h" 3
      std::pair<const_iterator, const_iterator>
      equal_range(const key_type& __x) const
      { return _M_t.equal_range(__x); }
# 1397 "/usr/include/c++/10.2.0/bits/stl_map.h" 3
      template<typename _K1, typename _T1, typename _C1, typename _A1>
 friend bool
 operator==(const map<_K1, _T1, _C1, _A1>&,
     const map<_K1, _T1, _C1, _A1>&);







      template<typename _K1, typename _T1, typename _C1, typename _A1>
 friend bool
 operator<(const map<_K1, _T1, _C1, _A1>&,
    const map<_K1, _T1, _C1, _A1>&);

    };
# 1461 "/usr/include/c++/10.2.0/bits/stl_map.h" 3
  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator==(const map<_Key, _Tp, _Compare, _Alloc>& __x,
        const map<_Key, _Tp, _Compare, _Alloc>& __y)
    { return __x._M_t == __y._M_t; }
# 1499 "/usr/include/c++/10.2.0/bits/stl_map.h" 3
  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator<(const map<_Key, _Tp, _Compare, _Alloc>& __x,
       const map<_Key, _Tp, _Compare, _Alloc>& __y)
    { return __x._M_t < __y._M_t; }


  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator!=(const map<_Key, _Tp, _Compare, _Alloc>& __x,
        const map<_Key, _Tp, _Compare, _Alloc>& __y)
    { return !(__x == __y); }


  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator>(const map<_Key, _Tp, _Compare, _Alloc>& __x,
       const map<_Key, _Tp, _Compare, _Alloc>& __y)
    { return __y < __x; }


  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator<=(const map<_Key, _Tp, _Compare, _Alloc>& __x,
        const map<_Key, _Tp, _Compare, _Alloc>& __y)
    { return !(__y < __x); }


  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator>=(const map<_Key, _Tp, _Compare, _Alloc>& __x,
        const map<_Key, _Tp, _Compare, _Alloc>& __y)
    { return !(__x < __y); }



  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline void
    swap(map<_Key, _Tp, _Compare, _Alloc>& __x,
  map<_Key, _Tp, _Compare, _Alloc>& __y)
    noexcept(noexcept(__x.swap(__y)))
    { __x.swap(__y); }


# 1565 "/usr/include/c++/10.2.0/bits/stl_map.h" 3

}
# 62 "/usr/include/c++/10.2.0/map" 2 3
# 1 "/usr/include/c++/10.2.0/bits/stl_multimap.h" 1 3
# 64 "/usr/include/c++/10.2.0/bits/stl_multimap.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{



  template <typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    class map;
# 96 "/usr/include/c++/10.2.0/bits/stl_multimap.h" 3
  template <typename _Key, typename _Tp,
     typename _Compare = std::less<_Key>,
     typename _Alloc = std::allocator<std::pair<const _Key, _Tp> > >
    class multimap
    {
    public:
      typedef _Key key_type;
      typedef _Tp mapped_type;
      typedef std::pair<const _Key, _Tp> value_type;
      typedef _Compare key_compare;
      typedef _Alloc allocator_type;

    private:
# 122 "/usr/include/c++/10.2.0/bits/stl_multimap.h" 3
      static_assert(is_same<typename _Alloc::value_type, value_type>::value,
   "std::multimap must have the same value_type as its allocator");



    public:
      class value_compare
      : public std::binary_function<value_type, value_type, bool>
      {
 friend class multimap<_Key, _Tp, _Compare, _Alloc>;
      protected:
 _Compare comp;

 value_compare(_Compare __c)
 : comp(__c) { }

      public:
 bool operator()(const value_type& __x, const value_type& __y) const
 { return comp(__x.first, __y.first); }
      };

    private:

      typedef typename __gnu_cxx::__alloc_traits<_Alloc>::template
 rebind<value_type>::other _Pair_alloc_type;

      typedef _Rb_tree<key_type, value_type, _Select1st<value_type>,
         key_compare, _Pair_alloc_type> _Rep_type;

      _Rep_type _M_t;

      typedef __gnu_cxx::__alloc_traits<_Pair_alloc_type> _Alloc_traits;

    public:


      typedef typename _Alloc_traits::pointer pointer;
      typedef typename _Alloc_traits::const_pointer const_pointer;
      typedef typename _Alloc_traits::reference reference;
      typedef typename _Alloc_traits::const_reference const_reference;
      typedef typename _Rep_type::iterator iterator;
      typedef typename _Rep_type::const_iterator const_iterator;
      typedef typename _Rep_type::size_type size_type;
      typedef typename _Rep_type::difference_type difference_type;
      typedef typename _Rep_type::reverse_iterator reverse_iterator;
      typedef typename _Rep_type::const_reverse_iterator const_reverse_iterator;
# 182 "/usr/include/c++/10.2.0/bits/stl_multimap.h" 3
      multimap() = default;







      explicit
      multimap(const _Compare& __comp,
        const allocator_type& __a = allocator_type())
      : _M_t(__comp, _Pair_alloc_type(__a)) { }
# 204 "/usr/include/c++/10.2.0/bits/stl_multimap.h" 3
      multimap(const multimap&) = default;
# 213 "/usr/include/c++/10.2.0/bits/stl_multimap.h" 3
      multimap(multimap&&) = default;
# 225 "/usr/include/c++/10.2.0/bits/stl_multimap.h" 3
      multimap(initializer_list<value_type> __l,
        const _Compare& __comp = _Compare(),
        const allocator_type& __a = allocator_type())
      : _M_t(__comp, _Pair_alloc_type(__a))
      { _M_t._M_insert_range_equal(__l.begin(), __l.end()); }


      explicit
      multimap(const allocator_type& __a)
      : _M_t(_Pair_alloc_type(__a)) { }


      multimap(const multimap& __m, const allocator_type& __a)
      : _M_t(__m._M_t, _Pair_alloc_type(__a)) { }


      multimap(multimap&& __m, const allocator_type& __a)
      noexcept(is_nothrow_copy_constructible<_Compare>::value
        && _Alloc_traits::_S_always_equal())
      : _M_t(std::move(__m._M_t), _Pair_alloc_type(__a)) { }


      multimap(initializer_list<value_type> __l, const allocator_type& __a)
      : _M_t(_Pair_alloc_type(__a))
      { _M_t._M_insert_range_equal(__l.begin(), __l.end()); }


      template<typename _InputIterator>
 multimap(_InputIterator __first, _InputIterator __last,
   const allocator_type& __a)
 : _M_t(_Pair_alloc_type(__a))
 { _M_t._M_insert_range_equal(__first, __last); }
# 268 "/usr/include/c++/10.2.0/bits/stl_multimap.h" 3
      template<typename _InputIterator>
 multimap(_InputIterator __first, _InputIterator __last)
 : _M_t()
 { _M_t._M_insert_range_equal(__first, __last); }
# 284 "/usr/include/c++/10.2.0/bits/stl_multimap.h" 3
      template<typename _InputIterator>
 multimap(_InputIterator __first, _InputIterator __last,
   const _Compare& __comp,
   const allocator_type& __a = allocator_type())
 : _M_t(__comp, _Pair_alloc_type(__a))
 { _M_t._M_insert_range_equal(__first, __last); }







      ~multimap() = default;
# 313 "/usr/include/c++/10.2.0/bits/stl_multimap.h" 3
      multimap&
      operator=(const multimap&) = default;


      multimap&
      operator=(multimap&&) = default;
# 331 "/usr/include/c++/10.2.0/bits/stl_multimap.h" 3
      multimap&
      operator=(initializer_list<value_type> __l)
      {
 _M_t._M_assign_equal(__l.begin(), __l.end());
 return *this;
      }



      allocator_type
      get_allocator() const noexcept
      { return allocator_type(_M_t.get_allocator()); }







      iterator
      begin() noexcept
      { return _M_t.begin(); }






      const_iterator
      begin() const noexcept
      { return _M_t.begin(); }






      iterator
      end() noexcept
      { return _M_t.end(); }






      const_iterator
      end() const noexcept
      { return _M_t.end(); }






      reverse_iterator
      rbegin() noexcept
      { return _M_t.rbegin(); }






      const_reverse_iterator
      rbegin() const noexcept
      { return _M_t.rbegin(); }






      reverse_iterator
      rend() noexcept
      { return _M_t.rend(); }






      const_reverse_iterator
      rend() const noexcept
      { return _M_t.rend(); }







      const_iterator
      cbegin() const noexcept
      { return _M_t.begin(); }






      const_iterator
      cend() const noexcept
      { return _M_t.end(); }






      const_reverse_iterator
      crbegin() const noexcept
      { return _M_t.rbegin(); }






      const_reverse_iterator
      crend() const noexcept
      { return _M_t.rend(); }




      bool
      empty() const noexcept
      { return _M_t.empty(); }


      size_type
      size() const noexcept
      { return _M_t.size(); }


      size_type
      max_size() const noexcept
      { return _M_t.max_size(); }
# 489 "/usr/include/c++/10.2.0/bits/stl_multimap.h" 3
      template<typename... _Args>
 iterator
 emplace(_Args&&... __args)
 { return _M_t._M_emplace_equal(std::forward<_Args>(__args)...); }
# 516 "/usr/include/c++/10.2.0/bits/stl_multimap.h" 3
      template<typename... _Args>
 iterator
 emplace_hint(const_iterator __pos, _Args&&... __args)
 {
   return _M_t._M_emplace_hint_equal(__pos,
         std::forward<_Args>(__args)...);
 }
# 538 "/usr/include/c++/10.2.0/bits/stl_multimap.h" 3
      iterator
      insert(const value_type& __x)
      { return _M_t._M_insert_equal(__x); }




      iterator
      insert(value_type&& __x)
      { return _M_t._M_insert_equal(std::move(__x)); }

      template<typename _Pair>
 __enable_if_t<is_constructible<value_type, _Pair>::value, iterator>
 insert(_Pair&& __x)
 { return _M_t._M_emplace_equal(std::forward<_Pair>(__x)); }
# 577 "/usr/include/c++/10.2.0/bits/stl_multimap.h" 3
      iterator

      insert(const_iterator __position, const value_type& __x)



      { return _M_t._M_insert_equal_(__position, __x); }




      iterator
      insert(const_iterator __position, value_type&& __x)
      { return _M_t._M_insert_equal_(__position, std::move(__x)); }

      template<typename _Pair>
 __enable_if_t<is_constructible<value_type, _Pair&&>::value, iterator>
 insert(const_iterator __position, _Pair&& __x)
 {
   return _M_t._M_emplace_hint_equal(__position,
         std::forward<_Pair>(__x));
 }
# 611 "/usr/include/c++/10.2.0/bits/stl_multimap.h" 3
      template<typename _InputIterator>
 void
 insert(_InputIterator __first, _InputIterator __last)
 { _M_t._M_insert_range_equal(__first, __last); }
# 624 "/usr/include/c++/10.2.0/bits/stl_multimap.h" 3
      void
      insert(initializer_list<value_type> __l)
      { this->insert(__l.begin(), __l.end()); }
# 701 "/usr/include/c++/10.2.0/bits/stl_multimap.h" 3
      iterator
      erase(const_iterator __position)
      { return _M_t.erase(__position); }


      __attribute ((__abi_tag__ ("cxx11")))
      iterator
      erase(iterator __position)
      { return _M_t.erase(__position); }
# 738 "/usr/include/c++/10.2.0/bits/stl_multimap.h" 3
      size_type
      erase(const key_type& __x)
      { return _M_t.erase(__x); }
# 759 "/usr/include/c++/10.2.0/bits/stl_multimap.h" 3
      iterator
      erase(const_iterator __first, const_iterator __last)
      { return _M_t.erase(__first, __last); }
# 796 "/usr/include/c++/10.2.0/bits/stl_multimap.h" 3
      void
      swap(multimap& __x)
      noexcept(__is_nothrow_swappable<_Compare>::value)
      { _M_t.swap(__x._M_t); }







      void
      clear() noexcept
      { _M_t.clear(); }






      key_compare
      key_comp() const
      { return _M_t.key_comp(); }





      value_compare
      value_comp() const
      { return value_compare(_M_t.key_comp()); }
# 842 "/usr/include/c++/10.2.0/bits/stl_multimap.h" 3
      iterator
      find(const key_type& __x)
      { return _M_t.find(__x); }
# 866 "/usr/include/c++/10.2.0/bits/stl_multimap.h" 3
      const_iterator
      find(const key_type& __x) const
      { return _M_t.find(__x); }
# 884 "/usr/include/c++/10.2.0/bits/stl_multimap.h" 3
      size_type
      count(const key_type& __x) const
      { return _M_t.count(__x); }
# 927 "/usr/include/c++/10.2.0/bits/stl_multimap.h" 3
      iterator
      lower_bound(const key_type& __x)
      { return _M_t.lower_bound(__x); }
# 952 "/usr/include/c++/10.2.0/bits/stl_multimap.h" 3
      const_iterator
      lower_bound(const key_type& __x) const
      { return _M_t.lower_bound(__x); }
# 972 "/usr/include/c++/10.2.0/bits/stl_multimap.h" 3
      iterator
      upper_bound(const key_type& __x)
      { return _M_t.upper_bound(__x); }
# 992 "/usr/include/c++/10.2.0/bits/stl_multimap.h" 3
      const_iterator
      upper_bound(const key_type& __x) const
      { return _M_t.upper_bound(__x); }
# 1019 "/usr/include/c++/10.2.0/bits/stl_multimap.h" 3
      std::pair<iterator, iterator>
      equal_range(const key_type& __x)
      { return _M_t.equal_range(__x); }
# 1046 "/usr/include/c++/10.2.0/bits/stl_multimap.h" 3
      std::pair<const_iterator, const_iterator>
      equal_range(const key_type& __x) const
      { return _M_t.equal_range(__x); }
# 1063 "/usr/include/c++/10.2.0/bits/stl_multimap.h" 3
      template<typename _K1, typename _T1, typename _C1, typename _A1>
 friend bool
 operator==(const multimap<_K1, _T1, _C1, _A1>&,
     const multimap<_K1, _T1, _C1, _A1>&);







      template<typename _K1, typename _T1, typename _C1, typename _A1>
 friend bool
 operator<(const multimap<_K1, _T1, _C1, _A1>&,
    const multimap<_K1, _T1, _C1, _A1>&);

  };
# 1126 "/usr/include/c++/10.2.0/bits/stl_multimap.h" 3
  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator==(const multimap<_Key, _Tp, _Compare, _Alloc>& __x,
        const multimap<_Key, _Tp, _Compare, _Alloc>& __y)
    { return __x._M_t == __y._M_t; }
# 1164 "/usr/include/c++/10.2.0/bits/stl_multimap.h" 3
  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator<(const multimap<_Key, _Tp, _Compare, _Alloc>& __x,
       const multimap<_Key, _Tp, _Compare, _Alloc>& __y)
    { return __x._M_t < __y._M_t; }


  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator!=(const multimap<_Key, _Tp, _Compare, _Alloc>& __x,
        const multimap<_Key, _Tp, _Compare, _Alloc>& __y)
    { return !(__x == __y); }


  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator>(const multimap<_Key, _Tp, _Compare, _Alloc>& __x,
       const multimap<_Key, _Tp, _Compare, _Alloc>& __y)
    { return __y < __x; }


  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator<=(const multimap<_Key, _Tp, _Compare, _Alloc>& __x,
        const multimap<_Key, _Tp, _Compare, _Alloc>& __y)
    { return !(__y < __x); }


  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator>=(const multimap<_Key, _Tp, _Compare, _Alloc>& __x,
        const multimap<_Key, _Tp, _Compare, _Alloc>& __y)
    { return !(__x < __y); }



  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline void
    swap(multimap<_Key, _Tp, _Compare, _Alloc>& __x,
  multimap<_Key, _Tp, _Compare, _Alloc>& __y)
    noexcept(noexcept(__x.swap(__y)))
    { __x.swap(__y); }


# 1230 "/usr/include/c++/10.2.0/bits/stl_multimap.h" 3

}
# 63 "/usr/include/c++/10.2.0/map" 2 3

# 1 "/usr/include/c++/10.2.0/bits/erase_if.h" 1 3
# 33 "/usr/include/c++/10.2.0/bits/erase_if.h" 3
       
# 34 "/usr/include/c++/10.2.0/bits/erase_if.h" 3
# 65 "/usr/include/c++/10.2.0/map" 2 3
# 45 "/usr/include/json/value.h" 2 3 4


# 1 "/usr/include/c++/10.2.0/vector" 1 3 4
# 58 "/usr/include/c++/10.2.0/vector" 3 4
       
# 59 "/usr/include/c++/10.2.0/vector" 3
# 67 "/usr/include/c++/10.2.0/vector" 3
# 1 "/usr/include/c++/10.2.0/bits/stl_vector.h" 1 3
# 77 "/usr/include/c++/10.2.0/bits/stl_vector.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{




  template<typename _Tp, typename _Alloc>
    struct _Vector_base
    {
      typedef typename __gnu_cxx::__alloc_traits<_Alloc>::template
 rebind<_Tp>::other _Tp_alloc_type;
      typedef typename __gnu_cxx::__alloc_traits<_Tp_alloc_type>::pointer
        pointer;

      struct _Vector_impl_data
      {
 pointer _M_start;
 pointer _M_finish;
 pointer _M_end_of_storage;

 _Vector_impl_data() noexcept
 : _M_start(), _M_finish(), _M_end_of_storage()
 { }


 _Vector_impl_data(_Vector_impl_data&& __x) noexcept
 : _M_start(__x._M_start), _M_finish(__x._M_finish),
   _M_end_of_storage(__x._M_end_of_storage)
 { __x._M_start = __x._M_finish = __x._M_end_of_storage = pointer(); }


 void
 _M_copy_data(_Vector_impl_data const& __x) noexcept
 {
   _M_start = __x._M_start;
   _M_finish = __x._M_finish;
   _M_end_of_storage = __x._M_end_of_storage;
 }

 void
 _M_swap_data(_Vector_impl_data& __x) noexcept
 {


   _Vector_impl_data __tmp;
   __tmp._M_copy_data(*this);
   _M_copy_data(__x);
   __x._M_copy_data(__tmp);
 }
      };

      struct _Vector_impl
 : public _Tp_alloc_type, public _Vector_impl_data
      {
 _Vector_impl() noexcept(is_nothrow_default_constructible<_Tp_alloc_type>::value)

 : _Tp_alloc_type()
 { }

 _Vector_impl(_Tp_alloc_type const& __a) noexcept
 : _Tp_alloc_type(__a)
 { }




 _Vector_impl(_Vector_impl&& __x) noexcept
 : _Tp_alloc_type(std::move(__x)), _Vector_impl_data(std::move(__x))
 { }

 _Vector_impl(_Tp_alloc_type&& __a) noexcept
 : _Tp_alloc_type(std::move(__a))
 { }

 _Vector_impl(_Tp_alloc_type&& __a, _Vector_impl&& __rv) noexcept
 : _Tp_alloc_type(std::move(__a)), _Vector_impl_data(std::move(__rv))
 { }
# 270 "/usr/include/c++/10.2.0/bits/stl_vector.h" 3
      };

    public:
      typedef _Alloc allocator_type;

      _Tp_alloc_type&
      _M_get_Tp_allocator() noexcept
      { return this->_M_impl; }

      const _Tp_alloc_type&
      _M_get_Tp_allocator() const noexcept
      { return this->_M_impl; }

      allocator_type
      get_allocator() const noexcept
      { return allocator_type(_M_get_Tp_allocator()); }


      _Vector_base() = default;




      _Vector_base(const allocator_type& __a) noexcept
      : _M_impl(__a) { }



      _Vector_base(size_t __n)
      : _M_impl()
      { _M_create_storage(__n); }


      _Vector_base(size_t __n, const allocator_type& __a)
      : _M_impl(__a)
      { _M_create_storage(__n); }


      _Vector_base(_Vector_base&&) = default;



      _Vector_base(_Tp_alloc_type&& __a) noexcept
      : _M_impl(std::move(__a)) { }

      _Vector_base(_Vector_base&& __x, const allocator_type& __a)
      : _M_impl(__a)
      {
 if (__x.get_allocator() == __a)
   this->_M_impl._M_swap_data(__x._M_impl);
 else
   {
     size_t __n = __x._M_impl._M_finish - __x._M_impl._M_start;
     _M_create_storage(__n);
   }
      }


      _Vector_base(const allocator_type& __a, _Vector_base&& __x)
      : _M_impl(_Tp_alloc_type(__a), std::move(__x._M_impl))
      { }


      ~_Vector_base() noexcept
      {
 _M_deallocate(_M_impl._M_start,
        _M_impl._M_end_of_storage - _M_impl._M_start);
      }

    public:
      _Vector_impl _M_impl;

      pointer
      _M_allocate(size_t __n)
      {
 typedef __gnu_cxx::__alloc_traits<_Tp_alloc_type> _Tr;
 return __n != 0 ? _Tr::allocate(_M_impl, __n) : pointer();
      }

      void
      _M_deallocate(pointer __p, size_t __n)
      {
 typedef __gnu_cxx::__alloc_traits<_Tp_alloc_type> _Tr;
 if (__p)
   _Tr::deallocate(_M_impl, __p, __n);
      }

    protected:
      void
      _M_create_storage(size_t __n)
      {
 this->_M_impl._M_start = this->_M_allocate(__n);
 this->_M_impl._M_finish = this->_M_impl._M_start;
 this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __n;
      }
    };
# 388 "/usr/include/c++/10.2.0/bits/stl_vector.h" 3
  template<typename _Tp, typename _Alloc = std::allocator<_Tp> >
    class vector : protected _Vector_base<_Tp, _Alloc>
    {
# 401 "/usr/include/c++/10.2.0/bits/stl_vector.h" 3
      static_assert(is_same<typename remove_cv<_Tp>::type, _Tp>::value,
   "std::vector must have a non-const, non-volatile value_type");

      static_assert(is_same<typename _Alloc::value_type, _Tp>::value,
   "std::vector must have the same value_type as its allocator");



      typedef _Vector_base<_Tp, _Alloc> _Base;
      typedef typename _Base::_Tp_alloc_type _Tp_alloc_type;
      typedef __gnu_cxx::__alloc_traits<_Tp_alloc_type> _Alloc_traits;

    public:
      typedef _Tp value_type;
      typedef typename _Base::pointer pointer;
      typedef typename _Alloc_traits::const_pointer const_pointer;
      typedef typename _Alloc_traits::reference reference;
      typedef typename _Alloc_traits::const_reference const_reference;
      typedef __gnu_cxx::__normal_iterator<pointer, vector> iterator;
      typedef __gnu_cxx::__normal_iterator<const_pointer, vector>
      const_iterator;
      typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
      typedef std::reverse_iterator<iterator> reverse_iterator;
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef _Alloc allocator_type;

    private:

      static constexpr bool
      _S_nothrow_relocate(true_type)
      {
 return noexcept(std::__relocate_a(std::declval<pointer>(),
       std::declval<pointer>(),
       std::declval<pointer>(),
       std::declval<_Tp_alloc_type&>()));
      }

      static constexpr bool
      _S_nothrow_relocate(false_type)
      { return false; }

      static constexpr bool
      _S_use_relocate()
      {



 return _S_nothrow_relocate(__is_move_insertable<_Tp_alloc_type>{});
      }

      static pointer
      _S_do_relocate(pointer __first, pointer __last, pointer __result,
       _Tp_alloc_type& __alloc, true_type) noexcept
      {
 return std::__relocate_a(__first, __last, __result, __alloc);
      }

      static pointer
      _S_do_relocate(pointer, pointer, pointer __result,
       _Tp_alloc_type&, false_type) noexcept
      { return __result; }

      static pointer
      _S_relocate(pointer __first, pointer __last, pointer __result,
    _Tp_alloc_type& __alloc) noexcept
      {
 using __do_it = __bool_constant<_S_use_relocate()>;
 return _S_do_relocate(__first, __last, __result, __alloc, __do_it{});
      }


    protected:
      using _Base::_M_allocate;
      using _Base::_M_deallocate;
      using _Base::_M_impl;
      using _Base::_M_get_Tp_allocator;

    public:







      vector() = default;
# 496 "/usr/include/c++/10.2.0/bits/stl_vector.h" 3
      explicit
      vector(const allocator_type& __a) noexcept
      : _Base(__a) { }
# 509 "/usr/include/c++/10.2.0/bits/stl_vector.h" 3
      explicit
      vector(size_type __n, const allocator_type& __a = allocator_type())
      : _Base(_S_check_init_len(__n, __a), __a)
      { _M_default_initialize(__n); }
# 522 "/usr/include/c++/10.2.0/bits/stl_vector.h" 3
      vector(size_type __n, const value_type& __value,
      const allocator_type& __a = allocator_type())
      : _Base(_S_check_init_len(__n, __a), __a)
      { _M_fill_initialize(__n, __value); }
# 553 "/usr/include/c++/10.2.0/bits/stl_vector.h" 3
      vector(const vector& __x)
      : _Base(__x.size(),
 _Alloc_traits::_S_select_on_copy(__x._M_get_Tp_allocator()))
      {
 this->_M_impl._M_finish =
   std::__uninitialized_copy_a(__x.begin(), __x.end(),
          this->_M_impl._M_start,
          _M_get_Tp_allocator());
      }
# 572 "/usr/include/c++/10.2.0/bits/stl_vector.h" 3
      vector(vector&&) noexcept = default;


      vector(const vector& __x, const allocator_type& __a)
      : _Base(__x.size(), __a)
      {
 this->_M_impl._M_finish =
   std::__uninitialized_copy_a(__x.begin(), __x.end(),
          this->_M_impl._M_start,
          _M_get_Tp_allocator());
      }

    private:
      vector(vector&& __rv, const allocator_type& __m, true_type) noexcept
      : _Base(__m, std::move(__rv))
      { }

      vector(vector&& __rv, const allocator_type& __m, false_type)
      : _Base(__m)
      {
 if (__rv.get_allocator() == __m)
   this->_M_impl._M_swap_data(__rv._M_impl);
 else if (!__rv.empty())
   {
     this->_M_create_storage(__rv.size());
     this->_M_impl._M_finish =
       std::__uninitialized_move_a(__rv.begin(), __rv.end(),
       this->_M_impl._M_start,
       _M_get_Tp_allocator());
     __rv.clear();
   }
      }

    public:

      vector(vector&& __rv, const allocator_type& __m)
      noexcept( noexcept(
 vector(std::declval<vector&&>(), std::declval<const allocator_type&>(),
        std::declval<typename _Alloc_traits::is_always_equal>())) )
      : vector(std::move(__rv), __m, typename _Alloc_traits::is_always_equal{})
      { }
# 625 "/usr/include/c++/10.2.0/bits/stl_vector.h" 3
      vector(initializer_list<value_type> __l,
      const allocator_type& __a = allocator_type())
      : _Base(__a)
      {
 _M_range_initialize(__l.begin(), __l.end(),
       random_access_iterator_tag());
      }
# 651 "/usr/include/c++/10.2.0/bits/stl_vector.h" 3
      template<typename _InputIterator,
        typename = std::_RequireInputIter<_InputIterator>>
 vector(_InputIterator __first, _InputIterator __last,
        const allocator_type& __a = allocator_type())
 : _Base(__a)
 {
   _M_range_initialize(__first, __last,
         std::__iterator_category(__first));
 }
# 678 "/usr/include/c++/10.2.0/bits/stl_vector.h" 3
      ~vector() noexcept
      {
 std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
        _M_get_Tp_allocator());
 ;
      }
# 694 "/usr/include/c++/10.2.0/bits/stl_vector.h" 3
      vector&
      operator=(const vector& __x);
# 708 "/usr/include/c++/10.2.0/bits/stl_vector.h" 3
      vector&
      operator=(vector&& __x) noexcept(_Alloc_traits::_S_nothrow_move())
      {
 constexpr bool __move_storage =
   _Alloc_traits::_S_propagate_on_move_assign()
   || _Alloc_traits::_S_always_equal();
 _M_move_assign(std::move(__x), __bool_constant<__move_storage>());
 return *this;
      }
# 729 "/usr/include/c++/10.2.0/bits/stl_vector.h" 3
      vector&
      operator=(initializer_list<value_type> __l)
      {
 this->_M_assign_aux(__l.begin(), __l.end(),
       random_access_iterator_tag());
 return *this;
      }
# 748 "/usr/include/c++/10.2.0/bits/stl_vector.h" 3
      void
      assign(size_type __n, const value_type& __val)
      { _M_fill_assign(__n, __val); }
# 765 "/usr/include/c++/10.2.0/bits/stl_vector.h" 3
      template<typename _InputIterator,
        typename = std::_RequireInputIter<_InputIterator>>
 void
 assign(_InputIterator __first, _InputIterator __last)
 { _M_assign_dispatch(__first, __last, __false_type()); }
# 793 "/usr/include/c++/10.2.0/bits/stl_vector.h" 3
      void
      assign(initializer_list<value_type> __l)
      {
 this->_M_assign_aux(__l.begin(), __l.end(),
       random_access_iterator_tag());
      }



      using _Base::get_allocator;







      iterator
      begin() noexcept
      { return iterator(this->_M_impl._M_start); }






      const_iterator
      begin() const noexcept
      { return const_iterator(this->_M_impl._M_start); }






      iterator
      end() noexcept
      { return iterator(this->_M_impl._M_finish); }






      const_iterator
      end() const noexcept
      { return const_iterator(this->_M_impl._M_finish); }






      reverse_iterator
      rbegin() noexcept
      { return reverse_iterator(end()); }






      const_reverse_iterator
      rbegin() const noexcept
      { return const_reverse_iterator(end()); }






      reverse_iterator
      rend() noexcept
      { return reverse_iterator(begin()); }






      const_reverse_iterator
      rend() const noexcept
      { return const_reverse_iterator(begin()); }







      const_iterator
      cbegin() const noexcept
      { return const_iterator(this->_M_impl._M_start); }






      const_iterator
      cend() const noexcept
      { return const_iterator(this->_M_impl._M_finish); }






      const_reverse_iterator
      crbegin() const noexcept
      { return const_reverse_iterator(end()); }






      const_reverse_iterator
      crend() const noexcept
      { return const_reverse_iterator(begin()); }




      size_type
      size() const noexcept
      { return size_type(this->_M_impl._M_finish - this->_M_impl._M_start); }


      size_type
      max_size() const noexcept
      { return _S_max_size(_M_get_Tp_allocator()); }
# 936 "/usr/include/c++/10.2.0/bits/stl_vector.h" 3
      void
      resize(size_type __new_size)
      {
 if (__new_size > size())
   _M_default_append(__new_size - size());
 else if (__new_size < size())
   _M_erase_at_end(this->_M_impl._M_start + __new_size);
      }
# 956 "/usr/include/c++/10.2.0/bits/stl_vector.h" 3
      void
      resize(size_type __new_size, const value_type& __x)
      {
 if (__new_size > size())
   _M_fill_insert(end(), __new_size - size(), __x);
 else if (__new_size < size())
   _M_erase_at_end(this->_M_impl._M_start + __new_size);
      }
# 988 "/usr/include/c++/10.2.0/bits/stl_vector.h" 3
      void
      shrink_to_fit()
      { _M_shrink_to_fit(); }






      size_type
      capacity() const noexcept
      { return size_type(this->_M_impl._M_end_of_storage
    - this->_M_impl._M_start); }





      bool
      empty() const noexcept
      { return begin() == end(); }
# 1027 "/usr/include/c++/10.2.0/bits/stl_vector.h" 3
      void
      reserve(size_type __n);
# 1042 "/usr/include/c++/10.2.0/bits/stl_vector.h" 3
      reference
      operator[](size_type __n) noexcept
      {
 ;
 return *(this->_M_impl._M_start + __n);
      }
# 1060 "/usr/include/c++/10.2.0/bits/stl_vector.h" 3
      const_reference
      operator[](size_type __n) const noexcept
      {
 ;
 return *(this->_M_impl._M_start + __n);
      }

    protected:

      void
      _M_range_check(size_type __n) const
      {
 if (__n >= this->size())
   __throw_out_of_range_fmt(("vector::_M_range_check: __n " "(which is %zu) >= this->size() " "(which is %zu)")

                            ,
       __n, this->size());
      }

    public:
# 1091 "/usr/include/c++/10.2.0/bits/stl_vector.h" 3
      reference
      at(size_type __n)
      {
 _M_range_check(__n);
 return (*this)[__n];
      }
# 1109 "/usr/include/c++/10.2.0/bits/stl_vector.h" 3
      const_reference
      at(size_type __n) const
      {
 _M_range_check(__n);
 return (*this)[__n];
      }





      reference
      front() noexcept
      {
 ;
 return *begin();
      }





      const_reference
      front() const noexcept
      {
 ;
 return *begin();
      }





      reference
      back() noexcept
      {
 ;
 return *(end() - 1);
      }





      const_reference
      back() const noexcept
      {
 ;
 return *(end() - 1);
      }
# 1167 "/usr/include/c++/10.2.0/bits/stl_vector.h" 3
      _Tp*
      data() noexcept
      { return _M_data_ptr(this->_M_impl._M_start); }

      const _Tp*
      data() const noexcept
      { return _M_data_ptr(this->_M_impl._M_start); }
# 1186 "/usr/include/c++/10.2.0/bits/stl_vector.h" 3
      void
      push_back(const value_type& __x)
      {
 if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
   {
     ;
     _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,
         __x);
     ++this->_M_impl._M_finish;
     ;
   }
 else
   _M_realloc_insert(end(), __x);
      }


      void
      push_back(value_type&& __x)
      { emplace_back(std::move(__x)); }

      template<typename... _Args>



 void

 emplace_back(_Args&&... __args);
# 1224 "/usr/include/c++/10.2.0/bits/stl_vector.h" 3
      void
      pop_back() noexcept
      {
 ;
 --this->_M_impl._M_finish;
 _Alloc_traits::destroy(this->_M_impl, this->_M_impl._M_finish);
 ;
      }
# 1246 "/usr/include/c++/10.2.0/bits/stl_vector.h" 3
      template<typename... _Args>
 iterator
 emplace(const_iterator __position, _Args&&... __args)
 { return _M_emplace_aux(__position, std::forward<_Args>(__args)...); }
# 1262 "/usr/include/c++/10.2.0/bits/stl_vector.h" 3
      iterator
      insert(const_iterator __position, const value_type& __x);
# 1292 "/usr/include/c++/10.2.0/bits/stl_vector.h" 3
      iterator
      insert(const_iterator __position, value_type&& __x)
      { return _M_insert_rval(__position, std::move(__x)); }
# 1309 "/usr/include/c++/10.2.0/bits/stl_vector.h" 3
      iterator
      insert(const_iterator __position, initializer_list<value_type> __l)
      {
 auto __offset = __position - cbegin();
 _M_range_insert(begin() + __offset, __l.begin(), __l.end(),
   std::random_access_iterator_tag());
 return begin() + __offset;
      }
# 1334 "/usr/include/c++/10.2.0/bits/stl_vector.h" 3
      iterator
      insert(const_iterator __position, size_type __n, const value_type& __x)
      {
 difference_type __offset = __position - cbegin();
 _M_fill_insert(begin() + __offset, __n, __x);
 return begin() + __offset;
      }
# 1376 "/usr/include/c++/10.2.0/bits/stl_vector.h" 3
      template<typename _InputIterator,
        typename = std::_RequireInputIter<_InputIterator>>
 iterator
 insert(const_iterator __position, _InputIterator __first,
        _InputIterator __last)
 {
   difference_type __offset = __position - cbegin();
   _M_insert_dispatch(begin() + __offset,
        __first, __last, __false_type());
   return begin() + __offset;
 }
# 1428 "/usr/include/c++/10.2.0/bits/stl_vector.h" 3
      iterator

      erase(const_iterator __position)
      { return _M_erase(begin() + (__position - cbegin())); }
# 1455 "/usr/include/c++/10.2.0/bits/stl_vector.h" 3
      iterator

      erase(const_iterator __first, const_iterator __last)
      {
 const auto __beg = begin();
 const auto __cbeg = cbegin();
 return _M_erase(__beg + (__first - __cbeg), __beg + (__last - __cbeg));
      }
# 1479 "/usr/include/c++/10.2.0/bits/stl_vector.h" 3
      void
      swap(vector& __x) noexcept
      {


                                                          ;

 this->_M_impl._M_swap_data(__x._M_impl);
 _Alloc_traits::_S_on_swap(_M_get_Tp_allocator(),
      __x._M_get_Tp_allocator());
      }







      void
      clear() noexcept
      { _M_erase_at_end(this->_M_impl._M_start); }

    protected:




      template<typename _ForwardIterator>
 pointer
 _M_allocate_and_copy(size_type __n,
        _ForwardIterator __first, _ForwardIterator __last)
 {
   pointer __result = this->_M_allocate(__n);
   try
     {
       std::__uninitialized_copy_a(__first, __last, __result,
       _M_get_Tp_allocator());
       return __result;
     }
   catch(...)
     {
       _M_deallocate(__result, __n);
       throw;
     }
 }
# 1556 "/usr/include/c++/10.2.0/bits/stl_vector.h" 3
      template<typename _InputIterator>
 void
 _M_range_initialize(_InputIterator __first, _InputIterator __last,
       std::input_iterator_tag)
 {
   try {
     for (; __first != __last; ++__first)

       emplace_back(*__first);



   } catch(...) {
     clear();
     throw;
   }
 }


      template<typename _ForwardIterator>
 void
 _M_range_initialize(_ForwardIterator __first, _ForwardIterator __last,
       std::forward_iterator_tag)
 {
   const size_type __n = std::distance(__first, __last);
   this->_M_impl._M_start
     = this->_M_allocate(_S_check_init_len(__n, _M_get_Tp_allocator()));
   this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __n;
   this->_M_impl._M_finish =
     std::__uninitialized_copy_a(__first, __last,
     this->_M_impl._M_start,
     _M_get_Tp_allocator());
 }



      void
      _M_fill_initialize(size_type __n, const value_type& __value)
      {
 this->_M_impl._M_finish =
   std::__uninitialized_fill_n_a(this->_M_impl._M_start, __n, __value,
     _M_get_Tp_allocator());
      }



      void
      _M_default_initialize(size_type __n)
      {
 this->_M_impl._M_finish =
   std::__uninitialized_default_n_a(this->_M_impl._M_start, __n,
        _M_get_Tp_allocator());
      }
# 1618 "/usr/include/c++/10.2.0/bits/stl_vector.h" 3
      template<typename _Integer>
 void
 _M_assign_dispatch(_Integer __n, _Integer __val, __true_type)
 { _M_fill_assign(__n, __val); }


      template<typename _InputIterator>
 void
 _M_assign_dispatch(_InputIterator __first, _InputIterator __last,
      __false_type)
 { _M_assign_aux(__first, __last, std::__iterator_category(__first)); }


      template<typename _InputIterator>
 void
 _M_assign_aux(_InputIterator __first, _InputIterator __last,
        std::input_iterator_tag);


      template<typename _ForwardIterator>
 void
 _M_assign_aux(_ForwardIterator __first, _ForwardIterator __last,
        std::forward_iterator_tag);



      void
      _M_fill_assign(size_type __n, const value_type& __val);







      template<typename _Integer>
 void
 _M_insert_dispatch(iterator __pos, _Integer __n, _Integer __val,
      __true_type)
 { _M_fill_insert(__pos, __n, __val); }


      template<typename _InputIterator>
 void
 _M_insert_dispatch(iterator __pos, _InputIterator __first,
      _InputIterator __last, __false_type)
 {
   _M_range_insert(__pos, __first, __last,
     std::__iterator_category(__first));
 }


      template<typename _InputIterator>
 void
 _M_range_insert(iterator __pos, _InputIterator __first,
   _InputIterator __last, std::input_iterator_tag);


      template<typename _ForwardIterator>
 void
 _M_range_insert(iterator __pos, _ForwardIterator __first,
   _ForwardIterator __last, std::forward_iterator_tag);



      void
      _M_fill_insert(iterator __pos, size_type __n, const value_type& __x);



      void
      _M_default_append(size_type __n);

      bool
      _M_shrink_to_fit();
# 1705 "/usr/include/c++/10.2.0/bits/stl_vector.h" 3
      struct _Temporary_value
      {
 template<typename... _Args>
   explicit
   _Temporary_value(vector* __vec, _Args&&... __args) : _M_this(__vec)
   {
     _Alloc_traits::construct(_M_this->_M_impl, _M_ptr(),
         std::forward<_Args>(__args)...);
   }

 ~_Temporary_value()
 { _Alloc_traits::destroy(_M_this->_M_impl, _M_ptr()); }

 value_type&
 _M_val() { return *_M_ptr(); }

      private:
 _Tp*
 _M_ptr() { return reinterpret_cast<_Tp*>(&__buf); }

 vector* _M_this;
 typename aligned_storage<sizeof(_Tp), alignof(_Tp)>::type __buf;
      };



      template<typename _Arg>
 void
 _M_insert_aux(iterator __position, _Arg&& __arg);

      template<typename... _Args>
 void
 _M_realloc_insert(iterator __position, _Args&&... __args);


      iterator
      _M_insert_rval(const_iterator __position, value_type&& __v);


      template<typename... _Args>
 iterator
 _M_emplace_aux(const_iterator __position, _Args&&... __args);


      iterator
      _M_emplace_aux(const_iterator __position, value_type&& __v)
      { return _M_insert_rval(__position, std::move(__v)); }



      size_type
      _M_check_len(size_type __n, const char* __s) const
      {
 if (max_size() - size() < __n)
   __throw_length_error((__s));

 const size_type __len = size() + (std::max)(size(), __n);
 return (__len < size() || __len > max_size()) ? max_size() : __len;
      }


      static size_type
      _S_check_init_len(size_type __n, const allocator_type& __a)
      {
 if (__n > _S_max_size(_Tp_alloc_type(__a)))
   __throw_length_error(
       ("cannot create std::vector larger than max_size()"));
 return __n;
      }

      static size_type
      _S_max_size(const _Tp_alloc_type& __a) noexcept
      {



 const size_t __diffmax
   = __gnu_cxx::__numeric_traits<ptrdiff_t>::__max / sizeof(_Tp);
 const size_t __allocmax = _Alloc_traits::max_size(__a);
 return (std::min)(__diffmax, __allocmax);
      }





      void
      _M_erase_at_end(pointer __pos) noexcept
      {
 if (size_type __n = this->_M_impl._M_finish - __pos)
   {
     std::_Destroy(__pos, this->_M_impl._M_finish,
     _M_get_Tp_allocator());
     this->_M_impl._M_finish = __pos;
     ;
   }
      }

      iterator
      _M_erase(iterator __position);

      iterator
      _M_erase(iterator __first, iterator __last);


    private:



      void
      _M_move_assign(vector&& __x, true_type) noexcept
      {
 vector __tmp(get_allocator());
 this->_M_impl._M_swap_data(__x._M_impl);
 __tmp._M_impl._M_swap_data(__x._M_impl);
 std::__alloc_on_move(_M_get_Tp_allocator(), __x._M_get_Tp_allocator());
      }



      void
      _M_move_assign(vector&& __x, false_type)
      {
 if (__x._M_get_Tp_allocator() == this->_M_get_Tp_allocator())
   _M_move_assign(std::move(__x), true_type());
 else
   {


     this->_M_assign_aux(std::make_move_iterator(__x.begin()),
           std::make_move_iterator(__x.end()),
    std::random_access_iterator_tag());
     __x.clear();
   }
      }


      template<typename _Up>
 _Up*
 _M_data_ptr(_Up* __ptr) const noexcept
 { return __ptr; }


      template<typename _Ptr>
 typename std::pointer_traits<_Ptr>::element_type*
 _M_data_ptr(_Ptr __ptr) const
 { return empty() ? nullptr : std::__to_address(__ptr); }
# 1868 "/usr/include/c++/10.2.0/bits/stl_vector.h" 3
    };
# 1890 "/usr/include/c++/10.2.0/bits/stl_vector.h" 3
  template<typename _Tp, typename _Alloc>
    inline bool
    operator==(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
    { return (__x.size() == __y.size()
       && std::equal(__x.begin(), __x.end(), __y.begin())); }
# 1928 "/usr/include/c++/10.2.0/bits/stl_vector.h" 3
  template<typename _Tp, typename _Alloc>
    inline bool
    operator<(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
    { return std::lexicographical_compare(__x.begin(), __x.end(),
       __y.begin(), __y.end()); }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator!=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
    { return !(__x == __y); }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator>(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
    { return __y < __x; }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator<=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
    { return !(__y < __x); }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator>=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
    { return !(__x < __y); }



  template<typename _Tp, typename _Alloc>
    inline void
    swap(vector<_Tp, _Alloc>& __x, vector<_Tp, _Alloc>& __y)
    noexcept(noexcept(__x.swap(__y)))
    { __x.swap(__y); }


# 1982 "/usr/include/c++/10.2.0/bits/stl_vector.h" 3

}
# 68 "/usr/include/c++/10.2.0/vector" 2 3
# 1 "/usr/include/c++/10.2.0/bits/stl_bvector.h" 1 3
# 64 "/usr/include/c++/10.2.0/bits/stl_bvector.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{



  typedef unsigned long _Bit_type;
  enum { _S_word_bit = int(8 * sizeof(_Bit_type)) };

  struct _Bit_reference
  {
    _Bit_type * _M_p;
    _Bit_type _M_mask;

    _Bit_reference(_Bit_type * __x, _Bit_type __y)
    : _M_p(__x), _M_mask(__y) { }

    _Bit_reference() noexcept : _M_p(0), _M_mask(0) { }


    _Bit_reference(const _Bit_reference&) = default;


    operator bool() const noexcept
    { return !!(*_M_p & _M_mask); }

    _Bit_reference&
    operator=(bool __x) noexcept
    {
      if (__x)
 *_M_p |= _M_mask;
      else
 *_M_p &= ~_M_mask;
      return *this;
    }

    _Bit_reference&
    operator=(const _Bit_reference& __x) noexcept
    { return *this = bool(__x); }

    bool
    operator==(const _Bit_reference& __x) const
    { return bool(*this) == bool(__x); }

    bool
    operator<(const _Bit_reference& __x) const
    { return !bool(*this) && bool(__x); }

    void
    flip() noexcept
    { *_M_p ^= _M_mask; }
  };


  inline void
  swap(_Bit_reference __x, _Bit_reference __y) noexcept
  {
    bool __tmp = __x;
    __x = __y;
    __y = __tmp;
  }

  inline void
  swap(_Bit_reference __x, bool& __y) noexcept
  {
    bool __tmp = __x;
    __x = __y;
    __y = __tmp;
  }

  inline void
  swap(bool& __x, _Bit_reference __y) noexcept
  {
    bool __tmp = __x;
    __x = __y;
    __y = __tmp;
  }


  struct _Bit_iterator_base
  : public std::iterator<std::random_access_iterator_tag, bool>
  {
    _Bit_type * _M_p;
    unsigned int _M_offset;

    _Bit_iterator_base(_Bit_type * __x, unsigned int __y)
    : _M_p(__x), _M_offset(__y) { }

    void
    _M_bump_up()
    {
      if (_M_offset++ == int(_S_word_bit) - 1)
 {
   _M_offset = 0;
   ++_M_p;
 }
    }

    void
    _M_bump_down()
    {
      if (_M_offset-- == 0)
 {
   _M_offset = int(_S_word_bit) - 1;
   --_M_p;
 }
    }

    void
    _M_incr(ptrdiff_t __i)
    {
      difference_type __n = __i + _M_offset;
      _M_p += __n / int(_S_word_bit);
      __n = __n % int(_S_word_bit);
      if (__n < 0)
 {
   __n += int(_S_word_bit);
   --_M_p;
 }
      _M_offset = static_cast<unsigned int>(__n);
    }

    friend bool
    operator==(const _Bit_iterator_base& __x, const _Bit_iterator_base& __y)
    { return __x._M_p == __y._M_p && __x._M_offset == __y._M_offset; }
# 199 "/usr/include/c++/10.2.0/bits/stl_bvector.h" 3
    friend bool
    operator<(const _Bit_iterator_base& __x, const _Bit_iterator_base& __y)
    {
      return __x._M_p < __y._M_p
     || (__x._M_p == __y._M_p && __x._M_offset < __y._M_offset);
    }

    friend bool
    operator!=(const _Bit_iterator_base& __x, const _Bit_iterator_base& __y)
    { return !(__x == __y); }

    friend bool
    operator>(const _Bit_iterator_base& __x, const _Bit_iterator_base& __y)
    { return __y < __x; }

    friend bool
    operator<=(const _Bit_iterator_base& __x, const _Bit_iterator_base& __y)
    { return !(__y < __x); }

    friend bool
    operator>=(const _Bit_iterator_base& __x, const _Bit_iterator_base& __y)
    { return !(__x < __y); }


    friend ptrdiff_t
    operator-(const _Bit_iterator_base& __x, const _Bit_iterator_base& __y)
    {
      return (int(_S_word_bit) * (__x._M_p - __y._M_p)
       + __x._M_offset - __y._M_offset);
    }
  };

  struct _Bit_iterator : public _Bit_iterator_base
  {
    typedef _Bit_reference reference;



    typedef _Bit_reference* pointer;

    typedef _Bit_iterator iterator;

    _Bit_iterator() : _Bit_iterator_base(0, 0) { }

    _Bit_iterator(_Bit_type * __x, unsigned int __y)
    : _Bit_iterator_base(__x, __y) { }

    iterator
    _M_const_cast() const
    { return *this; }

    reference
    operator*() const
    { return reference(_M_p, 1UL << _M_offset); }

    iterator&
    operator++()
    {
      _M_bump_up();
      return *this;
    }

    iterator
    operator++(int)
    {
      iterator __tmp = *this;
      _M_bump_up();
      return __tmp;
    }

    iterator&
    operator--()
    {
      _M_bump_down();
      return *this;
    }

    iterator
    operator--(int)
    {
      iterator __tmp = *this;
      _M_bump_down();
      return __tmp;
    }

    iterator&
    operator+=(difference_type __i)
    {
      _M_incr(__i);
      return *this;
    }

    iterator&
    operator-=(difference_type __i)
    {
      *this += -__i;
      return *this;
    }

    reference
    operator[](difference_type __i) const
    { return *(*this + __i); }

    friend iterator
    operator+(const iterator& __x, difference_type __n)
    {
      iterator __tmp = __x;
      __tmp += __n;
      return __tmp;
    }

    friend iterator
    operator+(difference_type __n, const iterator& __x)
    { return __x + __n; }

    friend iterator
    operator-(const iterator& __x, difference_type __n)
    {
      iterator __tmp = __x;
      __tmp -= __n;
      return __tmp;
    }
  };

  struct _Bit_const_iterator : public _Bit_iterator_base
  {
    typedef bool reference;
    typedef bool const_reference;



    typedef const bool* pointer;

    typedef _Bit_const_iterator const_iterator;

    _Bit_const_iterator() : _Bit_iterator_base(0, 0) { }

    _Bit_const_iterator(_Bit_type * __x, unsigned int __y)
    : _Bit_iterator_base(__x, __y) { }

    _Bit_const_iterator(const _Bit_iterator& __x)
    : _Bit_iterator_base(__x._M_p, __x._M_offset) { }

    _Bit_iterator
    _M_const_cast() const
    { return _Bit_iterator(_M_p, _M_offset); }

    const_reference
    operator*() const
    { return _Bit_reference(_M_p, 1UL << _M_offset); }

    const_iterator&
    operator++()
    {
      _M_bump_up();
      return *this;
    }

    const_iterator
    operator++(int)
    {
      const_iterator __tmp = *this;
      _M_bump_up();
      return __tmp;
    }

    const_iterator&
    operator--()
    {
      _M_bump_down();
      return *this;
    }

    const_iterator
    operator--(int)
    {
      const_iterator __tmp = *this;
      _M_bump_down();
      return __tmp;
    }

    const_iterator&
    operator+=(difference_type __i)
    {
      _M_incr(__i);
      return *this;
    }

    const_iterator&
    operator-=(difference_type __i)
    {
      *this += -__i;
      return *this;
    }

    const_reference
    operator[](difference_type __i) const
    { return *(*this + __i); }

    friend const_iterator
    operator+(const const_iterator& __x, difference_type __n)
    {
      const_iterator __tmp = __x;
      __tmp += __n;
      return __tmp;
    }

    friend const_iterator
    operator-(const const_iterator& __x, difference_type __n)
    {
      const_iterator __tmp = __x;
      __tmp -= __n;
      return __tmp;
    }

    friend const_iterator
    operator+(difference_type __n, const const_iterator& __x)
    { return __x + __n; }
  };

  inline void
  __fill_bvector(_Bit_type * __v,
   unsigned int __first, unsigned int __last, bool __x)
  {
    const _Bit_type __fmask = ~0ul << __first;
    const _Bit_type __lmask = ~0ul >> (_S_word_bit - __last);
    const _Bit_type __mask = __fmask & __lmask;

    if (__x)
      *__v |= __mask;
    else
      *__v &= ~__mask;
  }

  inline void
  fill(_Bit_iterator __first, _Bit_iterator __last, const bool& __x)
  {
    if (__first._M_p != __last._M_p)
      {
 _Bit_type* __first_p = __first._M_p;
 if (__first._M_offset != 0)
   __fill_bvector(__first_p++, __first._M_offset, _S_word_bit, __x);

 __builtin_memset(__first_p, __x ? ~0 : 0,
    (__last._M_p - __first_p) * sizeof(_Bit_type));

 if (__last._M_offset != 0)
   __fill_bvector(__last._M_p, 0, __last._M_offset, __x);
      }
    else if (__first._M_offset != __last._M_offset)
      __fill_bvector(__first._M_p, __first._M_offset, __last._M_offset, __x);
  }

  template<typename _Alloc>
    struct _Bvector_base
    {
      typedef typename __gnu_cxx::__alloc_traits<_Alloc>::template
        rebind<_Bit_type>::other _Bit_alloc_type;
      typedef typename __gnu_cxx::__alloc_traits<_Bit_alloc_type>
 _Bit_alloc_traits;
      typedef typename _Bit_alloc_traits::pointer _Bit_pointer;

      struct _Bvector_impl_data
      {
 _Bit_iterator _M_start;
 _Bit_iterator _M_finish;
 _Bit_pointer _M_end_of_storage;

 _Bvector_impl_data() noexcept
 : _M_start(), _M_finish(), _M_end_of_storage()
 { }


 _Bvector_impl_data(_Bvector_impl_data&& __x) noexcept
 : _M_start(__x._M_start), _M_finish(__x._M_finish)
 , _M_end_of_storage(__x._M_end_of_storage)
 { __x._M_reset(); }

 void
 _M_move_data(_Bvector_impl_data&& __x) noexcept
 {
   this->_M_start = __x._M_start;
   this->_M_finish = __x._M_finish;
   this->_M_end_of_storage = __x._M_end_of_storage;
   __x._M_reset();
 }


 void
 _M_reset() noexcept
 {
   _M_start = _M_finish = _Bit_iterator();
   _M_end_of_storage = _Bit_pointer();
 }
      };

      struct _Bvector_impl
 : public _Bit_alloc_type, public _Bvector_impl_data
 {
 public:
   _Bvector_impl() noexcept(is_nothrow_default_constructible<_Bit_alloc_type>::value)

   : _Bit_alloc_type()
   { }

   _Bvector_impl(const _Bit_alloc_type& __a) noexcept
   : _Bit_alloc_type(__a)
   { }


 _Bvector_impl(_Bvector_impl&&) = default;


 _Bit_type*
 _M_end_addr() const noexcept
 {
   if (this->_M_end_of_storage)
     return std::__addressof(this->_M_end_of_storage[-1]) + 1;
   return 0;
 }
      };

    public:
      typedef _Alloc allocator_type;

      _Bit_alloc_type&
      _M_get_Bit_allocator() noexcept
      { return this->_M_impl; }

      const _Bit_alloc_type&
      _M_get_Bit_allocator() const noexcept
      { return this->_M_impl; }

      allocator_type
      get_allocator() const noexcept
      { return allocator_type(_M_get_Bit_allocator()); }


      _Bvector_base() = default;




      _Bvector_base(const allocator_type& __a)
      : _M_impl(__a) { }


      _Bvector_base(_Bvector_base&&) = default;


      ~_Bvector_base()
      { this->_M_deallocate(); }

    protected:
      _Bvector_impl _M_impl;

      _Bit_pointer
      _M_allocate(size_t __n)
      { return _Bit_alloc_traits::allocate(_M_impl, _S_nword(__n)); }

      void
      _M_deallocate()
      {
 if (_M_impl._M_start._M_p)
   {
     const size_t __n = _M_impl._M_end_addr() - _M_impl._M_start._M_p;
     _Bit_alloc_traits::deallocate(_M_impl,
       _M_impl._M_end_of_storage - __n,
       __n);
     _M_impl._M_reset();
   }
      }


      void
      _M_move_data(_Bvector_base&& __x) noexcept
      { _M_impl._M_move_data(std::move(__x._M_impl)); }


      static size_t
      _S_nword(size_t __n)
      { return (__n + int(_S_word_bit) - 1) / int(_S_word_bit); }
    };



}




namespace std __attribute__ ((__visibility__ ("default")))
{


# 614 "/usr/include/c++/10.2.0/bits/stl_bvector.h" 3
  template<typename _Alloc>
    class vector<bool, _Alloc> : protected _Bvector_base<_Alloc>
    {
      typedef _Bvector_base<_Alloc> _Base;
      typedef typename _Base::_Bit_pointer _Bit_pointer;
      typedef typename _Base::_Bit_alloc_traits _Bit_alloc_traits;


      friend struct std::hash<vector>;


    public:
      typedef bool value_type;
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef _Bit_reference reference;
      typedef bool const_reference;
      typedef _Bit_reference* pointer;
      typedef const bool* const_pointer;
      typedef _Bit_iterator iterator;
      typedef _Bit_const_iterator const_iterator;
      typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
      typedef std::reverse_iterator<iterator> reverse_iterator;
      typedef _Alloc allocator_type;

      allocator_type
      get_allocator() const
      { return _Base::get_allocator(); }

    protected:
      using _Base::_M_allocate;
      using _Base::_M_deallocate;
      using _Base::_S_nword;
      using _Base::_M_get_Bit_allocator;

    public:

      vector() = default;




      explicit
      vector(const allocator_type& __a)
      : _Base(__a) { }


      explicit
      vector(size_type __n, const allocator_type& __a = allocator_type())
      : vector(__n, false, __a)
      { }

      vector(size_type __n, const bool& __value,
      const allocator_type& __a = allocator_type())





      : _Base(__a)
      {
 _M_initialize(__n);
 _M_initialize_value(__value);
      }

      vector(const vector& __x)
      : _Base(_Bit_alloc_traits::_S_select_on_copy(__x._M_get_Bit_allocator()))
      {
 _M_initialize(__x.size());
 _M_copy_aligned(__x.begin(), __x.end(), this->_M_impl._M_start);
      }


      vector(vector&&) = default;

      vector(vector&& __x, const allocator_type& __a)
      noexcept(_Bit_alloc_traits::_S_always_equal())
      : _Base(__a)
      {
 if (__x.get_allocator() == __a)
   this->_M_move_data(std::move(__x));
 else
   {
     _M_initialize(__x.size());
     _M_copy_aligned(__x.begin(), __x.end(), begin());
     __x.clear();
   }
      }

      vector(const vector& __x, const allocator_type& __a)
      : _Base(__a)
      {
 _M_initialize(__x.size());
 _M_copy_aligned(__x.begin(), __x.end(), this->_M_impl._M_start);
      }

      vector(initializer_list<bool> __l,
      const allocator_type& __a = allocator_type())
      : _Base(__a)
      {
 _M_initialize_range(__l.begin(), __l.end(),
       random_access_iterator_tag());
      }



      template<typename _InputIterator,
        typename = std::_RequireInputIter<_InputIterator>>
 vector(_InputIterator __first, _InputIterator __last,
        const allocator_type& __a = allocator_type())
 : _Base(__a)
 { _M_initialize_dispatch(__first, __last, __false_type()); }
# 737 "/usr/include/c++/10.2.0/bits/stl_bvector.h" 3
      ~vector() noexcept { }

      vector&
      operator=(const vector& __x)
      {
 if (&__x == this)
   return *this;

 if (_Bit_alloc_traits::_S_propagate_on_copy_assign())
   {
     if (this->_M_get_Bit_allocator() != __x._M_get_Bit_allocator())
       {
  this->_M_deallocate();
  std::__alloc_on_copy(_M_get_Bit_allocator(),
         __x._M_get_Bit_allocator());
  _M_initialize(__x.size());
       }
     else
       std::__alloc_on_copy(_M_get_Bit_allocator(),
       __x._M_get_Bit_allocator());
   }

 if (__x.size() > capacity())
   {
     this->_M_deallocate();
     _M_initialize(__x.size());
   }
 this->_M_impl._M_finish = _M_copy_aligned(__x.begin(), __x.end(),
        begin());
 return *this;
      }


      vector&
      operator=(vector&& __x) noexcept(_Bit_alloc_traits::_S_nothrow_move())
      {
 if (_Bit_alloc_traits::_S_propagate_on_move_assign()
     || this->_M_get_Bit_allocator() == __x._M_get_Bit_allocator())
   {
     this->_M_deallocate();
     this->_M_move_data(std::move(__x));
     std::__alloc_on_move(_M_get_Bit_allocator(),
     __x._M_get_Bit_allocator());
   }
 else
   {
     if (__x.size() > capacity())
       {
  this->_M_deallocate();
  _M_initialize(__x.size());
       }
     this->_M_impl._M_finish = _M_copy_aligned(__x.begin(), __x.end(),
            begin());
     __x.clear();
   }
 return *this;
      }

      vector&
      operator=(initializer_list<bool> __l)
      {
 this->assign (__l.begin(), __l.end());
 return *this;
      }






      void
      assign(size_type __n, const bool& __x)
      { _M_fill_assign(__n, __x); }


      template<typename _InputIterator,
        typename = std::_RequireInputIter<_InputIterator>>
 void
 assign(_InputIterator __first, _InputIterator __last)
 { _M_assign_aux(__first, __last, std::__iterator_category(__first)); }
# 828 "/usr/include/c++/10.2.0/bits/stl_bvector.h" 3
      void
      assign(initializer_list<bool> __l)
      { _M_assign_aux(__l.begin(), __l.end(), random_access_iterator_tag()); }


      iterator
      begin() noexcept
      { return iterator(this->_M_impl._M_start._M_p, 0); }

      const_iterator
      begin() const noexcept
      { return const_iterator(this->_M_impl._M_start._M_p, 0); }

      iterator
      end() noexcept
      { return this->_M_impl._M_finish; }

      const_iterator
      end() const noexcept
      { return this->_M_impl._M_finish; }

      reverse_iterator
      rbegin() noexcept
      { return reverse_iterator(end()); }

      const_reverse_iterator
      rbegin() const noexcept
      { return const_reverse_iterator(end()); }

      reverse_iterator
      rend() noexcept
      { return reverse_iterator(begin()); }

      const_reverse_iterator
      rend() const noexcept
      { return const_reverse_iterator(begin()); }


      const_iterator
      cbegin() const noexcept
      { return const_iterator(this->_M_impl._M_start._M_p, 0); }

      const_iterator
      cend() const noexcept
      { return this->_M_impl._M_finish; }

      const_reverse_iterator
      crbegin() const noexcept
      { return const_reverse_iterator(end()); }

      const_reverse_iterator
      crend() const noexcept
      { return const_reverse_iterator(begin()); }


      size_type
      size() const noexcept
      { return size_type(end() - begin()); }

      size_type
      max_size() const noexcept
      {
 const size_type __isize =
   __gnu_cxx::__numeric_traits<difference_type>::__max
   - int(_S_word_bit) + 1;
 const size_type __asize
   = _Bit_alloc_traits::max_size(_M_get_Bit_allocator());
 return (__asize <= __isize / int(_S_word_bit)
  ? __asize * int(_S_word_bit) : __isize);
      }

      size_type
      capacity() const noexcept
      { return size_type(const_iterator(this->_M_impl._M_end_addr(), 0)
    - begin()); }

      bool
      empty() const noexcept
      { return begin() == end(); }

      reference
      operator[](size_type __n)
      {
 return *iterator(this->_M_impl._M_start._M_p
    + __n / int(_S_word_bit), __n % int(_S_word_bit));
      }

      const_reference
      operator[](size_type __n) const
      {
 return *const_iterator(this->_M_impl._M_start._M_p
        + __n / int(_S_word_bit), __n % int(_S_word_bit));
      }

    protected:
      void
      _M_range_check(size_type __n) const
      {
 if (__n >= this->size())
   __throw_out_of_range_fmt(("vector<bool>::_M_range_check: __n " "(which is %zu) >= this->size() " "(which is %zu)")

                            ,
       __n, this->size());
      }

    public:
      reference
      at(size_type __n)
      { _M_range_check(__n); return (*this)[__n]; }

      const_reference
      at(size_type __n) const
      { _M_range_check(__n); return (*this)[__n]; }

      void
      reserve(size_type __n)
      {
 if (__n > max_size())
   __throw_length_error(("vector::reserve"));
 if (capacity() < __n)
   _M_reallocate(__n);
      }

      reference
      front()
      { return *begin(); }

      const_reference
      front() const
      { return *begin(); }

      reference
      back()
      { return *(end() - 1); }

      const_reference
      back() const
      { return *(end() - 1); }






      void
      data() noexcept { }

      void
      push_back(bool __x)
      {
 if (this->_M_impl._M_finish._M_p != this->_M_impl._M_end_addr())
   *this->_M_impl._M_finish++ = __x;
 else
   _M_insert_aux(end(), __x);
      }

      void
      swap(vector& __x) noexcept
      {
 std::swap(this->_M_impl._M_start, __x._M_impl._M_start);
 std::swap(this->_M_impl._M_finish, __x._M_impl._M_finish);
 std::swap(this->_M_impl._M_end_of_storage,
    __x._M_impl._M_end_of_storage);
 _Bit_alloc_traits::_S_on_swap(_M_get_Bit_allocator(),
          __x._M_get_Bit_allocator());
      }


      static void
      swap(reference __x, reference __y) noexcept
      {
 bool __tmp = __x;
 __x = __y;
 __y = __tmp;
      }

      iterator

      insert(const_iterator __position, const bool& __x = bool())



      {
 const difference_type __n = __position - begin();
 if (this->_M_impl._M_finish._M_p != this->_M_impl._M_end_addr()
     && __position == end())
   *this->_M_impl._M_finish++ = __x;
 else
   _M_insert_aux(__position._M_const_cast(), __x);
 return begin() + __n;
      }


      template<typename _InputIterator,
        typename = std::_RequireInputIter<_InputIterator>>
 iterator
 insert(const_iterator __position,
        _InputIterator __first, _InputIterator __last)
 {
   difference_type __offset = __position - cbegin();
   _M_insert_dispatch(__position._M_const_cast(),
        __first, __last, __false_type());
   return begin() + __offset;
 }
# 1044 "/usr/include/c++/10.2.0/bits/stl_bvector.h" 3
      iterator
      insert(const_iterator __position, size_type __n, const bool& __x)
      {
 difference_type __offset = __position - cbegin();
 _M_fill_insert(__position._M_const_cast(), __n, __x);
 return begin() + __offset;
      }







      iterator
      insert(const_iterator __p, initializer_list<bool> __l)
      { return this->insert(__p, __l.begin(), __l.end()); }


      void
      pop_back()
      { --this->_M_impl._M_finish; }

      iterator

      erase(const_iterator __position)



      { return _M_erase(__position._M_const_cast()); }

      iterator

      erase(const_iterator __first, const_iterator __last)



      { return _M_erase(__first._M_const_cast(), __last._M_const_cast()); }

      void
      resize(size_type __new_size, bool __x = bool())
      {
 if (__new_size < size())
   _M_erase_at_end(begin() + difference_type(__new_size));
 else
   insert(end(), __new_size - size(), __x);
      }


      void
      shrink_to_fit()
      { _M_shrink_to_fit(); }


      void
      flip() noexcept
      {
 _Bit_type * const __end = this->_M_impl._M_end_addr();
 for (_Bit_type * __p = this->_M_impl._M_start._M_p; __p != __end; ++__p)
   *__p = ~*__p;
      }

      void
      clear() noexcept
      { _M_erase_at_end(begin()); }


      template<typename... _Args>



 void

 emplace_back(_Args&&... __args)
 {
   push_back(bool(__args...));



 }

      template<typename... _Args>
 iterator
 emplace(const_iterator __pos, _Args&&... __args)
 { return insert(__pos, bool(__args...)); }


    protected:

      iterator
      _M_copy_aligned(const_iterator __first, const_iterator __last,
        iterator __result)
      {
 _Bit_type* __q = std::copy(__first._M_p, __last._M_p, __result._M_p);
 return std::copy(const_iterator(__last._M_p, 0), __last,
    iterator(__q, 0));
      }

      void
      _M_initialize(size_type __n)
      {
 if (__n)
   {
     _Bit_pointer __q = this->_M_allocate(__n);
     this->_M_impl._M_end_of_storage = __q + _S_nword(__n);
     this->_M_impl._M_start = iterator(std::__addressof(*__q), 0);
   }
 else
   {
     this->_M_impl._M_end_of_storage = _Bit_pointer();
     this->_M_impl._M_start = iterator(0, 0);
   }
 this->_M_impl._M_finish = this->_M_impl._M_start + difference_type(__n);

      }

      void
      _M_initialize_value(bool __x)
      {
 if (_Bit_type* __p = this->_M_impl._M_start._M_p)
   __builtin_memset(__p, __x ? ~0 : 0,
      (this->_M_impl._M_end_addr() - __p)
      * sizeof(_Bit_type));
      }

      void
      _M_reallocate(size_type __n);


      bool
      _M_shrink_to_fit();






      template<typename _Integer>
 void
 _M_initialize_dispatch(_Integer __n, _Integer __x, __true_type)
 {
   _M_initialize(static_cast<size_type>(__n));
   _M_initialize_value(__x);
 }

      template<typename _InputIterator>
 void
 _M_initialize_dispatch(_InputIterator __first, _InputIterator __last,
          __false_type)
 { _M_initialize_range(__first, __last,
         std::__iterator_category(__first)); }

      template<typename _InputIterator>
 void
 _M_initialize_range(_InputIterator __first, _InputIterator __last,
       std::input_iterator_tag)
 {
   for (; __first != __last; ++__first)
     push_back(*__first);
 }

      template<typename _ForwardIterator>
 void
 _M_initialize_range(_ForwardIterator __first, _ForwardIterator __last,
       std::forward_iterator_tag)
 {
   const size_type __n = std::distance(__first, __last);
   _M_initialize(__n);
   std::copy(__first, __last, this->_M_impl._M_start);
 }
# 1230 "/usr/include/c++/10.2.0/bits/stl_bvector.h" 3
      void
      _M_fill_assign(size_t __n, bool __x)
      {
 if (__n > size())
   {
     _M_initialize_value(__x);
     insert(end(), __n - size(), __x);
   }
 else
   {
     _M_erase_at_end(begin() + __n);
     _M_initialize_value(__x);
   }
      }

      template<typename _InputIterator>
 void
 _M_assign_aux(_InputIterator __first, _InputIterator __last,
        std::input_iterator_tag)
 {
   iterator __cur = begin();
   for (; __first != __last && __cur != end(); ++__cur, (void)++__first)
     *__cur = *__first;
   if (__first == __last)
     _M_erase_at_end(__cur);
   else
     insert(end(), __first, __last);
 }

      template<typename _ForwardIterator>
 void
 _M_assign_aux(_ForwardIterator __first, _ForwardIterator __last,
        std::forward_iterator_tag)
 {
   const size_type __len = std::distance(__first, __last);
   if (__len < size())
     _M_erase_at_end(std::copy(__first, __last, begin()));
   else
     {
       _ForwardIterator __mid = __first;
       std::advance(__mid, size());
       std::copy(__first, __mid, begin());
       insert(end(), __mid, __last);
     }
 }





      template<typename _Integer>
 void
 _M_insert_dispatch(iterator __pos, _Integer __n, _Integer __x,
      __true_type)
 { _M_fill_insert(__pos, __n, __x); }

      template<typename _InputIterator>
 void
 _M_insert_dispatch(iterator __pos,
      _InputIterator __first, _InputIterator __last,
      __false_type)
 { _M_insert_range(__pos, __first, __last,
     std::__iterator_category(__first)); }

      void
      _M_fill_insert(iterator __position, size_type __n, bool __x);

      template<typename _InputIterator>
 void
 _M_insert_range(iterator __pos, _InputIterator __first,
   _InputIterator __last, std::input_iterator_tag)
 {
   for (; __first != __last; ++__first)
     {
       __pos = insert(__pos, *__first);
       ++__pos;
     }
 }

      template<typename _ForwardIterator>
 void
 _M_insert_range(iterator __position, _ForwardIterator __first,
   _ForwardIterator __last, std::forward_iterator_tag);

      void
      _M_insert_aux(iterator __position, bool __x);

      size_type
      _M_check_len(size_type __n, const char* __s) const
      {
 if (max_size() - size() < __n)
   __throw_length_error((__s));

 const size_type __len = size() + std::max(size(), __n);
 return (__len < size() || __len > max_size()) ? max_size() : __len;
      }

      void
      _M_erase_at_end(iterator __pos)
      { this->_M_impl._M_finish = __pos; }

      iterator
      _M_erase(iterator __pos);

      iterator
      _M_erase(iterator __first, iterator __last);
  };



}



namespace std __attribute__ ((__visibility__ ("default")))
{




  template<typename _Alloc>
    struct hash<std::vector<bool, _Alloc>>
    : public __hash_base<size_t, std::vector<bool, _Alloc>>
    {
      size_t
      operator()(const std::vector<bool, _Alloc>&) const noexcept;
    };


}
# 69 "/usr/include/c++/10.2.0/vector" 2 3



# 1 "/usr/include/c++/10.2.0/bits/vector.tcc" 1 3
# 59 "/usr/include/c++/10.2.0/bits/vector.tcc" 3
namespace std __attribute__ ((__visibility__ ("default")))
{



  template<typename _Tp, typename _Alloc>
    void
    vector<_Tp, _Alloc>::
    reserve(size_type __n)
    {
      if (__n > this->max_size())
 __throw_length_error(("vector::reserve"));
      if (this->capacity() < __n)
 {
   const size_type __old_size = size();
   pointer __tmp;

   if (_S_use_relocate())
     {
       __tmp = this->_M_allocate(__n);
       _S_relocate(this->_M_impl._M_start, this->_M_impl._M_finish,
     __tmp, _M_get_Tp_allocator());
     }
   else

     {
       __tmp = _M_allocate_and_copy(__n,
  std::__make_move_if_noexcept_iterator(this->_M_impl._M_start),
  std::__make_move_if_noexcept_iterator(this->_M_impl._M_finish));
       std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
       _M_get_Tp_allocator());
     }
   ;
   _M_deallocate(this->_M_impl._M_start,
   this->_M_impl._M_end_of_storage
   - this->_M_impl._M_start);
   this->_M_impl._M_start = __tmp;
   this->_M_impl._M_finish = __tmp + __old_size;
   this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __n;
 }
    }


  template<typename _Tp, typename _Alloc>
    template<typename... _Args>



      void

      vector<_Tp, _Alloc>::
      emplace_back(_Args&&... __args)
      {
 if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
   {
     ;
     _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,
         std::forward<_Args>(__args)...);
     ++this->_M_impl._M_finish;
     ;
   }
 else
   _M_realloc_insert(end(), std::forward<_Args>(__args)...);



      }


  template<typename _Tp, typename _Alloc>
    typename vector<_Tp, _Alloc>::iterator
    vector<_Tp, _Alloc>::

    insert(const_iterator __position, const value_type& __x)



    {
      const size_type __n = __position - begin();
      if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
 if (__position == end())
   {
     ;
     _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,
         __x);
     ++this->_M_impl._M_finish;
     ;
   }
 else
   {

     const auto __pos = begin() + (__position - cbegin());


     _Temporary_value __x_copy(this, __x);
     _M_insert_aux(__pos, std::move(__x_copy._M_val()));



   }
      else

 _M_realloc_insert(begin() + (__position - cbegin()), __x);




      return iterator(this->_M_impl._M_start + __n);
    }

  template<typename _Tp, typename _Alloc>
    typename vector<_Tp, _Alloc>::iterator
    vector<_Tp, _Alloc>::
    _M_erase(iterator __position)
    {
      if (__position + 1 != end())
 std::move(__position + 1, end(), __position);
      --this->_M_impl._M_finish;
      _Alloc_traits::destroy(this->_M_impl, this->_M_impl._M_finish);
      ;
      return __position;
    }

  template<typename _Tp, typename _Alloc>
    typename vector<_Tp, _Alloc>::iterator
    vector<_Tp, _Alloc>::
    _M_erase(iterator __first, iterator __last)
    {
      if (__first != __last)
 {
   if (__last != end())
     std::move(__last, end(), __first);
   _M_erase_at_end(__first.base() + (end() - __last));
 }
      return __first;
    }

  template<typename _Tp, typename _Alloc>
    vector<_Tp, _Alloc>&
    vector<_Tp, _Alloc>::
    operator=(const vector<_Tp, _Alloc>& __x)
    {
      if (&__x != this)
 {
   ;

   if (_Alloc_traits::_S_propagate_on_copy_assign())
     {
       if (!_Alloc_traits::_S_always_equal()
           && _M_get_Tp_allocator() != __x._M_get_Tp_allocator())
         {

    this->clear();
    _M_deallocate(this->_M_impl._M_start,
    this->_M_impl._M_end_of_storage
    - this->_M_impl._M_start);
    this->_M_impl._M_start = nullptr;
    this->_M_impl._M_finish = nullptr;
    this->_M_impl._M_end_of_storage = nullptr;
  }
       std::__alloc_on_copy(_M_get_Tp_allocator(),
       __x._M_get_Tp_allocator());
     }

   const size_type __xlen = __x.size();
   if (__xlen > capacity())
     {
       pointer __tmp = _M_allocate_and_copy(__xlen, __x.begin(),
         __x.end());
       std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
       _M_get_Tp_allocator());
       _M_deallocate(this->_M_impl._M_start,
       this->_M_impl._M_end_of_storage
       - this->_M_impl._M_start);
       this->_M_impl._M_start = __tmp;
       this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __xlen;
     }
   else if (size() >= __xlen)
     {
       std::_Destroy(std::copy(__x.begin(), __x.end(), begin()),
       end(), _M_get_Tp_allocator());
     }
   else
     {
       std::copy(__x._M_impl._M_start, __x._M_impl._M_start + size(),
   this->_M_impl._M_start);
       std::__uninitialized_copy_a(__x._M_impl._M_start + size(),
       __x._M_impl._M_finish,
       this->_M_impl._M_finish,
       _M_get_Tp_allocator());
     }
   this->_M_impl._M_finish = this->_M_impl._M_start + __xlen;
 }
      return *this;
    }

  template<typename _Tp, typename _Alloc>
    void
    vector<_Tp, _Alloc>::
    _M_fill_assign(size_t __n, const value_type& __val)
    {
      if (__n > capacity())
 {
   vector __tmp(__n, __val, _M_get_Tp_allocator());
   __tmp._M_impl._M_swap_data(this->_M_impl);
 }
      else if (__n > size())
 {
   std::fill(begin(), end(), __val);
   const size_type __add = __n - size();
   ;
   this->_M_impl._M_finish =
     std::__uninitialized_fill_n_a(this->_M_impl._M_finish,
       __add, __val, _M_get_Tp_allocator());
   ;
 }
      else
        _M_erase_at_end(std::fill_n(this->_M_impl._M_start, __n, __val));
    }

  template<typename _Tp, typename _Alloc>
    template<typename _InputIterator>
      void
      vector<_Tp, _Alloc>::
      _M_assign_aux(_InputIterator __first, _InputIterator __last,
      std::input_iterator_tag)
      {
 pointer __cur(this->_M_impl._M_start);
 for (; __first != __last && __cur != this->_M_impl._M_finish;
      ++__cur, (void)++__first)
   *__cur = *__first;
 if (__first == __last)
   _M_erase_at_end(__cur);
 else
   _M_range_insert(end(), __first, __last,
     std::__iterator_category(__first));
      }

  template<typename _Tp, typename _Alloc>
    template<typename _ForwardIterator>
      void
      vector<_Tp, _Alloc>::
      _M_assign_aux(_ForwardIterator __first, _ForwardIterator __last,
      std::forward_iterator_tag)
      {
 const size_type __len = std::distance(__first, __last);

 if (__len > capacity())
   {
     _S_check_init_len(__len, _M_get_Tp_allocator());
     pointer __tmp(_M_allocate_and_copy(__len, __first, __last));
     std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
     _M_get_Tp_allocator());
     ;
     _M_deallocate(this->_M_impl._M_start,
     this->_M_impl._M_end_of_storage
     - this->_M_impl._M_start);
     this->_M_impl._M_start = __tmp;
     this->_M_impl._M_finish = this->_M_impl._M_start + __len;
     this->_M_impl._M_end_of_storage = this->_M_impl._M_finish;
   }
 else if (size() >= __len)
   _M_erase_at_end(std::copy(__first, __last, this->_M_impl._M_start));
 else
   {
     _ForwardIterator __mid = __first;
     std::advance(__mid, size());
     std::copy(__first, __mid, this->_M_impl._M_start);
     const size_type __attribute__((__unused__)) __n = __len - size();
     ;
     this->_M_impl._M_finish =
       std::__uninitialized_copy_a(__mid, __last,
       this->_M_impl._M_finish,
       _M_get_Tp_allocator());
     ;
   }
      }


  template<typename _Tp, typename _Alloc>
    auto
    vector<_Tp, _Alloc>::
    _M_insert_rval(const_iterator __position, value_type&& __v) -> iterator
    {
      const auto __n = __position - cbegin();
      if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
 if (__position == cend())
   {
     ;
     _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,
         std::move(__v));
     ++this->_M_impl._M_finish;
     ;
   }
 else
   _M_insert_aux(begin() + __n, std::move(__v));
      else
 _M_realloc_insert(begin() + __n, std::move(__v));

      return iterator(this->_M_impl._M_start + __n);
    }

  template<typename _Tp, typename _Alloc>
    template<typename... _Args>
      auto
      vector<_Tp, _Alloc>::
      _M_emplace_aux(const_iterator __position, _Args&&... __args)
      -> iterator
      {
 const auto __n = __position - cbegin();
 if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
   if (__position == cend())
     {
       ;
       _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,
           std::forward<_Args>(__args)...);
       ++this->_M_impl._M_finish;
       ;
     }
   else
     {



       _Temporary_value __tmp(this, std::forward<_Args>(__args)...);
       _M_insert_aux(begin() + __n, std::move(__tmp._M_val()));
     }
 else
   _M_realloc_insert(begin() + __n, std::forward<_Args>(__args)...);

 return iterator(this->_M_impl._M_start + __n);
      }

  template<typename _Tp, typename _Alloc>
    template<typename _Arg>
      void
      vector<_Tp, _Alloc>::
      _M_insert_aux(iterator __position, _Arg&& __arg)






    {
      ;
      _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,
          std::move(*(this->_M_impl._M_finish - 1)));
      ++this->_M_impl._M_finish;
      ;



      std::move_backward(__position.base(), this->_M_impl._M_finish - 2, this->_M_impl._M_finish - 1)

                                     ;



      *__position = std::forward<_Arg>(__arg);

    }


  template<typename _Tp, typename _Alloc>
    template<typename... _Args>
      void
      vector<_Tp, _Alloc>::
      _M_realloc_insert(iterator __position, _Args&&... __args)






    {
      const size_type __len =
 _M_check_len(size_type(1), "vector::_M_realloc_insert");
      pointer __old_start = this->_M_impl._M_start;
      pointer __old_finish = this->_M_impl._M_finish;
      const size_type __elems_before = __position - begin();
      pointer __new_start(this->_M_allocate(__len));
      pointer __new_finish(__new_start);
      try
 {





   _Alloc_traits::construct(this->_M_impl,
       __new_start + __elems_before,

       std::forward<_Args>(__args)...);



   __new_finish = pointer();


   if (_S_use_relocate())
     {
       __new_finish = _S_relocate(__old_start, __position.base(),
      __new_start, _M_get_Tp_allocator());

       ++__new_finish;

       __new_finish = _S_relocate(__position.base(), __old_finish,
      __new_finish, _M_get_Tp_allocator());
     }
   else

     {
       __new_finish
  = std::__uninitialized_move_if_noexcept_a
  (__old_start, __position.base(),
   __new_start, _M_get_Tp_allocator());

       ++__new_finish;

       __new_finish
  = std::__uninitialized_move_if_noexcept_a
  (__position.base(), __old_finish,
   __new_finish, _M_get_Tp_allocator());
     }
 }
      catch(...)
 {
   if (!__new_finish)
     _Alloc_traits::destroy(this->_M_impl,
       __new_start + __elems_before);
   else
     std::_Destroy(__new_start, __new_finish, _M_get_Tp_allocator());
   _M_deallocate(__new_start, __len);
   throw;
 }

      if (!_S_use_relocate())

 std::_Destroy(__old_start, __old_finish, _M_get_Tp_allocator());
      ;
      _M_deallocate(__old_start,
      this->_M_impl._M_end_of_storage - __old_start);
      this->_M_impl._M_start = __new_start;
      this->_M_impl._M_finish = __new_finish;
      this->_M_impl._M_end_of_storage = __new_start + __len;
    }

  template<typename _Tp, typename _Alloc>
    void
    vector<_Tp, _Alloc>::
    _M_fill_insert(iterator __position, size_type __n, const value_type& __x)
    {
      if (__n != 0)
 {
   if (size_type(this->_M_impl._M_end_of_storage
   - this->_M_impl._M_finish) >= __n)
     {



       _Temporary_value __tmp(this, __x);
       value_type& __x_copy = __tmp._M_val();

       const size_type __elems_after = end() - __position;
       pointer __old_finish(this->_M_impl._M_finish);
       if (__elems_after > __n)
  {
    ;
    std::__uninitialized_move_a(this->_M_impl._M_finish - __n,
           this->_M_impl._M_finish,
           this->_M_impl._M_finish,
           _M_get_Tp_allocator());
    this->_M_impl._M_finish += __n;
    ;
    std::move_backward(__position.base(), __old_finish - __n, __old_finish)
                                        ;
    std::fill(__position.base(), __position.base() + __n,
       __x_copy);
  }
       else
  {
    ;
    this->_M_impl._M_finish =
      std::__uninitialized_fill_n_a(this->_M_impl._M_finish,
        __n - __elems_after,
        __x_copy,
        _M_get_Tp_allocator());
    ;
    std::__uninitialized_move_a(__position.base(), __old_finish,
           this->_M_impl._M_finish,
           _M_get_Tp_allocator());
    this->_M_impl._M_finish += __elems_after;
    ;
    std::fill(__position.base(), __old_finish, __x_copy);
  }
     }
   else
     {
       const size_type __len =
  _M_check_len(__n, "vector::_M_fill_insert");
       const size_type __elems_before = __position - begin();
       pointer __new_start(this->_M_allocate(__len));
       pointer __new_finish(__new_start);
       try
  {

    std::__uninitialized_fill_n_a(__new_start + __elems_before,
      __n, __x,
      _M_get_Tp_allocator());
    __new_finish = pointer();

    __new_finish
      = std::__uninitialized_move_if_noexcept_a
      (this->_M_impl._M_start, __position.base(),
       __new_start, _M_get_Tp_allocator());

    __new_finish += __n;

    __new_finish
      = std::__uninitialized_move_if_noexcept_a
      (__position.base(), this->_M_impl._M_finish,
       __new_finish, _M_get_Tp_allocator());
  }
       catch(...)
  {
    if (!__new_finish)
      std::_Destroy(__new_start + __elems_before,
      __new_start + __elems_before + __n,
      _M_get_Tp_allocator());
    else
      std::_Destroy(__new_start, __new_finish,
      _M_get_Tp_allocator());
    _M_deallocate(__new_start, __len);
    throw;
  }
       std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
       _M_get_Tp_allocator());
       ;
       _M_deallocate(this->_M_impl._M_start,
       this->_M_impl._M_end_of_storage
       - this->_M_impl._M_start);
       this->_M_impl._M_start = __new_start;
       this->_M_impl._M_finish = __new_finish;
       this->_M_impl._M_end_of_storage = __new_start + __len;
     }
 }
    }


  template<typename _Tp, typename _Alloc>
    void
    vector<_Tp, _Alloc>::
    _M_default_append(size_type __n)
    {
      if (__n != 0)
 {
   const size_type __size = size();
   size_type __navail = size_type(this->_M_impl._M_end_of_storage
      - this->_M_impl._M_finish);

   if (__size > max_size() || __navail > max_size() - __size)
     __builtin_unreachable();

   if (__navail >= __n)
     {
       ;
       this->_M_impl._M_finish =
  std::__uninitialized_default_n_a(this->_M_impl._M_finish,
       __n, _M_get_Tp_allocator());
       ;
     }
   else
     {
       const size_type __len =
  _M_check_len(__n, "vector::_M_default_append");
       pointer __new_start(this->_M_allocate(__len));
       if (_S_use_relocate())
  {
    try
      {
        std::__uninitialized_default_n_a(__new_start + __size,
         __n, _M_get_Tp_allocator());
      }
    catch(...)
      {
        _M_deallocate(__new_start, __len);
        throw;
      }
    _S_relocate(this->_M_impl._M_start, this->_M_impl._M_finish,
         __new_start, _M_get_Tp_allocator());
  }
       else
  {
    pointer __destroy_from = pointer();
    try
      {
        std::__uninitialized_default_n_a(__new_start + __size,
         __n, _M_get_Tp_allocator());
        __destroy_from = __new_start + __size;
        std::__uninitialized_move_if_noexcept_a(
         this->_M_impl._M_start, this->_M_impl._M_finish,
         __new_start, _M_get_Tp_allocator());
      }
    catch(...)
      {
        if (__destroy_from)
   std::_Destroy(__destroy_from, __destroy_from + __n,
          _M_get_Tp_allocator());
        _M_deallocate(__new_start, __len);
        throw;
      }
    std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
    _M_get_Tp_allocator());
  }
       ;
       _M_deallocate(this->_M_impl._M_start,
       this->_M_impl._M_end_of_storage
       - this->_M_impl._M_start);
       this->_M_impl._M_start = __new_start;
       this->_M_impl._M_finish = __new_start + __size + __n;
       this->_M_impl._M_end_of_storage = __new_start + __len;
     }
 }
    }

  template<typename _Tp, typename _Alloc>
    bool
    vector<_Tp, _Alloc>::
    _M_shrink_to_fit()
    {
      if (capacity() == size())
 return false;
      ;
      return std::__shrink_to_fit_aux<vector>::_S_do_it(*this);
    }


  template<typename _Tp, typename _Alloc>
    template<typename _InputIterator>
      void
      vector<_Tp, _Alloc>::
      _M_range_insert(iterator __pos, _InputIterator __first,
        _InputIterator __last, std::input_iterator_tag)
      {
 if (__pos == end())
   {
     for (; __first != __last; ++__first)
       insert(end(), *__first);
   }
 else if (__first != __last)
   {
     vector __tmp(__first, __last, _M_get_Tp_allocator());
     insert(__pos,
     std::make_move_iterator(__tmp.begin()),
     std::make_move_iterator(__tmp.end()));
   }
      }

  template<typename _Tp, typename _Alloc>
    template<typename _ForwardIterator>
      void
      vector<_Tp, _Alloc>::
      _M_range_insert(iterator __position, _ForwardIterator __first,
        _ForwardIterator __last, std::forward_iterator_tag)
      {
 if (__first != __last)
   {
     const size_type __n = std::distance(__first, __last);
     if (size_type(this->_M_impl._M_end_of_storage
     - this->_M_impl._M_finish) >= __n)
       {
  const size_type __elems_after = end() - __position;
  pointer __old_finish(this->_M_impl._M_finish);
  if (__elems_after > __n)
    {
      ;
      std::__uninitialized_move_a(this->_M_impl._M_finish - __n,
      this->_M_impl._M_finish,
      this->_M_impl._M_finish,
      _M_get_Tp_allocator());
      this->_M_impl._M_finish += __n;
      ;
      std::move_backward(__position.base(), __old_finish - __n, __old_finish)
                                          ;
      std::copy(__first, __last, __position);
    }
  else
    {
      _ForwardIterator __mid = __first;
      std::advance(__mid, __elems_after);
      ;
      std::__uninitialized_copy_a(__mid, __last,
      this->_M_impl._M_finish,
      _M_get_Tp_allocator());
      this->_M_impl._M_finish += __n - __elems_after;
      ;
      std::__uninitialized_move_a(__position.base(),
      __old_finish,
      this->_M_impl._M_finish,
      _M_get_Tp_allocator());
      this->_M_impl._M_finish += __elems_after;
      ;
      std::copy(__first, __mid, __position);
    }
       }
     else
       {
  const size_type __len =
    _M_check_len(__n, "vector::_M_range_insert");
  pointer __new_start(this->_M_allocate(__len));
  pointer __new_finish(__new_start);
  try
    {
      __new_finish
        = std::__uninitialized_move_if_noexcept_a
        (this->_M_impl._M_start, __position.base(),
         __new_start, _M_get_Tp_allocator());
      __new_finish
        = std::__uninitialized_copy_a(__first, __last,
          __new_finish,
          _M_get_Tp_allocator());
      __new_finish
        = std::__uninitialized_move_if_noexcept_a
        (__position.base(), this->_M_impl._M_finish,
         __new_finish, _M_get_Tp_allocator());
    }
  catch(...)
    {
      std::_Destroy(__new_start, __new_finish,
      _M_get_Tp_allocator());
      _M_deallocate(__new_start, __len);
      throw;
    }
  std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
         _M_get_Tp_allocator());
  ;
  _M_deallocate(this->_M_impl._M_start,
         this->_M_impl._M_end_of_storage
         - this->_M_impl._M_start);
  this->_M_impl._M_start = __new_start;
  this->_M_impl._M_finish = __new_finish;
  this->_M_impl._M_end_of_storage = __new_start + __len;
       }
   }
      }



  template<typename _Alloc>
    void
    vector<bool, _Alloc>::
    _M_reallocate(size_type __n)
    {
      _Bit_pointer __q = this->_M_allocate(__n);
      iterator __start(std::__addressof(*__q), 0);
      iterator __finish(_M_copy_aligned(begin(), end(), __start));
      this->_M_deallocate();
      this->_M_impl._M_start = __start;
      this->_M_impl._M_finish = __finish;
      this->_M_impl._M_end_of_storage = __q + _S_nword(__n);
    }

  template<typename _Alloc>
    void
    vector<bool, _Alloc>::
    _M_fill_insert(iterator __position, size_type __n, bool __x)
    {
      if (__n == 0)
 return;
      if (capacity() - size() >= __n)
 {
   std::copy_backward(__position, end(),
        this->_M_impl._M_finish + difference_type(__n));
   std::fill(__position, __position + difference_type(__n), __x);
   this->_M_impl._M_finish += difference_type(__n);
 }
      else
 {
   const size_type __len =
     _M_check_len(__n, "vector<bool>::_M_fill_insert");
   _Bit_pointer __q = this->_M_allocate(__len);
   iterator __start(std::__addressof(*__q), 0);
   iterator __i = _M_copy_aligned(begin(), __position, __start);
   std::fill(__i, __i + difference_type(__n), __x);
   iterator __finish = std::copy(__position, end(),
     __i + difference_type(__n));
   this->_M_deallocate();
   this->_M_impl._M_end_of_storage = __q + _S_nword(__len);
   this->_M_impl._M_start = __start;
   this->_M_impl._M_finish = __finish;
 }
    }

  template<typename _Alloc>
    template<typename _ForwardIterator>
      void
      vector<bool, _Alloc>::
      _M_insert_range(iterator __position, _ForwardIterator __first,
        _ForwardIterator __last, std::forward_iterator_tag)
      {
 if (__first != __last)
   {
     size_type __n = std::distance(__first, __last);
     if (capacity() - size() >= __n)
       {
  std::copy_backward(__position, end(),
       this->_M_impl._M_finish
       + difference_type(__n));
  std::copy(__first, __last, __position);
  this->_M_impl._M_finish += difference_type(__n);
       }
     else
       {
  const size_type __len =
    _M_check_len(__n, "vector<bool>::_M_insert_range");
  _Bit_pointer __q = this->_M_allocate(__len);
  iterator __start(std::__addressof(*__q), 0);
  iterator __i = _M_copy_aligned(begin(), __position, __start);
  __i = std::copy(__first, __last, __i);
  iterator __finish = std::copy(__position, end(), __i);
  this->_M_deallocate();
  this->_M_impl._M_end_of_storage = __q + _S_nword(__len);
  this->_M_impl._M_start = __start;
  this->_M_impl._M_finish = __finish;
       }
   }
      }

  template<typename _Alloc>
    void
    vector<bool, _Alloc>::
    _M_insert_aux(iterator __position, bool __x)
    {
      if (this->_M_impl._M_finish._M_p != this->_M_impl._M_end_addr())
 {
   std::copy_backward(__position, this->_M_impl._M_finish,
        this->_M_impl._M_finish + 1);
   *__position = __x;
   ++this->_M_impl._M_finish;
 }
      else
 {
   const size_type __len =
     _M_check_len(size_type(1), "vector<bool>::_M_insert_aux");
   _Bit_pointer __q = this->_M_allocate(__len);
   iterator __start(std::__addressof(*__q), 0);
   iterator __i = _M_copy_aligned(begin(), __position, __start);
   *__i++ = __x;
   iterator __finish = std::copy(__position, end(), __i);
   this->_M_deallocate();
   this->_M_impl._M_end_of_storage = __q + _S_nword(__len);
   this->_M_impl._M_start = __start;
   this->_M_impl._M_finish = __finish;
 }
    }

  template<typename _Alloc>
    typename vector<bool, _Alloc>::iterator
    vector<bool, _Alloc>::
    _M_erase(iterator __position)
    {
      if (__position + 1 != end())
        std::copy(__position + 1, end(), __position);
      --this->_M_impl._M_finish;
      return __position;
    }

  template<typename _Alloc>
    typename vector<bool, _Alloc>::iterator
    vector<bool, _Alloc>::
    _M_erase(iterator __first, iterator __last)
    {
      if (__first != __last)
 _M_erase_at_end(std::copy(__last, end(), __first));
      return __first;
    }


  template<typename _Alloc>
    bool
    vector<bool, _Alloc>::
    _M_shrink_to_fit()
    {
      if (capacity() - size() < int(_S_word_bit))
 return false;
      try
 {
   _M_reallocate(size());
   return true;
 }
      catch(...)
 { return false; }
    }




}



namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _Alloc>
    size_t
    hash<std::vector<bool, _Alloc>>::
    operator()(const std::vector<bool, _Alloc>& __b) const noexcept
    {
      size_t __hash = 0;
      using std::_S_word_bit;
      using std::_Bit_type;

      const size_t __words = __b.size() / _S_word_bit;
      if (__words)
 {
   const size_t __clength = __words * sizeof(_Bit_type);
   __hash = std::_Hash_impl::hash(__b._M_impl._M_start._M_p, __clength);
 }

      const size_t __extrabits = __b.size() % _S_word_bit;
      if (__extrabits)
 {
   _Bit_type __hiword = *__b._M_impl._M_finish._M_p;
   __hiword &= ~((~static_cast<_Bit_type>(0)) << __extrabits);

   const size_t __clength
     = (__extrabits + 8 - 1) / 8;
   if (__words)
     __hash = std::_Hash_impl::hash(&__hiword, __clength, __hash);
   else
     __hash = std::_Hash_impl::hash(&__hiword, __clength);
 }

      return __hash;
    }


}
# 73 "/usr/include/c++/10.2.0/vector" 2 3
# 48 "/usr/include/json/value.h" 2 3 4
# 56 "/usr/include/json/value.h" 3 4
#pragma pack(push, 8)



namespace Json {






class Exception : public std::exception {
public:
  Exception(String msg);
  ~Exception() noexcept override;
  char const* what() const noexcept override;

protected:
  String msg_;
};







class RuntimeError : public Exception {
public:
  RuntimeError(String const& msg);
};







class LogicError : public Exception {
public:
  LogicError(String const& msg);
};



[[noreturn]] void throwRuntimeError(String const& msg);

[[noreturn]] void throwLogicError(String const& msg);



enum ValueType {
  nullValue = 0,
  intValue,
  uintValue,
  realValue,
  stringValue,
  booleanValue,
  arrayValue,
  objectValue
};

enum CommentPlacement {
  commentBefore = 0,
  commentAfterOnSameLine,
  commentAfter,

  numberOfCommentPlacement
};



enum PrecisionType {
  significantDigits = 0,
  decimalPlaces
};
# 147 "/usr/include/json/value.h" 3 4
class StaticString {
public:
  explicit StaticString(const char* czstring) : c_str_(czstring) {}

  operator const char*() const { return c_str_; }

  const char* c_str() const { return c_str_; }

private:
  const char* c_str_;
};
# 193 "/usr/include/json/value.h" 3 4
class Value {
  friend class ValueIteratorBase;

public:
  using Members = std::vector<String>;
  using iterator = ValueIterator;
  using const_iterator = ValueConstIterator;
  using UInt = Json::UInt;
  using Int = Json::Int;

  using UInt64 = Json::UInt64;
  using Int64 = Json::Int64;

  using LargestInt = Json::LargestInt;
  using LargestUInt = Json::LargestUInt;
  using ArrayIndex = Json::ArrayIndex;


  using value_type = std::string;



  static const Value& null;
  static const Value& nullRef;



  static Value const& nullSingleton();


  static constexpr LargestInt minLargestInt =
      LargestInt(~(LargestUInt(-1) / 2));

  static constexpr LargestInt maxLargestInt = LargestInt(LargestUInt(-1) / 2);

  static constexpr LargestUInt maxLargestUInt = LargestUInt(-1);


  static constexpr Int minInt = Int(~(UInt(-1) / 2));

  static constexpr Int maxInt = Int(UInt(-1) / 2);

  static constexpr UInt maxUInt = UInt(-1);



  static constexpr Int64 minInt64 = Int64(~(UInt64(-1) / 2));

  static constexpr Int64 maxInt64 = Int64(UInt64(-1) / 2);

  static constexpr UInt64 maxUInt64 = UInt64(-1);


  static constexpr UInt defaultRealPrecision = 17;



  static constexpr double maxUInt64AsDouble = 18446744073709551615.0;






private:


  class CZString {
  public:
    enum DuplicationPolicy { noDuplication = 0, duplicate, duplicateOnCopy };
    CZString(ArrayIndex index);
    CZString(char const* str, unsigned length, DuplicationPolicy allocate);
    CZString(CZString const& other);
    CZString(CZString&& other);
    ~CZString();
    CZString& operator=(const CZString& other);
    CZString& operator=(CZString&& other);

    bool operator<(CZString const& other) const;
    bool operator==(CZString const& other) const;
    ArrayIndex index() const;

    char const* data() const;
    unsigned length() const;
    bool isStaticString() const;

  private:
    void swap(CZString& other);

    struct StringStorage {
      unsigned policy_ : 2;
      unsigned length_ : 30;
    };

    char const* cstr_;
    union {
      ArrayIndex index_;
      StringStorage storage_;
    };
  };

public:
  typedef std::map<CZString, Value> ObjectValues;


public:
# 315 "/usr/include/json/value.h" 3 4
  Value(ValueType type = nullValue);
  Value(Int value);
  Value(UInt value);

  Value(Int64 value);
  Value(UInt64 value);

  Value(double value);
  Value(const char* value);
  Value(const char* begin, const char* end);
# 342 "/usr/include/json/value.h" 3 4
  Value(const StaticString& value);
  Value(const String& value);
  Value(bool value);
  Value(std::nullptr_t ptr) = delete;
  Value(const Value& other);
  Value(Value&& other);
  ~Value();



  Value& operator=(const Value& other);
  Value& operator=(Value&& other);


  void swap(Value& other);

  void swapPayload(Value& other);


  void copy(const Value& other);

  void copyPayload(const Value& other);

  ValueType type() const;


  bool operator<(const Value& other) const;
  bool operator<=(const Value& other) const;
  bool operator>=(const Value& other) const;
  bool operator>(const Value& other) const;
  bool operator==(const Value& other) const;
  bool operator!=(const Value& other) const;
  int compare(const Value& other) const;

  const char* asCString() const;




  String asString() const;



  bool getString(char const** begin, char const** end) const;
  Int asInt() const;
  UInt asUInt() const;

  Int64 asInt64() const;
  UInt64 asUInt64() const;

  LargestInt asLargestInt() const;
  LargestUInt asLargestUInt() const;
  float asFloat() const;
  double asDouble() const;
  bool asBool() const;

  bool isNull() const;
  bool isBool() const;
  bool isInt() const;
  bool isInt64() const;
  bool isUInt() const;
  bool isUInt64() const;
  bool isIntegral() const;
  bool isDouble() const;
  bool isNumeric() const;
  bool isString() const;
  bool isArray() const;
  bool isObject() const;


  template <typename T> T as() const = delete;
  template <typename T> bool is() const = delete;

  bool isConvertibleTo(ValueType other) const;


  ArrayIndex size() const;



  bool empty() const;


  explicit operator bool() const;




  void clear();






  void resize(ArrayIndex newSize);







  Value& operator[](ArrayIndex index);
  Value& operator[](int index);






  const Value& operator[](ArrayIndex index) const;
  const Value& operator[](int index) const;




  Value get(ArrayIndex index, const Value& defaultValue) const;

  bool isValidIndex(ArrayIndex index) const;



  Value& append(const Value& value);
  Value& append(Value&& value);


  bool insert(ArrayIndex index, const Value& newValue);
  bool insert(ArrayIndex index, Value&& newValue);




  Value& operator[](const char* key);


  const Value& operator[](const char* key) const;


  Value& operator[](const String& key);



  const Value& operator[](const String& key) const;
# 498 "/usr/include/json/value.h" 3 4
  Value& operator[](const StaticString& key);


  Value get(const char* key, const Value& defaultValue) const;



  Value get(const char* begin, const char* end,
            const Value& defaultValue) const;



  Value get(const String& key, const Value& defaultValue) const;



  Value const* find(char const* begin, char const* end) const;



  Value* demand(char const* begin, char const* end);





  void removeMember(const char* key);


  void removeMember(const String& key);


  bool removeMember(const char* key, Value* removed);






  bool removeMember(String const& key, Value* removed);

  bool removeMember(const char* begin, const char* end, Value* removed);






  bool removeIndex(ArrayIndex index, Value* removed);



  bool isMember(const char* key) const;


  bool isMember(const String& key) const;

  bool isMember(const char* begin, const char* end) const;






  Members getMemberNames() const;


  __attribute__((deprecated("Use setComment(String const&) instead.")))
  void setComment(const char* comment, CommentPlacement placement) {
    setComment(String(comment, strlen(comment)), placement);
  }

  void setComment(const char* comment, size_t len, CommentPlacement placement) {
    setComment(String(comment, len), placement);
  }

  void setComment(String comment, CommentPlacement placement);
  bool hasComment(CommentPlacement placement) const;

  String getComment(CommentPlacement placement) const;

  String toStyledString() const;

  const_iterator begin() const;
  const_iterator end() const;

  iterator begin();
  iterator end();



  void setOffsetStart(ptrdiff_t start);
  void setOffsetLimit(ptrdiff_t limit);
  ptrdiff_t getOffsetStart() const;
  ptrdiff_t getOffsetLimit() const;

private:
  void setType(ValueType v) {
    bits_.value_type_ = static_cast<unsigned char>(v);
  }
  bool isAllocated() const { return bits_.allocated_; }
  void setIsAllocated(bool v) { bits_.allocated_ = v; }

  void initBasic(ValueType type, bool allocated = false);
  void dupPayload(const Value& other);
  void releasePayload();
  void dupMeta(const Value& other);

  Value& resolveReference(const char* key);
  Value& resolveReference(const char* key, const char* end);
# 618 "/usr/include/json/value.h" 3 4
  union ValueHolder {
    LargestInt int_;
    LargestUInt uint_;
    double real_;
    bool bool_;
    char* string_;
    ObjectValues* map_;
  } value_;

  struct {

    unsigned int value_type_ : 8;

    unsigned int allocated_ : 1;
  } bits_;

  class Comments {
  public:
    Comments() = default;
    Comments(const Comments& that);
    Comments(Comments&& that);
    Comments& operator=(const Comments& that);
    Comments& operator=(Comments&& that);
    bool has(CommentPlacement slot) const;
    String get(CommentPlacement slot) const;
    void set(CommentPlacement slot, String comment);

  private:
    using Array = std::array<String, numberOfCommentPlacement>;
    std::unique_ptr<Array> ptr_;
  };
  Comments comments_;



  ptrdiff_t start_;
  ptrdiff_t limit_;
};

template <> inline bool Value::as<bool>() const { return asBool(); }
template <> inline bool Value::is<bool>() const { return isBool(); }

template <> inline Int Value::as<Int>() const { return asInt(); }
template <> inline bool Value::is<Int>() const { return isInt(); }

template <> inline UInt Value::as<UInt>() const { return asUInt(); }
template <> inline bool Value::is<UInt>() const { return isUInt(); }


template <> inline Int64 Value::as<Int64>() const { return asInt64(); }
template <> inline bool Value::is<Int64>() const { return isInt64(); }

template <> inline UInt64 Value::as<UInt64>() const { return asUInt64(); }
template <> inline bool Value::is<UInt64>() const { return isUInt64(); }


template <> inline double Value::as<double>() const { return asDouble(); }
template <> inline bool Value::is<double>() const { return isDouble(); }

template <> inline String Value::as<String>() const { return asString(); }
template <> inline bool Value::is<String>() const { return isString(); }



template <> inline float Value::as<float>() const { return asFloat(); }
template <> inline const char* Value::as<const char*>() const {
  return asCString();
}




class PathArgument {
public:
  friend class Path;

  PathArgument();
  PathArgument(ArrayIndex index);
  PathArgument(const char* key);
  PathArgument(String key);

private:
  enum Kind { kindNone = 0, kindIndex, kindKey };
  String key_;
  ArrayIndex index_{};
  Kind kind_{kindNone};
};
# 717 "/usr/include/json/value.h" 3 4
class Path {
public:
  Path(const String& path, const PathArgument& a1 = PathArgument(),
       const PathArgument& a2 = PathArgument(),
       const PathArgument& a3 = PathArgument(),
       const PathArgument& a4 = PathArgument(),
       const PathArgument& a5 = PathArgument());

  const Value& resolve(const Value& root) const;
  Value resolve(const Value& root, const Value& defaultValue) const;


  Value& make(Value& root) const;

private:
  using InArgs = std::vector<const PathArgument*>;
  using Args = std::vector<PathArgument>;

  void makePath(const String& path, const InArgs& in);
  void addPathInArg(const String& path, const InArgs& in,
                    InArgs::const_iterator& itInArg, PathArgument::Kind kind);
  static void invalidPath(const String& path, int location);

  Args args_;
};




class ValueIteratorBase {
public:
  using iterator_category = std::bidirectional_iterator_tag;
  using size_t = unsigned int;
  using difference_type = int;
  using SelfType = ValueIteratorBase;

  bool operator==(const SelfType& other) const { return isEqual(other); }

  bool operator!=(const SelfType& other) const { return !isEqual(other); }

  difference_type operator-(const SelfType& other) const {
    return other.computeDistance(*this);
  }



  Value key() const;



  UInt index() const;




  String name() const;





  __attribute__((deprecated("Use `key = name();` instead.")))
  char const* memberName() const;



  char const* memberName(char const** end) const;

protected:






  const Value& deref() const;
  Value& deref();

  void increment();

  void decrement();

  difference_type computeDistance(const SelfType& other) const;

  bool isEqual(const SelfType& other) const;

  void copy(const SelfType& other);

private:
  Value::ObjectValues::iterator current_;

  bool isNull_{true};

public:


  ValueIteratorBase();
  explicit ValueIteratorBase(const Value::ObjectValues::iterator& current);
};




class ValueConstIterator : public ValueIteratorBase {
  friend class Value;

public:
  using value_type = const Value;


  using reference = const Value&;
  using pointer = const Value*;
  using SelfType = ValueConstIterator;

  ValueConstIterator();
  ValueConstIterator(ValueIterator const& other);

private:


  explicit ValueConstIterator(const Value::ObjectValues::iterator& current);

public:
  SelfType& operator=(const ValueIteratorBase& other);

  SelfType operator++(int) {
    SelfType temp(*this);
    ++*this;
    return temp;
  }

  SelfType operator--(int) {
    SelfType temp(*this);
    --*this;
    return temp;
  }

  SelfType& operator--() {
    decrement();
    return *this;
  }

  SelfType& operator++() {
    increment();
    return *this;
  }

  reference operator*() const { return deref(); }

  pointer operator->() const { return &deref(); }
};



class ValueIterator : public ValueIteratorBase {
  friend class Value;

public:
  using value_type = Value;
  using size_t = unsigned int;
  using difference_type = int;
  using reference = Value&;
  using pointer = Value*;
  using SelfType = ValueIterator;

  ValueIterator();
  explicit ValueIterator(const ValueConstIterator& other);
  ValueIterator(const ValueIterator& other);

private:


  explicit ValueIterator(const Value::ObjectValues::iterator& current);

public:
  SelfType& operator=(const SelfType& other);

  SelfType operator++(int) {
    SelfType temp(*this);
    ++*this;
    return temp;
  }

  SelfType operator--(int) {
    SelfType temp(*this);
    --*this;
    return temp;
  }

  SelfType& operator--() {
    decrement();
    return *this;
  }

  SelfType& operator++() {
    increment();
    return *this;
  }






  reference operator*() { return deref(); }
  pointer operator->() { return &deref(); }
};

inline void swap(Value& a, Value& b) { a.swap(b); }

}

#pragma pack(pop)
# 12 "/usr/include/json/reader.h" 2 3 4

# 1 "/usr/include/c++/10.2.0/deque" 1 3 4
# 58 "/usr/include/c++/10.2.0/deque" 3 4
       
# 59 "/usr/include/c++/10.2.0/deque" 3
# 67 "/usr/include/c++/10.2.0/deque" 3
# 1 "/usr/include/c++/10.2.0/bits/stl_deque.h" 1 3
# 72 "/usr/include/c++/10.2.0/bits/stl_deque.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{


# 95 "/usr/include/c++/10.2.0/bits/stl_deque.h" 3
  constexpr inline size_t
  __deque_buf_size(size_t __size)
  { return (__size < 512
     ? size_t(512 / __size) : size_t(1)); }
# 112 "/usr/include/c++/10.2.0/bits/stl_deque.h" 3
  template<typename _Tp, typename _Ref, typename _Ptr>
    struct _Deque_iterator
    {






    private:
      template<typename _CvTp>
 using __iter = _Deque_iterator<_Tp, _CvTp&, __ptr_rebind<_Ptr, _CvTp>>;
    public:
      typedef __iter<_Tp> iterator;
      typedef __iter<const _Tp> const_iterator;
      typedef __ptr_rebind<_Ptr, _Tp> _Elt_pointer;
      typedef __ptr_rebind<_Ptr, _Elt_pointer> _Map_pointer;


      static size_t _S_buffer_size() noexcept
      { return __deque_buf_size(sizeof(_Tp)); }

      typedef std::random_access_iterator_tag iterator_category;
      typedef _Tp value_type;
      typedef _Ptr pointer;
      typedef _Ref reference;
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef _Deque_iterator _Self;

      _Elt_pointer _M_cur;
      _Elt_pointer _M_first;
      _Elt_pointer _M_last;
      _Map_pointer _M_node;

      _Deque_iterator(_Elt_pointer __x, _Map_pointer __y) noexcept
      : _M_cur(__x), _M_first(*__y),
 _M_last(*__y + _S_buffer_size()), _M_node(__y) { }

      _Deque_iterator() noexcept
      : _M_cur(), _M_first(), _M_last(), _M_node() { }
# 161 "/usr/include/c++/10.2.0/bits/stl_deque.h" 3
      template<typename _Iter,
        typename = _Require<is_same<_Self, const_iterator>,
       is_same<_Iter, iterator>>>
       _Deque_iterator(const _Iter& __x) noexcept
       : _M_cur(__x._M_cur), _M_first(__x._M_first),
  _M_last(__x._M_last), _M_node(__x._M_node) { }

      _Deque_iterator(const _Deque_iterator& __x) noexcept
       : _M_cur(__x._M_cur), _M_first(__x._M_first),
  _M_last(__x._M_last), _M_node(__x._M_node) { }

      _Deque_iterator& operator=(const _Deque_iterator&) = default;


      iterator
      _M_const_cast() const noexcept
      { return iterator(_M_cur, _M_node); }

      reference
      operator*() const noexcept
      { return *_M_cur; }

      pointer
      operator->() const noexcept
      { return _M_cur; }

      _Self&
      operator++() noexcept
      {
 ++_M_cur;
 if (_M_cur == _M_last)
   {
     _M_set_node(_M_node + 1);
     _M_cur = _M_first;
   }
 return *this;
      }

      _Self
      operator++(int) noexcept
      {
 _Self __tmp = *this;
 ++*this;
 return __tmp;
      }

      _Self&
      operator--() noexcept
      {
 if (_M_cur == _M_first)
   {
     _M_set_node(_M_node - 1);
     _M_cur = _M_last;
   }
 --_M_cur;
 return *this;
      }

      _Self
      operator--(int) noexcept
      {
 _Self __tmp = *this;
 --*this;
 return __tmp;
      }

      _Self&
      operator+=(difference_type __n) noexcept
      {
 const difference_type __offset = __n + (_M_cur - _M_first);
 if (__offset >= 0 && __offset < difference_type(_S_buffer_size()))
   _M_cur += __n;
 else
   {
     const difference_type __node_offset =
       __offset > 0 ? __offset / difference_type(_S_buffer_size())
      : -difference_type((-__offset - 1)
           / _S_buffer_size()) - 1;
     _M_set_node(_M_node + __node_offset);
     _M_cur = _M_first + (__offset - __node_offset
     * difference_type(_S_buffer_size()));
   }
 return *this;
      }

      _Self&
      operator-=(difference_type __n) noexcept
      { return *this += -__n; }

      reference
      operator[](difference_type __n) const noexcept
      { return *(*this + __n); }






      void
      _M_set_node(_Map_pointer __new_node) noexcept
      {
 _M_node = __new_node;
 _M_first = *__new_node;
 _M_last = _M_first + difference_type(_S_buffer_size());
      }

      friend bool
      operator==(const _Self& __x, const _Self& __y) noexcept
      { return __x._M_cur == __y._M_cur; }




      template<typename _RefR, typename _PtrR>
 friend bool
 operator==(const _Self& __x,
     const _Deque_iterator<_Tp, _RefR, _PtrR>& __y)
 noexcept
 { return __x._M_cur == __y._M_cur; }
# 290 "/usr/include/c++/10.2.0/bits/stl_deque.h" 3
      friend bool
      operator!=(const _Self& __x, const _Self& __y) noexcept
      { return !(__x == __y); }

      template<typename _RefR, typename _PtrR>
 friend bool
 operator!=(const _Self& __x,
     const _Deque_iterator<_Tp, _RefR, _PtrR>& __y)
 noexcept
 { return !(__x == __y); }

      friend bool
      operator<(const _Self& __x, const _Self& __y) noexcept
      {
 return (__x._M_node == __y._M_node)
   ? (__x._M_cur < __y._M_cur) : (__x._M_node < __y._M_node);
      }

      template<typename _RefR, typename _PtrR>
 friend bool
 operator<(const _Self& __x,
    const _Deque_iterator<_Tp, _RefR, _PtrR>& __y)
 noexcept
 {
   return (__x._M_node == __y._M_node)
     ? (__x._M_cur < __y._M_cur) : (__x._M_node < __y._M_node);
 }

      friend bool
      operator>(const _Self& __x, const _Self& __y) noexcept
      { return __y < __x; }

      template<typename _RefR, typename _PtrR>
 friend bool
 operator>(const _Self& __x,
    const _Deque_iterator<_Tp, _RefR, _PtrR>& __y)
 noexcept
 { return __y < __x; }

      friend bool
      operator<=(const _Self& __x, const _Self& __y) noexcept
      { return !(__y < __x); }

      template<typename _RefR, typename _PtrR>
 friend bool
 operator<=(const _Self& __x,
     const _Deque_iterator<_Tp, _RefR, _PtrR>& __y)
 noexcept
 { return !(__y < __x); }

      friend bool
      operator>=(const _Self& __x, const _Self& __y) noexcept
      { return !(__x < __y); }

      template<typename _RefR, typename _PtrR>
 friend bool
 operator>=(const _Self& __x,
     const _Deque_iterator<_Tp, _RefR, _PtrR>& __y)
 noexcept
 { return !(__x < __y); }


      friend difference_type
      operator-(const _Self& __x, const _Self& __y) noexcept
      {
 return difference_type(_S_buffer_size())
   * (__x._M_node - __y._M_node - 1) + (__x._M_cur - __x._M_first)
   + (__y._M_last - __y._M_cur);
      }





      template<typename _RefR, typename _PtrR>
 friend difference_type
 operator-(const _Self& __x,
    const _Deque_iterator<_Tp, _RefR, _PtrR>& __y) noexcept
 {
   return difference_type(_S_buffer_size())
     * (__x._M_node - __y._M_node - 1) + (__x._M_cur - __x._M_first)
     + (__y._M_last - __y._M_cur);
 }

      friend _Self
      operator+(const _Self& __x, difference_type __n) noexcept
      {
 _Self __tmp = __x;
 __tmp += __n;
 return __tmp;
      }

      friend _Self
      operator-(const _Self& __x, difference_type __n) noexcept
      {
 _Self __tmp = __x;
 __tmp -= __n;
 return __tmp;
      }

      friend _Self
      operator+(difference_type __n, const _Self& __x) noexcept
      { return __x + __n; }
    };
# 405 "/usr/include/c++/10.2.0/bits/stl_deque.h" 3
  template<typename _Tp, typename _Alloc>
    class _Deque_base
    {
    protected:
      typedef typename __gnu_cxx::__alloc_traits<_Alloc>::template
 rebind<_Tp>::other _Tp_alloc_type;
      typedef __gnu_cxx::__alloc_traits<_Tp_alloc_type> _Alloc_traits;





      typedef typename _Alloc_traits::pointer _Ptr;
      typedef typename _Alloc_traits::const_pointer _Ptr_const;


      typedef typename _Alloc_traits::template rebind<_Ptr>::other
 _Map_alloc_type;
      typedef __gnu_cxx::__alloc_traits<_Map_alloc_type> _Map_alloc_traits;

      typedef _Alloc allocator_type;

      allocator_type
      get_allocator() const noexcept
      { return allocator_type(_M_get_Tp_allocator()); }

      typedef _Deque_iterator<_Tp, _Tp&, _Ptr> iterator;
      typedef _Deque_iterator<_Tp, const _Tp&, _Ptr_const> const_iterator;

      _Deque_base()
      : _M_impl()
      { _M_initialize_map(0); }

      _Deque_base(size_t __num_elements)
      : _M_impl()
      { _M_initialize_map(__num_elements); }

      _Deque_base(const allocator_type& __a, size_t __num_elements)
      : _M_impl(__a)
      { _M_initialize_map(__num_elements); }

      _Deque_base(const allocator_type& __a)
      : _M_impl(__a)
      { }


      _Deque_base(_Deque_base&& __x)
      : _M_impl(std::move(__x._M_get_Tp_allocator()))
      {
 _M_initialize_map(0);
 if (__x._M_impl._M_map)
   this->_M_impl._M_swap_data(__x._M_impl);
      }

      _Deque_base(_Deque_base&& __x, const allocator_type& __a)
      : _M_impl(std::move(__x._M_impl), _Tp_alloc_type(__a))
      { __x._M_initialize_map(0); }

      _Deque_base(_Deque_base&& __x, const allocator_type& __a, size_t __n)
      : _M_impl(__a)
      {
 if (__x.get_allocator() == __a)
   {
     if (__x._M_impl._M_map)
       {
  _M_initialize_map(0);
  this->_M_impl._M_swap_data(__x._M_impl);
       }
   }
 else
   {
     _M_initialize_map(__n);
   }
      }


      ~_Deque_base() noexcept;

      typedef typename iterator::_Map_pointer _Map_pointer;

      struct _Deque_impl_data
      {
 _Map_pointer _M_map;
 size_t _M_map_size;
 iterator _M_start;
 iterator _M_finish;

 _Deque_impl_data() noexcept
 : _M_map(), _M_map_size(), _M_start(), _M_finish()
 { }


 _Deque_impl_data(const _Deque_impl_data&) = default;
 _Deque_impl_data&
 operator=(const _Deque_impl_data&) = default;

 _Deque_impl_data(_Deque_impl_data&& __x) noexcept
 : _Deque_impl_data(__x)
 { __x = _Deque_impl_data(); }


 void
 _M_swap_data(_Deque_impl_data& __x) noexcept
 {


   std::swap(*this, __x);
 }
      };




      struct _Deque_impl
      : public _Tp_alloc_type, public _Deque_impl_data
      {
 _Deque_impl() noexcept(is_nothrow_default_constructible<_Tp_alloc_type>::value)

 : _Tp_alloc_type()
 { }

 _Deque_impl(const _Tp_alloc_type& __a) noexcept
 : _Tp_alloc_type(__a)
 { }


 _Deque_impl(_Deque_impl&&) = default;

 _Deque_impl(_Tp_alloc_type&& __a) noexcept
 : _Tp_alloc_type(std::move(__a))
 { }

 _Deque_impl(_Deque_impl&& __d, _Tp_alloc_type&& __a)
 : _Tp_alloc_type(std::move(__a)), _Deque_impl_data(std::move(__d))
 { }

      };

      _Tp_alloc_type&
      _M_get_Tp_allocator() noexcept
      { return this->_M_impl; }

      const _Tp_alloc_type&
      _M_get_Tp_allocator() const noexcept
      { return this->_M_impl; }

      _Map_alloc_type
      _M_get_map_allocator() const noexcept
      { return _Map_alloc_type(_M_get_Tp_allocator()); }

      _Ptr
      _M_allocate_node()
      {
 typedef __gnu_cxx::__alloc_traits<_Tp_alloc_type> _Traits;
 return _Traits::allocate(_M_impl, __deque_buf_size(sizeof(_Tp)));
      }

      void
      _M_deallocate_node(_Ptr __p) noexcept
      {
 typedef __gnu_cxx::__alloc_traits<_Tp_alloc_type> _Traits;
 _Traits::deallocate(_M_impl, __p, __deque_buf_size(sizeof(_Tp)));
      }

      _Map_pointer
      _M_allocate_map(size_t __n)
      {
 _Map_alloc_type __map_alloc = _M_get_map_allocator();
 return _Map_alloc_traits::allocate(__map_alloc, __n);
      }

      void
      _M_deallocate_map(_Map_pointer __p, size_t __n) noexcept
      {
 _Map_alloc_type __map_alloc = _M_get_map_allocator();
 _Map_alloc_traits::deallocate(__map_alloc, __p, __n);
      }

      void _M_initialize_map(size_t);
      void _M_create_nodes(_Map_pointer __nstart, _Map_pointer __nfinish);
      void _M_destroy_nodes(_Map_pointer __nstart,
       _Map_pointer __nfinish) noexcept;
      enum { _S_initial_map_size = 8 };

      _Deque_impl _M_impl;
    };

  template<typename _Tp, typename _Alloc>
    _Deque_base<_Tp, _Alloc>::
    ~_Deque_base() noexcept
    {
      if (this->_M_impl._M_map)
 {
   _M_destroy_nodes(this->_M_impl._M_start._M_node,
      this->_M_impl._M_finish._M_node + 1);
   _M_deallocate_map(this->_M_impl._M_map, this->_M_impl._M_map_size);
 }
    }
# 612 "/usr/include/c++/10.2.0/bits/stl_deque.h" 3
  template<typename _Tp, typename _Alloc>
    void
    _Deque_base<_Tp, _Alloc>::
    _M_initialize_map(size_t __num_elements)
    {
      const size_t __num_nodes = (__num_elements / __deque_buf_size(sizeof(_Tp))
      + 1);

      this->_M_impl._M_map_size = std::max((size_t) _S_initial_map_size,
        size_t(__num_nodes + 2));
      this->_M_impl._M_map = _M_allocate_map(this->_M_impl._M_map_size);






      _Map_pointer __nstart = (this->_M_impl._M_map
          + (this->_M_impl._M_map_size - __num_nodes) / 2);
      _Map_pointer __nfinish = __nstart + __num_nodes;

      try
 { _M_create_nodes(__nstart, __nfinish); }
      catch(...)
 {
   _M_deallocate_map(this->_M_impl._M_map, this->_M_impl._M_map_size);
   this->_M_impl._M_map = _Map_pointer();
   this->_M_impl._M_map_size = 0;
   throw;
 }

      this->_M_impl._M_start._M_set_node(__nstart);
      this->_M_impl._M_finish._M_set_node(__nfinish - 1);
      this->_M_impl._M_start._M_cur = _M_impl._M_start._M_first;
      this->_M_impl._M_finish._M_cur = (this->_M_impl._M_finish._M_first
     + __num_elements
     % __deque_buf_size(sizeof(_Tp)));
    }

  template<typename _Tp, typename _Alloc>
    void
    _Deque_base<_Tp, _Alloc>::
    _M_create_nodes(_Map_pointer __nstart, _Map_pointer __nfinish)
    {
      _Map_pointer __cur;
      try
 {
   for (__cur = __nstart; __cur < __nfinish; ++__cur)
     *__cur = this->_M_allocate_node();
 }
      catch(...)
 {
   _M_destroy_nodes(__nstart, __cur);
   throw;
 }
    }

  template<typename _Tp, typename _Alloc>
    void
    _Deque_base<_Tp, _Alloc>::
    _M_destroy_nodes(_Map_pointer __nstart,
       _Map_pointer __nfinish) noexcept
    {
      for (_Map_pointer __n = __nstart; __n < __nfinish; ++__n)
 _M_deallocate_node(*__n);
    }
# 763 "/usr/include/c++/10.2.0/bits/stl_deque.h" 3
  template<typename _Tp, typename _Alloc = std::allocator<_Tp> >
    class deque : protected _Deque_base<_Tp, _Alloc>
    {
# 776 "/usr/include/c++/10.2.0/bits/stl_deque.h" 3
      static_assert(is_same<typename remove_cv<_Tp>::type, _Tp>::value,
   "std::deque must have a non-const, non-volatile value_type");

      static_assert(is_same<typename _Alloc::value_type, _Tp>::value,
   "std::deque must have the same value_type as its allocator");



      typedef _Deque_base<_Tp, _Alloc> _Base;
      typedef typename _Base::_Tp_alloc_type _Tp_alloc_type;
      typedef typename _Base::_Alloc_traits _Alloc_traits;
      typedef typename _Base::_Map_pointer _Map_pointer;

    public:
      typedef _Tp value_type;
      typedef typename _Alloc_traits::pointer pointer;
      typedef typename _Alloc_traits::const_pointer const_pointer;
      typedef typename _Alloc_traits::reference reference;
      typedef typename _Alloc_traits::const_reference const_reference;
      typedef typename _Base::iterator iterator;
      typedef typename _Base::const_iterator const_iterator;
      typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
      typedef std::reverse_iterator<iterator> reverse_iterator;
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef _Alloc allocator_type;

    private:
      static size_t _S_buffer_size() noexcept
      { return __deque_buf_size(sizeof(_Tp)); }


      using _Base::_M_initialize_map;
      using _Base::_M_create_nodes;
      using _Base::_M_destroy_nodes;
      using _Base::_M_allocate_node;
      using _Base::_M_deallocate_node;
      using _Base::_M_allocate_map;
      using _Base::_M_deallocate_map;
      using _Base::_M_get_Tp_allocator;





      using _Base::_M_impl;

    public:







      deque() = default;
# 840 "/usr/include/c++/10.2.0/bits/stl_deque.h" 3
      explicit
      deque(const allocator_type& __a)
      : _Base(__a, 0) { }
# 853 "/usr/include/c++/10.2.0/bits/stl_deque.h" 3
      explicit
      deque(size_type __n, const allocator_type& __a = allocator_type())
      : _Base(__a, _S_check_init_len(__n, __a))
      { _M_default_initialize(); }
# 866 "/usr/include/c++/10.2.0/bits/stl_deque.h" 3
      deque(size_type __n, const value_type& __value,
     const allocator_type& __a = allocator_type())
      : _Base(__a, _S_check_init_len(__n, __a))
      { _M_fill_initialize(__value); }
# 893 "/usr/include/c++/10.2.0/bits/stl_deque.h" 3
      deque(const deque& __x)
      : _Base(_Alloc_traits::_S_select_on_copy(__x._M_get_Tp_allocator()),
       __x.size())
      { std::__uninitialized_copy_a(__x.begin(), __x.end(),
        this->_M_impl._M_start,
        _M_get_Tp_allocator()); }
# 909 "/usr/include/c++/10.2.0/bits/stl_deque.h" 3
      deque(deque&&) = default;


      deque(const deque& __x, const allocator_type& __a)
      : _Base(__a, __x.size())
      { std::__uninitialized_copy_a(__x.begin(), __x.end(),
        this->_M_impl._M_start,
        _M_get_Tp_allocator()); }


      deque(deque&& __x, const allocator_type& __a)
      : deque(std::move(__x), __a, typename _Alloc_traits::is_always_equal{})
      { }

    private:
      deque(deque&& __x, const allocator_type& __a, true_type)
      : _Base(std::move(__x), __a)
      { }

      deque(deque&& __x, const allocator_type& __a, false_type)
      : _Base(std::move(__x), __a, __x.size())
      {
 if (__x.get_allocator() != __a && !__x.empty())
   {
     std::__uninitialized_move_a(__x.begin(), __x.end(),
     this->_M_impl._M_start,
     _M_get_Tp_allocator());
     __x.clear();
   }
      }

    public:
# 952 "/usr/include/c++/10.2.0/bits/stl_deque.h" 3
      deque(initializer_list<value_type> __l,
     const allocator_type& __a = allocator_type())
      : _Base(__a)
      {
 _M_range_initialize(__l.begin(), __l.end(),
       random_access_iterator_tag());
      }
# 977 "/usr/include/c++/10.2.0/bits/stl_deque.h" 3
      template<typename _InputIterator,
        typename = std::_RequireInputIter<_InputIterator>>
 deque(_InputIterator __first, _InputIterator __last,
       const allocator_type& __a = allocator_type())
 : _Base(__a)
 {
   _M_range_initialize(__first, __last,
         std::__iterator_category(__first));
 }
# 1003 "/usr/include/c++/10.2.0/bits/stl_deque.h" 3
      ~deque()
      { _M_destroy_data(begin(), end(), _M_get_Tp_allocator()); }
# 1015 "/usr/include/c++/10.2.0/bits/stl_deque.h" 3
      deque&
      operator=(const deque& __x);
# 1027 "/usr/include/c++/10.2.0/bits/stl_deque.h" 3
      deque&
      operator=(deque&& __x) noexcept(_Alloc_traits::_S_always_equal())
      {
 using __always_equal = typename _Alloc_traits::is_always_equal;
 _M_move_assign1(std::move(__x), __always_equal{});
 return *this;
      }
# 1046 "/usr/include/c++/10.2.0/bits/stl_deque.h" 3
      deque&
      operator=(initializer_list<value_type> __l)
      {
 _M_assign_aux(__l.begin(), __l.end(),
        random_access_iterator_tag());
 return *this;
      }
# 1065 "/usr/include/c++/10.2.0/bits/stl_deque.h" 3
      void
      assign(size_type __n, const value_type& __val)
      { _M_fill_assign(__n, __val); }
# 1082 "/usr/include/c++/10.2.0/bits/stl_deque.h" 3
      template<typename _InputIterator,
        typename = std::_RequireInputIter<_InputIterator>>
 void
 assign(_InputIterator __first, _InputIterator __last)
 { _M_assign_aux(__first, __last, std::__iterator_category(__first)); }
# 1109 "/usr/include/c++/10.2.0/bits/stl_deque.h" 3
      void
      assign(initializer_list<value_type> __l)
      { _M_assign_aux(__l.begin(), __l.end(), random_access_iterator_tag()); }



      allocator_type
      get_allocator() const noexcept
      { return _Base::get_allocator(); }






      iterator
      begin() noexcept
      { return this->_M_impl._M_start; }





      const_iterator
      begin() const noexcept
      { return this->_M_impl._M_start; }






      iterator
      end() noexcept
      { return this->_M_impl._M_finish; }






      const_iterator
      end() const noexcept
      { return this->_M_impl._M_finish; }






      reverse_iterator
      rbegin() noexcept
      { return reverse_iterator(this->_M_impl._M_finish); }






      const_reverse_iterator
      rbegin() const noexcept
      { return const_reverse_iterator(this->_M_impl._M_finish); }






      reverse_iterator
      rend() noexcept
      { return reverse_iterator(this->_M_impl._M_start); }






      const_reverse_iterator
      rend() const noexcept
      { return const_reverse_iterator(this->_M_impl._M_start); }






      const_iterator
      cbegin() const noexcept
      { return this->_M_impl._M_start; }






      const_iterator
      cend() const noexcept
      { return this->_M_impl._M_finish; }






      const_reverse_iterator
      crbegin() const noexcept
      { return const_reverse_iterator(this->_M_impl._M_finish); }






      const_reverse_iterator
      crend() const noexcept
      { return const_reverse_iterator(this->_M_impl._M_start); }




      size_type
      size() const noexcept
      { return this->_M_impl._M_finish - this->_M_impl._M_start; }


      size_type
      max_size() const noexcept
      { return _S_max_size(_M_get_Tp_allocator()); }
# 1248 "/usr/include/c++/10.2.0/bits/stl_deque.h" 3
      void
      resize(size_type __new_size)
      {
 const size_type __len = size();
 if (__new_size > __len)
   _M_default_append(__new_size - __len);
 else if (__new_size < __len)
   _M_erase_at_end(this->_M_impl._M_start
     + difference_type(__new_size));
      }
# 1270 "/usr/include/c++/10.2.0/bits/stl_deque.h" 3
      void
      resize(size_type __new_size, const value_type& __x)
# 1287 "/usr/include/c++/10.2.0/bits/stl_deque.h" 3
      {
 const size_type __len = size();
 if (__new_size > __len)
   _M_fill_insert(this->_M_impl._M_finish, __new_size - __len, __x);
 else if (__new_size < __len)
   _M_erase_at_end(this->_M_impl._M_start
     + difference_type(__new_size));
      }



      void
      shrink_to_fit() noexcept
      { _M_shrink_to_fit(); }






      bool
      empty() const noexcept
      { return this->_M_impl._M_finish == this->_M_impl._M_start; }
# 1323 "/usr/include/c++/10.2.0/bits/stl_deque.h" 3
      reference
      operator[](size_type __n) noexcept
      {
 ;
 return this->_M_impl._M_start[difference_type(__n)];
      }
# 1341 "/usr/include/c++/10.2.0/bits/stl_deque.h" 3
      const_reference
      operator[](size_type __n) const noexcept
      {
 ;
 return this->_M_impl._M_start[difference_type(__n)];
      }

    protected:

      void
      _M_range_check(size_type __n) const
      {
 if (__n >= this->size())
   __throw_out_of_range_fmt(("deque::_M_range_check: __n " "(which is %zu)>= this->size() " "(which is %zu)")

                            ,
       __n, this->size());
      }

    public:
# 1372 "/usr/include/c++/10.2.0/bits/stl_deque.h" 3
      reference
      at(size_type __n)
      {
 _M_range_check(__n);
 return (*this)[__n];
      }
# 1390 "/usr/include/c++/10.2.0/bits/stl_deque.h" 3
      const_reference
      at(size_type __n) const
      {
 _M_range_check(__n);
 return (*this)[__n];
      }





      reference
      front() noexcept
      {
 ;
 return *begin();
      }





      const_reference
      front() const noexcept
      {
 ;
 return *begin();
      }





      reference
      back() noexcept
      {
 ;
 iterator __tmp = end();
 --__tmp;
 return *__tmp;
      }





      const_reference
      back() const noexcept
      {
 ;
 const_iterator __tmp = end();
 --__tmp;
 return *__tmp;
      }
# 1455 "/usr/include/c++/10.2.0/bits/stl_deque.h" 3
      void
      push_front(const value_type& __x)
      {
 if (this->_M_impl._M_start._M_cur != this->_M_impl._M_start._M_first)
   {
     _Alloc_traits::construct(this->_M_impl,
         this->_M_impl._M_start._M_cur - 1,
         __x);
     --this->_M_impl._M_start._M_cur;
   }
 else
   _M_push_front_aux(__x);
      }


      void
      push_front(value_type&& __x)
      { emplace_front(std::move(__x)); }

      template<typename... _Args>



 void

 emplace_front(_Args&&... __args);
# 1492 "/usr/include/c++/10.2.0/bits/stl_deque.h" 3
      void
      push_back(const value_type& __x)
      {
 if (this->_M_impl._M_finish._M_cur
     != this->_M_impl._M_finish._M_last - 1)
   {
     _Alloc_traits::construct(this->_M_impl,
         this->_M_impl._M_finish._M_cur, __x);
     ++this->_M_impl._M_finish._M_cur;
   }
 else
   _M_push_back_aux(__x);
      }


      void
      push_back(value_type&& __x)
      { emplace_back(std::move(__x)); }

      template<typename... _Args>



 void

 emplace_back(_Args&&... __args);
# 1528 "/usr/include/c++/10.2.0/bits/stl_deque.h" 3
      void
      pop_front() noexcept
      {
 ;
 if (this->_M_impl._M_start._M_cur
     != this->_M_impl._M_start._M_last - 1)
   {
     _Alloc_traits::destroy(_M_get_Tp_allocator(),
       this->_M_impl._M_start._M_cur);
     ++this->_M_impl._M_start._M_cur;
   }
 else
   _M_pop_front_aux();
      }
# 1551 "/usr/include/c++/10.2.0/bits/stl_deque.h" 3
      void
      pop_back() noexcept
      {
 ;
 if (this->_M_impl._M_finish._M_cur
     != this->_M_impl._M_finish._M_first)
   {
     --this->_M_impl._M_finish._M_cur;
     _Alloc_traits::destroy(_M_get_Tp_allocator(),
       this->_M_impl._M_finish._M_cur);
   }
 else
   _M_pop_back_aux();
      }
# 1576 "/usr/include/c++/10.2.0/bits/stl_deque.h" 3
      template<typename... _Args>
 iterator
 emplace(const_iterator __position, _Args&&... __args);
# 1589 "/usr/include/c++/10.2.0/bits/stl_deque.h" 3
      iterator
      insert(const_iterator __position, const value_type& __x);
# 1615 "/usr/include/c++/10.2.0/bits/stl_deque.h" 3
      iterator
      insert(const_iterator __position, value_type&& __x)
      { return emplace(__position, std::move(__x)); }
# 1629 "/usr/include/c++/10.2.0/bits/stl_deque.h" 3
      iterator
      insert(const_iterator __p, initializer_list<value_type> __l)
      {
 auto __offset = __p - cbegin();
 _M_range_insert_aux(__p._M_const_cast(), __l.begin(), __l.end(),
       std::random_access_iterator_tag());
 return begin() + __offset;
      }
# 1648 "/usr/include/c++/10.2.0/bits/stl_deque.h" 3
      iterator
      insert(const_iterator __position, size_type __n, const value_type& __x)
      {
 difference_type __offset = __position - cbegin();
 _M_fill_insert(__position._M_const_cast(), __n, __x);
 return begin() + __offset;
      }
# 1682 "/usr/include/c++/10.2.0/bits/stl_deque.h" 3
      template<typename _InputIterator,
        typename = std::_RequireInputIter<_InputIterator>>
 iterator
 insert(const_iterator __position, _InputIterator __first,
        _InputIterator __last)
 {
   difference_type __offset = __position - cbegin();
   _M_range_insert_aux(__position._M_const_cast(), __first, __last,
         std::__iterator_category(__first));
   return begin() + __offset;
 }
# 1728 "/usr/include/c++/10.2.0/bits/stl_deque.h" 3
      iterator

      erase(const_iterator __position)



      { return _M_erase(__position._M_const_cast()); }
# 1752 "/usr/include/c++/10.2.0/bits/stl_deque.h" 3
      iterator

      erase(const_iterator __first, const_iterator __last)



      { return _M_erase(__first._M_const_cast(), __last._M_const_cast()); }
# 1771 "/usr/include/c++/10.2.0/bits/stl_deque.h" 3
      void
      swap(deque& __x) noexcept
      {


                                                          ;

 _M_impl._M_swap_data(__x._M_impl);
 _Alloc_traits::_S_on_swap(_M_get_Tp_allocator(),
      __x._M_get_Tp_allocator());
      }







      void
      clear() noexcept
      { _M_erase_at_end(begin()); }

    protected:
# 1821 "/usr/include/c++/10.2.0/bits/stl_deque.h" 3
      static size_t
      _S_check_init_len(size_t __n, const allocator_type& __a)
      {
 if (__n > _S_max_size(__a))
   __throw_length_error(
       ("cannot create std::deque larger than max_size()"));
 return __n;
      }

      static size_type
      _S_max_size(const _Tp_alloc_type& __a) noexcept
      {
 const size_t __diffmax = __gnu_cxx::__numeric_traits<ptrdiff_t>::__max;
 const size_t __allocmax = _Alloc_traits::max_size(__a);
 return (std::min)(__diffmax, __allocmax);
      }
# 1850 "/usr/include/c++/10.2.0/bits/stl_deque.h" 3
      template<typename _InputIterator>
 void
 _M_range_initialize(_InputIterator __first, _InputIterator __last,
       std::input_iterator_tag);


      template<typename _ForwardIterator>
 void
 _M_range_initialize(_ForwardIterator __first, _ForwardIterator __last,
       std::forward_iterator_tag);
# 1872 "/usr/include/c++/10.2.0/bits/stl_deque.h" 3
      void
      _M_fill_initialize(const value_type& __value);



      void
      _M_default_initialize();
# 1903 "/usr/include/c++/10.2.0/bits/stl_deque.h" 3
      template<typename _InputIterator>
 void
 _M_assign_aux(_InputIterator __first, _InputIterator __last,
        std::input_iterator_tag);


      template<typename _ForwardIterator>
 void
 _M_assign_aux(_ForwardIterator __first, _ForwardIterator __last,
        std::forward_iterator_tag)
 {
   const size_type __len = std::distance(__first, __last);
   if (__len > size())
     {
       _ForwardIterator __mid = __first;
       std::advance(__mid, size());
       std::copy(__first, __mid, begin());
       _M_range_insert_aux(end(), __mid, __last,
      std::__iterator_category(__first));
     }
   else
     _M_erase_at_end(std::copy(__first, __last, begin()));
 }



      void
      _M_fill_assign(size_type __n, const value_type& __val)
      {
 if (__n > size())
   {
     std::fill(begin(), end(), __val);
     _M_fill_insert(end(), __n - size(), __val);
   }
 else
   {
     _M_erase_at_end(begin() + difference_type(__n));
     std::fill(begin(), end(), __val);
   }
      }
# 1951 "/usr/include/c++/10.2.0/bits/stl_deque.h" 3
      template<typename... _Args>
 void _M_push_back_aux(_Args&&... __args);

      template<typename... _Args>
 void _M_push_front_aux(_Args&&... __args);


      void _M_pop_back_aux();

      void _M_pop_front_aux();
# 1990 "/usr/include/c++/10.2.0/bits/stl_deque.h" 3
      template<typename _InputIterator>
 void
 _M_range_insert_aux(iterator __pos, _InputIterator __first,
       _InputIterator __last, std::input_iterator_tag);


      template<typename _ForwardIterator>
 void
 _M_range_insert_aux(iterator __pos, _ForwardIterator __first,
       _ForwardIterator __last, std::forward_iterator_tag);




      void
      _M_fill_insert(iterator __pos, size_type __n, const value_type& __x);






      template<typename... _Args>
 iterator
 _M_insert_aux(iterator __pos, _Args&&... __args);



      void
      _M_insert_aux(iterator __pos, size_type __n, const value_type& __x);


      template<typename _ForwardIterator>
 void
 _M_insert_aux(iterator __pos,
        _ForwardIterator __first, _ForwardIterator __last,
        size_type __n);




      void
      _M_destroy_data_aux(iterator __first, iterator __last);



      template<typename _Alloc1>
 void
 _M_destroy_data(iterator __first, iterator __last, const _Alloc1&)
 { _M_destroy_data_aux(__first, __last); }

      void
      _M_destroy_data(iterator __first, iterator __last,
        const std::allocator<_Tp>&)
      {
 if (!__has_trivial_destructor(value_type))
   _M_destroy_data_aux(__first, __last);
      }


      void
      _M_erase_at_begin(iterator __pos)
      {
 _M_destroy_data(begin(), __pos, _M_get_Tp_allocator());
 _M_destroy_nodes(this->_M_impl._M_start._M_node, __pos._M_node);
 this->_M_impl._M_start = __pos;
      }



      void
      _M_erase_at_end(iterator __pos)
      {
 _M_destroy_data(__pos, end(), _M_get_Tp_allocator());
 _M_destroy_nodes(__pos._M_node + 1,
    this->_M_impl._M_finish._M_node + 1);
 this->_M_impl._M_finish = __pos;
      }

      iterator
      _M_erase(iterator __pos);

      iterator
      _M_erase(iterator __first, iterator __last);



      void
      _M_default_append(size_type __n);

      bool
      _M_shrink_to_fit();




      iterator
      _M_reserve_elements_at_front(size_type __n)
      {
 const size_type __vacancies = this->_M_impl._M_start._M_cur
          - this->_M_impl._M_start._M_first;
 if (__n > __vacancies)
   _M_new_elements_at_front(__n - __vacancies);
 return this->_M_impl._M_start - difference_type(__n);
      }

      iterator
      _M_reserve_elements_at_back(size_type __n)
      {
 const size_type __vacancies = (this->_M_impl._M_finish._M_last
           - this->_M_impl._M_finish._M_cur) - 1;
 if (__n > __vacancies)
   _M_new_elements_at_back(__n - __vacancies);
 return this->_M_impl._M_finish + difference_type(__n);
      }

      void
      _M_new_elements_at_front(size_type __new_elements);

      void
      _M_new_elements_at_back(size_type __new_elements);
# 2122 "/usr/include/c++/10.2.0/bits/stl_deque.h" 3
      void
      _M_reserve_map_at_back(size_type __nodes_to_add = 1)
      {
 if (__nodes_to_add + 1 > this->_M_impl._M_map_size
     - (this->_M_impl._M_finish._M_node - this->_M_impl._M_map))
   _M_reallocate_map(__nodes_to_add, false);
      }

      void
      _M_reserve_map_at_front(size_type __nodes_to_add = 1)
      {
 if (__nodes_to_add > size_type(this->_M_impl._M_start._M_node
           - this->_M_impl._M_map))
   _M_reallocate_map(__nodes_to_add, true);
      }

      void
      _M_reallocate_map(size_type __nodes_to_add, bool __add_at_front);





      void
      _M_move_assign1(deque&& __x, true_type) noexcept
      {
 this->_M_impl._M_swap_data(__x._M_impl);
 __x.clear();
 std::__alloc_on_move(_M_get_Tp_allocator(), __x._M_get_Tp_allocator());
      }




      void
      _M_move_assign1(deque&& __x, false_type)
      {
 constexpr bool __move_storage =
   _Alloc_traits::_S_propagate_on_move_assign();
 _M_move_assign2(std::move(__x), __bool_constant<__move_storage>());
      }



      template<typename... _Args>
      void
      _M_replace_map(_Args&&... __args)
      {

 deque __newobj(std::forward<_Args>(__args)...);

 clear();
 _M_deallocate_node(*begin()._M_node);
 _M_deallocate_map(this->_M_impl._M_map, this->_M_impl._M_map_size);
 this->_M_impl._M_map = nullptr;
 this->_M_impl._M_map_size = 0;

 this->_M_impl._M_swap_data(__newobj._M_impl);
      }


      void
      _M_move_assign2(deque&& __x, true_type)
      {

 auto __alloc = __x._M_get_Tp_allocator();


 _M_replace_map(std::move(__x));

 _M_get_Tp_allocator() = std::move(__alloc);
      }



      void
      _M_move_assign2(deque&& __x, false_type)
      {
 if (__x._M_get_Tp_allocator() == this->_M_get_Tp_allocator())
   {


     _M_replace_map(std::move(__x), __x.get_allocator());
   }
 else
   {


     _M_assign_aux(std::make_move_iterator(__x.begin()),
     std::make_move_iterator(__x.end()),
     std::random_access_iterator_tag());
     __x.clear();
   }
      }

    };
# 2239 "/usr/include/c++/10.2.0/bits/stl_deque.h" 3
  template<typename _Tp, typename _Alloc>
    inline bool
    operator==(const deque<_Tp, _Alloc>& __x, const deque<_Tp, _Alloc>& __y)
    { return __x.size() == __y.size()
      && std::equal(__x.begin(), __x.end(), __y.begin()); }
# 2277 "/usr/include/c++/10.2.0/bits/stl_deque.h" 3
  template<typename _Tp, typename _Alloc>
    inline bool
    operator<(const deque<_Tp, _Alloc>& __x, const deque<_Tp, _Alloc>& __y)
    { return std::lexicographical_compare(__x.begin(), __x.end(),
       __y.begin(), __y.end()); }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator!=(const deque<_Tp, _Alloc>& __x, const deque<_Tp, _Alloc>& __y)
    { return !(__x == __y); }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator>(const deque<_Tp, _Alloc>& __x, const deque<_Tp, _Alloc>& __y)
    { return __y < __x; }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator<=(const deque<_Tp, _Alloc>& __x, const deque<_Tp, _Alloc>& __y)
    { return !(__y < __x); }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator>=(const deque<_Tp, _Alloc>& __x, const deque<_Tp, _Alloc>& __y)
    { return !(__x < __y); }



  template<typename _Tp, typename _Alloc>
    inline void
    swap(deque<_Tp,_Alloc>& __x, deque<_Tp,_Alloc>& __y)
    noexcept(noexcept(__x.swap(__y)))
    { __x.swap(__y); }








  template<class _Tp>
    struct __is_bitwise_relocatable<std::deque<_Tp>>
    : true_type { };



}
# 68 "/usr/include/c++/10.2.0/deque" 2 3

# 1 "/usr/include/c++/10.2.0/bits/deque.tcc" 1 3
# 61 "/usr/include/c++/10.2.0/bits/deque.tcc" 3
namespace std __attribute__ ((__visibility__ ("default")))
{




  template <typename _Tp, typename _Alloc>
    void
    deque<_Tp, _Alloc>::
    _M_default_initialize()
    {
      _Map_pointer __cur;
      try
 {
   for (__cur = this->_M_impl._M_start._M_node;
        __cur < this->_M_impl._M_finish._M_node;
        ++__cur)
     std::__uninitialized_default_a(*__cur, *__cur + _S_buffer_size(),
        _M_get_Tp_allocator());
   std::__uninitialized_default_a(this->_M_impl._M_finish._M_first,
      this->_M_impl._M_finish._M_cur,
      _M_get_Tp_allocator());
 }
      catch(...)
 {
   std::_Destroy(this->_M_impl._M_start, iterator(*__cur, __cur),
   _M_get_Tp_allocator());
   throw;
 }
    }


  template <typename _Tp, typename _Alloc>
    deque<_Tp, _Alloc>&
    deque<_Tp, _Alloc>::
    operator=(const deque& __x)
    {
      if (&__x != this)
 {

   if (_Alloc_traits::_S_propagate_on_copy_assign())
     {
       if (!_Alloc_traits::_S_always_equal()
    && _M_get_Tp_allocator() != __x._M_get_Tp_allocator())
  {


    _M_replace_map(__x, __x.get_allocator());
    std::__alloc_on_copy(_M_get_Tp_allocator(),
           __x._M_get_Tp_allocator());
    return *this;
  }
       std::__alloc_on_copy(_M_get_Tp_allocator(),
       __x._M_get_Tp_allocator());
     }

   const size_type __len = size();
   if (__len >= __x.size())
     _M_erase_at_end(std::copy(__x.begin(), __x.end(),
          this->_M_impl._M_start));
   else
     {
       const_iterator __mid = __x.begin() + difference_type(__len);
       std::copy(__x.begin(), __mid, this->_M_impl._M_start);
       _M_range_insert_aux(this->_M_impl._M_finish, __mid, __x.end(),
      std::random_access_iterator_tag());
     }
 }
      return *this;
    }


  template<typename _Tp, typename _Alloc>
    template<typename... _Args>



      void

      deque<_Tp, _Alloc>::
      emplace_front(_Args&&... __args)
      {
 if (this->_M_impl._M_start._M_cur != this->_M_impl._M_start._M_first)
   {
     _Alloc_traits::construct(this->_M_impl,
         this->_M_impl._M_start._M_cur - 1,
         std::forward<_Args>(__args)...);
     --this->_M_impl._M_start._M_cur;
   }
 else
   _M_push_front_aux(std::forward<_Args>(__args)...);



      }

  template<typename _Tp, typename _Alloc>
    template<typename... _Args>



      void

      deque<_Tp, _Alloc>::
      emplace_back(_Args&&... __args)
      {
 if (this->_M_impl._M_finish._M_cur
     != this->_M_impl._M_finish._M_last - 1)
   {
     _Alloc_traits::construct(this->_M_impl,
         this->_M_impl._M_finish._M_cur,
         std::forward<_Args>(__args)...);
     ++this->_M_impl._M_finish._M_cur;
   }
 else
   _M_push_back_aux(std::forward<_Args>(__args)...);



      }



  template<typename _Tp, typename _Alloc>
    template<typename... _Args>
      typename deque<_Tp, _Alloc>::iterator
      deque<_Tp, _Alloc>::
      emplace(const_iterator __position, _Args&&... __args)
      {
 if (__position._M_cur == this->_M_impl._M_start._M_cur)
   {
     emplace_front(std::forward<_Args>(__args)...);
     return this->_M_impl._M_start;
   }
 else if (__position._M_cur == this->_M_impl._M_finish._M_cur)
   {
     emplace_back(std::forward<_Args>(__args)...);
     iterator __tmp = this->_M_impl._M_finish;
     --__tmp;
     return __tmp;
   }
 else
   return _M_insert_aux(__position._M_const_cast(),
          std::forward<_Args>(__args)...);
      }


  template <typename _Tp, typename _Alloc>
    typename deque<_Tp, _Alloc>::iterator
    deque<_Tp, _Alloc>::

    insert(const_iterator __position, const value_type& __x)



    {
      if (__position._M_cur == this->_M_impl._M_start._M_cur)
 {
   push_front(__x);
   return this->_M_impl._M_start;
 }
      else if (__position._M_cur == this->_M_impl._M_finish._M_cur)
 {
   push_back(__x);
   iterator __tmp = this->_M_impl._M_finish;
   --__tmp;
   return __tmp;
 }
      else
 return _M_insert_aux(__position._M_const_cast(), __x);
   }

  template <typename _Tp, typename _Alloc>
    typename deque<_Tp, _Alloc>::iterator
    deque<_Tp, _Alloc>::
    _M_erase(iterator __position)
    {
      iterator __next = __position;
      ++__next;
      const difference_type __index = __position - begin();
      if (static_cast<size_type>(__index) < (size() >> 1))
 {
   if (__position != begin())
     std::move_backward(begin(), __position, __next);
   pop_front();
 }
      else
 {
   if (__next != end())
     std::move(__next, end(), __position);
   pop_back();
 }
      return begin() + __index;
    }

  template <typename _Tp, typename _Alloc>
    typename deque<_Tp, _Alloc>::iterator
    deque<_Tp, _Alloc>::
    _M_erase(iterator __first, iterator __last)
    {
      if (__first == __last)
 return __first;
      else if (__first == begin() && __last == end())
 {
   clear();
   return end();
 }
      else
 {
   const difference_type __n = __last - __first;
   const difference_type __elems_before = __first - begin();
   if (static_cast<size_type>(__elems_before) <= (size() - __n) / 2)
     {
       if (__first != begin())
  std::move_backward(begin(), __first, __last);
       _M_erase_at_begin(begin() + __n);
     }
   else
     {
       if (__last != end())
  std::move(__last, end(), __first);
       _M_erase_at_end(end() - __n);
     }
   return begin() + __elems_before;
 }
    }

  template <typename _Tp, class _Alloc>
    template <typename _InputIterator>
      void
      deque<_Tp, _Alloc>::
      _M_assign_aux(_InputIterator __first, _InputIterator __last,
      std::input_iterator_tag)
      {
 iterator __cur = begin();
 for (; __first != __last && __cur != end(); ++__cur, (void)++__first)
   *__cur = *__first;
 if (__first == __last)
   _M_erase_at_end(__cur);
 else
   _M_range_insert_aux(end(), __first, __last,
         std::__iterator_category(__first));
      }

  template <typename _Tp, typename _Alloc>
    void
    deque<_Tp, _Alloc>::
    _M_fill_insert(iterator __pos, size_type __n, const value_type& __x)
    {
      if (__pos._M_cur == this->_M_impl._M_start._M_cur)
 {
   iterator __new_start = _M_reserve_elements_at_front(__n);
   try
     {
       std::__uninitialized_fill_a(__new_start, this->_M_impl._M_start,
       __x, _M_get_Tp_allocator());
       this->_M_impl._M_start = __new_start;
     }
   catch(...)
     {
       _M_destroy_nodes(__new_start._M_node,
          this->_M_impl._M_start._M_node);
       throw;
     }
 }
      else if (__pos._M_cur == this->_M_impl._M_finish._M_cur)
 {
   iterator __new_finish = _M_reserve_elements_at_back(__n);
   try
     {
       std::__uninitialized_fill_a(this->_M_impl._M_finish,
       __new_finish, __x,
       _M_get_Tp_allocator());
       this->_M_impl._M_finish = __new_finish;
     }
   catch(...)
     {
       _M_destroy_nodes(this->_M_impl._M_finish._M_node + 1,
          __new_finish._M_node + 1);
       throw;
     }
 }
      else
 _M_insert_aux(__pos, __n, __x);
    }


  template <typename _Tp, typename _Alloc>
    void
    deque<_Tp, _Alloc>::
    _M_default_append(size_type __n)
    {
      if (__n)
 {
   iterator __new_finish = _M_reserve_elements_at_back(__n);
   try
     {
       std::__uninitialized_default_a(this->_M_impl._M_finish,
          __new_finish,
          _M_get_Tp_allocator());
       this->_M_impl._M_finish = __new_finish;
     }
   catch(...)
     {
       _M_destroy_nodes(this->_M_impl._M_finish._M_node + 1,
          __new_finish._M_node + 1);
       throw;
     }
 }
    }

  template <typename _Tp, typename _Alloc>
    bool
    deque<_Tp, _Alloc>::
    _M_shrink_to_fit()
    {
      const difference_type __front_capacity
 = (this->_M_impl._M_start._M_cur - this->_M_impl._M_start._M_first);
      if (__front_capacity == 0)
 return false;

      const difference_type __back_capacity
 = (this->_M_impl._M_finish._M_last - this->_M_impl._M_finish._M_cur);
      if (__front_capacity + __back_capacity < _S_buffer_size())
 return false;

      return std::__shrink_to_fit_aux<deque>::_S_do_it(*this);
    }


  template <typename _Tp, typename _Alloc>
    void
    deque<_Tp, _Alloc>::
    _M_fill_initialize(const value_type& __value)
    {
      _Map_pointer __cur;
      try
 {
   for (__cur = this->_M_impl._M_start._M_node;
        __cur < this->_M_impl._M_finish._M_node;
        ++__cur)
     std::__uninitialized_fill_a(*__cur, *__cur + _S_buffer_size(),
     __value, _M_get_Tp_allocator());
   std::__uninitialized_fill_a(this->_M_impl._M_finish._M_first,
          this->_M_impl._M_finish._M_cur,
          __value, _M_get_Tp_allocator());
 }
      catch(...)
 {
   std::_Destroy(this->_M_impl._M_start, iterator(*__cur, __cur),
   _M_get_Tp_allocator());
   throw;
 }
    }

  template <typename _Tp, typename _Alloc>
    template <typename _InputIterator>
      void
      deque<_Tp, _Alloc>::
      _M_range_initialize(_InputIterator __first, _InputIterator __last,
     std::input_iterator_tag)
      {
 this->_M_initialize_map(0);
 try
   {
     for (; __first != __last; ++__first)

       emplace_back(*__first);



   }
 catch(...)
   {
     clear();
     throw;
   }
      }

  template <typename _Tp, typename _Alloc>
    template <typename _ForwardIterator>
      void
      deque<_Tp, _Alloc>::
      _M_range_initialize(_ForwardIterator __first, _ForwardIterator __last,
     std::forward_iterator_tag)
      {
 const size_type __n = std::distance(__first, __last);
 this->_M_initialize_map(_S_check_init_len(__n, _M_get_Tp_allocator()));

 _Map_pointer __cur_node;
 try
   {
     for (__cur_node = this->_M_impl._M_start._M_node;
   __cur_node < this->_M_impl._M_finish._M_node;
   ++__cur_node)
       {
  _ForwardIterator __mid = __first;
  std::advance(__mid, _S_buffer_size());
  std::__uninitialized_copy_a(__first, __mid, *__cur_node,
         _M_get_Tp_allocator());
  __first = __mid;
       }
     std::__uninitialized_copy_a(__first, __last,
     this->_M_impl._M_finish._M_first,
     _M_get_Tp_allocator());
   }
 catch(...)
   {
     std::_Destroy(this->_M_impl._M_start,
     iterator(*__cur_node, __cur_node),
     _M_get_Tp_allocator());
     throw;
   }
      }


  template<typename _Tp, typename _Alloc>

    template<typename... _Args>
      void
      deque<_Tp, _Alloc>::
      _M_push_back_aux(_Args&&... __args)





      {
 if (size() == max_size())
   __throw_length_error(
       ("cannot create std::deque larger than max_size()"));

 _M_reserve_map_at_back();
 *(this->_M_impl._M_finish._M_node + 1) = this->_M_allocate_node();
 try
   {

     _Alloc_traits::construct(this->_M_impl,
         this->_M_impl._M_finish._M_cur,
         std::forward<_Args>(__args)...);



     this->_M_impl._M_finish._M_set_node(this->_M_impl._M_finish._M_node
      + 1);
     this->_M_impl._M_finish._M_cur = this->_M_impl._M_finish._M_first;
   }
 catch(...)
   {
     _M_deallocate_node(*(this->_M_impl._M_finish._M_node + 1));
     throw;
   }
      }


  template<typename _Tp, typename _Alloc>

    template<typename... _Args>
      void
      deque<_Tp, _Alloc>::
      _M_push_front_aux(_Args&&... __args)





      {
 if (size() == max_size())
   __throw_length_error(
       ("cannot create std::deque larger than max_size()"));

 _M_reserve_map_at_front();
 *(this->_M_impl._M_start._M_node - 1) = this->_M_allocate_node();
 try
   {
     this->_M_impl._M_start._M_set_node(this->_M_impl._M_start._M_node
            - 1);
     this->_M_impl._M_start._M_cur = this->_M_impl._M_start._M_last - 1;

     _Alloc_traits::construct(this->_M_impl,
         this->_M_impl._M_start._M_cur,
         std::forward<_Args>(__args)...);



   }
 catch(...)
   {
     ++this->_M_impl._M_start;
     _M_deallocate_node(*(this->_M_impl._M_start._M_node - 1));
     throw;
   }
      }


  template <typename _Tp, typename _Alloc>
    void deque<_Tp, _Alloc>::
    _M_pop_back_aux()
    {
      _M_deallocate_node(this->_M_impl._M_finish._M_first);
      this->_M_impl._M_finish._M_set_node(this->_M_impl._M_finish._M_node - 1);
      this->_M_impl._M_finish._M_cur = this->_M_impl._M_finish._M_last - 1;
      _Alloc_traits::destroy(_M_get_Tp_allocator(),
        this->_M_impl._M_finish._M_cur);
    }






  template <typename _Tp, typename _Alloc>
    void deque<_Tp, _Alloc>::
    _M_pop_front_aux()
    {
      _Alloc_traits::destroy(_M_get_Tp_allocator(),
        this->_M_impl._M_start._M_cur);
      _M_deallocate_node(this->_M_impl._M_start._M_first);
      this->_M_impl._M_start._M_set_node(this->_M_impl._M_start._M_node + 1);
      this->_M_impl._M_start._M_cur = this->_M_impl._M_start._M_first;
    }

  template <typename _Tp, typename _Alloc>
    template <typename _InputIterator>
      void
      deque<_Tp, _Alloc>::
      _M_range_insert_aux(iterator __pos,
     _InputIterator __first, _InputIterator __last,
     std::input_iterator_tag)
      { std::copy(__first, __last, std::inserter(*this, __pos)); }

  template <typename _Tp, typename _Alloc>
    template <typename _ForwardIterator>
      void
      deque<_Tp, _Alloc>::
      _M_range_insert_aux(iterator __pos,
     _ForwardIterator __first, _ForwardIterator __last,
     std::forward_iterator_tag)
      {
 const size_type __n = std::distance(__first, __last);
 if (__pos._M_cur == this->_M_impl._M_start._M_cur)
   {
     iterator __new_start = _M_reserve_elements_at_front(__n);
     try
       {
  std::__uninitialized_copy_a(__first, __last, __new_start,
         _M_get_Tp_allocator());
  this->_M_impl._M_start = __new_start;
       }
     catch(...)
       {
  _M_destroy_nodes(__new_start._M_node,
     this->_M_impl._M_start._M_node);
  throw;
       }
   }
 else if (__pos._M_cur == this->_M_impl._M_finish._M_cur)
   {
     iterator __new_finish = _M_reserve_elements_at_back(__n);
     try
       {
  std::__uninitialized_copy_a(__first, __last,
         this->_M_impl._M_finish,
         _M_get_Tp_allocator());
  this->_M_impl._M_finish = __new_finish;
       }
     catch(...)
       {
  _M_destroy_nodes(this->_M_impl._M_finish._M_node + 1,
     __new_finish._M_node + 1);
  throw;
       }
   }
 else
   _M_insert_aux(__pos, __first, __last, __n);
      }

  template<typename _Tp, typename _Alloc>

    template<typename... _Args>
      typename deque<_Tp, _Alloc>::iterator
      deque<_Tp, _Alloc>::
      _M_insert_aux(iterator __pos, _Args&&... __args)
      {
 value_type __x_copy(std::forward<_Args>(__args)...);







 difference_type __index = __pos - this->_M_impl._M_start;
 if (static_cast<size_type>(__index) < size() / 2)
   {
     push_front(std::move(front()));
     iterator __front1 = this->_M_impl._M_start;
     ++__front1;
     iterator __front2 = __front1;
     ++__front2;
     __pos = this->_M_impl._M_start + __index;
     iterator __pos1 = __pos;
     ++__pos1;
     std::move(__front2, __pos1, __front1);
   }
 else
   {
     push_back(std::move(back()));
     iterator __back1 = this->_M_impl._M_finish;
     --__back1;
     iterator __back2 = __back1;
     --__back2;
     __pos = this->_M_impl._M_start + __index;
     std::move_backward(__pos, __back2, __back1);
   }
 *__pos = std::move(__x_copy);
 return __pos;
      }

  template <typename _Tp, typename _Alloc>
    void
    deque<_Tp, _Alloc>::
    _M_insert_aux(iterator __pos, size_type __n, const value_type& __x)
    {
      const difference_type __elems_before = __pos - this->_M_impl._M_start;
      const size_type __length = this->size();
      value_type __x_copy = __x;
      if (__elems_before < difference_type(__length / 2))
 {
   iterator __new_start = _M_reserve_elements_at_front(__n);
   iterator __old_start = this->_M_impl._M_start;
   __pos = this->_M_impl._M_start + __elems_before;
   try
     {
       if (__elems_before >= difference_type(__n))
  {
    iterator __start_n = (this->_M_impl._M_start
     + difference_type(__n));
    std::__uninitialized_move_a(this->_M_impl._M_start,
           __start_n, __new_start,
           _M_get_Tp_allocator());
    this->_M_impl._M_start = __new_start;
    std::move(__start_n, __pos, __old_start);
    std::fill(__pos - difference_type(__n), __pos, __x_copy);
  }
       else
  {
    std::__uninitialized_move_fill(this->_M_impl._M_start,
       __pos, __new_start,
       this->_M_impl._M_start,
       __x_copy,
       _M_get_Tp_allocator());
    this->_M_impl._M_start = __new_start;
    std::fill(__old_start, __pos, __x_copy);
  }
     }
   catch(...)
     {
       _M_destroy_nodes(__new_start._M_node,
          this->_M_impl._M_start._M_node);
       throw;
     }
 }
      else
 {
   iterator __new_finish = _M_reserve_elements_at_back(__n);
   iterator __old_finish = this->_M_impl._M_finish;
   const difference_type __elems_after =
     difference_type(__length) - __elems_before;
   __pos = this->_M_impl._M_finish - __elems_after;
   try
     {
       if (__elems_after > difference_type(__n))
  {
    iterator __finish_n = (this->_M_impl._M_finish
      - difference_type(__n));
    std::__uninitialized_move_a(__finish_n,
           this->_M_impl._M_finish,
           this->_M_impl._M_finish,
           _M_get_Tp_allocator());
    this->_M_impl._M_finish = __new_finish;
    std::move_backward(__pos, __finish_n, __old_finish);
    std::fill(__pos, __pos + difference_type(__n), __x_copy);
  }
       else
  {
    std::__uninitialized_fill_move(this->_M_impl._M_finish,
       __pos + difference_type(__n),
       __x_copy, __pos,
       this->_M_impl._M_finish,
       _M_get_Tp_allocator());
    this->_M_impl._M_finish = __new_finish;
    std::fill(__pos, __old_finish, __x_copy);
  }
     }
   catch(...)
     {
       _M_destroy_nodes(this->_M_impl._M_finish._M_node + 1,
          __new_finish._M_node + 1);
       throw;
     }
 }
    }

  template <typename _Tp, typename _Alloc>
    template <typename _ForwardIterator>
      void
      deque<_Tp, _Alloc>::
      _M_insert_aux(iterator __pos,
      _ForwardIterator __first, _ForwardIterator __last,
      size_type __n)
      {
 const difference_type __elemsbefore = __pos - this->_M_impl._M_start;
 const size_type __length = size();
 if (static_cast<size_type>(__elemsbefore) < __length / 2)
   {
     iterator __new_start = _M_reserve_elements_at_front(__n);
     iterator __old_start = this->_M_impl._M_start;
     __pos = this->_M_impl._M_start + __elemsbefore;
     try
       {
  if (__elemsbefore >= difference_type(__n))
    {
      iterator __start_n = (this->_M_impl._M_start
       + difference_type(__n));
      std::__uninitialized_move_a(this->_M_impl._M_start,
      __start_n, __new_start,
      _M_get_Tp_allocator());
      this->_M_impl._M_start = __new_start;
      std::move(__start_n, __pos, __old_start);
      std::copy(__first, __last, __pos - difference_type(__n));
    }
  else
    {
      _ForwardIterator __mid = __first;
      std::advance(__mid, difference_type(__n) - __elemsbefore);
      std::__uninitialized_move_copy(this->_M_impl._M_start,
         __pos, __first, __mid,
         __new_start,
         _M_get_Tp_allocator());
      this->_M_impl._M_start = __new_start;
      std::copy(__mid, __last, __old_start);
    }
       }
     catch(...)
       {
  _M_destroy_nodes(__new_start._M_node,
     this->_M_impl._M_start._M_node);
  throw;
       }
   }
 else
 {
   iterator __new_finish = _M_reserve_elements_at_back(__n);
   iterator __old_finish = this->_M_impl._M_finish;
   const difference_type __elemsafter =
     difference_type(__length) - __elemsbefore;
   __pos = this->_M_impl._M_finish - __elemsafter;
   try
     {
       if (__elemsafter > difference_type(__n))
  {
    iterator __finish_n = (this->_M_impl._M_finish
      - difference_type(__n));
    std::__uninitialized_move_a(__finish_n,
           this->_M_impl._M_finish,
           this->_M_impl._M_finish,
           _M_get_Tp_allocator());
    this->_M_impl._M_finish = __new_finish;
    std::move_backward(__pos, __finish_n, __old_finish);
    std::copy(__first, __last, __pos);
  }
       else
  {
    _ForwardIterator __mid = __first;
    std::advance(__mid, __elemsafter);
    std::__uninitialized_copy_move(__mid, __last, __pos,
       this->_M_impl._M_finish,
       this->_M_impl._M_finish,
       _M_get_Tp_allocator());
    this->_M_impl._M_finish = __new_finish;
    std::copy(__first, __mid, __pos);
  }
     }
   catch(...)
     {
       _M_destroy_nodes(this->_M_impl._M_finish._M_node + 1,
          __new_finish._M_node + 1);
       throw;
     }
 }
      }

   template<typename _Tp, typename _Alloc>
     void
     deque<_Tp, _Alloc>::
     _M_destroy_data_aux(iterator __first, iterator __last)
     {
       for (_Map_pointer __node = __first._M_node + 1;
     __node < __last._M_node; ++__node)
  std::_Destroy(*__node, *__node + _S_buffer_size(),
         _M_get_Tp_allocator());

       if (__first._M_node != __last._M_node)
  {
    std::_Destroy(__first._M_cur, __first._M_last,
    _M_get_Tp_allocator());
    std::_Destroy(__last._M_first, __last._M_cur,
    _M_get_Tp_allocator());
  }
       else
  std::_Destroy(__first._M_cur, __last._M_cur,
         _M_get_Tp_allocator());
     }

  template <typename _Tp, typename _Alloc>
    void
    deque<_Tp, _Alloc>::
    _M_new_elements_at_front(size_type __new_elems)
    {
      if (this->max_size() - this->size() < __new_elems)
 __throw_length_error(("deque::_M_new_elements_at_front"));

      const size_type __new_nodes = ((__new_elems + _S_buffer_size() - 1)
         / _S_buffer_size());
      _M_reserve_map_at_front(__new_nodes);
      size_type __i;
      try
 {
   for (__i = 1; __i <= __new_nodes; ++__i)
     *(this->_M_impl._M_start._M_node - __i) = this->_M_allocate_node();
 }
      catch(...)
 {
   for (size_type __j = 1; __j < __i; ++__j)
     _M_deallocate_node(*(this->_M_impl._M_start._M_node - __j));
   throw;
 }
    }

  template <typename _Tp, typename _Alloc>
    void
    deque<_Tp, _Alloc>::
    _M_new_elements_at_back(size_type __new_elems)
    {
      if (this->max_size() - this->size() < __new_elems)
 __throw_length_error(("deque::_M_new_elements_at_back"));

      const size_type __new_nodes = ((__new_elems + _S_buffer_size() - 1)
         / _S_buffer_size());
      _M_reserve_map_at_back(__new_nodes);
      size_type __i;
      try
 {
   for (__i = 1; __i <= __new_nodes; ++__i)
     *(this->_M_impl._M_finish._M_node + __i) = this->_M_allocate_node();
 }
      catch(...)
 {
   for (size_type __j = 1; __j < __i; ++__j)
     _M_deallocate_node(*(this->_M_impl._M_finish._M_node + __j));
   throw;
 }
    }

  template <typename _Tp, typename _Alloc>
    void
    deque<_Tp, _Alloc>::
    _M_reallocate_map(size_type __nodes_to_add, bool __add_at_front)
    {
      const size_type __old_num_nodes
 = this->_M_impl._M_finish._M_node - this->_M_impl._M_start._M_node + 1;
      const size_type __new_num_nodes = __old_num_nodes + __nodes_to_add;

      _Map_pointer __new_nstart;
      if (this->_M_impl._M_map_size > 2 * __new_num_nodes)
 {
   __new_nstart = this->_M_impl._M_map + (this->_M_impl._M_map_size
      - __new_num_nodes) / 2
    + (__add_at_front ? __nodes_to_add : 0);
   if (__new_nstart < this->_M_impl._M_start._M_node)
     std::copy(this->_M_impl._M_start._M_node,
        this->_M_impl._M_finish._M_node + 1,
        __new_nstart);
   else
     std::copy_backward(this->_M_impl._M_start._M_node,
          this->_M_impl._M_finish._M_node + 1,
          __new_nstart + __old_num_nodes);
 }
      else
 {
   size_type __new_map_size = this->_M_impl._M_map_size
         + std::max(this->_M_impl._M_map_size,
      __nodes_to_add) + 2;

   _Map_pointer __new_map = this->_M_allocate_map(__new_map_size);
   __new_nstart = __new_map + (__new_map_size - __new_num_nodes) / 2
    + (__add_at_front ? __nodes_to_add : 0);
   std::copy(this->_M_impl._M_start._M_node,
      this->_M_impl._M_finish._M_node + 1,
      __new_nstart);
   _M_deallocate_map(this->_M_impl._M_map, this->_M_impl._M_map_size);

   this->_M_impl._M_map = __new_map;
   this->_M_impl._M_map_size = __new_map_size;
 }

      this->_M_impl._M_start._M_set_node(__new_nstart);
      this->_M_impl._M_finish._M_set_node(__new_nstart + __old_num_nodes - 1);
    }





  template<typename _Tp, typename _VTp>
    void
    __fill_a1(const std::_Deque_iterator<_Tp, _Tp&, _Tp*>& __first,
       const std::_Deque_iterator<_Tp, _Tp&, _Tp*>& __last,
       const _VTp& __value)
    {
      typedef std::_Deque_iterator<_Tp, _Tp&, _Tp*> _Iter;
      if (__first._M_node != __last._M_node)
 {
   std::__fill_a1(__first._M_cur, __first._M_last, __value);

   for (typename _Iter::_Map_pointer __node = __first._M_node + 1;
        __node < __last._M_node; ++__node)
     std::__fill_a1(*__node, *__node + _Iter::_S_buffer_size(), __value);

   std::__fill_a1(__last._M_first, __last._M_cur, __value);
 }
      else
 std::__fill_a1(__first._M_cur, __last._M_cur, __value);
    }

  template<bool _IsMove,
    typename _Tp, typename _Ref, typename _Ptr, typename _OI>
    _OI
    __copy_move_dit(std::_Deque_iterator<_Tp, _Ref, _Ptr> __first,
      std::_Deque_iterator<_Tp, _Ref, _Ptr> __last,
      _OI __result)
    {
      typedef std::_Deque_iterator<_Tp, _Ref, _Ptr> _Iter;
      if (__first._M_node != __last._M_node)
 {
   __result
     = std::__copy_move_a1<_IsMove>(__first._M_cur, __first._M_last,
        __result);

   for (typename _Iter::_Map_pointer __node = __first._M_node + 1;
        __node != __last._M_node; ++__node)
     __result
       = std::__copy_move_a1<_IsMove>(*__node,
          *__node + _Iter::_S_buffer_size(),
          __result);

   return std::__copy_move_a1<_IsMove>(__last._M_first, __last._M_cur,
           __result);
 }

      return std::__copy_move_a1<_IsMove>(__first._M_cur, __last._M_cur,
       __result);
    }

  template<bool _IsMove,
    typename _Tp, typename _Ref, typename _Ptr, typename _OI>
    _OI
    __copy_move_a1(std::_Deque_iterator<_Tp, _Ref, _Ptr> __first,
     std::_Deque_iterator<_Tp, _Ref, _Ptr> __last,
     _OI __result)
    { return __copy_move_dit<_IsMove>(__first, __last, __result); }

  template<bool _IsMove,
    typename _ITp, typename _IRef, typename _IPtr, typename _OTp>
    std::_Deque_iterator<_OTp, _OTp&, _OTp*>
    __copy_move_a1(std::_Deque_iterator<_ITp, _IRef, _IPtr> __first,
     std::_Deque_iterator<_ITp, _IRef, _IPtr> __last,
     std::_Deque_iterator<_OTp, _OTp&, _OTp*> __result)
    { return __copy_move_dit<_IsMove>(__first, __last, __result); }

  template<bool _IsMove, typename _II, typename _Tp>
    typename __gnu_cxx::__enable_if<
      __is_random_access_iter<_II>::__value,
      std::_Deque_iterator<_Tp, _Tp&, _Tp*> >::__type
    __copy_move_a1(_II __first, _II __last,
     std::_Deque_iterator<_Tp, _Tp&, _Tp*> __result)
    {
      typedef std::_Deque_iterator<_Tp, _Tp&, _Tp*> _Iter;
      typedef typename _Iter::difference_type difference_type;

      difference_type __len = __last - __first;
      while (__len > 0)
 {
   const difference_type __clen
     = std::min(__len, __result._M_last - __result._M_cur);
   std::__copy_move_a1<_IsMove>(__first, __first + __clen,
           __result._M_cur);

   __first += __clen;
   __result += __clen;
   __len -= __clen;
 }

      return __result;
    }

  template<bool _IsMove,
    typename _Tp, typename _Ref, typename _Ptr, typename _OI>
    _OI
    __copy_move_backward_dit(
  std::_Deque_iterator<_Tp, _Ref, _Ptr> __first,
  std::_Deque_iterator<_Tp, _Ref, _Ptr> __last,
  _OI __result)
    {
      typedef std::_Deque_iterator<_Tp, _Ref, _Ptr> _Iter;
      if (__first._M_node != __last._M_node)
 {
   __result = std::__copy_move_backward_a1<_IsMove>(
  __last._M_first, __last._M_cur, __result);

   for (typename _Iter::_Map_pointer __node = __last._M_node - 1;
        __node != __first._M_node; --__node)
     __result = std::__copy_move_backward_a1<_IsMove>(
  *__node, *__node + _Iter::_S_buffer_size(), __result);

   return std::__copy_move_backward_a1<_IsMove>(
   __first._M_cur, __first._M_last, __result);
 }

      return std::__copy_move_backward_a1<_IsMove>(
  __first._M_cur, __last._M_cur, __result);
    }

  template<bool _IsMove,
    typename _Tp, typename _Ref, typename _Ptr, typename _OI>
    _OI
    __copy_move_backward_a1(
  std::_Deque_iterator<_Tp, _Ref, _Ptr> __first,
  std::_Deque_iterator<_Tp, _Ref, _Ptr> __last,
  _OI __result)
    { return __copy_move_backward_dit<_IsMove>(__first, __last, __result); }

  template<bool _IsMove,
    typename _ITp, typename _IRef, typename _IPtr, typename _OTp>
    std::_Deque_iterator<_OTp, _OTp&, _OTp*>
    __copy_move_backward_a1(
  std::_Deque_iterator<_ITp, _IRef, _IPtr> __first,
  std::_Deque_iterator<_ITp, _IRef, _IPtr> __last,
  std::_Deque_iterator<_OTp, _OTp&, _OTp*> __result)
    { return __copy_move_backward_dit<_IsMove>(__first, __last, __result); }

  template<bool _IsMove, typename _II, typename _Tp>
    typename __gnu_cxx::__enable_if<
      __is_random_access_iter<_II>::__value,
      std::_Deque_iterator<_Tp, _Tp&, _Tp*> >::__type
    __copy_move_backward_a1(_II __first, _II __last,
  std::_Deque_iterator<_Tp, _Tp&, _Tp*> __result)
    {
      typedef std::_Deque_iterator<_Tp, _Tp&, _Tp*> _Iter;
      typedef typename _Iter::difference_type difference_type;

      difference_type __len = __last - __first;
      while (__len > 0)
 {
   difference_type __rlen = __result._M_cur - __result._M_first;
   _Tp* __rend = __result._M_cur;
   if (!__rlen)
     {
       __rlen = _Iter::_S_buffer_size();
       __rend = *(__result._M_node - 1) + __rlen;
     }

   const difference_type __clen = std::min(__len, __rlen);
   std::__copy_move_backward_a1<_IsMove>(__last - __clen, __last, __rend);

   __last -= __clen;
   __result -= __clen;
   __len -= __clen;
 }

      return __result;
    }

  template<typename _Tp, typename _Ref, typename _Ptr, typename _II>
    bool
    __equal_dit(
 const std::_Deque_iterator<_Tp, _Ref, _Ptr>& __first1,
 const std::_Deque_iterator<_Tp, _Ref, _Ptr>& __last1,
 _II __first2)
    {
      typedef std::_Deque_iterator<_Tp, _Ref, _Ptr> _Iter;
      if (__first1._M_node != __last1._M_node)
 {
   if (!std::__equal_aux1(__first1._M_cur, __first1._M_last, __first2))
     return false;

   __first2 += __first1._M_last - __first1._M_cur;
   for (typename _Iter::_Map_pointer __node = __first1._M_node + 1;
        __node != __last1._M_node;
        __first2 += _Iter::_S_buffer_size(), ++__node)
     if (!std::__equal_aux1(*__node, *__node + _Iter::_S_buffer_size(),
      __first2))
       return false;

   return std::__equal_aux1(__last1._M_first, __last1._M_cur, __first2);
 }

      return std::__equal_aux1(__first1._M_cur, __last1._M_cur, __first2);
    }

  template<typename _Tp, typename _Ref, typename _Ptr, typename _II>
    typename __gnu_cxx::__enable_if<
      __is_random_access_iter<_II>::__value, bool>::__type
    __equal_aux1(std::_Deque_iterator<_Tp, _Ref, _Ptr> __first1,
   std::_Deque_iterator<_Tp, _Ref, _Ptr> __last1,
   _II __first2)
    { return std::__equal_dit(__first1, __last1, __first2); }

  template<typename _Tp1, typename _Ref1, typename _Ptr1,
    typename _Tp2, typename _Ref2, typename _Ptr2>
    bool
    __equal_aux1(std::_Deque_iterator<_Tp1, _Ref1, _Ptr1> __first1,
   std::_Deque_iterator<_Tp1, _Ref1, _Ptr1> __last1,
   std::_Deque_iterator<_Tp2, _Ref2, _Ptr2> __first2)
    { return std::__equal_dit(__first1, __last1, __first2); }

  template<typename _II, typename _Tp, typename _Ref, typename _Ptr>
    typename __gnu_cxx::__enable_if<
      __is_random_access_iter<_II>::__value, bool>::__type
    __equal_aux1(_II __first1, _II __last1,
  std::_Deque_iterator<_Tp, _Ref, _Ptr> __first2)
    {
      typedef std::_Deque_iterator<_Tp, _Ref, _Ptr> _Iter;
      typedef typename _Iter::difference_type difference_type;

      difference_type __len = __last1 - __first1;
      while (__len > 0)
 {
   const difference_type __clen
     = std::min(__len, __first2._M_last - __first2._M_cur);
   if (!std::__equal_aux1(__first1, __first1 + __clen, __first2._M_cur))
     return false;

   __first1 += __clen;
   __len -= __clen;
   __first2 += __clen;
 }

      return true;
    }


}
# 70 "/usr/include/c++/10.2.0/deque" 2 3
# 14 "/usr/include/json/reader.h" 2 3 4


# 1 "/usr/include/c++/10.2.0/stack" 1 3 4
# 58 "/usr/include/c++/10.2.0/stack" 3 4
       
# 59 "/usr/include/c++/10.2.0/stack" 3


# 1 "/usr/include/c++/10.2.0/bits/stl_stack.h" 1 3
# 65 "/usr/include/c++/10.2.0/bits/stl_stack.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{

# 98 "/usr/include/c++/10.2.0/bits/stl_stack.h" 3
  template<typename _Tp, typename _Sequence = deque<_Tp> >
    class stack
    {
# 111 "/usr/include/c++/10.2.0/bits/stl_stack.h" 3
      template<typename _Tp1, typename _Seq1>
 friend bool
 operator==(const stack<_Tp1, _Seq1>&, const stack<_Tp1, _Seq1>&);

      template<typename _Tp1, typename _Seq1>
 friend bool
 operator<(const stack<_Tp1, _Seq1>&, const stack<_Tp1, _Seq1>&);
# 126 "/usr/include/c++/10.2.0/bits/stl_stack.h" 3
      template<typename _Alloc>
 using _Uses = typename
   enable_if<uses_allocator<_Sequence, _Alloc>::value>::type;
# 139 "/usr/include/c++/10.2.0/bits/stl_stack.h" 3
    public:
      typedef typename _Sequence::value_type value_type;
      typedef typename _Sequence::reference reference;
      typedef typename _Sequence::const_reference const_reference;
      typedef typename _Sequence::size_type size_type;
      typedef _Sequence container_type;

    protected:

      _Sequence c;

    public:
# 160 "/usr/include/c++/10.2.0/bits/stl_stack.h" 3
      template<typename _Seq = _Sequence, typename _Requires = typename
        enable_if<is_default_constructible<_Seq>::value>::type>
 stack()
 : c() { }

      explicit
      stack(const _Sequence& __c)
      : c(__c) { }

      explicit
      stack(_Sequence&& __c)
      : c(std::move(__c)) { }

      template<typename _Alloc, typename _Requires = _Uses<_Alloc>>
 explicit
 stack(const _Alloc& __a)
 : c(__a) { }

      template<typename _Alloc, typename _Requires = _Uses<_Alloc>>
 stack(const _Sequence& __c, const _Alloc& __a)
 : c(__c, __a) { }

      template<typename _Alloc, typename _Requires = _Uses<_Alloc>>
 stack(_Sequence&& __c, const _Alloc& __a)
 : c(std::move(__c), __a) { }

      template<typename _Alloc, typename _Requires = _Uses<_Alloc>>
 stack(const stack& __q, const _Alloc& __a)
 : c(__q.c, __a) { }

      template<typename _Alloc, typename _Requires = _Uses<_Alloc>>
 stack(stack&& __q, const _Alloc& __a)
 : c(std::move(__q.c), __a) { }





      bool
      empty() const
      { return c.empty(); }


      size_type
      size() const
      { return c.size(); }





      reference
      top()
      {
 ;
 return c.back();
      }





      const_reference
      top() const
      {
 ;
 return c.back();
      }
# 238 "/usr/include/c++/10.2.0/bits/stl_stack.h" 3
      void
      push(const value_type& __x)
      { c.push_back(__x); }


      void
      push(value_type&& __x)
      { c.push_back(std::move(__x)); }







      template<typename... _Args>
 void
 emplace(_Args&&... __args)
 { c.emplace_back(std::forward<_Args>(__args)...); }
# 271 "/usr/include/c++/10.2.0/bits/stl_stack.h" 3
      void
      pop()
      {
 ;
 c.pop_back();
      }


      void
      swap(stack& __s)



      noexcept(__is_nothrow_swappable<_Tp>::value)

      {
 using std::swap;
 swap(c, __s.c);
      }

    };
# 317 "/usr/include/c++/10.2.0/bits/stl_stack.h" 3
  template<typename _Tp, typename _Seq>
    inline bool
    operator==(const stack<_Tp, _Seq>& __x, const stack<_Tp, _Seq>& __y)
    { return __x.c == __y.c; }
# 335 "/usr/include/c++/10.2.0/bits/stl_stack.h" 3
  template<typename _Tp, typename _Seq>
    inline bool
    operator<(const stack<_Tp, _Seq>& __x, const stack<_Tp, _Seq>& __y)
    { return __x.c < __y.c; }


  template<typename _Tp, typename _Seq>
    inline bool
    operator!=(const stack<_Tp, _Seq>& __x, const stack<_Tp, _Seq>& __y)
    { return !(__x == __y); }


  template<typename _Tp, typename _Seq>
    inline bool
    operator>(const stack<_Tp, _Seq>& __x, const stack<_Tp, _Seq>& __y)
    { return __y < __x; }


  template<typename _Tp, typename _Seq>
    inline bool
    operator<=(const stack<_Tp, _Seq>& __x, const stack<_Tp, _Seq>& __y)
    { return !(__y < __x); }


  template<typename _Tp, typename _Seq>
    inline bool
    operator>=(const stack<_Tp, _Seq>& __x, const stack<_Tp, _Seq>& __y)
    { return !(__x < __y); }
# 372 "/usr/include/c++/10.2.0/bits/stl_stack.h" 3
  template<typename _Tp, typename _Seq>
    inline




    void

    swap(stack<_Tp, _Seq>& __x, stack<_Tp, _Seq>& __y)
    noexcept(noexcept(__x.swap(__y)))
    { __x.swap(__y); }

  template<typename _Tp, typename _Seq, typename _Alloc>
    struct uses_allocator<stack<_Tp, _Seq>, _Alloc>
    : public uses_allocator<_Seq, _Alloc>::type { };



}
# 62 "/usr/include/c++/10.2.0/stack" 2 3
# 17 "/usr/include/json/reader.h" 2 3 4
# 26 "/usr/include/json/reader.h" 3 4
#pragma pack(push, 8)

namespace Json {







class __attribute__((deprecated("Use CharReader and CharReaderBuilder instead.")))
                                                              Reader {
public:
  using Char = char;
  using Location = const Char*;






  struct StructuredError {
    ptrdiff_t offset_start;
    ptrdiff_t offset_limit;
    String message;
  };



  __attribute__((deprecated("Use CharReader and CharReaderBuilder instead")))
  Reader();



  __attribute__((deprecated("Use CharReader and CharReaderBuilder instead")))
  Reader(const Features& features);
# 77 "/usr/include/json/reader.h" 3 4
  bool parse(const std::string& document, Value& root,
             bool collectComments = true);
# 96 "/usr/include/json/reader.h" 3 4
  bool parse(const char* beginDoc, const char* endDoc, Value& root,
             bool collectComments = true);



  bool parse(IStream& is, Value& root, bool collectComments = true);
# 111 "/usr/include/json/reader.h" 3 4
  __attribute__((deprecated("Use getFormattedErrorMessages() instead.")))
  String getFormatedErrorMessages() const;
# 121 "/usr/include/json/reader.h" 3 4
  String getFormattedErrorMessages() const;
# 130 "/usr/include/json/reader.h" 3 4
  std::vector<StructuredError> getStructuredErrors() const;
# 139 "/usr/include/json/reader.h" 3 4
  bool pushError(const Value& value, const String& message);
# 149 "/usr/include/json/reader.h" 3 4
  bool pushError(const Value& value, const String& message, const Value& extra);






  bool good() const;

private:
  enum TokenType {
    tokenEndOfStream = 0,
    tokenObjectBegin,
    tokenObjectEnd,
    tokenArrayBegin,
    tokenArrayEnd,
    tokenString,
    tokenNumber,
    tokenTrue,
    tokenFalse,
    tokenNull,
    tokenArraySeparator,
    tokenMemberSeparator,
    tokenComment,
    tokenError
  };

  class Token {
  public:
    TokenType type_;
    Location start_;
    Location end_;
  };

  class ErrorInfo {
  public:
    Token token_;
    String message_;
    Location extra_;
  };

  using Errors = std::deque<ErrorInfo>;

  bool readToken(Token& token);
  void skipSpaces();
  bool match(const Char* pattern, int patternLength);
  bool readComment();
  bool readCStyleComment();
  bool readCppStyleComment();
  bool readString();
  void readNumber();
  bool readValue();
  bool readObject(Token& token);
  bool readArray(Token& token);
  bool decodeNumber(Token& token);
  bool decodeNumber(Token& token, Value& decoded);
  bool decodeString(Token& token);
  bool decodeString(Token& token, String& decoded);
  bool decodeDouble(Token& token);
  bool decodeDouble(Token& token, Value& decoded);
  bool decodeUnicodeCodePoint(Token& token, Location& current, Location end,
                              unsigned int& unicode);
  bool decodeUnicodeEscapeSequence(Token& token, Location& current,
                                   Location end, unsigned int& unicode);
  bool addError(const String& message, Token& token, Location extra = nullptr);
  bool recoverFromError(TokenType skipUntilToken);
  bool addErrorAndRecover(const String& message, Token& token,
                          TokenType skipUntilToken);
  void skipUntilSpace();
  Value& currentValue();
  Char getNextChar();
  void getLocationLineAndColumn(Location location, int& line,
                                int& column) const;
  String getLocationLineAndColumn(Location location) const;
  void addComment(Location begin, Location end, CommentPlacement placement);
  void skipCommentTokens(Token& token);

  static bool containsNewLine(Location begin, Location end);
  static String normalizeEOL(Location begin, Location end);

  using Nodes = std::stack<Value*>;
  Nodes nodes_;
  Errors errors_;
  String document_;
  Location begin_{};
  Location end_{};
  Location current_{};
  Location lastValueEnd_{};
  Value* lastValue_{};
  String commentsBefore_;
  Features features_;
  bool collectComments_{};
};



class CharReader {
public:
  virtual ~CharReader() = default;
# 264 "/usr/include/json/reader.h" 3 4
  virtual bool parse(char const* beginDoc, char const* endDoc, Value* root,
                     String* errs) = 0;

  class Factory {
  public:
    virtual ~Factory() = default;



    virtual CharReader* newCharReader() const = 0;
  };
};
# 289 "/usr/include/json/reader.h" 3 4
class CharReaderBuilder : public CharReader::Factory {
public:
# 332 "/usr/include/json/reader.h" 3 4
  Json::Value settings_;

  CharReaderBuilder();
  ~CharReaderBuilder() override;

  CharReader* newCharReader() const override;




  bool validate(Json::Value* invalid) const;



  Value& operator[](const String& key);






  static void setDefaults(Json::Value* settings);





  static void strictMode(Json::Value* settings);
};





bool parseFromStream(CharReader::Factory const&, IStream&, Value* root,
                              String* errs);
# 393 "/usr/include/json/reader.h" 3 4
 IStream& operator>>(IStream&, Value&);

}

#pragma pack(pop)
# 12 "/usr/include/json/json.h" 2 3 4

# 1 "/usr/include/json/writer.h" 1 3 4
# 23 "/usr/include/json/writer.h" 3 4
#pragma pack(push, 8)

namespace Json {

class Value;
# 41 "/usr/include/json/writer.h" 3 4
class StreamWriter {
protected:
  OStream* sout_;
public:
  StreamWriter();
  virtual ~StreamWriter();







  virtual int write(Value const& root, OStream* sout) = 0;



  class Factory {
  public:
    virtual ~Factory();



    virtual StreamWriter* newStreamWriter() const = 0;
  };
};




String writeString(StreamWriter::Factory const& factory,
                            Value const& root);
# 89 "/usr/include/json/writer.h" 3 4
class StreamWriterBuilder : public StreamWriter::Factory {
public:
# 119 "/usr/include/json/writer.h" 3 4
  Json::Value settings_;

  StreamWriterBuilder();
  ~StreamWriterBuilder() override;




  StreamWriter* newStreamWriter() const override;




  bool validate(Json::Value* invalid) const;


  Value& operator[](const String& key);






  static void setDefaults(Json::Value* settings);
};




class __attribute__((deprecated("Use StreamWriter instead"))) Writer {
public:
  virtual ~Writer();

  virtual String write(const Value& root) = 0;
};
# 168 "/usr/include/json/writer.h" 3 4
class __attribute__((deprecated("Use StreamWriterBuilder instead"))) FastWriter
    : public Writer {
public:
  FastWriter();
  ~FastWriter() override = default;

  void enableYAMLCompatibility();






  void dropNullPlaceholders();

  void omitEndingLineFeed();

public:
  String write(const Value& root) override;

private:
  void writeValue(const Value& value);

  String document_;
  bool yamlCompatibilityEnabled_{false};
  bool dropNullPlaceholders_{false};
  bool omitEndingLineFeed_{false};
};
# 228 "/usr/include/json/writer.h" 3 4
class __attribute__((deprecated("Use StreamWriterBuilder instead")))
    StyledWriter : public Writer {
public:
  StyledWriter();
  ~StyledWriter() override = default;

public:




  String write(const Value& root) override;

private:
  void writeValue(const Value& value);
  void writeArrayValue(const Value& value);
  bool isMultilineArray(const Value& value);
  void pushValue(const String& value);
  void writeIndent();
  void writeWithIndent(const String& value);
  void indent();
  void unindent();
  void writeCommentBeforeValue(const Value& root);
  void writeCommentAfterValueOnSameLine(const Value& root);
  static bool hasCommentForValue(const Value& value);
  static String normalizeEOL(const String& text);

  using ChildValues = std::vector<String>;

  ChildValues childValues_;
  String document_;
  String indentString_;
  unsigned int rightMargin_{74};
  unsigned int indentSize_{3};
  bool addChildValues_{false};
};
# 297 "/usr/include/json/writer.h" 3 4
class __attribute__((deprecated("Use StreamWriterBuilder instead")))
    StyledStreamWriter {
public:



  StyledStreamWriter(String indentation = "\t");
  ~StyledStreamWriter() = default;

public:






  void write(OStream& out, const Value& root);

private:
  void writeValue(const Value& value);
  void writeArrayValue(const Value& value);
  bool isMultilineArray(const Value& value);
  void pushValue(const String& value);
  void writeIndent();
  void writeWithIndent(const String& value);
  void indent();
  void unindent();
  void writeCommentBeforeValue(const Value& root);
  void writeCommentAfterValueOnSameLine(const Value& root);
  static bool hasCommentForValue(const Value& value);
  static String normalizeEOL(const String& text);

  using ChildValues = std::vector<String>;

  ChildValues childValues_;
  OStream* document_;
  String indentString_;
  unsigned int rightMargin_{74};
  String indentation_;
  bool addChildValues_ : 1;
  bool indented_ : 1;
};





String valueToString(Int value);
String valueToString(UInt value);

String valueToString(LargestInt value);
String valueToString(LargestUInt value);
String valueToString(
    double value, unsigned int precision = Value::defaultRealPrecision,
    PrecisionType precisionType = PrecisionType::significantDigits);
String valueToString(bool value);
String valueToQuotedString(const char* value);



 OStream& operator<<(OStream&, const Value& root);

}

#pragma pack(pop)
# 14 "/usr/include/json/json.h" 2 3 4
# 2 "lib/project_lister.cpp" 2


# 3 "lib/project_lister.cpp"
struct Project_Line
{
    String_Const_u8 name;
    String_Const_u8 dir;
    String_Const_u8 project_file_name;
};

struct Project_Line_Array
{
    Project_Line *project_files;
    i32 count;
};

struct Project_File
{
    Project_Line_Array project_array;
};

struct Project_Lister_Result
{
    b32 success;
    i32 index;
};

static char *project_file_path = "/home/sam/.bin/4coder/project.json";
static Project_File project_file = {};

static void add_project_to_file(Application_Links *app, Project *project, Arena *arena)
{
    Project_Line_Array old = project_file.project_array;
    project_file.project_array.count = old.count + 1;
    project_file.project_array.project_files = ((Project_Line*)linalloc_wrap_unintialized(linalloc_push((arena), sizeof(Project_Line)*(old.count + 1), SCu8((u8*)("lib/project_lister.cpp" ":" "34" ":"), (u64)(sizeof("lib/project_lister.cpp" ":" "34" ":") - 1)))));

    Project_Line *project_line = project_file.project_array.project_files;
    for(int i = 0; i < old.count; i++)
    {
        project_line->name = old.project_files[i].name;
        project_line->dir = old.project_files[i].dir;
        project_line->project_file_name = old.project_files[i].project_file_name;
    }
    if(project->loaded)
    {
        project_line[old.count].name = project->name;
        project_line[old.count].dir = project->dir;
        project_line[old.count].project_file_name = SCu8("project.4coder");
    }
}

static void parse_project_file(Application_Links *app, Arena *arena)
{

    FILE *projects = fopen(project_file_path, "r");

    char *json_file;
    long length;
    if (projects)
    {
        fseek (projects, 0, 
# 60 "lib/project_lister.cpp" 3 4
                           2
# 60 "lib/project_lister.cpp"
                                   );
        length = ftell (projects);
        fseek (projects, 0, 
# 62 "lib/project_lister.cpp" 3 4
                           0
# 62 "lib/project_lister.cpp"
                                   );
        json_file = (char*)malloc ((length+1)*sizeof(char));
        if (json_file)
        {
            fread (json_file, sizeof(char), length, projects);
        }
        fclose (projects);
    }

    printf(json_file);
    project_file.project_array.count = 1;
    project_file.project_array.project_files = ((Project_Line*)linalloc_wrap_unintialized(linalloc_push((arena), sizeof(Project_Line)*(1), SCu8((u8*)("lib/project_lister.cpp" ":" "73" ":"), (u64)(sizeof("lib/project_lister.cpp" ":" "73" ":") - 1)))));

    Project_Line *project_line = project_file.project_array.project_files;
    for(int i = 0; i < 1; i++)
    {
        project_line->name = SCu8("4coder");
        project_line->dir = SCu8("/home/sam/.bin/4coder");
        project_line->project_file_name = SCu8("project.4coder");
    }
}

static void
set_project(Application_Links *app, Arena *arena, i32 index)
{
    Project_Line proj = project_file.project_array.project_files[index];
    File_Name_Data dump = dump_file_search_up_path(app, arena, proj.dir, proj.project_file_name);
    set_current_project_from_data(app, proj.project_file_name,
                                  dump.data, proj.dir);
}

static Project_Lister_Result
get_projects_from_file(Application_Links *app, Arena *arena, String_Const_u8 query)
{
    Project_Lister_Result result = {};

    Lister_Block lister(app, arena);
    lister_set_query(lister, query);
    lister_set_default_handlers(lister);


    parse_project_file(app, arena);
    Project_Line *project_line = project_file.project_array.project_files;
    i32 count = project_file.project_array.count;
    for(i32 i = 0; i < count; i++)
    {
        lister_add_item(lister, project_line->name, project_line->dir, (void*)(((u8*)0) + i), 0);
    }

    Lister_Result l_result = run_lister(app, lister);
    if(!l_result.canceled)
    {
        result.success = true;
        result.index = (i32)((u8*)(l_result.user_data) - (u8*)(0));
    }

    return (result);
}

static Project_Lister_Result
get_projects_from_file(Application_Links *app, Arena *arena, char *query){
    return(get_projects_from_file(app, arena, SCu8(query)));
}

CUSTOM_COMMAND(project_lister, "lib/project_lister.cpp", 126, Normal)
CUSTOM_DOC("Open a lister of all projects")
{
    Scratch_Block scratch(app);
    Project_Lister_Result proj =
        get_projects_from_file(app, scratch, "Project:");
    if (proj.success){
        set_project(app, scratch, proj.index);
    }
}

CUSTOM_COMMAND(add_project_to_master, "lib/project_lister.cpp", 137, Normal)
CUSTOM_DOC("Adds loaded project into master file")
{
    Scratch_Block scratch(app);
    add_project_to_file(app, &current_project, scratch);
}
# 15 "4coder_sam.cpp" 2





static void
custom_render_buffer(Application_Links *app, View_ID view_id,
                     Face_ID face_id, Buffer_ID buffer,
                     Text_Layout_ID text_layout_id,
                     Rect_f32 rect) {
    Profile_Scope_Block profile_block_25 ((app), SCu8((u8*)("render buffer"), (u64)(sizeof("render buffer") - 1)), SCu8((u8*)("4coder_sam.cpp" ":" "25" ":"), (u64)(sizeof("4coder_sam.cpp" ":" "25" ":") - 1)));

    View_ID active_view = get_active_view(app, Access_Always);
    b32 is_active_view = (active_view == view_id);
    Rect_f32 prev_clip = draw_set_clip(app, rect);

    Range_i64 visible_range = text_layout_get_visible_range(app, text_layout_id);


    Face_Metrics metrics = get_face_metrics(app, face_id);
    f32 cursor_roundness =
        metrics.normal_advance * global_config.cursor_roundness;
    f32 mark_thickness = (f32)global_config.mark_thickness;


    Token_Array token_array = get_token_array_from_buffer(app, buffer);
    if (token_array.tokens != 0) {
        draw_cpp_token_colors(app, text_layout_id, &token_array);


        if (global_config.use_comment_keyword) {
            Comment_Highlight_Pair pairs[] = {
                {SCu8((u8*)("NOTE"), (u64)(sizeof("NOTE") - 1)), finalize_color(defcolor_comment_pop, 0)},
                {SCu8((u8*)("TODO"), (u64)(sizeof("TODO") - 1)), finalize_color(defcolor_comment_pop, 1)},
            };
            draw_comment_highlights(app, buffer, text_layout_id, &token_array, pairs,
                                    ((sizeof(pairs))/(sizeof(*pairs))));
        }
    } else {
        paint_text_color_fcolor(app, text_layout_id, visible_range,
                                fcolor_id(defcolor_text_default));
    }

    i64 cursor_pos = view_correct_cursor(app, view_id);
    view_correct_mark(app, view_id);


    if (global_config.use_scope_highlight) {
        Color_Array colors = finalize_color_array(defcolor_back_cycle);
        draw_scope_highlight(app, buffer, text_layout_id, cursor_pos, colors.vals,
                             colors.count);
    }

    if (global_config.use_error_highlight || global_config.use_jump_highlight) {

        String_Const_u8 name = SCu8((u8*)("*compilation*"), (u64)(sizeof("*compilation*") - 1));
        Buffer_ID compilation_buffer = get_buffer_by_name(app, name, Access_Always);
        if (global_config.use_error_highlight) {
            draw_jump_highlights(app, buffer, text_layout_id, compilation_buffer,
                                 fcolor_id(defcolor_highlight_junk));
        }


        if (global_config.use_jump_highlight) {
            Buffer_ID jump_buffer = get_locked_jump_buffer(app);
            if (jump_buffer != compilation_buffer) {
                draw_jump_highlights(app, buffer, text_layout_id, jump_buffer,
                                     fcolor_id(defcolor_highlight_white));
            }
        }
    }


    if (global_config.use_paren_helper) {
        Color_Array colors = finalize_color_array(defcolor_text_cycle);
        draw_paren_highlight(app, buffer, text_layout_id, cursor_pos, colors.vals,
                             colors.count);
    }


    if (global_config.highlight_line_at_cursor && is_active_view) {
        i64 line_number = get_line_number_from_pos(app, buffer, cursor_pos);
        draw_line_highlight(app, text_layout_id, line_number,
                            fcolor_id(defcolor_highlight_cursor_line));
    }


    b64 show_whitespace = false;
    view_get_setting(app, view_id, ViewSetting_ShowWhitespace, &show_whitespace);
    if (show_whitespace) {
        if (token_array.tokens == 0) {
            draw_whitespace_highlight(app, buffer, text_layout_id, cursor_roundness);
        } else {
            draw_whitespace_highlight(app, text_layout_id, &token_array,
                                      cursor_roundness);
        }
    }


    switch (fcoder_mode) {
        case FCoderMode_Original: {
            draw_original_4coder_style_cursor_mark_highlight(
                                                             app, view_id, is_active_view, buffer, text_layout_id, cursor_roundness,
                                                             mark_thickness);
        } break;
        case FCoderMode_NotepadLike: {
            draw_notepad_style_cursor_highlight(app, view_id, buffer, text_layout_id,
                                                cursor_roundness);
        } break;
    }


    paint_fade_ranges(app, text_layout_id, buffer);


    draw_text_layout_default(app, text_layout_id);

    draw_set_clip(app, prev_clip);
}


static void
custom_render_caller(Application_Links *app, Frame_Info frame_info, View_ID view_id) {
    Profile_Scope_Block profile_block_138 ((app), SCu8((u8*)("default render caller"), (u64)(sizeof("default render caller") - 1)), SCu8((u8*)("4coder_sam.cpp" ":" "138" ":"), (u64)(sizeof("4coder_sam.cpp" ":" "138" ":") - 1)));
    View_ID active_view = get_active_view(app, Access_Always);
    b32 is_active_view = (active_view == view_id);

    Buffer_ID buffer = view_get_buffer(app, view_id, Access_Always);
    Face_ID face_id = get_face_id(app, buffer);
    Face_Metrics face_metrics = get_face_metrics(app, face_id);
    f32 line_height = face_metrics.line_height;
    f32 digit_advance = face_metrics.decimal_digit_advance;

    Rect_f32 region = vim_draw_background_and_margin(app, view_id, is_active_view, line_height + 2.0f);
    Rect_f32 prev_clip = draw_set_clip(app, region);


    b64 showing_file_bar = false;
    if (view_get_setting(app, view_id, ViewSetting_ShowFileBar, &showing_file_bar) && showing_file_bar){





        Rect_f32_Pair pair = layout_file_bar_on_top(region, line_height);
        vim_draw_file_bar(app, view_id, buffer, face_id, pair.min);
        region = pair.max;

    }

    Buffer_Scroll scroll = view_get_buffer_scroll(app, view_id);

    Buffer_Point_Delta_Result delta = delta_apply(app, view_id,
                                                  frame_info.animation_dt, scroll);
    if (!block_match((&scroll.position), (&delta.point), sizeof(*(&scroll.position)))){
        block_copy((&scroll.position), (&delta.point), sizeof(*(&scroll.position)));
        view_set_buffer_scroll(app, view_id, scroll, SetBufferScroll_NoCursorChange);
    }
    if (delta.still_animating){
        animate_in_n_milliseconds(app, 0);
    }


    {
        Query_Bar *space[32];
        Query_Bar_Ptr_Array query_bars = {};
        query_bars.ptrs = space;
        if (get_active_query_bars(app, view_id, ((sizeof(space))/(sizeof(*space))), &query_bars)){
            for (i32 i = 0; i < query_bars.count; i += 1){
                Rect_f32_Pair pair = layout_query_bar_on_top(region, line_height, 1);
                draw_query_bar(app, query_bars.ptrs[i], face_id, pair.min);
                region = pair.max;
            }
        }
    }


    if (show_fps_hud){
        Rect_f32_Pair pair = layout_fps_hud_on_bottom(region, line_height);
        draw_fps_hud(app, frame_info, face_id, pair.max);
        region = pair.min;
        animate_in_n_milliseconds(app, 1000);
    }


    Rect_f32 line_number_rect = {};
    if (global_config.show_line_number_margins){
        Rect_f32_Pair pair = layout_line_number_margin(app, buffer, region, digit_advance);
        line_number_rect = pair.min;
        region = pair.max;
    }


    Buffer_Point buffer_point = scroll.position;
    Text_Layout_ID text_layout_id = text_layout_create(app, buffer, region, buffer_point);


    use_relative_line_number_mode = true;
    if(global_config.show_line_number_margins) {
        if(use_relative_line_number_mode) {
            draw_relative_line_number_margin(app, view_id, buffer, face_id, text_layout_id, line_number_rect);
        } else {
            draw_line_number_margin(app, view_id, buffer, face_id, text_layout_id, line_number_rect);
        }
    }

    vim_render_buffer(app, view_id, face_id, buffer, text_layout_id, region);

    text_layout_free(app, text_layout_id);
    draw_set_clip(app, prev_clip);
}


static void
custom_setup_default_mapping(Application_Links* app, Mapping *mapping, Vim_Key vim_leader) {
    Mapping *m = 0; Command_Map *map = 0;
    m = (mapping);





    map = mapping_get_or_make_map(m, (mapid_global));

    map_set_binding_l(m, map, default_startup, InputEventKind_Core, (CoreCode_Startup), 0);
    map_set_binding_l(m, map, default_try_exit, InputEventKind_Core, (CoreCode_TryExit), 0);
    map_set_binding_l(m, map, project_go_to_root_directory, InputEventKind_KeyStroke, (KeyCode_H), KeyCode_Control, 0);
    map_set_binding_l(m, map, toggle_fullscreen, InputEventKind_KeyStroke, (KeyCode_Alt), KeyCode_Return, 0);
    map_set_binding_l(m, map, save_all_dirty_buffers, InputEventKind_KeyStroke, (KeyCode_S), KeyCode_Control, KeyCode_Shift, 0);
    map_set_binding_l(m, map, change_to_build_panel, InputEventKind_KeyStroke, (KeyCode_Period), KeyCode_Alt, 0);
    map_set_binding_l(m, map, close_build_panel, InputEventKind_KeyStroke, (KeyCode_Comma), KeyCode_Alt, 0);
    map_set_binding_l(m, map, goto_next_jump, InputEventKind_KeyStroke, (KeyCode_N), KeyCode_Control, 0);
    map_set_binding_l(m, map, goto_prev_jump, InputEventKind_KeyStroke, (KeyCode_P), KeyCode_Control, 0);
    map_set_binding_l(m, map, build_in_build_panel, InputEventKind_KeyStroke, (KeyCode_M), KeyCode_Alt, 0);

    map_set_binding_l(m, map, goto_first_jump, InputEventKind_KeyStroke, (KeyCode_M), KeyCode_Alt, KeyCode_Shift, 0);
    map_set_binding_l(m, map, toggle_filebar, InputEventKind_KeyStroke, (KeyCode_B), KeyCode_Alt, 0);
    map_set_binding_l(m, map, execute_any_cli, InputEventKind_KeyStroke, (KeyCode_Z), KeyCode_Alt, 0);
    map_set_binding_l(m, map, execute_previous_cli, InputEventKind_KeyStroke, (KeyCode_Z), KeyCode_Alt, KeyCode_Shift, 0);
    map_set_binding_l(m, map, command_lister, InputEventKind_KeyStroke, (KeyCode_X), KeyCode_Alt, 0);
    map_set_binding_l(m, map, project_command_lister, InputEventKind_KeyStroke, (KeyCode_X), KeyCode_Alt, KeyCode_Shift, 0);
    map_set_binding_l(m, map, list_all_functions_current_buffer, InputEventKind_KeyStroke, (KeyCode_I), KeyCode_Control, KeyCode_Shift, 0);
    map_set_binding_l(m, map, project_fkey_command, InputEventKind_KeyStroke, (KeyCode_F1), 0);
    map_set_binding_l(m, map, project_fkey_command, InputEventKind_KeyStroke, (KeyCode_F2), 0);
    map_set_binding_l(m, map, project_fkey_command, InputEventKind_KeyStroke, (KeyCode_F3), 0);
    map_set_binding_l(m, map, project_fkey_command, InputEventKind_KeyStroke, (KeyCode_F4), 0);
    map_set_binding_l(m, map, project_fkey_command, InputEventKind_KeyStroke, (KeyCode_F5), 0);
    map_set_binding_l(m, map, project_fkey_command, InputEventKind_KeyStroke, (KeyCode_F6), 0);
    map_set_binding_l(m, map, project_fkey_command, InputEventKind_KeyStroke, (KeyCode_F7), 0);
    map_set_binding_l(m, map, project_fkey_command, InputEventKind_KeyStroke, (KeyCode_F8), 0);
    map_set_binding_l(m, map, project_fkey_command, InputEventKind_KeyStroke, (KeyCode_F9), 0);
    map_set_binding_l(m, map, project_fkey_command, InputEventKind_KeyStroke, (KeyCode_F12), 0);
    map_set_binding_l(m, map, project_fkey_command, InputEventKind_KeyStroke, (KeyCode_F13), 0);
    map_set_binding_l(m, map, project_fkey_command, InputEventKind_KeyStroke, (KeyCode_F14), 0);
    map_set_binding_l(m, map, project_fkey_command, InputEventKind_KeyStroke, (KeyCode_F15), 0);
    map_set_binding_l(m, map, project_fkey_command, InputEventKind_KeyStroke, (KeyCode_F16), 0);
    map_set_binding_l(m, map, exit_4coder, InputEventKind_KeyStroke, (KeyCode_F4), KeyCode_Alt, 0);
    map_set_binding_l(m, map, mouse_wheel_scroll, InputEventKind_MouseWheel, 0, 0);
    map_set_binding_l(m, map, mouse_wheel_change_face_size, InputEventKind_MouseWheel, 0, KeyCode_Control, 0);





    map = mapping_get_or_make_map(m, (mapid_file));
    map_set_parent(m, map, (mapid_global));

    map_set_binding_l(m, map, click_set_cursor_and_mark, InputEventKind_MouseButton, (MouseCode_Left), 0);
    map_set_binding_l(m, map, click_set_cursor, InputEventKind_MouseButtonRelease, (MouseCode_Left), 0);
    map_set_binding_l(m, map, click_set_cursor_and_mark, InputEventKind_Core, (CoreCode_ClickActivateView), 0);
    map_set_binding_l(m, map, click_set_cursor_if_lbutton, InputEventKind_MouseMove, 0, 0);

    map_set_binding_text_input(map, write_text_input);

    map_set_binding_l(m, map, delete_char, InputEventKind_KeyStroke, (KeyCode_Delete), 0);
    map_set_binding_l(m, map, backspace_char, InputEventKind_KeyStroke, (KeyCode_Backspace), 0);
    map_set_binding_l(m, map, move_up, InputEventKind_KeyStroke, (KeyCode_Up), 0);
    map_set_binding_l(m, map, move_down, InputEventKind_KeyStroke, (KeyCode_Down), 0);
    map_set_binding_l(m, map, move_left, InputEventKind_KeyStroke, (KeyCode_Left), 0);
    map_set_binding_l(m, map, move_right, InputEventKind_KeyStroke, (KeyCode_Right), 0);
    map_set_binding_l(m, map, seek_end_of_line, InputEventKind_KeyStroke, (KeyCode_End), 0);
    map_set_binding_l(m, map, seek_beginning_of_line, InputEventKind_KeyStroke, (KeyCode_Home), 0);
    map_set_binding_l(m, map, page_up, InputEventKind_KeyStroke, (KeyCode_PageUp), 0);
    map_set_binding_l(m, map, page_down, InputEventKind_KeyStroke, (KeyCode_PageDown), 0);
    map_set_binding_l(m, map, goto_beginning_of_file, InputEventKind_KeyStroke, (KeyCode_PageUp), KeyCode_Control, 0);
    map_set_binding_l(m, map, goto_end_of_file, InputEventKind_KeyStroke, (KeyCode_PageDown), KeyCode_Control, 0);
    map_set_binding_l(m, map, move_up_to_blank_line_end, InputEventKind_KeyStroke, (KeyCode_Up), KeyCode_Control, 0);
    map_set_binding_l(m, map, move_down_to_blank_line_end, InputEventKind_KeyStroke, (KeyCode_Down), KeyCode_Control, 0);
    map_set_binding_l(m, map, move_left_whitespace_boundary, InputEventKind_KeyStroke, (KeyCode_Left), KeyCode_Control, 0);
    map_set_binding_l(m, map, move_right_whitespace_boundary, InputEventKind_KeyStroke, (KeyCode_Right), KeyCode_Control, 0);
    map_set_binding_l(m, map, move_line_up, InputEventKind_KeyStroke, (KeyCode_Up), KeyCode_Alt, 0);
    map_set_binding_l(m, map, move_line_down, InputEventKind_KeyStroke, (KeyCode_Down), KeyCode_Alt, 0);
    map_set_binding_l(m, map, backspace_alpha_numeric_boundary, InputEventKind_KeyStroke, (KeyCode_Backspace), KeyCode_Control, 0);
    map_set_binding_l(m, map, delete_alpha_numeric_boundary, InputEventKind_KeyStroke, (KeyCode_Delete), KeyCode_Control, 0);
    map_set_binding_l(m, map, snipe_backward_whitespace_or_token_boundary, InputEventKind_KeyStroke, (KeyCode_Backspace), KeyCode_Alt, 0);
    map_set_binding_l(m, map, snipe_forward_whitespace_or_token_boundary, InputEventKind_KeyStroke, (KeyCode_Delete), KeyCode_Alt, 0);
    map_set_binding_l(m, map, set_mark, InputEventKind_KeyStroke, (KeyCode_Space), KeyCode_Control, 0);
    map_set_binding_l(m, map, copy, InputEventKind_KeyStroke, (KeyCode_C), KeyCode_Control, 0);
    map_set_binding_l(m, map, delete_range, InputEventKind_KeyStroke, (KeyCode_D), KeyCode_Control, 0);
    map_set_binding_l(m, map, delete_line, InputEventKind_KeyStroke, (KeyCode_D), KeyCode_Control, KeyCode_Shift, 0);
    map_set_binding_l(m, map, goto_line, InputEventKind_KeyStroke, (KeyCode_G), KeyCode_Control, 0);
    map_set_binding_l(m, map, paste_and_indent, InputEventKind_KeyStroke, (KeyCode_V), KeyCode_Control, 0);
    map_set_binding_l(m, map, paste_next_and_indent, InputEventKind_KeyStroke, (KeyCode_V), KeyCode_Control, KeyCode_Shift, 0);
    map_set_binding_l(m, map, cut, InputEventKind_KeyStroke, (KeyCode_X), KeyCode_Control, 0);
    map_set_binding_l(m, map, vim_redo, InputEventKind_KeyStroke, (KeyCode_Y), KeyCode_Control, 0);
    map_set_binding_l(m, map, vim_undo, InputEventKind_KeyStroke, (KeyCode_Z), KeyCode_Control, 0);
    map_set_binding_l(m, map, if_read_only_goto_position, InputEventKind_KeyStroke, (KeyCode_Return), 0);
    map_set_binding_l(m, map, if_read_only_goto_position_same_panel, InputEventKind_KeyStroke, (KeyCode_Return), KeyCode_Shift, 0);
    map_set_binding_l(m, map, view_jump_list_with_lister, InputEventKind_KeyStroke, (KeyCode_Period), KeyCode_Control, KeyCode_Shift, 0);
    map_set_binding_l(m, map, vim_enter_normal_mode_escape, InputEventKind_KeyStroke, (KeyCode_Escape), 0);





    map = mapping_get_or_make_map(m, (mapid_code));
    map_set_parent(m, map, (mapid_file));

    map_set_binding_l(m, map, click_set_cursor_and_mark, InputEventKind_MouseButton, (MouseCode_Left), 0);
    map_set_binding_l(m, map, click_set_cursor, InputEventKind_MouseButtonRelease, (MouseCode_Left), 0);
    map_set_binding_l(m, map, click_set_cursor_and_mark, InputEventKind_Core, (CoreCode_ClickActivateView), 0);
    map_set_binding_l(m, map, click_set_cursor_if_lbutton, InputEventKind_MouseMove, 0, 0);

    map_set_binding_text_input(map, vim_write_text_abbrev_and_auto_indent);

    map_set_binding_l(m, map, move_left_alpha_numeric_boundary, InputEventKind_KeyStroke, (KeyCode_Left), KeyCode_Control, 0);
    map_set_binding_l(m, map, move_right_alpha_numeric_boundary, InputEventKind_KeyStroke, (KeyCode_Right), KeyCode_Control, 0);
    map_set_binding_l(m, map, move_left_alpha_numeric_or_camel_boundary, InputEventKind_KeyStroke, (KeyCode_Left), KeyCode_Alt, 0);
    map_set_binding_l(m, map, move_right_alpha_numeric_or_camel_boundary, InputEventKind_KeyStroke, (KeyCode_Right), KeyCode_Alt, 0);
    map_set_binding_l(m, map, vim_backspace_char, InputEventKind_KeyStroke, (KeyCode_Backspace), 0);
    map_set_binding_l(m, map, comment_line_toggle, InputEventKind_KeyStroke, (KeyCode_Semicolon), KeyCode_Control, 0);
    map_set_binding_l(m, map, word_complete, InputEventKind_KeyStroke, (KeyCode_Tab), 0);

    map_set_binding_l(m, map, auto_indent_range, InputEventKind_KeyStroke, (KeyCode_Tab), KeyCode_Control, 0);
    map_set_binding_l(m, map, auto_indent_line_at_cursor, InputEventKind_KeyStroke, (KeyCode_Tab), KeyCode_Shift, 0);
    map_set_binding_l(m, map, word_complete_drop_down, InputEventKind_KeyStroke, (KeyCode_Tab), KeyCode_Shift, KeyCode_Control, 0);
    map_set_binding_l(m, map, write_block, InputEventKind_KeyStroke, (KeyCode_R), KeyCode_Alt, 0);
    map_set_binding_l(m, map, write_todo, InputEventKind_KeyStroke, (KeyCode_T), KeyCode_Alt, 0);
    map_set_binding_l(m, map, write_note, InputEventKind_KeyStroke, (KeyCode_Y), KeyCode_Alt, 0);
    map_set_binding_l(m, map, list_all_locations_of_type_definition, InputEventKind_KeyStroke, (KeyCode_D), KeyCode_Alt, 0);
    map_set_binding_l(m, map, list_all_locations_of_type_definition_of_identifier, InputEventKind_KeyStroke, (KeyCode_T), KeyCode_Alt, KeyCode_Shift, 0);
    map_set_binding_l(m, map, open_long_braces, InputEventKind_KeyStroke, (KeyCode_LeftBracket), KeyCode_Control, 0);
    map_set_binding_l(m, map, open_long_braces_semicolon, InputEventKind_KeyStroke, (KeyCode_LeftBracket), KeyCode_Control, KeyCode_Shift, 0);
    map_set_binding_l(m, map, open_long_braces_break, InputEventKind_KeyStroke, (KeyCode_RightBracket), KeyCode_Control, KeyCode_Shift, 0);
    map_set_binding_l(m, map, select_surrounding_scope, InputEventKind_KeyStroke, (KeyCode_LeftBracket), KeyCode_Alt, 0);
    map_set_binding_l(m, map, select_surrounding_scope_maximal, InputEventKind_KeyStroke, (KeyCode_LeftBracket), KeyCode_Alt, KeyCode_Shift, 0);
    map_set_binding_l(m, map, select_prev_scope_absolute, InputEventKind_KeyStroke, (KeyCode_RightBracket), KeyCode_Alt, 0);
    map_set_binding_l(m, map, select_prev_top_most_scope, InputEventKind_KeyStroke, (KeyCode_RightBracket), KeyCode_Alt, KeyCode_Shift, 0);
    map_set_binding_l(m, map, select_next_scope_absolute, InputEventKind_KeyStroke, (KeyCode_Quote), KeyCode_Alt, 0);
    map_set_binding_l(m, map, select_next_scope_after_current, InputEventKind_KeyStroke, (KeyCode_Quote), KeyCode_Alt, KeyCode_Shift, 0);
    map_set_binding_l(m, map, place_in_scope, InputEventKind_KeyStroke, (KeyCode_ForwardSlash), KeyCode_Alt, 0);
    map_set_binding_l(m, map, delete_current_scope, InputEventKind_KeyStroke, (KeyCode_Minus), KeyCode_Alt, 0);
    map_set_binding_l(m, map, if0_off, InputEventKind_KeyStroke, (KeyCode_I), KeyCode_Alt, 0);
    map_set_binding_l(m, map, open_file_in_quotes, InputEventKind_KeyStroke, (KeyCode_1), KeyCode_Alt, 0);
    map_set_binding_l(m, map, open_matching_file_cpp, InputEventKind_KeyStroke, (KeyCode_2), KeyCode_Alt, 0);
    map_set_binding_l(m, map, write_zero_struct, InputEventKind_KeyStroke, (KeyCode_0), KeyCode_Control, 0);





    map = mapping_get_or_make_map(m, (vim_mapid_normal));
    map_set_parent(m, map, (mapid_global));

    map_set_binding_l(m, map, vim_start_mouse_select, InputEventKind_MouseButton, (MouseCode_Left), 0);
    map_set_binding_l(m, map, click_set_cursor, InputEventKind_MouseButtonRelease, (MouseCode_Left), 0);
    map_set_binding_l(m, map, click_set_cursor_and_mark, InputEventKind_Core, (CoreCode_ClickActivateView), 0);
    map_set_binding_l(m, map, vim_mouse_drag, InputEventKind_MouseMove, 0, 0);





    map = mapping_get_or_make_map(m, (vim_mapid_visual));
    map_set_parent(m, map, (vim_mapid_normal));
# 399 "4coder_sam.cpp"
    Vim_Binding_Map* vim_map = 0;





    vim_map = vim_select_map_(app, &vim_map_text_objects);

    vim_bind_(vim_map, vim_text_object_inner_scope, SCu8((u8*)("vim_text_object_inner_scope"), (u64)(sizeof("vim_text_object_inner_scope") - 1)), vim_key_sequence(vim_key(KeyCode_I), vim_key(KeyCode_LeftBracket, KeyCode_Shift)));
    vim_bind_(vim_map, vim_text_object_inner_scope, SCu8((u8*)("vim_text_object_inner_scope"), (u64)(sizeof("vim_text_object_inner_scope") - 1)), vim_key_sequence(vim_key(KeyCode_I), vim_key(KeyCode_RightBracket, KeyCode_Shift)));
    vim_bind_(vim_map, vim_text_object_inner_paren, SCu8((u8*)("vim_text_object_inner_paren"), (u64)(sizeof("vim_text_object_inner_paren") - 1)), vim_key_sequence(vim_key(KeyCode_I), vim_key(KeyCode_9, KeyCode_Shift)));
    vim_bind_(vim_map, vim_text_object_inner_paren, SCu8((u8*)("vim_text_object_inner_paren"), (u64)(sizeof("vim_text_object_inner_paren") - 1)), vim_key_sequence(vim_key(KeyCode_I), vim_key(KeyCode_0, KeyCode_Shift)));
    vim_bind_(vim_map, vim_text_object_inner_single_quotes, SCu8((u8*)("vim_text_object_inner_single_quotes"), (u64)(sizeof("vim_text_object_inner_single_quotes") - 1)), vim_key_sequence(vim_key(KeyCode_I), vim_key(KeyCode_Quote)));
    vim_bind_(vim_map, vim_text_object_inner_double_quotes, SCu8((u8*)("vim_text_object_inner_double_quotes"), (u64)(sizeof("vim_text_object_inner_double_quotes") - 1)), vim_key_sequence(vim_key(KeyCode_I), vim_key(KeyCode_Quote, KeyCode_Shift)));
    vim_bind_(vim_map, vim_text_object_inner_word, SCu8((u8*)("vim_text_object_inner_word"), (u64)(sizeof("vim_text_object_inner_word") - 1)), vim_key_sequence(vim_key(KeyCode_I), vim_key(KeyCode_W)));
    vim_bind_(vim_map, vim_text_object_isearch_repeat_forward, SCu8((u8*)("vim_text_object_isearch_repeat_forward"), (u64)(sizeof("vim_text_object_isearch_repeat_forward") - 1)), vim_key_sequence(vim_key(KeyCode_G), vim_key(KeyCode_N)));
    vim_bind_(vim_map, vim_text_object_isearch_repeat_backward, SCu8((u8*)("vim_text_object_isearch_repeat_backward"), (u64)(sizeof("vim_text_object_isearch_repeat_backward") - 1)), vim_key_sequence(vim_key(KeyCode_G), vim_key(KeyCode_N, KeyCode_Shift)));





    vim_map = vim_select_map_(app, &vim_map_operator_pending);
    vim_add_parent_binding_map(vim_map, &(vim_map_text_objects));

    vim_bind_(vim_map, vim_motion_left, SCu8((u8*)("vim_motion_left"), (u64)(sizeof("vim_motion_left") - 1)), vim_key_sequence(vim_key(KeyCode_H)));
    vim_bind_(vim_map, vim_motion_down, SCu8((u8*)("vim_motion_down"), (u64)(sizeof("vim_motion_down") - 1)), vim_key_sequence(vim_key(KeyCode_J)));
    vim_bind_(vim_map, vim_motion_up, SCu8((u8*)("vim_motion_up"), (u64)(sizeof("vim_motion_up") - 1)), vim_key_sequence(vim_key(KeyCode_K)));
    vim_bind_(vim_map, vim_motion_right, SCu8((u8*)("vim_motion_right"), (u64)(sizeof("vim_motion_right") - 1)), vim_key_sequence(vim_key(KeyCode_L)));
    vim_bind_(vim_map, vim_motion_left, SCu8((u8*)("vim_motion_left"), (u64)(sizeof("vim_motion_left") - 1)), vim_key_sequence(vim_key(KeyCode_Left)));
    vim_bind_(vim_map, vim_motion_down, SCu8((u8*)("vim_motion_down"), (u64)(sizeof("vim_motion_down") - 1)), vim_key_sequence(vim_key(KeyCode_Down)));
    vim_bind_(vim_map, vim_motion_up, SCu8((u8*)("vim_motion_up"), (u64)(sizeof("vim_motion_up") - 1)), vim_key_sequence(vim_key(KeyCode_Up)));
    vim_bind_(vim_map, vim_motion_right, SCu8((u8*)("vim_motion_right"), (u64)(sizeof("vim_motion_right") - 1)), vim_key_sequence(vim_key(KeyCode_Right)));
    vim_bind_(vim_map, vim_motion_to_empty_line_down, SCu8((u8*)("vim_motion_to_empty_line_down"), (u64)(sizeof("vim_motion_to_empty_line_down") - 1)), vim_key_sequence(vim_key(KeyCode_RightBracket, KeyCode_Shift)));
    vim_bind_(vim_map, vim_motion_to_empty_line_up, SCu8((u8*)("vim_motion_to_empty_line_up"), (u64)(sizeof("vim_motion_to_empty_line_up") - 1)), vim_key_sequence(vim_key(KeyCode_LeftBracket, KeyCode_Shift)));
    vim_bind_(vim_map, vim_motion_word, SCu8((u8*)("vim_motion_word"), (u64)(sizeof("vim_motion_word") - 1)), vim_key_sequence(vim_key(KeyCode_W)));
    vim_bind_(vim_map, vim_motion_big_word, SCu8((u8*)("vim_motion_big_word"), (u64)(sizeof("vim_motion_big_word") - 1)), vim_key_sequence(vim_key(KeyCode_W, KeyCode_Shift)));
    vim_bind_(vim_map, vim_motion_word_end, SCu8((u8*)("vim_motion_word_end"), (u64)(sizeof("vim_motion_word_end") - 1)), vim_key_sequence(vim_key(KeyCode_E)));
    vim_bind_(vim_map, vim_motion_word_backward, SCu8((u8*)("vim_motion_word_backward"), (u64)(sizeof("vim_motion_word_backward") - 1)), vim_key_sequence(vim_key(KeyCode_B)));
    vim_bind_(vim_map, vim_motion_big_word_backward, SCu8((u8*)("vim_motion_big_word_backward"), (u64)(sizeof("vim_motion_big_word_backward") - 1)), vim_key_sequence(vim_key(KeyCode_B, KeyCode_Shift)));
    vim_bind_(vim_map, vim_motion_line_start_textual, SCu8((u8*)("vim_motion_line_start_textual"), (u64)(sizeof("vim_motion_line_start_textual") - 1)), vim_key_sequence(vim_key(KeyCode_0)));
    vim_bind_(vim_map, vim_motion_line_start_textual, SCu8((u8*)("vim_motion_line_start_textual"), (u64)(sizeof("vim_motion_line_start_textual") - 1)), vim_key_sequence(vim_key(KeyCode_6, KeyCode_Shift)));
    vim_bind_(vim_map, vim_motion_line_end_textual, SCu8((u8*)("vim_motion_line_end_textual"), (u64)(sizeof("vim_motion_line_end_textual") - 1)), vim_key_sequence(vim_key(KeyCode_4, KeyCode_Shift)));
    vim_bind_(vim_map, vim_motion_scope, SCu8((u8*)("vim_motion_scope"), (u64)(sizeof("vim_motion_scope") - 1)), vim_key_sequence(vim_key(KeyCode_5, KeyCode_Shift)));
    vim_bind_(vim_map, vim_motion_buffer_start_or_goto_line, SCu8((u8*)("vim_motion_buffer_start_or_goto_line"), (u64)(sizeof("vim_motion_buffer_start_or_goto_line") - 1)), vim_key_sequence(vim_key(KeyCode_G), vim_key(KeyCode_G)));
    vim_bind_(vim_map, vim_motion_buffer_end_or_goto_line, SCu8((u8*)("vim_motion_buffer_end_or_goto_line"), (u64)(sizeof("vim_motion_buffer_end_or_goto_line") - 1)), vim_key_sequence(vim_key(KeyCode_G, KeyCode_Shift)));
    vim_bind_(vim_map, vim_motion_page_top, SCu8((u8*)("vim_motion_page_top"), (u64)(sizeof("vim_motion_page_top") - 1)), vim_key_sequence(vim_key(KeyCode_H, KeyCode_Shift)));
    vim_bind_(vim_map, vim_motion_page_mid, SCu8((u8*)("vim_motion_page_mid"), (u64)(sizeof("vim_motion_page_mid") - 1)), vim_key_sequence(vim_key(KeyCode_M, KeyCode_Shift)));
    vim_bind_(vim_map, vim_motion_page_bottom, SCu8((u8*)("vim_motion_page_bottom"), (u64)(sizeof("vim_motion_page_bottom") - 1)), vim_key_sequence(vim_key(KeyCode_L, KeyCode_Shift)));
    vim_bind_(vim_map, vim_motion_find_character_case_sensitive, SCu8((u8*)("vim_motion_find_character_case_sensitive"), (u64)(sizeof("vim_motion_find_character_case_sensitive") - 1)), vim_key_sequence(vim_key(KeyCode_F)));
    vim_bind_(vim_map, vim_motion_find_character_backward_case_sensitive, SCu8((u8*)("vim_motion_find_character_backward_case_sensitive"), (u64)(sizeof("vim_motion_find_character_backward_case_sensitive") - 1)), vim_key_sequence(vim_key(KeyCode_F, KeyCode_Shift)));
    vim_bind_(vim_map, vim_motion_to_character_case_sensitive, SCu8((u8*)("vim_motion_to_character_case_sensitive"), (u64)(sizeof("vim_motion_to_character_case_sensitive") - 1)), vim_key_sequence(vim_key(KeyCode_T)));
    vim_bind_(vim_map, vim_motion_to_character_backward_case_sensitive, SCu8((u8*)("vim_motion_to_character_backward_case_sensitive"), (u64)(sizeof("vim_motion_to_character_backward_case_sensitive") - 1)), vim_key_sequence(vim_key(KeyCode_T, KeyCode_Shift)));
    vim_bind_(vim_map, vim_motion_find_character_pair_case_sensitive, SCu8((u8*)("vim_motion_find_character_pair_case_sensitive"), (u64)(sizeof("vim_motion_find_character_pair_case_sensitive") - 1)), vim_key_sequence(vim_key(KeyCode_S)));
    vim_bind_(vim_map, vim_motion_find_character_pair_backward_case_sensitive, SCu8((u8*)("vim_motion_find_character_pair_backward_case_sensitive"), (u64)(sizeof("vim_motion_find_character_pair_backward_case_sensitive") - 1)), vim_key_sequence(vim_key(KeyCode_S, KeyCode_Shift)));
    vim_bind_(vim_map, vim_motion_repeat_character_seek_same_direction, SCu8((u8*)("vim_motion_repeat_character_seek_same_direction"), (u64)(sizeof("vim_motion_repeat_character_seek_same_direction") - 1)), vim_key_sequence(vim_key(KeyCode_Semicolon)));
    vim_bind_(vim_map, vim_motion_repeat_character_seek_reverse_direction, SCu8((u8*)("vim_motion_repeat_character_seek_reverse_direction"), (u64)(sizeof("vim_motion_repeat_character_seek_reverse_direction") - 1)), vim_key_sequence(vim_key(KeyCode_Comma)));





    vim_map = vim_select_map_(app, &vim_map_normal);
    vim_add_parent_binding_map(vim_map, &(vim_map_operator_pending));

    vim_bind_(vim_map, comment_line, SCu8((u8*)("comment_line"), (u64)(sizeof("comment_line") - 1)), vim_key_sequence(vim_key(KeyCode_Control, KeyCode_ForwardSlash)));
    vim_bind_(vim_map, vim_register, SCu8((u8*)("vim_register"), (u64)(sizeof("vim_register") - 1)), vim_key_sequence(vim_key(KeyCode_Quote, KeyCode_Shift)));
    vim_bind_(vim_map, vim_change, SCu8((u8*)("vim_change"), (u64)(sizeof("vim_change") - 1)), vim_key_sequence(vim_key(KeyCode_C)));
    vim_bind_(vim_map, vim_change_eol, SCu8((u8*)("vim_change_eol"), (u64)(sizeof("vim_change_eol") - 1)), vim_key_sequence(vim_key(KeyCode_C, KeyCode_Shift)));
    vim_bind_(vim_map, vim_delete, SCu8((u8*)("vim_delete"), (u64)(sizeof("vim_delete") - 1)), vim_key_sequence(vim_key(KeyCode_D)));
    vim_bind_(vim_map, vim_delete_eol, SCu8((u8*)("vim_delete_eol"), (u64)(sizeof("vim_delete_eol") - 1)), vim_key_sequence(vim_key(KeyCode_D, KeyCode_Shift)));
    vim_bind_(vim_map, vim_delete_character, SCu8((u8*)("vim_delete_character"), (u64)(sizeof("vim_delete_character") - 1)), vim_key_sequence(vim_key(KeyCode_X)));
    vim_bind_(vim_map, vim_yank, SCu8((u8*)("vim_yank"), (u64)(sizeof("vim_yank") - 1)), vim_key_sequence(vim_key(KeyCode_Y)));
    vim_bind_(vim_map, vim_yank_eol, SCu8((u8*)("vim_yank_eol"), (u64)(sizeof("vim_yank_eol") - 1)), vim_key_sequence(vim_key(KeyCode_Y, KeyCode_Shift)));
    vim_bind_(vim_map, vim_paste, SCu8((u8*)("vim_paste"), (u64)(sizeof("vim_paste") - 1)), vim_key_sequence(vim_key(KeyCode_P)));
    vim_bind_(vim_map, vim_paste_pre_cursor, SCu8((u8*)("vim_paste_pre_cursor"), (u64)(sizeof("vim_paste_pre_cursor") - 1)), vim_key_sequence(vim_key(KeyCode_P, KeyCode_Shift)));
    vim_bind_(vim_map, vim_auto_indent, SCu8((u8*)("vim_auto_indent"), (u64)(sizeof("vim_auto_indent") - 1)), vim_key_sequence(vim_key(KeyCode_Equal)));
    vim_bind_(vim_map, vim_indent, SCu8((u8*)("vim_indent"), (u64)(sizeof("vim_indent") - 1)), vim_key_sequence(vim_key(KeyCode_Period, KeyCode_Shift)));
    vim_bind_(vim_map, vim_outdent, SCu8((u8*)("vim_outdent"), (u64)(sizeof("vim_outdent") - 1)), vim_key_sequence(vim_key(KeyCode_Comma, KeyCode_Shift)));
    vim_bind_(vim_map, vim_replace, SCu8((u8*)("vim_replace"), (u64)(sizeof("vim_replace") - 1)), vim_key_sequence(vim_key(KeyCode_R)));
    vim_bind_(vim_map, vim_new_line_below, SCu8((u8*)("vim_new_line_below"), (u64)(sizeof("vim_new_line_below") - 1)), vim_key_sequence(vim_key(KeyCode_O)))->flags |= VimBindingFlag_TextCommand;
    vim_bind_(vim_map, vim_new_line_above, SCu8((u8*)("vim_new_line_above"), (u64)(sizeof("vim_new_line_above") - 1)), vim_key_sequence(vim_key(KeyCode_O, KeyCode_Shift)))->flags |= VimBindingFlag_TextCommand;
    vim_bind_(vim_map, vim_join_line, SCu8((u8*)("vim_join_line"), (u64)(sizeof("vim_join_line") - 1)), vim_key_sequence(vim_key(KeyCode_J, KeyCode_Shift)));
    vim_bind_(vim_map, vim_align, SCu8((u8*)("vim_align"), (u64)(sizeof("vim_align") - 1)), vim_key_sequence(vim_key(KeyCode_G), vim_key(KeyCode_L)));
    vim_bind_(vim_map, vim_align_right, SCu8((u8*)("vim_align_right"), (u64)(sizeof("vim_align_right") - 1)), vim_key_sequence(vim_key(KeyCode_G), vim_key(KeyCode_L, KeyCode_Shift)));
    vim_bind_(vim_map, vim_align_string, SCu8((u8*)("vim_align_string"), (u64)(sizeof("vim_align_string") - 1)), vim_key_sequence(vim_key(KeyCode_G), vim_key(KeyCode_L, KeyCode_Control)));
    vim_bind_(vim_map, vim_align_string_right, SCu8((u8*)("vim_align_string_right"), (u64)(sizeof("vim_align_string_right") - 1)), vim_key_sequence(vim_key(KeyCode_G), vim_key(KeyCode_L, KeyCode_Shift, KeyCode_Control)));
    vim_bind_(vim_map, vim_lowercase, SCu8((u8*)("vim_lowercase"), (u64)(sizeof("vim_lowercase") - 1)), vim_key_sequence(vim_key(KeyCode_G), vim_key(KeyCode_U)));
    vim_bind_(vim_map, vim_uppercase, SCu8((u8*)("vim_uppercase"), (u64)(sizeof("vim_uppercase") - 1)), vim_key_sequence(vim_key(KeyCode_G), vim_key(KeyCode_U, KeyCode_Shift)));
    vim_bind_(vim_map, vim_miblo_increment, SCu8((u8*)("vim_miblo_increment"), (u64)(sizeof("vim_miblo_increment") - 1)), vim_key_sequence(vim_key(KeyCode_A, KeyCode_Control)));
    vim_bind_(vim_map, vim_miblo_decrement, SCu8((u8*)("vim_miblo_decrement"), (u64)(sizeof("vim_miblo_decrement") - 1)), vim_key_sequence(vim_key(KeyCode_X, KeyCode_Control)));
    vim_bind_(vim_map, vim_miblo_increment_sequence, SCu8((u8*)("vim_miblo_increment_sequence"), (u64)(sizeof("vim_miblo_increment_sequence") - 1)), vim_key_sequence(vim_key(KeyCode_G), vim_key(KeyCode_A, KeyCode_Control)));
    vim_bind_(vim_map, vim_miblo_decrement_sequence, SCu8((u8*)("vim_miblo_decrement_sequence"), (u64)(sizeof("vim_miblo_decrement_sequence") - 1)), vim_key_sequence(vim_key(KeyCode_G), vim_key(KeyCode_X, KeyCode_Control)));


    vim_bind_(vim_map, vim_enter_insert_mode, SCu8((u8*)("vim_enter_insert_mode"), (u64)(sizeof("vim_enter_insert_mode") - 1)), vim_key_sequence(vim_key(KeyCode_I)))->flags |= VimBindingFlag_TextCommand;
    vim_bind_(vim_map, vim_enter_insert_sol_mode, SCu8((u8*)("vim_enter_insert_sol_mode"), (u64)(sizeof("vim_enter_insert_sol_mode") - 1)), vim_key_sequence(vim_key(KeyCode_I, KeyCode_Shift)))->flags |= VimBindingFlag_TextCommand;
    vim_bind_(vim_map, vim_enter_append_mode, SCu8((u8*)("vim_enter_append_mode"), (u64)(sizeof("vim_enter_append_mode") - 1)), vim_key_sequence(vim_key(KeyCode_A)))->flags |= VimBindingFlag_TextCommand;
    vim_bind_(vim_map, vim_enter_append_eol_mode, SCu8((u8*)("vim_enter_append_eol_mode"), (u64)(sizeof("vim_enter_append_eol_mode") - 1)), vim_key_sequence(vim_key(KeyCode_A, KeyCode_Shift)))->flags |= VimBindingFlag_TextCommand;
    vim_bind_(vim_map, vim_toggle_visual_mode, SCu8((u8*)("vim_toggle_visual_mode"), (u64)(sizeof("vim_toggle_visual_mode") - 1)), vim_key_sequence(vim_key(KeyCode_V)));
    vim_bind_(vim_map, vim_toggle_visual_line_mode, SCu8((u8*)("vim_toggle_visual_line_mode"), (u64)(sizeof("vim_toggle_visual_line_mode") - 1)), vim_key_sequence(vim_key(KeyCode_V, KeyCode_Shift)));
    vim_bind_(vim_map, vim_toggle_visual_block_mode, SCu8((u8*)("vim_toggle_visual_block_mode"), (u64)(sizeof("vim_toggle_visual_block_mode") - 1)), vim_key_sequence(vim_key(KeyCode_V, KeyCode_Control)));

    vim_bind_(vim_map, change_active_panel, SCu8((u8*)("change_active_panel"), (u64)(sizeof("change_active_panel") - 1)), vim_key_sequence(vim_key(KeyCode_W, KeyCode_Control), vim_key(KeyCode_W)));
    vim_bind_(vim_map, change_active_panel, SCu8((u8*)("change_active_panel"), (u64)(sizeof("change_active_panel") - 1)), vim_key_sequence(vim_key(KeyCode_W, KeyCode_Control), vim_key(KeyCode_W, KeyCode_Control)));
    vim_bind_(vim_map, swap_panels, SCu8((u8*)("swap_panels"), (u64)(sizeof("swap_panels") - 1)), vim_key_sequence(vim_key(KeyCode_W, KeyCode_Control), vim_key(KeyCode_X)));
    vim_bind_(vim_map, swap_panels, SCu8((u8*)("swap_panels"), (u64)(sizeof("swap_panels") - 1)), vim_key_sequence(vim_key(KeyCode_W, KeyCode_Control), vim_key(KeyCode_X, KeyCode_Control)));
    vim_bind_(vim_map, windmove_panel_left, SCu8((u8*)("windmove_panel_left"), (u64)(sizeof("windmove_panel_left") - 1)), vim_key_sequence(vim_key(KeyCode_W, KeyCode_Control), vim_key(KeyCode_H)));
    vim_bind_(vim_map, windmove_panel_left, SCu8((u8*)("windmove_panel_left"), (u64)(sizeof("windmove_panel_left") - 1)), vim_key_sequence(vim_key(KeyCode_W, KeyCode_Control), vim_key(KeyCode_H, KeyCode_Control)));
    vim_bind_(vim_map, windmove_panel_down, SCu8((u8*)("windmove_panel_down"), (u64)(sizeof("windmove_panel_down") - 1)), vim_key_sequence(vim_key(KeyCode_W, KeyCode_Control), vim_key(KeyCode_J)));
    vim_bind_(vim_map, windmove_panel_down, SCu8((u8*)("windmove_panel_down"), (u64)(sizeof("windmove_panel_down") - 1)), vim_key_sequence(vim_key(KeyCode_W, KeyCode_Control), vim_key(KeyCode_J, KeyCode_Control)));
    vim_bind_(vim_map, windmove_panel_up, SCu8((u8*)("windmove_panel_up"), (u64)(sizeof("windmove_panel_up") - 1)), vim_key_sequence(vim_key(KeyCode_W, KeyCode_Control), vim_key(KeyCode_K)));
    vim_bind_(vim_map, windmove_panel_up, SCu8((u8*)("windmove_panel_up"), (u64)(sizeof("windmove_panel_up") - 1)), vim_key_sequence(vim_key(KeyCode_W, KeyCode_Control), vim_key(KeyCode_K, KeyCode_Control)));
    vim_bind_(vim_map, windmove_panel_right, SCu8((u8*)("windmove_panel_right"), (u64)(sizeof("windmove_panel_right") - 1)), vim_key_sequence(vim_key(KeyCode_W, KeyCode_Control), vim_key(KeyCode_L)));
    vim_bind_(vim_map, windmove_panel_right, SCu8((u8*)("windmove_panel_right"), (u64)(sizeof("windmove_panel_right") - 1)), vim_key_sequence(vim_key(KeyCode_W, KeyCode_Control), vim_key(KeyCode_L, KeyCode_Control)));
    vim_bind_(vim_map, windmove_panel_swap_left, SCu8((u8*)("windmove_panel_swap_left"), (u64)(sizeof("windmove_panel_swap_left") - 1)), vim_key_sequence(vim_key(KeyCode_W, KeyCode_Control), vim_key(KeyCode_H, KeyCode_Shift)));
    vim_bind_(vim_map, windmove_panel_swap_left, SCu8((u8*)("windmove_panel_swap_left"), (u64)(sizeof("windmove_panel_swap_left") - 1)), vim_key_sequence(vim_key(KeyCode_W, KeyCode_Control), vim_key(KeyCode_H, KeyCode_Shift, KeyCode_Control)));
    vim_bind_(vim_map, windmove_panel_swap_down, SCu8((u8*)("windmove_panel_swap_down"), (u64)(sizeof("windmove_panel_swap_down") - 1)), vim_key_sequence(vim_key(KeyCode_W, KeyCode_Control), vim_key(KeyCode_J, KeyCode_Shift)));
    vim_bind_(vim_map, windmove_panel_swap_down, SCu8((u8*)("windmove_panel_swap_down"), (u64)(sizeof("windmove_panel_swap_down") - 1)), vim_key_sequence(vim_key(KeyCode_W, KeyCode_Control), vim_key(KeyCode_J, KeyCode_Shift, KeyCode_Control)));
    vim_bind_(vim_map, windmove_panel_swap_up, SCu8((u8*)("windmove_panel_swap_up"), (u64)(sizeof("windmove_panel_swap_up") - 1)), vim_key_sequence(vim_key(KeyCode_W, KeyCode_Control), vim_key(KeyCode_K, KeyCode_Shift)));
    vim_bind_(vim_map, windmove_panel_swap_up, SCu8((u8*)("windmove_panel_swap_up"), (u64)(sizeof("windmove_panel_swap_up") - 1)), vim_key_sequence(vim_key(KeyCode_W, KeyCode_Control), vim_key(KeyCode_K, KeyCode_Shift, KeyCode_Control)));
    vim_bind_(vim_map, windmove_panel_swap_right, SCu8((u8*)("windmove_panel_swap_right"), (u64)(sizeof("windmove_panel_swap_right") - 1)), vim_key_sequence(vim_key(KeyCode_W, KeyCode_Control), vim_key(KeyCode_L, KeyCode_Shift)));
    vim_bind_(vim_map, windmove_panel_swap_right, SCu8((u8*)("windmove_panel_swap_right"), (u64)(sizeof("windmove_panel_swap_right") - 1)), vim_key_sequence(vim_key(KeyCode_W, KeyCode_Control), vim_key(KeyCode_L, KeyCode_Shift, KeyCode_Control)));
    vim_bind_(vim_map, vim_split_window_vertical, SCu8((u8*)("vim_split_window_vertical"), (u64)(sizeof("vim_split_window_vertical") - 1)), vim_key_sequence(vim_key(KeyCode_W, KeyCode_Control), vim_key(KeyCode_V)));
    vim_bind_(vim_map, vim_split_window_vertical, SCu8((u8*)("vim_split_window_vertical"), (u64)(sizeof("vim_split_window_vertical") - 1)), vim_key_sequence(vim_key(KeyCode_W, KeyCode_Control), vim_key(KeyCode_V, KeyCode_Control)));
    vim_bind_(vim_map, vim_split_window_horizontal, SCu8((u8*)("vim_split_window_horizontal"), (u64)(sizeof("vim_split_window_horizontal") - 1)), vim_key_sequence(vim_key(KeyCode_W, KeyCode_Control), vim_key(KeyCode_S)));
    vim_bind_(vim_map, vim_split_window_horizontal, SCu8((u8*)("vim_split_window_horizontal"), (u64)(sizeof("vim_split_window_horizontal") - 1)), vim_key_sequence(vim_key(KeyCode_W, KeyCode_Control), vim_key(KeyCode_S, KeyCode_Control)));

    vim_bind_(vim_map, center_view, SCu8((u8*)("center_view"), (u64)(sizeof("center_view") - 1)), vim_key_sequence(vim_key(KeyCode_Z), vim_key(KeyCode_Z)));
    vim_bind_(vim_map, vim_view_move_line_to_top, SCu8((u8*)("vim_view_move_line_to_top"), (u64)(sizeof("vim_view_move_line_to_top") - 1)), vim_key_sequence(vim_key(KeyCode_Z), vim_key(KeyCode_T)));
    vim_bind_(vim_map, vim_view_move_line_to_bottom, SCu8((u8*)("vim_view_move_line_to_bottom"), (u64)(sizeof("vim_view_move_line_to_bottom") - 1)), vim_key_sequence(vim_key(KeyCode_Z), vim_key(KeyCode_B)));

    vim_bind_(vim_map, vim_page_up, SCu8((u8*)("vim_page_up"), (u64)(sizeof("vim_page_up") - 1)), vim_key_sequence(vim_key(KeyCode_B, KeyCode_Control)));
    vim_bind_(vim_map, vim_page_down, SCu8((u8*)("vim_page_down"), (u64)(sizeof("vim_page_down") - 1)), vim_key_sequence(vim_key(KeyCode_F, KeyCode_Control)));
    vim_bind_(vim_map, vim_half_page_up, SCu8((u8*)("vim_half_page_up"), (u64)(sizeof("vim_half_page_up") - 1)), vim_key_sequence(vim_key(KeyCode_U, KeyCode_Control)));
    vim_bind_(vim_map, vim_half_page_down, SCu8((u8*)("vim_half_page_down"), (u64)(sizeof("vim_half_page_down") - 1)), vim_key_sequence(vim_key(KeyCode_D, KeyCode_Control)));

    vim_bind_(vim_map, vim_step_back_jump_history, SCu8((u8*)("vim_step_back_jump_history"), (u64)(sizeof("vim_step_back_jump_history") - 1)), vim_key_sequence(vim_key(KeyCode_O, KeyCode_Control)));
    vim_bind_(vim_map, vim_step_forward_jump_history, SCu8((u8*)("vim_step_forward_jump_history"), (u64)(sizeof("vim_step_forward_jump_history") - 1)), vim_key_sequence(vim_key(KeyCode_I, KeyCode_Control)));
    vim_bind_(vim_map, vim_previous_buffer, SCu8((u8*)("vim_previous_buffer"), (u64)(sizeof("vim_previous_buffer") - 1)), vim_key_sequence(vim_key(KeyCode_6, KeyCode_Control)));

    vim_bind_(vim_map, vim_record_macro, SCu8((u8*)("vim_record_macro"), (u64)(sizeof("vim_record_macro") - 1)), vim_key_sequence(vim_key(KeyCode_Q)));
    vim_bind_(vim_map, vim_replay_macro, SCu8((u8*)("vim_replay_macro"), (u64)(sizeof("vim_replay_macro") - 1)), vim_key_sequence(vim_key(KeyCode_2, KeyCode_Shift)))->flags |= VimBindingFlag_TextCommand;
    vim_bind_(vim_map, vim_set_mark, SCu8((u8*)("vim_set_mark"), (u64)(sizeof("vim_set_mark") - 1)), vim_key_sequence(vim_key(KeyCode_M)));
    vim_bind_(vim_map, vim_go_to_mark, SCu8((u8*)("vim_go_to_mark"), (u64)(sizeof("vim_go_to_mark") - 1)), vim_key_sequence(vim_key(KeyCode_Quote)));
    vim_bind_(vim_map, vim_go_to_mark, SCu8((u8*)("vim_go_to_mark"), (u64)(sizeof("vim_go_to_mark") - 1)), vim_key_sequence(vim_key(KeyCode_Tick)));
    vim_bind_(vim_map, vim_go_to_mark_less_history, SCu8((u8*)("vim_go_to_mark_less_history"), (u64)(sizeof("vim_go_to_mark_less_history") - 1)), vim_key_sequence(vim_key(KeyCode_G), vim_key(KeyCode_Quote)));
    vim_bind_(vim_map, vim_go_to_mark_less_history, SCu8((u8*)("vim_go_to_mark_less_history"), (u64)(sizeof("vim_go_to_mark_less_history") - 1)), vim_key_sequence(vim_key(KeyCode_G), vim_key(KeyCode_Tick)));
    vim_bind_(vim_map, vim_open_file_in_quotes_in_same_window, SCu8((u8*)("vim_open_file_in_quotes_in_same_window"), (u64)(sizeof("vim_open_file_in_quotes_in_same_window") - 1)), vim_key_sequence(vim_key(KeyCode_G), vim_key(KeyCode_F)));
    vim_bind_(vim_map, vim_jump_to_definition_under_cursor, SCu8((u8*)("vim_jump_to_definition_under_cursor"), (u64)(sizeof("vim_jump_to_definition_under_cursor") - 1)), vim_key_sequence(vim_key(KeyCode_RightBracket, KeyCode_Control)));

    vim_name_bind_(vim_map, SCu8((u8*)("Project"), (u64)(sizeof("Project") - 1)), vim_key_sequence(vim_leader, vim_key(KeyCode_P)));
    vim_bind_(vim_map, project_lister, SCu8((u8*)("project_lister"), (u64)(sizeof("project_lister") - 1)), vim_key_sequence(vim_leader, vim_key(KeyCode_P), vim_key(KeyCode_P)));
    vim_bind_(vim_map, load_project, SCu8((u8*)("load_project"), (u64)(sizeof("load_project") - 1)), vim_key_sequence(vim_leader, vim_key(KeyCode_P), vim_key(KeyCode_O)));

    vim_name_bind_(vim_map, SCu8((u8*)("Buffer"), (u64)(sizeof("Buffer") - 1)), vim_key_sequence(vim_leader, vim_key(KeyCode_B)));
    vim_bind_(vim_map, interactive_switch_buffer, SCu8((u8*)("interactive_switch_buffer"), (u64)(sizeof("interactive_switch_buffer") - 1)), vim_key_sequence(vim_leader, vim_key(KeyCode_B), vim_key(KeyCode_B)));
    vim_bind_(vim_map, interactive_kill_buffer, SCu8((u8*)("interactive_kill_buffer"), (u64)(sizeof("interactive_kill_buffer") - 1)), vim_key_sequence(vim_leader, vim_key(KeyCode_B), vim_key(KeyCode_K)));
    vim_bind_(vim_map, kill_buffer, SCu8((u8*)("kill_buffer"), (u64)(sizeof("kill_buffer") - 1)), vim_key_sequence(vim_leader, vim_key(KeyCode_B), vim_key(KeyCode_D)));

    vim_name_bind_(vim_map, SCu8((u8*)("Files"), (u64)(sizeof("Files") - 1)), vim_key_sequence(vim_leader, vim_key(KeyCode_F)));
    vim_bind_(vim_map, interactive_new, SCu8((u8*)("interactive_new"), (u64)(sizeof("interactive_new") - 1)), vim_key_sequence(vim_leader, vim_key(KeyCode_F), vim_key(KeyCode_N)));
    vim_bind_(vim_map, interactive_open_or_new, SCu8((u8*)("interactive_open_or_new"), (u64)(sizeof("interactive_open_or_new") - 1)), vim_key_sequence(vim_leader, vim_key(KeyCode_F), vim_key(KeyCode_O)));
    vim_bind_(vim_map, q, SCu8((u8*)("q"), (u64)(sizeof("q") - 1)), vim_key_sequence(vim_leader, vim_key(KeyCode_F), vim_key(KeyCode_Q)));
    vim_bind_(vim_map, qa, SCu8((u8*)("qa"), (u64)(sizeof("qa") - 1)), vim_key_sequence(vim_leader, vim_key(KeyCode_F), vim_key(KeyCode_Q, KeyCode_Shift)));
    vim_bind_(vim_map, qa, SCu8((u8*)("qa"), (u64)(sizeof("qa") - 1)), vim_key_sequence(vim_leader, vim_key(KeyCode_F), vim_key(KeyCode_Q, KeyCode_Shift)));
    vim_bind_(vim_map, w, SCu8((u8*)("w"), (u64)(sizeof("w") - 1)), vim_key_sequence(vim_leader, vim_key(KeyCode_F), vim_key(KeyCode_W)));

    vim_name_bind_(vim_map, SCu8((u8*)("Search"), (u64)(sizeof("Search") - 1)), vim_key_sequence(vim_leader, vim_key(KeyCode_S)));
    vim_bind_(vim_map, list_all_substring_locations_case_insensitive, SCu8((u8*)("list_all_substring_locations_case_insensitive"), (u64)(sizeof("list_all_substring_locations_case_insensitive") - 1)), vim_key_sequence(vim_leader, vim_key(KeyCode_S), vim_key(KeyCode_S)));

    vim_name_bind_(vim_map, SCu8((u8*)("Tags"), (u64)(sizeof("Tags") - 1)), vim_key_sequence(vim_leader, vim_key(KeyCode_T)));
    vim_bind_(vim_map, jump_to_definition, SCu8((u8*)("jump_to_definition"), (u64)(sizeof("jump_to_definition") - 1)), vim_key_sequence(vim_leader, vim_key(KeyCode_T), vim_key(KeyCode_A)));


    vim_name_bind_(vim_map, SCu8((u8*)("Window"), (u64)(sizeof("Window") - 1)), vim_key_sequence(vim_leader, vim_key(KeyCode_W)));
    vim_bind_(vim_map, windmove_panel_down, SCu8((u8*)("windmove_panel_down"), (u64)(sizeof("windmove_panel_down") - 1)), vim_key_sequence(vim_leader, vim_key(KeyCode_W), vim_key(KeyCode_J)));
    vim_bind_(vim_map, windmove_panel_swap_down, SCu8((u8*)("windmove_panel_swap_down"), (u64)(sizeof("windmove_panel_swap_down") - 1)), vim_key_sequence(vim_leader, vim_key(KeyCode_W), vim_key(KeyCode_J, KeyCode_Shift)));
    vim_bind_(vim_map, windmove_panel_up, SCu8((u8*)("windmove_panel_up"), (u64)(sizeof("windmove_panel_up") - 1)), vim_key_sequence(vim_leader, vim_key(KeyCode_W), vim_key(KeyCode_K)));
    vim_bind_(vim_map, windmove_panel_swap_up, SCu8((u8*)("windmove_panel_swap_up"), (u64)(sizeof("windmove_panel_swap_up") - 1)), vim_key_sequence(vim_leader, vim_key(KeyCode_W), vim_key(KeyCode_K, KeyCode_Shift)));
    vim_bind_(vim_map, windmove_panel_left, SCu8((u8*)("windmove_panel_left"), (u64)(sizeof("windmove_panel_left") - 1)), vim_key_sequence(vim_leader, vim_key(KeyCode_W), vim_key(KeyCode_H)));
    vim_bind_(vim_map, windmove_panel_swap_left, SCu8((u8*)("windmove_panel_swap_left"), (u64)(sizeof("windmove_panel_swap_left") - 1)), vim_key_sequence(vim_leader, vim_key(KeyCode_W), vim_key(KeyCode_H, KeyCode_Shift)));
    vim_bind_(vim_map, windmove_panel_right, SCu8((u8*)("windmove_panel_right"), (u64)(sizeof("windmove_panel_right") - 1)), vim_key_sequence(vim_leader, vim_key(KeyCode_W), vim_key(KeyCode_L)));
    vim_bind_(vim_map, windmove_panel_swap_right, SCu8((u8*)("windmove_panel_swap_right"), (u64)(sizeof("windmove_panel_swap_right") - 1)), vim_key_sequence(vim_leader, vim_key(KeyCode_W), vim_key(KeyCode_L, KeyCode_Shift)));
    vim_bind_(vim_map, close_panel, SCu8((u8*)("close_panel"), (u64)(sizeof("close_panel") - 1)), vim_key_sequence(vim_leader, vim_key(KeyCode_W), vim_key(KeyCode_D)));

    vim_bind_(vim_map, vim_toggle_line_comment_range_indent_style, SCu8((u8*)("vim_toggle_line_comment_range_indent_style"), (u64)(sizeof("vim_toggle_line_comment_range_indent_style") - 1)), vim_key_sequence(vim_leader, vim_key(KeyCode_C), vim_key(KeyCode_C)));

    vim_bind_(vim_map, vim_enter_normal_mode_escape, SCu8((u8*)("vim_enter_normal_mode_escape"), (u64)(sizeof("vim_enter_normal_mode_escape") - 1)), vim_key_sequence(vim_key(KeyCode_Escape)));
    vim_bind_(vim_map, vim_isearch_word_under_cursor, SCu8((u8*)("vim_isearch_word_under_cursor"), (u64)(sizeof("vim_isearch_word_under_cursor") - 1)), vim_key_sequence(vim_key(KeyCode_8, KeyCode_Shift)));
    vim_bind_(vim_map, vim_reverse_isearch_word_under_cursor, SCu8((u8*)("vim_reverse_isearch_word_under_cursor"), (u64)(sizeof("vim_reverse_isearch_word_under_cursor") - 1)), vim_key_sequence(vim_key(KeyCode_3, KeyCode_Shift)));
    vim_bind_(vim_map, vim_repeat_command, SCu8((u8*)("vim_repeat_command"), (u64)(sizeof("vim_repeat_command") - 1)), vim_key_sequence(vim_key(KeyCode_Period)));
    vim_bind_(vim_map, vim_move_line_up, SCu8((u8*)("vim_move_line_up"), (u64)(sizeof("vim_move_line_up") - 1)), vim_key_sequence(vim_key(KeyCode_K, KeyCode_Alt)));
    vim_bind_(vim_map, vim_move_line_down, SCu8((u8*)("vim_move_line_down"), (u64)(sizeof("vim_move_line_down") - 1)), vim_key_sequence(vim_key(KeyCode_J, KeyCode_Alt)));
    vim_bind_(vim_map, vim_isearch, SCu8((u8*)("vim_isearch"), (u64)(sizeof("vim_isearch") - 1)), vim_key_sequence(vim_key(KeyCode_ForwardSlash)));
    vim_bind_(vim_map, vim_isearch_backward, SCu8((u8*)("vim_isearch_backward"), (u64)(sizeof("vim_isearch_backward") - 1)), vim_key_sequence(vim_key(KeyCode_ForwardSlash, KeyCode_Shift)));
    vim_bind_(vim_map, vim_isearch_repeat_forward, SCu8((u8*)("vim_isearch_repeat_forward"), (u64)(sizeof("vim_isearch_repeat_forward") - 1)), vim_key_sequence(vim_key(KeyCode_N)));
    vim_bind_(vim_map, vim_isearch_repeat_backward, SCu8((u8*)("vim_isearch_repeat_backward"), (u64)(sizeof("vim_isearch_repeat_backward") - 1)), vim_key_sequence(vim_key(KeyCode_N, KeyCode_Shift)));
    vim_bind_(vim_map, noh, SCu8((u8*)("noh"), (u64)(sizeof("noh") - 1)), vim_key_sequence(vim_leader, vim_key(KeyCode_N)));
    vim_bind_(vim_map, goto_next_jump, SCu8((u8*)("goto_next_jump"), (u64)(sizeof("goto_next_jump") - 1)), vim_key_sequence(vim_key(KeyCode_N, KeyCode_Control)));
    vim_bind_(vim_map, goto_prev_jump, SCu8((u8*)("goto_prev_jump"), (u64)(sizeof("goto_prev_jump") - 1)), vim_key_sequence(vim_key(KeyCode_P, KeyCode_Control)));
    vim_bind_(vim_map, vim_undo, SCu8((u8*)("vim_undo"), (u64)(sizeof("vim_undo") - 1)), vim_key_sequence(vim_key(KeyCode_U)));
    vim_bind_(vim_map, vim_redo, SCu8((u8*)("vim_redo"), (u64)(sizeof("vim_redo") - 1)), vim_key_sequence(vim_key(KeyCode_R, KeyCode_Control)));
    vim_bind_(vim_map, command_lister, SCu8((u8*)("command_lister"), (u64)(sizeof("command_lister") - 1)), vim_key_sequence(vim_key(KeyCode_Semicolon, KeyCode_Shift)));
    vim_bind_(vim_map, if_read_only_goto_position, SCu8((u8*)("if_read_only_goto_position"), (u64)(sizeof("if_read_only_goto_position") - 1)), vim_key_sequence(vim_key(KeyCode_Return)));
    vim_bind_(vim_map, if_read_only_goto_position_same_panel, SCu8((u8*)("if_read_only_goto_position_same_panel"), (u64)(sizeof("if_read_only_goto_position_same_panel") - 1)), vim_key_sequence(vim_key(KeyCode_Return, KeyCode_Shift)));





    vim_map = vim_select_map_(app, &vim_map_visual);
    vim_add_parent_binding_map(vim_map, &(vim_map_normal));
    vim_add_parent_binding_map(vim_map, &(vim_map_text_objects));

    vim_bind_(vim_map, vim_enter_visual_insert_mode, SCu8((u8*)("vim_enter_visual_insert_mode"), (u64)(sizeof("vim_enter_visual_insert_mode") - 1)), vim_key_sequence(vim_key(KeyCode_I, KeyCode_Shift)))->flags |= VimBindingFlag_TextCommand;
    vim_bind_(vim_map, vim_enter_visual_append_mode, SCu8((u8*)("vim_enter_visual_append_mode"), (u64)(sizeof("vim_enter_visual_append_mode") - 1)), vim_key_sequence(vim_key(KeyCode_A, KeyCode_Shift)))->flags |= VimBindingFlag_TextCommand;

    vim_bind_(vim_map, vim_lowercase, SCu8((u8*)("vim_lowercase"), (u64)(sizeof("vim_lowercase") - 1)), vim_key_sequence(vim_key(KeyCode_U)));
    vim_bind_(vim_map, vim_uppercase, SCu8((u8*)("vim_uppercase"), (u64)(sizeof("vim_uppercase") - 1)), vim_key_sequence(vim_key(KeyCode_U, KeyCode_Shift)));

    vim_bind_(vim_map, vim_isearch_selection, SCu8((u8*)("vim_isearch_selection"), (u64)(sizeof("vim_isearch_selection") - 1)), vim_key_sequence(vim_key(KeyCode_ForwardSlash)));
    vim_bind_(vim_map, vim_reverse_isearch_selection, SCu8((u8*)("vim_reverse_isearch_selection"), (u64)(sizeof("vim_reverse_isearch_selection") - 1)), vim_key_sequence(vim_key(KeyCode_ForwardSlash, KeyCode_Shift)));
}
void custom_layer_init(Application_Links *app) {
    Thread_Context *tctx = get_thread_context(app);


    default_framework_init(app);


    set_all_default_hooks(app);
    mapping_init(tctx, &framework_mapping);

    setup_default_mapping(&framework_mapping, mapid_global, mapid_file,
                          mapid_code);
    vim_init(app);
    vim_set_default_hooks(app);
    custom_setup_default_mapping(app, &framework_mapping, vim_key(KeyCode_Space));
    set_custom_hook((app),(HookID_RenderCaller),(Void_Func*)(custom_render_caller));
}
